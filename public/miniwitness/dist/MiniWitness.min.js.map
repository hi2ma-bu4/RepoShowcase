{
  "version": 3,
  "sources": ["../src/types.ts", "../src/grid.ts", "../src/rng.ts", "../src/validator.ts", "../src/generator.ts", "../src/ui.ts", "../src/serializer.ts", "../src/index.ts"],
  "sourcesContent": ["export enum Direction {\n\tUp = 0,\n\tRight = 1,\n\tDown = 2,\n\tLeft = 3,\n}\n\nexport enum CellType {\n\tNone = 0,\n\t/** \u8272\u5206\u3051\u304C\u5FC5\u8981\u306A\u30D6\u30ED\u30C3\u30AF */\n\tSquare = 1,\n\t/** \u540C\u3058\u8272\u306E\u30DA\u30A2\u4F5C\u6210 (\u661F) */\n\tStar = 2,\n\t/** \u30C6\u30C8\u30EA\u30B9 */\n\tTetris = 3,\n\t/** \u30C6\u30C8\u30EA\u30B9\uFF08\u56DE\u8EE2\u53EF\u80FD\uFF09 */\n\tTetrisRotated = 4,\n\t/** \u30C6\u30C8\u30EA\u30B9 (\u6E1B\u7B97) */\n\tTetrisNegative = 5,\n\t/** \u30C6\u30C8\u30EA\u30B9 (\u6E1B\u7B97\u30FB\u56DE\u8EE2\u53EF\u80FD) */\n\tTetrisNegativeRotated = 6,\n\t/** \u30C6\u30C8\u30E9\u30DD\u30C3\u30C9 (\u30A8\u30E9\u30FC\u524A\u9664) */\n\tEraser = 7,\n\t/** \u4E09\u89D2\u5F62 (\u901A\u904E\u8FBA\u6570\u6307\u5B9A) */\n\tTriangle = 8,\n}\n\nexport enum EdgeType {\n\tNormal = 0,\n\t/** \u7DDA\u306E\u771F\u3093\u4E2D\u3067\u65AD\u7DDA (\u901A\u884C\u4E0D\u53EF) */\n\tBroken = 1,\n\t/** \u305D\u3082\u305D\u3082\u5206\u5C90\u3082\u306A\u3057 (\u901A\u884C\u4E0D\u53EF) */\n\tAbsent = 2,\n\t/** \u901A\u904E\u5FC5\u9808 (\u30EF\u30A4\u30EB\u30C9\u30AB\u30FC\u30C9) */\n\tHexagon = 3,\n\t/** \u30E1\u30A4\u30F3\u7DDA\u306E\u307F\u901A\u904E\u5FC5\u9808 */\n\tHexagonMain = 4,\n\t/** \u5BFE\u79F0\u7DDA\u306E\u307F\u901A\u904E\u5FC5\u9808 */\n\tHexagonSymmetry = 5,\n}\n\nexport enum NodeType {\n\tNormal = 0,\n\tStart = 1,\n\tEnd = 2,\n\t/** \u901A\u904E\u5FC5\u9808 (\u30EF\u30A4\u30EB\u30C9\u30AB\u30FC\u30C9) */\n\tHexagon = 3,\n\t/** \u30E1\u30A4\u30F3\u7DDA\u306E\u307F\u901A\u904E\u5FC5\u9808 */\n\tHexagonMain = 4,\n\t/** \u5BFE\u79F0\u7DDA\u306E\u307F\u901A\u904E\u5FC5\u9808 */\n\tHexagonSymmetry = 5,\n}\n\nexport enum SymmetryType {\n\tNone = 0,\n\t/** \u5DE6\u53F3\u5BFE\u79F0 */\n\tHorizontal = 1,\n\t/** \u4E0A\u4E0B\u5BFE\u79F0 */\n\tVertical = 2,\n\t/** \u70B9\u5BFE\u79F0 */\n\tRotational = 3,\n}\n\n/**\n * \u4F7F\u7528\u53EF\u80FD\u8272\n * Core\u5185\u90E8\u3067\u306F\u6570\u5024\u3067\u7BA1\u7406\u3057\u3001UI\u3067\u5B9F\u969B\u306E\u8272\uFF08\u6587\u5B57\u5217\uFF09\u3068\u7D10\u4ED8\u3051\u308B\n */\nexport type Color = number;\nexport const Color = {\n\tNone: 0 as Color,\n\tBlack: 1 as Color,\n\tWhite: 2 as Color,\n\tRed: 3 as Color,\n\tBlue: 4 as Color,\n} as const;\n\nexport interface Point {\n\tx: number;\n\ty: number;\n}\n\nexport interface CellConstraint {\n\ttype: CellType;\n\tcolor: Color;\n\tshape?: number[][]; // [row][col] 0 or 1\n\tcount?: number; // Triangle count (1-3)\n}\n\nexport interface EdgeConstraint {\n\ttype: EdgeType;\n}\n\nexport interface NodeConstraint {\n\ttype: NodeType;\n}\n\n/**\n * \u30D1\u30BA\u30EB\u306E\u9759\u7684\u306A\u5B9A\u7FA9\u30C7\u30FC\u30BF\n */\nexport interface PuzzleData {\n\trows: number;\n\tcols: number;\n\tcells: CellConstraint[][]; // [row][col]\n\tvEdges: EdgeConstraint[][]; // Vertical edges [row][col] (row: 0..rows-1, col: 0..cols)\n\thEdges: EdgeConstraint[][]; // Horizontal edges [row][col] (row: 0..rows, col: 0..cols-1)\n\tnodes: NodeConstraint[][]; // [row][col]\n\tsymmetry?: SymmetryType;\n\t/** \u30D1\u30BA\u30EB\u751F\u6210\u306B\u4F7F\u7528\u3055\u308C\u305F\u4E71\u6570\u30B7\u30FC\u30C9 (16\u9032\u6570\u6587\u5B57\u5217) */\n\tseed?: string;\n}\n\n/**\n * \u30E6\u30FC\u30B6\u30FC\u306E\u5165\u529B\uFF08\u56DE\u7B54\u30D1\u30B9\uFF09\n */\nexport interface SolutionPath {\n\tpoints: Point[]; // \u901A\u904E\u3057\u305F\u30CE\u30FC\u30C9\u306E\u5EA7\u6A19\u914D\u5217\n}\n\nexport interface ValidationResult {\n\tisValid: boolean;\n\terrorReason?: string;\n\tinvalidatedCells?: Point[];\n\tinvalidatedEdges?: { type: \"h\" | \"v\"; r: number; c: number }[];\n\tinvalidatedNodes?: Point[];\n\terrorCells?: Point[];\n\terrorEdges?: { type: \"h\" | \"v\"; r: number; c: number }[];\n\terrorNodes?: Point[];\n\tregions?: Point[][];\n}\n\n/**\n * \u30D1\u30BA\u30EB\u751F\u6210\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\n */\nexport interface GenerationOptions {\n\trows?: number;\n\tcols?: number;\n\tuseHexagons?: boolean;\n\tuseSquares?: boolean;\n\tuseStars?: boolean;\n\tuseTetris?: boolean;\n\tuseTetrisNegative?: boolean;\n\tuseEraser?: boolean;\n\tuseTriangles?: boolean;\n\tuseBrokenEdges?: boolean;\n\tcomplexity?: number; // 0.0 - 1.0 (\u5236\u7D04\u306E\u5BC6\u5EA6)\n\tdifficulty?: number; // 0.0 (Easy) - 1.0 (Hard) (\u89E3\u30D1\u30BF\u30FC\u30F3\u306E\u6570\u306B\u57FA\u3065\u304F)\n\tpathLength?: number; // 0.0 (Shortest) - 1.0 (Longest)\n\tsymmetry?: SymmetryType;\n\t/** \u56DB\u89D2\u5F62\u3084\u661F\u306A\u3069\u306E\u8A18\u53F7\u306B\u4F7F\u7528\u53EF\u80FD\u306A\u8272\u306E\u30EA\u30B9\u30C8\u3002\u6307\u5B9A\u304C\u306A\u3044\u5834\u5408\u306F\u30C7\u30D5\u30A9\u30EB\u30C8\uFF08\u9ED2\u30FB\u767D\u30FB\u8D64\u30FB\u9752\uFF09\u304C\u4F7F\u7528\u3055\u308C\u308B\u3002 */\n\tavailableColors?: Color[];\n\t/** \u5404\u8A18\u53F7\u30BF\u30A4\u30D7\u306E\u30C7\u30D5\u30A9\u30EB\u30C8\u30AB\u30E9\u30FC\u3002\u6307\u5B9A\u304C\u306A\u3044\u5834\u5408\u306F\u305D\u308C\u305E\u308C\u306E\u8A18\u53F7\u306E\u6A19\u6E96\u8272\u304C\u4F7F\u7528\u3055\u308C\u308B\u3002\n\t * \u30AD\u30FC\u306B\u306F CellType \u306E\u6570\u5024\u3001\u307E\u305F\u306F \"Square\", \"Tetris\" \u306A\u3069\u306E\u6587\u5B57\u5217\u304C\u4F7F\u7528\u53EF\u80FD\u3067\u3059\u3002\n\t */\n\tdefaultColors?: Partial<Record<CellType | keyof typeof CellType, Color>>;\n\t/** \u30D1\u30BA\u30EB\u751F\u6210\u306B\u4F7F\u7528\u3059\u308B\u4E71\u6570\u30B7\u30FC\u30C9 (16\u9032\u6570\u6587\u5B57\u5217) */\n\tseed?: string;\n\t/** \u4F7F\u7528\u3059\u308B\u4E71\u6570\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0 */\n\trngType?: RngType;\n\t/** \u56FA\u5B9A\u3057\u305F\u3044\u30B9\u30BF\u30FC\u30C8\u5730\u70B9\u306E\u30EA\u30B9\u30C8 */\n\tstarts?: Point[];\n\t/** \u56FA\u5B9A\u3057\u305F\u3044\u30B4\u30FC\u30EB\u5730\u70B9\u306E\u30EA\u30B9\u30C8 */\n\tends?: Point[];\n}\n\nexport enum RngType {\n\tMulberry32 = 0,\n\tXorShift128Plus = 1,\n\tMathRandom = 2,\n}\n\n/**\n * \u30B7\u30EA\u30A2\u30E9\u30A4\u30BA\u6642\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\n */\nexport interface SerializationOptions {\n\t/** \u30D1\u30BA\u30EB\u69CB\u9020\u30C7\u30FC\u30BF\u3092\u542B\u3081\u308B\u304B */\n\tpuzzle?: PuzzleData;\n\t/** \u30B7\u30FC\u30C9\u60C5\u5831\u3092\u542B\u3081\u308B\u304B */\n\tseed?: { type: RngType; value: string };\n\t/** \u751F\u6210\u8A2D\u5B9A\u3092\u542B\u3081\u308B\u304B */\n\toptions?: GenerationOptions;\n\t/** \u89E3\u7B54\u30D1\u30B9\u3092\u542B\u3081\u308B\u304B */\n\tpath?: SolutionPath;\n\t/** \u30D1\u30EA\u30C6\u30A3\u30E2\u30FC\u30C9 ('detection': \u7834\u640D\u691C\u77E5\u306E\u307F, 'recovery': \u90E8\u5206\u5FA9\u5143\u53EF\u80FD) */\n\tparityMode?: \"detection\" | \"recovery\";\n}\n\n/**\n * \u30C7\u30B7\u30EA\u30A2\u30E9\u30A4\u30BA\u3055\u308C\u305F\u30C7\u30FC\u30BF\n */\nexport interface DeserializedData {\n\tpuzzle?: PuzzleData;\n\tseed?: { type: RngType; value: string };\n\toptions?: GenerationOptions;\n\tpath?: SolutionPath;\n}\n", "import { type CellConstraint, CellType, Color, type EdgeConstraint, EdgeType, type NodeConstraint, NodeType, type PuzzleData } from \"./types\";\n\n/**\n * \u30D1\u30BA\u30EB\u306E\u30B0\u30EA\u30C3\u30C9\u69CB\u9020\u3068\u72B6\u614B\u3092\u7BA1\u7406\u3059\u308B\u30AF\u30E9\u30B9\n */\nexport class Grid {\n\t/** \u884C\u6570 */\n\tpublic readonly rows: number;\n\t/** \u5217\u6570 */\n\tpublic readonly cols: number;\n\n\t/** \u30BB\u30EB\u306E\u5236\u7D04\uFF08\u8A18\u53F7\uFF09\u30DE\u30C8\u30EA\u30AF\u30B9 */\n\tpublic cells: CellConstraint[][] = [];\n\t/** \u6C34\u5E73\u30A8\u30C3\u30B8\u306E\u5236\u7D04\u30DE\u30C8\u30EA\u30AF\u30B9 */\n\tpublic hEdges: EdgeConstraint[][] = [];\n\t/** \u5782\u76F4\u30A8\u30C3\u30B8\u306E\u5236\u7D04\u30DE\u30C8\u30EA\u30AF\u30B9 */\n\tpublic vEdges: EdgeConstraint[][] = [];\n\t/** \u30CE\u30FC\u30C9\u306E\u5236\u7D04\u30DE\u30C8\u30EA\u30AF\u30B9 */\n\tpublic nodes: NodeConstraint[][] = [];\n\t/** \u5BFE\u79F0\u6027\u306E\u8A2D\u5B9A (SymmetryType) */\n\tpublic symmetry: number = 0;\n\t/** \u30D1\u30BA\u30EB\u751F\u6210\u306B\u4F7F\u7528\u3055\u308C\u305F\u4E71\u6570\u30B7\u30FC\u30C9 (16\u9032\u6570\u6587\u5B57\u5217) */\n\tpublic seed?: string;\n\n\t/**\n\t * \u65B0\u3057\u3044\u30B0\u30EA\u30C3\u30C9\u3092\u521D\u671F\u5316\u3059\u308B\n\t * @param rows \u884C\u6570\n\t * @param cols \u5217\u6570\n\t */\n\tconstructor(rows: number, cols: number) {\n\t\tthis.rows = rows;\n\t\tthis.cols = cols;\n\t\tthis.initializeGrid();\n\t}\n\n\t/**\n\t * \u30B0\u30EA\u30C3\u30C9\u306E\u5404\u8981\u7D20\u3092\u521D\u671F\u72B6\u614B\uFF08\u5236\u7D04\u306A\u3057\uFF09\u3067\u751F\u6210\u3059\u308B\n\t */\n\tprivate initializeGrid() {\n\t\t// Cells: rows * cols\n\t\tthis.cells = Array.from({ length: this.rows }, () => Array.from({ length: this.cols }, () => ({ type: CellType.None, color: Color.None })));\n\n\t\t// H-Edges: (rows + 1) * cols\n\t\tthis.hEdges = Array.from({ length: this.rows + 1 }, () => Array.from({ length: this.cols }, () => ({ type: EdgeType.Normal })));\n\n\t\t// V-Edges: rows * (cols + 1)\n\t\tthis.vEdges = Array.from({ length: this.rows }, () => Array.from({ length: this.cols + 1 }, () => ({ type: EdgeType.Normal })));\n\n\t\t// Nodes: (rows + 1) * (cols + 1)\n\t\tthis.nodes = Array.from({ length: this.rows + 1 }, () => Array.from({ length: this.cols + 1 }, () => ({ type: NodeType.Normal })));\n\t}\n\n\t/**\n\t * \u30B0\u30EA\u30C3\u30C9\u306E\u72B6\u614B\u3092 PuzzleData \u5F62\u5F0F\u3067\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3059\u308B\n\t * @returns \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\n\t */\n\tpublic export(): PuzzleData {\n\t\t// \u30C7\u30FC\u30BF\u306E\u30C7\u30A3\u30FC\u30D7\u30B3\u30D4\u30FC\u3092\u8FD4\u3059\n\t\treturn JSON.parse(\n\t\t\tJSON.stringify({\n\t\t\t\trows: this.rows,\n\t\t\t\tcols: this.cols,\n\t\t\t\tcells: this.cells,\n\t\t\t\tvEdges: this.vEdges,\n\t\t\t\thEdges: this.hEdges,\n\t\t\t\tnodes: this.nodes,\n\t\t\t\tsymmetry: this.symmetry,\n\t\t\t\tseed: this.seed,\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * PuzzleData \u304B\u3089 Grid \u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u3092\u751F\u6210\u3059\u308B\n\t * @param data \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\n\t * @returns Grid \u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\n\t */\n\tpublic static fromData(data: PuzzleData): Grid {\n\t\tconst grid = new Grid(data.rows, data.cols);\n\t\tgrid.cells = data.cells;\n\t\tgrid.vEdges = data.vEdges;\n\t\tgrid.hEdges = data.hEdges;\n\t\tgrid.nodes = data.nodes;\n\t\tgrid.symmetry = data.symmetry || 0;\n\t\tgrid.seed = data.seed;\n\t\treturn grid;\n\t}\n}\n", "export enum RngType {\n\tMulberry32 = 0,\n\tXorShift128Plus = 1,\n\tMathRandom = 2,\n}\n\nexport interface IRng {\n\tnext(): number;\n}\n\nexport class Mulberry32 implements IRng {\n\tprivate state: number;\n\tconstructor(seed: number) {\n\t\tthis.state = seed >>> 0;\n\t}\n\tnext(): number {\n\t\tlet t = (this.state += 0x6d2b79f5) | 0;\n\t\tt = Math.imul(t ^ (t >>> 15), t | 1);\n\t\tt ^= t + Math.imul(t ^ (t >>> 7), t | 61);\n\t\treturn ((t ^ (t >>> 14)) >>> 0) / 4294967296;\n\t}\n}\n\nexport class XorShift128Plus implements IRng {\n\tprivate s0: number;\n\tprivate s1: number;\n\tconstructor(seedLo: number, seedHi: number) {\n\t\tthis.s0 = seedLo >>> 0;\n\t\tthis.s1 = seedHi >>> 0;\n\t\tif (this.s0 === 0 && this.s1 === 0) {\n\t\t\tthis.s1 = 1;\n\t\t}\n\t}\n\tnext(): number {\n\t\tlet x = this.s0;\n\t\tconst y = this.s1;\n\t\tthis.s0 = y;\n\t\tx ^= x << 23;\n\t\tthis.s1 = x ^ y ^ (x >>> 17) ^ (y >>> 26);\n\t\treturn ((this.s1 + y) >>> 0) / 4294967296;\n\t}\n}\n\nexport class MathRandomRng implements IRng {\n\tnext(): number {\n\t\treturn Math.random();\n\t}\n}\n\nexport function createRng(type: RngType, seed: bigint): IRng {\n\tswitch (type) {\n\t\tcase RngType.Mulberry32:\n\t\t\treturn new Mulberry32(Number(seed & 0xffffffffn));\n\t\tcase RngType.XorShift128Plus:\n\t\t\treturn new XorShift128Plus(Number(seed & 0xffffffffn), Number((seed >> 32n) & 0xffffffffn));\n\t\tcase RngType.MathRandom:\n\t\t\treturn new MathRandomRng();\n\t\tdefault:\n\t\t\treturn new Mulberry32(Number(seed & 0xffffffffn));\n\t}\n}\n", "import { Grid } from \"./grid\";\nimport type { IRng } from \"./rng\";\nimport { CellType, Color, EdgeType, NodeType, SymmetryType, type Point, type SolutionPath, type ValidationResult } from \"./types\";\n\n/**\n * \u30D1\u30BA\u30EB\u306E\u56DE\u7B54\u3092\u691C\u8A3C\u3059\u308B\u30AF\u30E9\u30B9\n */\nexport class PuzzleValidator {\n\tprivate tetrisCache: Map<string, boolean> = new Map();\n\tprivate reachabilityCache: Map<string, boolean> = new Map();\n\tprivate rng: IRng | null = null;\n\n\tpublic setRng(rng: IRng | null) {\n\t\tthis.rng = rng;\n\t}\n\n\t/**\n\t * \u4E0E\u3048\u3089\u308C\u305F\u30B0\u30EA\u30C3\u30C9\u3068\u56DE\u7B54\u30D1\u30B9\u304C\u6B63\u5F53\u304B\u3069\u3046\u304B\u3092\u691C\u8A3C\u3059\u308B\n\t * @param grid \u30D1\u30BA\u30EB\u306E\u30B0\u30EA\u30C3\u30C9\u30C7\u30FC\u30BF\n\t * @param solution \u56DE\u7B54\u30D1\u30B9\n\t * @param externalCellsPrecalculated \u65E2\u77E5\u306E\u5916\u90E8\u30BB\u30EB\uFF08\u9AD8\u901F\u5316\u7528\uFF09\n\t * @returns \u691C\u8A3C\u7D50\u679C\uFF08\u6B63\u8AA4\u3001\u30A8\u30E9\u30FC\u7406\u7531\u3001\u7121\u52B9\u5316\u3055\u308C\u305F\u8A18\u53F7\u306A\u3069\uFF09\n\t */\n\tpublic validate(grid: Grid, solution: SolutionPath, externalCellsPrecalculated?: Set<string>): ValidationResult {\n\t\tconst path = solution.points;\n\t\tif (path.length < 2) return { isValid: false, errorReason: \"Path too short\" };\n\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\tconst symPath: Point[] = [];\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tfor (const p of path) {\n\t\t\t\tsymPath.push(this.getSymmetricalPoint(grid, p));\n\t\t\t}\n\t\t}\n\n\t\tconst start = path[0];\n\t\tconst end = path[path.length - 1];\n\n\t\t// \u958B\u59CB\u30CE\u30FC\u30C9\u3068\u7D42\u4E86\u30CE\u30FC\u30C9\u306E\u30C1\u30A7\u30C3\u30AF\n\t\tif (grid.nodes[start.y][start.x].type !== NodeType.Start) return { isValid: false, errorReason: \"Must start at Start Node\" };\n\t\tif (grid.nodes[end.y][end.x].type !== NodeType.End) return { isValid: false, errorReason: \"Must end at End Node\" };\n\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tconst symStart = symPath[0];\n\t\t\tconst symEnd = symPath[symPath.length - 1];\n\t\t\tif (grid.nodes[symStart.y][symStart.x].type !== NodeType.Start) return { isValid: false, errorReason: \"Symmetrical path must start at Start Node\" };\n\t\t\tif (grid.nodes[symEnd.y][symEnd.x].type !== NodeType.End) return { isValid: false, errorReason: \"Symmetrical path must end at End Node\" };\n\t\t}\n\n\t\t// \u30D1\u30B9\u306E\u9023\u7D9A\u6027\u3068\u81EA\u5DF1\u4EA4\u5DEE\u3001\u65AD\u7DDA\u30C1\u30A7\u30C3\u30AF\n\t\tconst visitedNodes = new Set<string>();\n\t\tconst visitedEdges = new Set<string>();\n\t\tvisitedNodes.add(`${start.x},${start.y}`);\n\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tconst symStart = symPath[0];\n\t\t\tif (visitedNodes.has(`${symStart.x},${symStart.y}`)) return { isValid: false, errorReason: \"Paths collide at start\" };\n\t\t\tvisitedNodes.add(`${symStart.x},${symStart.y}`);\n\t\t}\n\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst p1 = path[i];\n\t\t\tconst p2 = path[i + 1];\n\t\t\tconst dist = Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n\t\t\tif (dist !== 1) return { isValid: false, errorReason: \"Invalid jump in path\" };\n\n\t\t\tconst key = `${p2.x},${p2.y}`;\n\t\t\tif (visitedNodes.has(key)) return { isValid: false, errorReason: \"Self-intersecting path or path collision\" };\n\t\t\tvisitedNodes.add(key);\n\n\t\t\tif (this.isBrokenEdge(grid, p1, p2)) return { isValid: false, errorReason: \"Passed through broken edge\" };\n\t\t\tvisitedEdges.add(this.getEdgeKey(p1, p2));\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst sp1 = symPath[i];\n\t\t\t\tconst sp2 = symPath[i + 1];\n\t\t\t\tconst symKey = `${sp2.x},${sp2.y}`;\n\n\t\t\t\tif (visitedNodes.has(symKey)) return { isValid: false, errorReason: \"Path collision\" };\n\t\t\t\tvisitedNodes.add(symKey);\n\n\t\t\t\tif (this.isBrokenEdge(grid, sp1, sp2)) return { isValid: false, errorReason: \"Symmetrical path passed through broken edge\" };\n\n\t\t\t\tconst edgeKey = this.getEdgeKey(sp1, sp2);\n\t\t\t\tif (visitedEdges.has(edgeKey)) return { isValid: false, errorReason: \"Paths cross the same edge\" };\n\t\t\t\tvisitedEdges.add(edgeKey);\n\t\t\t}\n\t\t}\n\n\t\t// \u533A\u753B\u306E\u8A08\u7B97\n\t\tconst regions = this.calculateRegions(grid, path, symPath, externalCellsPrecalculated);\n\t\t// \u901A\u904E\u3057\u306A\u304B\u3063\u305F\u516D\u89D2\u5F62\u306E\u53D6\u5F97\n\t\tconst missed = this.getMissedHexagons(grid, path, symPath);\n\n\t\t// \u30D1\u30B9\u304C\u901A\u3063\u305F\u30A8\u30C3\u30B8\u3092\u8A18\u9332 (\u4E09\u89D2\u5F62\u306E\u30D0\u30EA\u30C7\u30FC\u30B7\u30E7\u30F3\u7528)\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t}\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tfor (let i = 0; i < symPath.length - 1; i++) {\n\t\t\t\tpathEdges.add(this.getEdgeKey(symPath[i], symPath[i + 1]));\n\t\t\t}\n\t\t}\n\n\t\t// \u30A8\u30E9\u30FC\u524A\u9664\uFF08\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF09\u3092\u8003\u616E\u3057\u305F\u5236\u7D04\u691C\u8A3C\n\t\tconst result = this.validateWithErasers(grid, regions, missed.edges, missed.nodes, pathEdges);\n\t\tresult.regions = regions;\n\t\treturn result;\n\t}\n\n\t/**\n\t * \u9AD8\u901F\u5316\u3055\u308C\u305F\u691C\u8A3C\uFF08\u5185\u90E8\u63A2\u7D22\u7528\uFF09\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param path \u30E1\u30A4\u30F3\u30D1\u30B9\n\t * @param symPath \u5BFE\u79F0\u30D1\u30B9\n\t * @param externalCells \u5916\u90E8\u30BB\u30EB\u306E\u30AD\u30E3\u30C3\u30B7\u30E5\n\t * @returns \u691C\u8A3C\u7D50\u679C\n\t */\n\tprivate validateFast(grid: Grid, path: Point[], symPath: Point[], externalCells?: Set<string>): ValidationResult {\n\t\tconst regions = this.calculateRegions(grid, path, symPath, externalCells);\n\t\tconst missed = this.getMissedHexagons(grid, path, symPath);\n\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t}\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tfor (let i = 0; i < symPath.length - 1; i++) {\n\t\t\t\tpathEdges.add(this.getEdgeKey(symPath[i], symPath[i + 1]));\n\t\t\t}\n\t\t}\n\n\t\treturn this.validateWithErasers(grid, regions, missed.edges, missed.nodes, pathEdges);\n\t}\n\n\t/**\n\t * \u4E8C\u70B9\u9593\u304C\u65AD\u7DDA\uFF08Broken or Absent\uFF09\u3057\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param p1 \u70B91\n\t * @param p2 \u70B92\n\t * @returns \u65AD\u7DDA\u3057\u3066\u3044\u308B\u304B\u3069\u3046\u304B\n\t */\n\tprivate isBrokenEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tlet type: EdgeType;\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\ttype = grid.vEdges[y][p1.x].type;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\ttype = grid.hEdges[p1.y][x].type;\n\t\t}\n\t\treturn type === EdgeType.Broken || type === EdgeType.Absent;\n\t}\n\n\t/**\n\t * \u4E8C\u70B9\u9593\u304C Absent\uFF08\u5B58\u5728\u3057\u306A\u3044\uFF09\u30A8\u30C3\u30B8\u304B\u78BA\u8A8D\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param p1 \u70B91\n\t * @param p2 \u70B92\n\t * @returns \u5B58\u5728\u3057\u306A\u3044\u304B\u3069\u3046\u304B\n\t */\n\tprivate isAbsentEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\treturn grid.vEdges[y][p1.x].type === EdgeType.Absent;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\treturn grid.hEdges[p1.y][x].type === EdgeType.Absent;\n\t\t}\n\t}\n\n\t/**\n\t * \u56DE\u7B54\u30D1\u30B9\u304C\u901A\u904E\u3057\u306A\u304B\u3063\u305F\u516D\u89D2\u5F62\uFF08\u30A8\u30C3\u30B8\u30FB\u30CE\u30FC\u30C9\uFF09\u3092\u30EA\u30B9\u30C8\u30A2\u30C3\u30D7\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param path \u30E1\u30A4\u30F3\u30D1\u30B9\n\t * @param symPath \u5BFE\u79F0\u30D1\u30B9\n\t * @returns \u901A\u904E\u3057\u306A\u304B\u3063\u305F\u516D\u89D2\u5F62\u306E\u30EA\u30B9\u30C8\n\t */\n\tprivate getMissedHexagons(grid: Grid, path: Point[], symPath: Point[] = []): { edges: { type: \"h\" | \"v\"; r: number; c: number }[]; nodes: Point[] } {\n\t\tconst mainPathEdges = new Set<string>();\n\t\tconst mainPathNodes = new Set<string>();\n\t\tfor (let i = 0; i < path.length; i++) {\n\t\t\tmainPathNodes.add(`${path[i].x},${path[i].y}`);\n\t\t\tif (i < path.length - 1) {\n\t\t\t\tmainPathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t\t}\n\t\t}\n\n\t\tconst symPathEdges = new Set<string>();\n\t\tconst symPathNodes = new Set<string>();\n\t\tfor (let i = 0; i < symPath.length; i++) {\n\t\t\tsymPathNodes.add(`${symPath[i].x},${symPath[i].y}`);\n\t\t\tif (i < symPath.length - 1) {\n\t\t\t\tsymPathEdges.add(this.getEdgeKey(symPath[i], symPath[i + 1]));\n\t\t\t}\n\t\t}\n\n\t\tconst missedEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tconst type = grid.hEdges[r][c].type;\n\t\t\t\tif (type === EdgeType.Hexagon || type === EdgeType.HexagonMain || type === EdgeType.HexagonSymmetry) {\n\t\t\t\t\tconst key = this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r });\n\t\t\t\t\tlet passed = false;\n\t\t\t\t\tif (type === EdgeType.Hexagon) passed = mainPathEdges.has(key) || symPathEdges.has(key);\n\t\t\t\t\telse if (type === EdgeType.HexagonMain) passed = mainPathEdges.has(key);\n\t\t\t\t\telse if (type === EdgeType.HexagonSymmetry) passed = symPathEdges.has(key);\n\n\t\t\t\t\tif (!passed) missedEdges.push({ type: \"h\", r, c });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tconst type = grid.vEdges[r][c].type;\n\t\t\t\tif (type === EdgeType.Hexagon || type === EdgeType.HexagonMain || type === EdgeType.HexagonSymmetry) {\n\t\t\t\t\tconst key = this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 });\n\t\t\t\t\tlet passed = false;\n\t\t\t\t\tif (type === EdgeType.Hexagon) passed = mainPathEdges.has(key) || symPathEdges.has(key);\n\t\t\t\t\telse if (type === EdgeType.HexagonMain) passed = mainPathEdges.has(key);\n\t\t\t\t\telse if (type === EdgeType.HexagonSymmetry) passed = symPathEdges.has(key);\n\n\t\t\t\t\tif (!passed) missedEdges.push({ type: \"v\", r, c });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst missedNodes: Point[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tconst type = grid.nodes[r][c].type;\n\t\t\t\tif (type === NodeType.Hexagon || type === NodeType.HexagonMain || type === NodeType.HexagonSymmetry) {\n\t\t\t\t\tconst posKey = `${c},${r}`;\n\t\t\t\t\tlet passed = false;\n\t\t\t\t\tif (type === NodeType.Hexagon) passed = mainPathNodes.has(posKey) || symPathNodes.has(posKey);\n\t\t\t\t\telse if (type === NodeType.HexagonMain) passed = mainPathNodes.has(posKey);\n\t\t\t\t\telse if (type === NodeType.HexagonSymmetry) passed = symPathNodes.has(posKey);\n\n\t\t\t\t\tif (!passed) missedNodes.push({ x: c, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { edges: missedEdges, nodes: missedNodes };\n\t}\n\n\t/**\n\t * \u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF08\u30A8\u30E9\u30FC\u524A\u9664\uFF09\u3092\u8003\u616E\u3057\u3066\u30D1\u30BA\u30EB\u306E\u5404\u5236\u7D04\u3092\u691C\u8A3C\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param regions \u533A\u753B\u30EA\u30B9\u30C8\n\t * @param missedHexagons \u901A\u904E\u3057\u306A\u304B\u3063\u305F\u30A8\u30C3\u30B8\u516D\u89D2\u5F62\n\t * @param missedNodeHexagons \u901A\u904E\u3057\u306A\u304B\u3063\u305F\u30CE\u30FC\u30C9\u516D\u89D2\u5F62\n\t * @returns \u691C\u8A3C\u7D50\u679C\n\t */\n\tprivate validateWithErasers(grid: Grid, regions: Point[][], missedHexagons: { type: \"h\" | \"v\"; r: number; c: number }[], missedNodeHexagons: Point[], pathEdges: Set<string>): ValidationResult {\n\t\tconst regionResults: { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] }[][] = [];\n\t\tlet allRegionsPossiblyValid = true;\n\n\t\tfor (let i = 0; i < regions.length; i++) {\n\t\t\tconst region = regions[i];\n\t\t\tconst erasers = region.filter((p) => grid.cells[p.y][p.x].type === CellType.Eraser);\n\t\t\tconst otherMarks = region.filter((p) => grid.cells[p.y][p.x].type !== CellType.None && grid.cells[p.y][p.x].type !== CellType.Eraser);\n\n\t\t\tconst adjacentMissedHexagons: number[] = [];\n\t\t\tfor (let j = 0; j < missedHexagons.length; j++) {\n\t\t\t\tif (this.isHexagonAdjacentToRegion(grid, missedHexagons[j], region)) adjacentMissedHexagons.push(j);\n\t\t\t}\n\n\t\t\tconst adjacentMissedNodeHexagons: number[] = [];\n\t\t\tfor (let j = 0; j < missedNodeHexagons.length; j++) {\n\t\t\t\tif (this.isNodeHexagonAdjacentToRegion(grid, missedNodeHexagons[j], region)) adjacentMissedNodeHexagons.push(j);\n\t\t\t}\n\n\t\t\t// \u5404\u533A\u753B\u3067\u30A8\u30E9\u30FC\u524A\u9664\u306E\u5168\u7D44\u307F\u5408\u308F\u305B\u3092\u8A66\u884C\n\t\t\tconst possible = this.getPossibleErasures(grid, region, erasers, otherMarks, adjacentMissedHexagons, adjacentMissedNodeHexagons, pathEdges);\n\t\t\tif (possible.length === 0) {\n\t\t\t\tallRegionsPossiblyValid = false;\n\t\t\t\t// \u30A8\u30E9\u30FC\u7B87\u6240\u3092\u7279\u5B9A\u3059\u308B\u305F\u3081\u306E\u30D9\u30B9\u30C8\u30A8\u30D5\u30A9\u30FC\u30C8\uFF08\u30E9\u30F3\u30C0\u30E0\u306A\u524A\u9664\uFF09\n\t\t\t\tconst bestEffort = this.getBestEffortErasures(grid, region, erasers, otherMarks, adjacentMissedHexagons, adjacentMissedNodeHexagons, pathEdges);\n\t\t\t\tregionResults.push([bestEffort]);\n\t\t\t} else {\n\t\t\t\t// \u6700\u5C0F\u306E\u524A\u9664\u6570\u3092\u6301\u3064\u89E3\u6C7A\u7B56\u3092\u512A\u5148\u3059\u308B\n\t\t\t\tpossible.sort((a, b) => {\n\t\t\t\t\tconst costA = a.invalidatedCells.length + a.invalidatedHexagons.length + a.invalidatedNodeHexagons.length;\n\t\t\t\t\tconst costB = b.invalidatedCells.length + b.invalidatedHexagons.length + b.invalidatedNodeHexagons.length;\n\t\t\t\t\tif (costA !== costB) return costA - costB;\n\n\t\t\t\t\t// \u540C\u30B3\u30B9\u30C8\u306A\u3089\u516D\u89D2\u5F62\uFF08\u30A8\u30C3\u30B8/\u30CE\u30FC\u30C9\uFF09\u3092\u512A\u5148\u3057\u3066\u7121\u52B9\u5316\u3059\u308B\n\t\t\t\t\tconst hexPriorityA = a.invalidatedHexagons.length + a.invalidatedNodeHexagons.length;\n\t\t\t\t\tconst hexPriorityB = b.invalidatedHexagons.length + b.invalidatedNodeHexagons.length;\n\t\t\t\t\tif (hexPriorityA !== hexPriorityB) return hexPriorityB - hexPriorityA;\n\n\t\t\t\t\treturn a.invalidatedCells.length - b.invalidatedCells.length;\n\t\t\t\t});\n\t\t\t\tregionResults.push(possible);\n\t\t\t}\n\t\t}\n\n\t\tif (allRegionsPossiblyValid) {\n\t\t\t// \u8907\u6570\u306E\u533A\u753B\u306B\u307E\u305F\u304C\u308B\u516D\u89D2\u5F62\u306E\u30A8\u30E9\u30FC\u524A\u9664\u5272\u308A\u5F53\u3066\u3092\u6C7A\u5B9A\n\t\t\tconst assignment = this.findGlobalAssignment(regionResults, missedHexagons.length, missedNodeHexagons.length);\n\t\t\tif (assignment) {\n\t\t\t\treturn {\n\t\t\t\t\tisValid: true,\n\t\t\t\t\tinvalidatedCells: assignment.invalidatedCells,\n\t\t\t\t\tinvalidatedEdges: assignment.invalidatedHexIndices.map((idx) => missedHexagons[idx]),\n\t\t\t\t\tinvalidatedNodes: assignment.invalidatedNodeHexIndices.map((idx) => missedNodeHexagons[idx]),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// \u5931\u6557\u6642\uFF1A\u30A8\u30E9\u30FC\u7B87\u6240\u306E\u53CE\u96C6\n\t\tconst errorCells: Point[] = [];\n\t\tconst invalidatedCells: Point[] = [];\n\t\tconst invalidatedHexIndices = new Set<number>();\n\t\tconst invalidatedNodeHexIndices = new Set<number>();\n\n\t\tfor (const options of regionResults) {\n\t\t\tconst best = options[0]; // \u6700\u521D\u306E\uFF08\u6700\u3082\u30B3\u30B9\u30C8\u306E\u4F4E\u3044\u3001\u307E\u305F\u306F\u30D9\u30B9\u30C8\u30A8\u30D5\u30A9\u30FC\u30C8\u306A\uFF09\u3082\u306E\u3092\u9078\u629E\n\t\t\terrorCells.push(...best.errorCells);\n\t\t\tinvalidatedCells.push(...best.invalidatedCells);\n\t\t\tfor (const idx of best.invalidatedHexagons) invalidatedHexIndices.add(idx);\n\t\t\tfor (const idx of best.invalidatedNodeHexagons) invalidatedNodeHexIndices.add(idx);\n\t\t}\n\n\t\t// \u7121\u52B9\u5316\u3055\u308C\u306A\u304B\u3063\u305F\u516D\u89D2\u5F62\u3082\u30A8\u30E9\u30FC\u3068\u3059\u308B\n\t\tconst errorEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\tfor (let i = 0; i < missedHexagons.length; i++) {\n\t\t\tif (!invalidatedHexIndices.has(i)) {\n\t\t\t\terrorEdges.push(missedHexagons[i]);\n\t\t\t}\n\t\t}\n\t\tconst errorNodes: Point[] = [];\n\t\tfor (let i = 0; i < missedNodeHexagons.length; i++) {\n\t\t\tif (!invalidatedNodeHexIndices.has(i)) {\n\t\t\t\terrorNodes.push(missedNodeHexagons[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tisValid: false,\n\t\t\terrorReason: \"Constraints failed\",\n\t\t\terrorCells,\n\t\t\terrorEdges,\n\t\t\terrorNodes,\n\t\t\tinvalidatedCells,\n\t\t\tinvalidatedEdges: Array.from(invalidatedHexIndices).map((idx) => missedHexagons[idx]),\n\t\t\tinvalidatedNodes: Array.from(invalidatedNodeHexIndices).map((idx) => missedNodeHexagons[idx]),\n\t\t};\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30A8\u30C3\u30B8\u304C\u7279\u5B9A\u306E\u533A\u753B\u306B\u96A3\u63A5\u3057\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param hex \u516D\u89D2\u5F62\u30A8\u30C3\u30B8\n\t * @param region \u533A\u753B\n\t * @returns \u96A3\u63A5\u3057\u3066\u3044\u308B\u304B\u3069\u3046\u304B\n\t */\n\tprivate isHexagonAdjacentToRegion(grid: Grid, hex: { type: \"h\" | \"v\"; r: number; c: number }, region: Point[]): boolean {\n\t\tconst regionCells = new Set(region.map((p) => `${p.x},${p.y}`));\n\t\tif (hex.type === \"h\") {\n\t\t\tif (hex.r > 0 && regionCells.has(`${hex.c},${hex.r - 1}`)) return true;\n\t\t\tif (hex.r < grid.rows && regionCells.has(`${hex.c},${hex.r}`)) return true;\n\t\t} else {\n\t\t\tif (hex.c > 0 && regionCells.has(`${hex.c - 1},${hex.r}`)) return true;\n\t\t\tif (hex.c < grid.cols && regionCells.has(`${hex.c},${hex.r}`)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30CE\u30FC\u30C9\u304C\u7279\u5B9A\u306E\u533A\u753B\u306B\u96A3\u63A5\u3057\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param node \u30CE\u30FC\u30C9\u5EA7\u6A19\n\t * @param region \u533A\u753B\n\t * @returns \u96A3\u63A5\u3057\u3066\u3044\u308B\u304B\u3069\u3046\u304B\n\t */\n\tprivate isNodeHexagonAdjacentToRegion(grid: Grid, node: Point, region: Point[]): boolean {\n\t\tconst regionCells = new Set(region.map((p) => `${p.x},${p.y}`));\n\t\t// \u30CE\u30FC\u30C9\u306E\u5468\u56F24\u3064\u306E\u30BB\u30EB\u306E\u3044\u305A\u308C\u304B\u304C\u533A\u753B\u306B\u542B\u307E\u308C\u3066\u3044\u308C\u3070\u96A3\u63A5\n\t\tconst adjCells = [\n\t\t\t{ x: node.x - 1, y: node.y - 1 },\n\t\t\t{ x: node.x, y: node.y - 1 },\n\t\t\t{ x: node.x - 1, y: node.y },\n\t\t\t{ x: node.x, y: node.y },\n\t\t];\n\t\tfor (const cell of adjCells) {\n\t\t\tif (cell.x >= 0 && cell.x < grid.cols && cell.y >= 0 && cell.y < grid.rows) {\n\t\t\t\tif (regionCells.has(`${cell.x},${cell.y}`)) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u533A\u753B\u5185\u306E\u30A8\u30E9\u30FC\u524A\u9664\u53EF\u80FD\u306A\u5168\u30D1\u30BF\u30FC\u30F3\u3092\u53D6\u5F97\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param region \u533A\u753B\n\t * @param erasers \u6D88\u3057\u30B4\u30E0\u306E\u30EA\u30B9\u30C8\n\t * @param otherMarks \u4ED6\u306E\u8A18\u53F7\u306E\u30EA\u30B9\u30C8\n\t * @param adjacentMissedHexagons \u96A3\u63A5\u3059\u308B\u672A\u901A\u904E\u30A8\u30C3\u30B8\u516D\u89D2\u5F62\n\t * @param adjacentMissedNodeHexagons \u96A3\u63A5\u3059\u308B\u672A\u901A\u904E\u30CE\u30FC\u30C9\u516D\u89D2\u5F62\n\t * @returns \u53EF\u80FD\u306A\u524A\u9664\u30D1\u30BF\u30FC\u30F3\u306E\u30EA\u30B9\u30C8\n\t */\n\tprivate getPossibleErasures(grid: Grid, region: Point[], erasers: Point[], otherMarks: Point[], adjacentMissedHexagons: number[], adjacentMissedNodeHexagons: number[], pathEdges: Set<string>): { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] }[] {\n\t\tconst results: { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] }[] = [];\n\t\tconst numErasers = erasers.length;\n\t\tif (numErasers === 0) {\n\t\t\tconst errorCells = this.getRegionErrors(grid, region, [], pathEdges);\n\t\t\tif (errorCells.length === 0 && adjacentMissedHexagons.length === 0 && adjacentMissedNodeHexagons.length === 0) {\n\t\t\t\tresults.push({ invalidatedCells: [], invalidatedHexagons: [], invalidatedNodeHexagons: [], isValid: true, errorCells: [] });\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\n\t\tconst itemsToNegate = [...otherMarks.map((p) => ({ type: \"cell\" as const, pos: p })), ...adjacentMissedHexagons.map((idx) => ({ type: \"hex\" as const, index: idx })), ...adjacentMissedNodeHexagons.map((idx) => ({ type: \"nodeHex\" as const, index: idx }))];\n\n\t\t// \u521D\u671F\u72B6\u614B\u3067\u30A8\u30E9\u30FC\u304C\u3042\u308B\u304B\u78BA\u8A8D\n\t\tconst initiallyValid = this.getRegionErrors(grid, region, [], pathEdges).length === 0 && adjacentMissedHexagons.length === 0 && adjacentMissedNodeHexagons.length === 0;\n\n\t\tfor (let N = 0; N <= numErasers; N++) {\n\t\t\tconst negatedEraserCombinations = this.getNCombinations(erasers, N);\n\t\t\tfor (const negatedErasers of negatedEraserCombinations) {\n\t\t\t\tconst negatedErasersSet = new Set(negatedErasers.map((e) => `${e.x},${e.y}`));\n\t\t\t\tconst activeErasers = erasers.filter((e) => !negatedErasersSet.has(`${e.x},${e.y}`));\n\n\t\t\t\tfor (let K = 0; K <= itemsToNegate.length; K++) {\n\t\t\t\t\tif (activeErasers.length !== N + K) continue;\n\n\t\t\t\t\tconst itemCombinations = this.getNCombinations(itemsToNegate, K);\n\t\t\t\t\tfor (const negatedItems of itemCombinations) {\n\t\t\t\t\t\tconst negatedCells = negatedItems.filter((it) => it.type === \"cell\").map((it) => it.pos as Point);\n\t\t\t\t\t\tconst negatedHexIndices = negatedItems.filter((it) => it.type === \"hex\").map((it) => it.index as number);\n\t\t\t\t\t\tconst negatedNodeHexIndices = negatedItems.filter((it) => it.type === \"nodeHex\").map((it) => it.index as number);\n\n\t\t\t\t\t\tconst errorCells = this.getRegionErrors(grid, region, [...negatedCells, ...negatedErasers], pathEdges);\n\t\t\t\t\t\tconst isValid = errorCells.length === 0;\n\n\t\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\t\tlet isUseful = true;\n\t\t\t\t\t\t\tif (initiallyValid) {\n\t\t\t\t\t\t\t\tif (K > 0) isUseful = false;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < negatedItems.length; i++) {\n\t\t\t\t\t\t\t\t\tconst subset = [...negatedItems.slice(0, i), ...negatedItems.slice(i + 1)];\n\t\t\t\t\t\t\t\t\tconst subsetCells = subset.filter((it) => it.type === \"cell\").map((it) => it.pos as Point);\n\t\t\t\t\t\t\t\t\tconst subsetHexIndices = new Set(subset.filter((it) => it.type === \"hex\").map((it) => it.index as number));\n\t\t\t\t\t\t\t\t\tconst subsetNodeHexIndices = new Set(subset.filter((it) => it.type === \"nodeHex\").map((it) => it.index as number));\n\n\t\t\t\t\t\t\t\t\tconst allHexSatisfied = adjacentMissedHexagons.every((idx) => subsetHexIndices.has(idx));\n\t\t\t\t\t\t\t\t\tconst allNodeHexSatisfied = adjacentMissedNodeHexagons.every((idx) => subsetNodeHexIndices.has(idx));\n\n\t\t\t\t\t\t\t\t\tif (this.getRegionErrors(grid, region, subsetCells, pathEdges).length === 0 && allHexSatisfied && allNodeHexSatisfied) {\n\t\t\t\t\t\t\t\t\t\tisUseful = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (isUseful) {\n\t\t\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\t\t\tinvalidatedCells: [...negatedCells, ...negatedErasers],\n\t\t\t\t\t\t\t\t\tinvalidatedHexagons: negatedHexIndices,\n\t\t\t\t\t\t\t\t\tinvalidatedNodeHexagons: negatedNodeHexIndices,\n\t\t\t\t\t\t\t\t\tisValid: true,\n\t\t\t\t\t\t\t\t\terrorCells: [],\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * \u30A8\u30E9\u30FC\u304C\u89E3\u6D88\u3067\u304D\u306A\u304B\u3063\u305F\u5834\u5408\u306E\u30D9\u30B9\u30C8\u30A8\u30D5\u30A9\u30FC\u30C8\u306A\u524A\u9664\uFF08\u53EF\u80FD\u306A\u9650\u308A\u6D88\u3057\u30B4\u30E0\u3092\u9069\u7528\uFF09\u3092\u53D6\u5F97\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param region \u533A\u753B\n\t * @param erasers \u6D88\u3057\u30B4\u30E0\u306E\u30EA\u30B9\u30C8\n\t * @param otherMarks \u4ED6\u306E\u8A18\u53F7\u306E\u30EA\u30B9\u30C8\n\t * @param adjacentMissedHexagons \u96A3\u63A5\u3059\u308B\u672A\u901A\u904E\u30A8\u30C3\u30B8\u516D\u89D2\u5F62\n\t * @param adjacentMissedNodeHexagons \u96A3\u63A5\u3059\u308B\u672A\u901A\u904E\u30CE\u30FC\u30C9\u516D\u89D2\u5F62\n\t * @returns \u30D9\u30B9\u30C8\u30A8\u30D5\u30A9\u30FC\u30C8\u306A\u524A\u9664\u7D50\u679C\n\t */\n\tprivate getBestEffortErasures(grid: Grid, region: Point[], erasers: Point[], otherMarks: Point[], adjacentMissedHexagons: number[], adjacentMissedNodeHexagons: number[], pathEdges: Set<string>): { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] } {\n\t\tconst naturalErrors = this.getRegionErrors(grid, region, [], pathEdges);\n\t\tconst initiallyValid = naturalErrors.length === 0 && adjacentMissedHexagons.length === 0 && adjacentMissedNodeHexagons.length === 0;\n\n\t\t// \u521D\u671F\u72B6\u614B\u3067\u6709\u52B9\u306A\u3089\u3001\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\u81EA\u4F53\u304C\u30A8\u30E9\u30FC\u3002\n\t\tif (initiallyValid) {\n\t\t\treturn {\n\t\t\t\tinvalidatedCells: [],\n\t\t\t\tinvalidatedHexagons: [],\n\t\t\t\tinvalidatedNodeHexagons: [],\n\t\t\t\tisValid: false,\n\t\t\t\terrorCells: [...erasers],\n\t\t\t};\n\t\t}\n\n\t\tif (erasers.length > 0) {\n\t\t\tconst itemsToNegate = [...otherMarks.map((p) => ({ type: \"cell\" as const, pos: p })), ...adjacentMissedHexagons.map((idx) => ({ type: \"hex\" as const, index: idx })), ...adjacentMissedNodeHexagons.map((idx) => ({ type: \"nodeHex\" as const, index: idx }))];\n\n\t\t\t// \u30A8\u30E9\u30FC\u89E3\u6D88\u30D1\u30BF\u30FC\u30F3\u3092\u3044\u304F\u3064\u304B\u8A66\u3057\u3001\u6700\u3082\u30A8\u30E9\u30FC\u304C\u5C11\u306A\u304F\u306A\u308B\u3082\u306E\u3092\u63A1\u7528\u3059\u308B\n\t\t\tlet bestResult: { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] } | null = null;\n\t\t\tlet minErrorCount = Infinity;\n\n\t\t\t// \u5358\u7D14\u306A\u512A\u5148\u9806\u4F4D\u306B\u57FA\u3065\u304F\u30D1\u30BF\u30FC\u30F3\n\t\t\tconst tryNegate = (priorityItems: ({ type: \"cell\"; pos: Point } | { type: \"hex\"; index: number } | { type: \"nodeHex\"; index: number })[]) => {\n\t\t\t\tconst toInvalidateCells: Point[] = [];\n\t\t\t\tconst toInvalidateHexagons: number[] = [];\n\t\t\t\tconst toInvalidateNodeHexagons: number[] = [];\n\t\t\t\tlet usedErasersCount = 0;\n\n\t\t\t\tfor (const item of priorityItems) {\n\t\t\t\t\tif (usedErasersCount < erasers.length) {\n\t\t\t\t\t\tif (item.type === \"cell\") toInvalidateCells.push(item.pos);\n\t\t\t\t\t\telse if (item.type === \"hex\") toInvalidateHexagons.push(item.index);\n\t\t\t\t\t\telse toInvalidateNodeHexagons.push(item.index);\n\t\t\t\t\t\tusedErasersCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// \u6B8B\u308A\u306E\u6D88\u3057\u30B4\u30E0\u306F\u30DA\u30A2\u306B\u3057\u3066\u7121\u52B9\u5316\u3092\u8A66\u307F\u308B\n\t\t\t\tconst remainingForPairs = erasers.length - usedErasersCount;\n\t\t\t\tconst N = Math.floor(remainingForPairs / 2);\n\t\t\t\tconst negatedErasers = erasers.slice(usedErasersCount, usedErasersCount + N);\n\t\t\t\tusedErasersCount += N * 2;\n\n\t\t\t\t// \u6D88\u3057\u30B4\u30E0\u81EA\u8EAB\u304C\u30A8\u30E9\u30FC\u304B\u3069\u3046\u304B\u3092\u5224\u5B9A\u3059\u308B\u305F\u3081\u3001getRegionErrors\u3092\u547C\u3076\n\t\t\t\t// \u6D88\u3057\u30B4\u30E0\u81EA\u8EAB\u306F\uFF08\u6D88\u3057\u5408\u3063\u305F\u30DA\u30A2\u3092\u9664\u304D\uFF09\u30DE\u30FC\u30AF\u3068\u3057\u3066\u6B8B\u308B\n\t\t\t\tconst errorCells = this.getRegionErrors(grid, region, [...toInvalidateCells, ...negatedErasers], pathEdges);\n\t\t\t\t// \u4F7F\u308F\u308C\u306A\u304B\u3063\u305F\u6D88\u3057\u30B4\u30E0\u306F\u30A8\u30E9\u30FC\n\t\t\t\tfor (let i = usedErasersCount; i < erasers.length; i++) {\n\t\t\t\t\terrorCells.push(erasers[i]);\n\t\t\t\t}\n\n\t\t\t\tconst unresolvedHexagons = Math.max(0, adjacentMissedHexagons.length - toInvalidateHexagons.length);\n\t\t\t\tconst unresolvedNodeHexagons = Math.max(0, adjacentMissedNodeHexagons.length - toInvalidateNodeHexagons.length);\n\t\t\t\tconst totalErrorCount = errorCells.length + unresolvedHexagons + unresolvedNodeHexagons;\n\n\t\t\t\tif (totalErrorCount < minErrorCount) {\n\t\t\t\t\tminErrorCount = totalErrorCount;\n\n\t\t\t\t\tbestResult = {\n\t\t\t\t\t\tinvalidatedCells: [...toInvalidateCells, ...negatedErasers],\n\t\t\t\t\t\tinvalidatedHexagons: toInvalidateHexagons,\n\t\t\t\t\t\tinvalidatedNodeHexagons: toInvalidateNodeHexagons,\n\t\t\t\t\t\tisValid: false,\n\t\t\t\t\t\terrorCells,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// \u30D1\u30BF\u30FC\u30F31: \u81EA\u7136\u767A\u751F\u3057\u305F\u30A8\u30E9\u30FC\u3092\u512A\u5148\n\t\t\ttryNegate([...naturalErrors.map((p) => ({ type: \"cell\" as const, pos: p })), ...adjacentMissedHexagons.map((idx) => ({ type: \"hex\" as const, index: idx })), ...adjacentMissedNodeHexagons.map((idx) => ({ type: \"nodeHex\" as const, index: idx }))]);\n\t\t\t// \u30D1\u30BF\u30FC\u30F32: \u5168\u3066\u306E\u30A2\u30A4\u30C6\u30E0\u3092\u9806\u756A\u306B\n\t\t\ttryNegate(itemsToNegate);\n\t\t\t// \u30D1\u30BF\u30FC\u30F33: \u81EA\u7136\u767A\u751F\u3057\u305F\u5404\u30A8\u30E9\u30FC\u3092\u500B\u5225\u306B1\u3064\u305A\u3064\u6D88\u3057\u3066\u307F\u308B\n\t\t\tfor (const errCell of naturalErrors) {\n\t\t\t\ttryNegate([{ type: \"cell\", pos: errCell }]);\n\t\t\t}\n\n\t\t\tif (bestResult) return bestResult;\n\t\t}\n\n\t\tconst errorCells = [...naturalErrors, ...erasers];\n\t\treturn {\n\t\t\tinvalidatedCells: [],\n\t\t\tinvalidatedHexagons: [],\n\t\t\tinvalidatedNodeHexagons: [],\n\t\t\tisValid: false,\n\t\t\terrorCells,\n\t\t};\n\t}\n\n\t/**\n\t * \u914D\u5217\u304B\u3089N\u500B\u9078\u3076\u7D44\u307F\u5408\u308F\u305B\u3092\u53D6\u5F97\u3059\u308B\n\t * @param items \u914D\u5217\n\t * @param n \u9078\u629E\u3059\u308B\u6570\n\t * @returns \u7D44\u307F\u5408\u308F\u305B\u306E\u30EA\u30B9\u30C8\n\t */\n\tprivate getNCombinations<T>(items: T[], n: number): T[][] {\n\t\tconst results: T[][] = [];\n\t\tconst backtrack = (start: number, current: T[]) => {\n\t\t\tif (current.length === n) {\n\t\t\t\tresults.push([...current]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (let i = start; i < items.length; i++) {\n\t\t\t\tcurrent.push(items[i]);\n\t\t\t\tbacktrack(i + 1, current);\n\t\t\t\tcurrent.pop();\n\t\t\t}\n\t\t};\n\t\tbacktrack(0, []);\n\t\treturn results;\n\t}\n\n\t/**\n\t * \u7279\u5B9A\u306E\u524A\u9664\u30FB\u7121\u52B9\u5316\u3092\u9069\u7528\u3057\u305F\u72B6\u614B\u3067\u3001\u533A\u753B\u5185\u306E\u5236\u7D04\u304C\u6E80\u305F\u3055\u308C\u3066\u3044\u308B\u304B\u691C\u8A3C\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param region \u533A\u753B\n\t * @param erasedCells \u7121\u52B9\u5316\u3055\u308C\u305F\u30BB\u30EB\u306E\u30EA\u30B9\u30C8\n\t * @returns \u6709\u52B9\u304B\u3069\u3046\u304B\n\t */\n\tprivate checkRegionValid(grid: Grid, region: Point[], erasedCells: Point[], pathEdges: Set<string>): boolean {\n\t\treturn this.getRegionErrors(grid, region, erasedCells, pathEdges).length === 0;\n\t}\n\n\t/**\n\t * \u533A\u753B\u5185\u306E\u30A8\u30E9\u30FC\u3068\u306A\u3063\u3066\u3044\u308B\u30BB\u30EB\u3092\u7279\u5B9A\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param region \u533A\u753B\n\t * @param erasedCells \u7121\u52B9\u5316\u3055\u308C\u305F\u30BB\u30EB\u306E\u30EA\u30B9\u30C8\n\t * @returns \u30A8\u30E9\u30FC\u30BB\u30EB\u306E\u30EA\u30B9\u30C8\n\t */\n\tprivate getRegionErrors(grid: Grid, region: Point[], erasedCells: Point[], pathEdges: Set<string>): Point[] {\n\t\tconst erasedSet = new Set(erasedCells.map((p) => `${p.x},${p.y}`));\n\t\tconst colorCounts = new Map<number, number>();\n\t\tconst colorCells = new Map<number, Point[]>();\n\t\tconst starColors = new Set<number>();\n\t\tconst squareColors = new Set<number>();\n\t\tconst tetrisPieces: { shape: number[][]; rotatable: boolean; pos: Point }[] = [];\n\t\tconst tetrisNegativePieces: { shape: number[][]; rotatable: boolean; pos: Point }[] = [];\n\t\tconst triangleCells: { count: number; pos: Point }[] = [];\n\n\t\tfor (const cell of region) {\n\t\t\tif (erasedSet.has(`${cell.x},${cell.y}`)) continue;\n\t\t\tconst constraint = grid.cells[cell.y][cell.x];\n\t\t\tif (constraint.type === CellType.None) continue;\n\n\t\t\tconst color = constraint.color;\n\t\t\tif (color !== Color.None) {\n\t\t\t\tcolorCounts.set(color, (colorCounts.get(color) || 0) + 1);\n\t\t\t\tif (!colorCells.has(color)) colorCells.set(color, []);\n\t\t\t\tcolorCells.get(color)!.push(cell);\n\t\t\t}\n\n\t\t\tif (constraint.type === CellType.Square) squareColors.add(color);\n\t\t\telse if (constraint.type === CellType.Star) starColors.add(color);\n\t\t\telse if (constraint.type === CellType.Tetris || constraint.type === CellType.TetrisRotated) {\n\t\t\t\tif (constraint.shape) tetrisPieces.push({ shape: constraint.shape, rotatable: constraint.type === CellType.TetrisRotated, pos: cell });\n\t\t\t} else if (constraint.type === CellType.TetrisNegative || constraint.type === CellType.TetrisNegativeRotated) {\n\t\t\t\tif (constraint.shape) tetrisNegativePieces.push({ shape: constraint.shape, rotatable: constraint.type === CellType.TetrisNegativeRotated, pos: cell });\n\t\t\t} else if (constraint.type === CellType.Triangle) {\n\t\t\t\ttriangleCells.push({ count: constraint.count || 0, pos: cell });\n\t\t\t}\n\t\t}\n\n\t\tconst errorCells: Point[] = [];\n\t\t// \u56DB\u89D2\u5F62\u306E\u30EB\u30FC\u30EB\uFF1A\u540C\u533A\u753B\u5185\u306F\u540C\u3058\u8272\n\t\tif (squareColors.size > 1) {\n\t\t\tfor (const cell of region) {\n\t\t\t\tif (erasedSet.has(`${cell.x},${cell.y}`)) continue;\n\t\t\t\tif (grid.cells[cell.y][cell.x].type === CellType.Square) errorCells.push(cell);\n\t\t\t}\n\t\t}\n\n\t\t// \u661F\u306E\u30EB\u30FC\u30EB\uFF1A\u540C\u8272\u306E\u8A18\u53F7\u304C\u3061\u3087\u3046\u30692\u3064\n\t\tfor (const color of starColors) {\n\t\t\tif (colorCounts.get(color) !== 2) {\n\t\t\t\tconst cells = colorCells.get(color) || [];\n\t\t\t\tfor (const p of cells) {\n\t\t\t\t\tconst type = grid.cells[p.y][p.x].type;\n\t\t\t\t\tif (type === CellType.Star) {\n\t\t\t\t\t\terrorCells.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// \u4E09\u89D2\u5F62\u306E\u30EB\u30FC\u30EB\uFF1A\u901A\u904E\u8FBA\u6570\n\t\tfor (const tri of triangleCells) {\n\t\t\tlet passedEdges = 0;\n\t\t\tconst cellEdges = [this.getEdgeKey({ x: tri.pos.x, y: tri.pos.y }, { x: tri.pos.x + 1, y: tri.pos.y }), this.getEdgeKey({ x: tri.pos.x, y: tri.pos.y + 1 }, { x: tri.pos.x + 1, y: tri.pos.y + 1 }), this.getEdgeKey({ x: tri.pos.x, y: tri.pos.y }, { x: tri.pos.x, y: tri.pos.y + 1 }), this.getEdgeKey({ x: tri.pos.x + 1, y: tri.pos.y }, { x: tri.pos.x + 1, y: tri.pos.y + 1 })];\n\t\t\tfor (const edge of cellEdges) {\n\t\t\t\tif (pathEdges.has(edge)) passedEdges++;\n\t\t\t}\n\t\t\tif (passedEdges !== tri.count) {\n\t\t\t\terrorCells.push(tri.pos);\n\t\t\t}\n\t\t}\n\n\t\t// \u30C6\u30C8\u30EA\u30B9\u306E\u30EB\u30FC\u30EB\uFF1A\u30BF\u30A4\u30EA\u30F3\u30B0\u53EF\u80FD\n\t\tif (tetrisPieces.length > 0 || tetrisNegativePieces.length > 0) {\n\t\t\tif (\n\t\t\t\t!this.checkTetrisConstraint(\n\t\t\t\t\tgrid,\n\t\t\t\t\tregion,\n\t\t\t\t\ttetrisPieces.map((p) => ({ shape: p.shape, rotatable: p.rotatable })),\n\t\t\t\t\ttetrisNegativePieces.map((p) => ({ shape: p.shape, rotatable: p.rotatable })),\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tfor (const p of tetrisPieces) errorCells.push(p.pos);\n\t\t\t\tfor (const p of tetrisNegativePieces) errorCells.push(p.pos);\n\t\t\t}\n\t\t}\n\t\treturn errorCells;\n\t}\n\n\t/**\n\t * \u30B0\u30ED\u30FC\u30D0\u30EB\u306A\u5236\u7D04\uFF08\u516D\u89D2\u5F62\uFF09\u306E\u5272\u308A\u5F53\u3066\u3092\u30D0\u30C3\u30AF\u30C8\u30E9\u30C3\u30AD\u30F3\u30B0\u3067\u63A2\u7D22\u3059\u308B\n\t * @param regionResults \u5404\u533A\u753B\u306E\u524A\u9664\u5019\u88DC\u30EA\u30B9\u30C8\n\t * @param totalMissedHexagons \u5408\u8A08\u672A\u901A\u904E\u30A8\u30C3\u30B8\u516D\u89D2\u5F62\u6570\n\t * @param totalMissedNodeHexagons \u5408\u8A08\u672A\u901A\u904E\u30CE\u30FC\u30C9\u516D\u89D2\u5F62\u6570\n\t * @returns \u6210\u529F\u3057\u305F\u5834\u5408\u306F\u5272\u308A\u5F53\u3066\u7D50\u679C\u3001\u5931\u6557\u3057\u305F\u5834\u5408\u306Fnull\n\t */\n\tprivate findGlobalAssignment(regionResults: { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean }[][], totalMissedHexagons: number, totalMissedNodeHexagons: number): { invalidatedCells: Point[]; invalidatedHexIndices: number[]; invalidatedNodeHexIndices: number[] } | null {\n\t\tconst numRegions = regionResults.length;\n\t\tconst currentHexErasures = new Array(totalMissedHexagons).fill(0);\n\t\tconst currentNodeHexErasures = new Array(totalMissedNodeHexagons).fill(0);\n\t\tconst allInvalidatedCells: Point[] = [];\n\t\tconst allInvalidatedHexIndices: number[] = [];\n\t\tconst allInvalidatedNodeHexIndices: number[] = [];\n\n\t\tconst backtrack = (regionIdx: number): boolean => {\n\t\t\tif (regionIdx === numRegions) return currentHexErasures.every((count) => count === 1) && currentNodeHexErasures.every((count) => count === 1);\n\t\t\tfor (const option of regionResults[regionIdx]) {\n\t\t\t\tlet possible = true;\n\t\t\t\tfor (const hexIdx of option.invalidatedHexagons)\n\t\t\t\t\tif (currentHexErasures[hexIdx] > 0) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (possible) {\n\t\t\t\t\tfor (const hexIdx of option.invalidatedNodeHexagons)\n\t\t\t\t\t\tif (currentNodeHexErasures[hexIdx] > 0) {\n\t\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (possible) {\n\t\t\t\t\tfor (const hexIdx of option.invalidatedHexagons) {\n\t\t\t\t\t\tcurrentHexErasures[hexIdx]++;\n\t\t\t\t\t\tallInvalidatedHexIndices.push(hexIdx);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const hexIdx of option.invalidatedNodeHexagons) {\n\t\t\t\t\t\tcurrentNodeHexErasures[hexIdx]++;\n\t\t\t\t\t\tallInvalidatedNodeHexIndices.push(hexIdx);\n\t\t\t\t\t}\n\t\t\t\t\tallInvalidatedCells.push(...option.invalidatedCells);\n\t\t\t\t\tif (backtrack(regionIdx + 1)) return true;\n\n\t\t\t\t\tfor (const hexIdx of option.invalidatedHexagons) {\n\t\t\t\t\t\tcurrentHexErasures[hexIdx]--;\n\t\t\t\t\t\tallInvalidatedHexIndices.pop();\n\t\t\t\t\t}\n\t\t\t\t\tfor (const hexIdx of option.invalidatedNodeHexagons) {\n\t\t\t\t\t\tcurrentNodeHexErasures[hexIdx]--;\n\t\t\t\t\t\tallInvalidatedNodeHexIndices.pop();\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < option.invalidatedCells.length; i++) allInvalidatedCells.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tif (backtrack(0))\n\t\t\treturn {\n\t\t\t\tinvalidatedCells: allInvalidatedCells,\n\t\t\t\tinvalidatedHexIndices: allInvalidatedHexIndices,\n\t\t\t\tinvalidatedNodeHexIndices: allInvalidatedNodeHexIndices,\n\t\t\t};\n\t\treturn null;\n\t}\n\n\t/**\n\t * \u30C6\u30C8\u30EA\u30B9\u5236\u7D04\u306E\u691C\u8A3C\n\t * \u9818\u57DF\u5185\u306E\u5168\u3066\u306E\u30C6\u30C8\u30EA\u30B9\u30D4\u30FC\u30B9\uFF08\u6B63\u30FB\u8CA0\uFF09\u3092\u76E4\u9762\u5185\u306B\u914D\u7F6E\u3057\u3001\n\t * \u5404\u30BB\u30EB\u306E\u5408\u8A08\u5024\u304C\u300C\u9818\u57DF\u5185\u306A\u30891\u3001\u9818\u57DF\u5916\u306A\u30890\u300D\u306B\u306A\u308B\u914D\u7F6E\u304C\u5B58\u5728\u3059\u308B\u304B\u3092\u78BA\u8A8D\u3059\u308B\u3002\n\t * \u91CD\u306A\u308A\u306F\u8A31\u5BB9\u3055\u308C\u308B\u304C\u3001\u6700\u7D42\u7684\u306A\u5408\u8A08\u304C\u30DE\u30A4\u30CA\u30B9\u306B\u306A\u308B\u3053\u3068\u306F\u8A31\u3055\u308C\u306A\u3044\u3002\n\t * \u307E\u305F\u3001\u5168\u3066\u306E\u30D4\u30FC\u30B9\u306F\u30D1\u30BA\u30EB\uFF08\u30B0\u30EA\u30C3\u30C9\uFF09\u306E\u7BC4\u56F2\u5185\u306B\u53CE\u307E\u3063\u3066\u3044\u308B\u5FC5\u8981\u304C\u3042\u308B\u3002\n\t * @param gridObj \u30B0\u30EA\u30C3\u30C9\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\n\t * @param region \u533A\u753B\n\t * @param pieces \u6B63\u306E\u30C6\u30C8\u30EA\u30B9\u30D4\u30FC\u30B9\n\t * @param negativePieces \u8CA0\u306E\u30C6\u30C8\u30EA\u30B9\u30D4\u30FC\u30B9\n\t */\n\tprivate checkTetrisConstraint(gridObj: Grid, region: Point[], pieces: { shape: number[][]; rotatable: boolean }[], negativePieces: { shape: number[][]; rotatable: boolean }[] = []): boolean {\n\t\tconst positiveArea = pieces.reduce((sum, p) => sum + this.getShapeArea(p.shape), 0);\n\t\tconst negativeArea = negativePieces.reduce((sum, p) => sum + this.getShapeArea(p.shape), 0);\n\t\tconst netArea = positiveArea - negativeArea;\n\n\t\tif (netArea < 0) return false;\n\t\tif (netArea !== 0 && netArea !== region.length) return false;\n\n\t\tconst rows = gridObj.rows;\n\t\tconst cols = gridObj.cols;\n\n\t\t// \u30AD\u30E3\u30C3\u30B7\u30E5\u306E\u78BA\u8A8D (\u30E1\u30E2\u30EA\u30EA\u30FC\u30AF\u9632\u6B62\u306E\u305F\u3081\u30B5\u30A4\u30BA\u3092\u5236\u9650)\n\t\tif (this.tetrisCache.size > 10000) this.tetrisCache.clear();\n\n\t\tconst regionMask = new Uint8Array(rows * cols);\n\t\tfor (const p of region) regionMask[p.y * cols + p.x] = 1;\n\t\tconst pieceKey = (p: { shape: number[][]; rotatable: boolean }, sign: number) => `${this.getShapeKey(p.shape)}-${p.rotatable}-${sign}`;\n\t\tconst piecesKey = [...pieces.map((p) => pieceKey(p, 1)), ...negativePieces.map((p) => pieceKey(p, -1))].sort().join(\"|\");\n\t\tconst cacheKey = `${rows}x${cols}:${regionMask.join(\"\")}:${piecesKey}`;\n\t\tif (this.tetrisCache.has(cacheKey)) return this.tetrisCache.get(cacheKey)!;\n\n\t\tconst target = new Int8Array(rows * cols);\n\t\tif (netArea > 0) {\n\t\t\tfor (let i = 0; i < regionMask.length; i++) target[i] = regionMask[i];\n\t\t}\n\t\tconst current = new Int8Array(rows * cols);\n\n\t\t// \u540C\u4E00\u30D4\u30FC\u30B9\u306E\u30B0\u30EB\u30FC\u30D7\u5316\n\t\tconst pieceGroups: {\n\t\t\trotations: { shape: number[][]; h: number; w: number }[];\n\t\t\tsign: number;\n\t\t\tarea: number;\n\t\t\tcount: number;\n\t\t}[] = [];\n\n\t\tconst allPieces = [...pieces.map((p) => ({ ...p, sign: 1 })), ...negativePieces.map((p) => ({ ...p, sign: -1 }))];\n\t\tfor (const p of allPieces) {\n\t\t\tconst rotations = p.rotatable ? this.getAllRotations(p.shape) : [p.shape];\n\t\t\tconst baseShapeKey = this.getShapeKey(rotations[0]);\n\n\t\t\tlet group = pieceGroups.find((g) => g.sign === p.sign && (p.rotatable ? g.rotations.length > 1 : g.rotations.length === 1) && this.getShapeKey(g.rotations[0].shape) === baseShapeKey);\n\n\t\t\tif (group) {\n\t\t\t\tgroup.count++;\n\t\t\t} else {\n\t\t\t\tpieceGroups.push({\n\t\t\t\t\trotations: rotations.map((r) => ({ shape: r, h: r.length, w: r[0].length })),\n\t\t\t\t\tsign: p.sign,\n\t\t\t\t\tarea: this.getShapeArea(p.shape),\n\t\t\t\t\tcount: 1,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// \u6B63\u306E\u30D4\u30FC\u30B9\u3001\u304B\u3064\u9762\u7A4D\u304C\u5927\u304D\u3044\u9806\u306B\u30BD\u30FC\u30C8\u3057\u3066\u679D\u5208\u308A\u52B9\u7387\u3092\u4E0A\u3052\u308B\n\t\tpieceGroups.sort((a, b) => b.sign - a.sign || b.area - a.area);\n\n\t\tlet posMismatch = netArea > 0 ? region.length : 0;\n\t\tlet negMismatch = 0;\n\t\tlet totalPositiveAreaLeft = positiveArea;\n\t\tlet totalNegativeAreaLeft = negativeArea;\n\n\t\tconst backtrack = (groupIdx: number, countInGroup: number, lastPos: number): boolean => {\n\t\t\t// \u9762\u7A4D\u30D9\u30FC\u30B9\u306E\u679D\u5208\u308A\n\t\t\tif (posMismatch > totalPositiveAreaLeft || negMismatch > totalNegativeAreaLeft) return false;\n\n\t\t\tif (groupIdx === pieceGroups.length) {\n\t\t\t\treturn posMismatch === 0 && negMismatch === 0;\n\t\t\t}\n\n\t\t\tconst group = pieceGroups[groupIdx];\n\t\t\tconst nextCount = countInGroup + 1;\n\t\t\tconst isLastInGroup = nextCount === group.count;\n\n\t\t\tif (group.sign === 1) totalPositiveAreaLeft -= group.area;\n\t\t\telse totalNegativeAreaLeft -= group.area;\n\n\t\t\tfor (const rot of group.rotations) {\n\t\t\t\tconst h = rot.h;\n\t\t\t\tconst w = rot.w;\n\t\t\t\tconst startPos = countInGroup === 0 ? 0 : lastPos;\n\n\t\t\t\tfor (let pos = startPos; pos <= rows * cols - (h > 0 ? (h - 1) * cols + w : 0); pos++) {\n\t\t\t\t\tconst r = Math.floor(pos / cols);\n\t\t\t\t\tconst c = pos % cols;\n\t\t\t\t\tif (r > rows - h || c > cols - w) continue;\n\n\t\t\t\t\tlet possible = true;\n\t\t\t\t\tconst placedIndices: number[] = [];\n\n\t\t\t\t\tfor (let pr = 0; pr < h; pr++) {\n\t\t\t\t\t\tfor (let pc = 0; pc < w; pc++) {\n\t\t\t\t\t\t\tif (rot.shape[pr][pc]) {\n\t\t\t\t\t\t\t\tconst tidx = (r + pr) * cols + (c + pc);\n\n\t\t\t\t\t\t\t\t// Incremental mismatch update\n\t\t\t\t\t\t\t\tif (group.sign === 1) {\n\t\t\t\t\t\t\t\t\tif (current[tidx] < target[tidx]) posMismatch--;\n\t\t\t\t\t\t\t\t\telse negMismatch++;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (current[tidx] <= target[tidx]) posMismatch++;\n\t\t\t\t\t\t\t\t\telse negMismatch--;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcurrent[tidx] += group.sign;\n\t\t\t\t\t\t\t\tplacedIndices.push(tidx);\n\n\t\t\t\t\t\t\t\tif (current[tidx] < 0) possible = false;\n\t\t\t\t\t\t\t\tif (group.sign === 1 && current[tidx] > 1 + negativeArea) possible = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!possible) break;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (possible) {\n\t\t\t\t\t\tif (isLastInGroup) {\n\t\t\t\t\t\t\tif (backtrack(groupIdx + 1, 0, 0)) {\n\t\t\t\t\t\t\t\tfor (const tidx of placedIndices) {\n\t\t\t\t\t\t\t\t\tcurrent[tidx] -= group.sign;\n\t\t\t\t\t\t\t\t\tif (group.sign === 1) {\n\t\t\t\t\t\t\t\t\t\tif (current[tidx] < target[tidx]) posMismatch++;\n\t\t\t\t\t\t\t\t\t\telse negMismatch--;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif (current[tidx] <= target[tidx]) posMismatch--;\n\t\t\t\t\t\t\t\t\t\telse negMismatch++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (group.sign === 1) totalPositiveAreaLeft += group.area;\n\t\t\t\t\t\t\t\telse totalNegativeAreaLeft += group.area;\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (backtrack(groupIdx, nextCount, pos)) {\n\t\t\t\t\t\t\t\tfor (const tidx of placedIndices) {\n\t\t\t\t\t\t\t\t\tcurrent[tidx] -= group.sign;\n\t\t\t\t\t\t\t\t\tif (group.sign === 1) {\n\t\t\t\t\t\t\t\t\t\tif (current[tidx] < target[tidx]) posMismatch++;\n\t\t\t\t\t\t\t\t\t\telse negMismatch--;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif (current[tidx] <= target[tidx]) posMismatch--;\n\t\t\t\t\t\t\t\t\t\telse negMismatch++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (group.sign === 1) totalPositiveAreaLeft += group.area;\n\t\t\t\t\t\t\t\telse totalNegativeAreaLeft += group.area;\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const tidx of placedIndices) {\n\t\t\t\t\t\tcurrent[tidx] -= group.sign;\n\t\t\t\t\t\tif (group.sign === 1) {\n\t\t\t\t\t\t\tif (current[tidx] < target[tidx]) posMismatch++;\n\t\t\t\t\t\t\telse negMismatch--;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (current[tidx] <= target[tidx]) posMismatch--;\n\t\t\t\t\t\t\telse negMismatch++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (group.sign === 1) totalPositiveAreaLeft += group.area;\n\t\t\telse totalNegativeAreaLeft += group.area;\n\t\t\treturn false;\n\t\t};\n\n\t\tconst res = backtrack(0, 0, 0);\n\t\tthis.tetrisCache.set(cacheKey, res);\n\t\treturn res;\n\t}\n\n\tprivate getShapeArea(shape: number[][]): number {\n\t\tlet area = 0;\n\t\tfor (const row of shape) for (const cell of row) if (cell) area++;\n\t\treturn area;\n\t}\n\n\tprivate getShapeKey(shape: number[][]): string {\n\t\treturn JSON.stringify(shape);\n\t}\n\n\t/**\n\t * \u518D\u5E30\u7684\u306B\u30BF\u30A4\u30EA\u30F3\u30B0\u3092\u8A66\u307F\u308B\n\t * @param regionGrid \u9818\u57DF\u306E\u30B0\u30EA\u30C3\u30C9\u8868\u73FE\n\t * @param pieces \u6B8B\u308A\u306E\u30D4\u30FC\u30B9\n\t * @returns \u30BF\u30A4\u30EA\u30F3\u30B0\u53EF\u80FD\u304B\u3069\u3046\u304B\n\t */\n\n\tprivate getAllRotations(shape: number[][]): number[][][] {\n\t\tconst results: number[][][] = [];\n\t\tconst keys = new Set<string>();\n\t\tlet curr = shape;\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tconst key = this.getShapeKey(curr);\n\t\t\tif (!keys.has(key)) {\n\t\t\t\tresults.push(curr);\n\t\t\t\tkeys.add(key);\n\t\t\t}\n\t\t\tcurr = this.rotate90(curr);\n\t\t}\n\t\treturn results;\n\t}\n\n\tprivate rotate90(shape: number[][]): number[][] {\n\t\tconst rows = shape.length;\n\t\tconst cols = shape[0].length;\n\t\tconst newShape = Array.from({ length: cols }, () => Array(rows).fill(0));\n\t\tfor (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) newShape[c][rows - 1 - r] = shape[r][c];\n\t\treturn newShape;\n\t}\n\n\t/**\n\t * \u56DE\u7B54\u30D1\u30B9\u306B\u3088\u3063\u3066\u5206\u5272\u3055\u308C\u305F\u5404\u533A\u753B\u306E\u30BB\u30EB\u30EA\u30B9\u30C8\u3092\u53D6\u5F97\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param path \u30E1\u30A4\u30F3\u30D1\u30B9\n\t * @param symPath \u5BFE\u79F0\u30D1\u30B9\n\t * @param externalCellsPrecalculated \u5916\u90E8\u30BB\u30EB\u306E\u30AD\u30E3\u30C3\u30B7\u30E5\n\t * @returns \u533A\u753B\u30EA\u30B9\u30C8\n\t */\n\tprivate calculateRegions(grid: Grid, path: Point[], symPath: Point[] = [], externalCellsPrecalculated?: Set<string>): Point[][] {\n\t\tconst regions: Point[][] = [];\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst visitedCells = new Uint8Array(rows * cols);\n\n\t\t// \u30A8\u30C3\u30B8\u306E\u30DE\u30B9\u30AF\u4F5C\u6210 (\u9AD8\u901F\u5316)\n\t\tconst hEdgesMask = new Uint8Array((rows + 1) * cols);\n\t\tconst vEdgesMask = new Uint8Array(rows * (cols + 1));\n\n\t\tconst setEdge = (p1: Point, p2: Point) => {\n\t\t\tif (p1.x === p2.x) {\n\t\t\t\tvEdgesMask[Math.min(p1.y, p2.y) * (cols + 1) + p1.x] = 1;\n\t\t\t} else {\n\t\t\t\thEdgesMask[p1.y * cols + Math.min(p1.x, p2.x)] = 1;\n\t\t\t}\n\t\t};\n\n\t\tfor (let i = 0; i < path.length - 1; i++) setEdge(path[i], path[i + 1]);\n\t\tfor (let i = 0; i < symPath.length - 1; i++) setEdge(symPath[i], symPath[i + 1]);\n\n\t\t// Absent\u30A8\u30C3\u30B8\u3082\u30DE\u30B9\u30AF\u306B\u8FFD\u52A0\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Absent) hEdgesMask[r * cols + c] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Absent) vEdgesMask[r * (cols + 1) + c] = 1;\n\t\t\t}\n\t\t}\n\n\t\tconst externalCells = externalCellsPrecalculated || this.getExternalCells(grid);\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tconst idx = r * cols + c;\n\t\t\t\tif (visitedCells[idx] || (externalCells && externalCells.has(`${c},${r}`))) continue;\n\n\t\t\t\tconst region: Point[] = [];\n\t\t\t\tconst queue: number[] = [idx];\n\t\t\t\tvisitedCells[idx] = 1;\n\n\t\t\t\tlet head = 0;\n\t\t\t\twhile (head < queue.length) {\n\t\t\t\t\tconst currIdx = queue[head++];\n\t\t\t\t\tconst cx = currIdx % cols;\n\t\t\t\t\tconst cy = Math.floor(currIdx / cols);\n\t\t\t\t\tregion.push({ x: cx, y: cy });\n\n\t\t\t\t\t// Neighbors: Up, Down, Left, Right\n\t\t\t\t\t// Up\n\t\t\t\t\tif (cy > 0 && !hEdgesMask[cy * cols + cx]) {\n\t\t\t\t\t\tconst nIdx = (cy - 1) * cols + cx;\n\t\t\t\t\t\tif (!visitedCells[nIdx] && (!externalCells || !externalCells.has(`${cx},${cy - 1}`))) {\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\n\t\t\t\t\t\t\tqueue.push(nIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Down\n\t\t\t\t\tif (cy < rows - 1 && !hEdgesMask[(cy + 1) * cols + cx]) {\n\t\t\t\t\t\tconst nIdx = (cy + 1) * cols + cx;\n\t\t\t\t\t\tif (!visitedCells[nIdx] && (!externalCells || !externalCells.has(`${cx},${cy + 1}`))) {\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\n\t\t\t\t\t\t\tqueue.push(nIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Left\n\t\t\t\t\tif (cx > 0 && !vEdgesMask[cy * (cols + 1) + cx]) {\n\t\t\t\t\t\tconst nIdx = cy * cols + (cx - 1);\n\t\t\t\t\t\tif (!visitedCells[nIdx] && (!externalCells || !externalCells.has(`${cx - 1},${cy}`))) {\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\n\t\t\t\t\t\t\tqueue.push(nIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Right\n\t\t\t\t\tif (cx < cols - 1 && !vEdgesMask[cy * (cols + 1) + (cx + 1)]) {\n\t\t\t\t\t\tconst nIdx = cy * cols + (cx + 1);\n\t\t\t\t\t\tif (!visitedCells[nIdx] && (!externalCells || !externalCells.has(`${cx + 1},${cy}`))) {\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\n\t\t\t\t\t\t\tqueue.push(nIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregions.push(region);\n\t\t\t}\n\t\t}\n\t\treturn regions;\n\t}\n\n\t/**\n\t * \u30A8\u30C3\u30B8\uFF08Absent\uFF09\u306B\u3088\u3063\u3066\u5916\u90E8\u306B\u7E4B\u304C\u3063\u3066\u3044\u308B\u30BB\u30EB\u3092\u7279\u5B9A\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @returns \u5916\u90E8\u30BB\u30EB\u306E\u30BB\u30C3\u30C8\n\t */\n\tprivate getExternalCells(grid: Grid): Set<string> {\n\t\tconst external = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [];\n\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\tif (grid.hEdges[0][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},0`)) {\n\t\t\t\t\texternal.add(`${c},0`);\n\t\t\t\t\tqueue.push({ x: c, y: 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.hEdges[grid.rows][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},${grid.rows - 1}`)) {\n\t\t\t\t\texternal.add(`${c},${grid.rows - 1}`);\n\t\t\t\t\tqueue.push({ x: c, y: grid.rows - 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tif (grid.vEdges[r][0].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`0,${r}`)) {\n\t\t\t\t\texternal.add(`0,${r}`);\n\t\t\t\t\tqueue.push({ x: 0, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.vEdges[r][grid.cols].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${grid.cols - 1},${r}`)) {\n\t\t\t\t\texternal.add(`${grid.cols - 1},${r}`);\n\t\t\t\t\tqueue.push({ x: grid.cols - 1, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.hEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.hEdges[curr.y + 1][curr.x] },\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x + 1] },\n\t\t\t];\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\tif (!external.has(`${n.nx},${n.ny}`) && n.edge.type === EdgeType.Absent) {\n\t\t\t\t\t\texternal.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn external;\n\t}\n\n\tprivate getSymmetricalPoint(grid: Grid, p: Point): Point {\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\treturn { x: grid.cols - p.x, y: p.y };\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\treturn { x: p.x, y: grid.rows - p.y };\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\treturn { x: grid.cols - p.x, y: grid.rows - p.y };\n\t\t}\n\t\treturn { ...p };\n\t}\n\n\tprivate getSymmetricalPointIndex(grid: Grid, idx: number): number {\n\t\tconst nodeCols = grid.cols + 1;\n\t\tconst r = Math.floor(idx / nodeCols);\n\t\tconst c = idx % nodeCols;\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\tlet sr = r,\n\t\t\tsc = c;\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\tsc = grid.cols - c;\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\tsr = grid.rows - r;\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\tsc = grid.cols - c;\n\t\t\tsr = grid.rows - r;\n\t\t}\n\t\treturn sr * nodeCols + sc;\n\t}\n\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u306E\u96E3\u6613\u5EA6\u30B9\u30B3\u30A2(0.0-1.0)\u3092\u7B97\u51FA\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param starts \u63A2\u7D22\u3092\u958B\u59CB\u3059\u308B\u30B9\u30BF\u30FC\u30C8\u30CE\u30FC\u30C9\u306E\u30EA\u30B9\u30C8\uFF08\u7701\u7565\u6642\u306F\u5168\u30B9\u30BF\u30FC\u30C8\u30CE\u30FC\u30C9\uFF09\n\t */\n\tpublic calculateDifficulty(grid: Grid, starts?: Point[]): number {\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst nodeCols = cols + 1;\n\t\tconst nodeCount = (rows + 1) * nodeCols;\n\t\tconst adj = Array.from({ length: nodeCount }, () => [] as { next: number; hexType: EdgeType; isBroken: boolean }[]);\n\t\tconst startNodes: number[] = [];\n\t\tconst endNodes: number[] = [];\n\t\tconst isEndNode = Array(nodeCount).fill(false);\n\t\tconst hexIdMap = new Map<string, number>();\n\t\tlet nextHexId = 0;\n\t\tconst hexagonEdges = new Set<string>();\n\t\tconst hexagonNodes = new Set<number>();\n\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tconst u = r * nodeCols + c;\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Start) startNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.End) {\n\t\t\t\t\tendNodes.push(u);\n\t\t\t\t\tisEndNode[u] = true;\n\t\t\t\t}\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Hexagon || grid.nodes[r][c].type === NodeType.HexagonMain || grid.nodes[r][c].type === NodeType.HexagonSymmetry) {\n\t\t\t\t\thexIdMap.set(`n${c},${r}`, nextHexId++);\n\t\t\t\t\thexagonNodes.add(u);\n\t\t\t\t}\n\n\t\t\t\tif (c < cols) {\n\t\t\t\t\tconst v = u + 1;\n\t\t\t\t\tconst type = grid.hEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon || type === EdgeType.HexagonMain || type === EdgeType.HexagonSymmetry;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, hexType: type, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, hexType: type, isBroken });\n\t\t\t\t\tif (isHexagon) {\n\t\t\t\t\t\thexIdMap.set(`eh${c},${r}`, nextHexId++);\n\t\t\t\t\t\thexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r }));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (r < rows) {\n\t\t\t\t\tconst v = u + nodeCols;\n\t\t\t\t\tconst type = grid.vEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon || type === EdgeType.HexagonMain || type === EdgeType.HexagonSymmetry;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, hexType: type, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, hexType: type, isBroken });\n\t\t\t\t\tif (isHexagon) {\n\t\t\t\t\t\thexIdMap.set(`ev${c},${r}`, nextHexId++);\n\t\t\t\t\t\thexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 }));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst stats = { totalNodesVisited: 0, branchingPoints: 0, solutions: 0, maxDepth: 0, backtracks: 0 };\n\t\tconst totalHexagons = nextHexId;\n\t\tconst fingerprints = new Set<string>();\n\n\t\t// \u76E4\u9762\u306E\u5927\u304D\u3055\u306B\u5408\u308F\u305B\u3066\u63A2\u7D22\u30EA\u30DF\u30C3\u30C8\u3092\u8ABF\u6574\n\t\tconst searchLimit = Math.max(1000, rows * cols * 200);\n\t\tconst externalCells = this.getExternalCells(grid);\n\n\t\t// \u30BB\u30EB\u30DE\u30FC\u30AF\uFF08\u56DB\u89D2\u3001\u661F\u3001\u30C6\u30C8\u30EA\u30B9\u3001\u6D88\u3057\u30B4\u30E0\uFF09\u304C\u3042\u308B\u304B\u4E8B\u524D\u306B\u30C1\u30A7\u30C3\u30AF\n\t\tlet hasCellMarks = false;\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tif (grid.cells[r][c].type !== CellType.None) {\n\t\t\t\t\thasCellMarks = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasCellMarks) break;\n\t\t}\n\n\t\tthis.tetrisCache.clear();\n\t\tthis.reachabilityCache.clear();\n\n\t\tconst targetStartIndices = starts ? starts.map((p) => p.y * nodeCols + p.x) : startNodes;\n\n\t\tfor (const startIdx of targetStartIndices) {\n\t\t\tconst nodeCols = grid.cols + 1;\n\t\t\tconst r = Math.floor(startIdx / nodeCols);\n\t\t\tconst c = startIdx % nodeCols;\n\t\t\tlet startHexMask = 0n;\n\t\t\tconst nodeType = grid.nodes[r][c].type;\n\t\t\tif (nodeType === NodeType.Hexagon || nodeType === NodeType.HexagonMain) {\n\t\t\t\tstartHexMask |= 1n << BigInt(hexIdMap.get(`n${c},${r}`)!);\n\t\t\t}\n\n\t\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snStart = this.getSymmetricalPointIndex(grid, startIdx);\n\t\t\t\tconst snR = Math.floor(snStart / nodeCols);\n\t\t\t\tconst snC = snStart % nodeCols;\n\t\t\t\tconst snNodeType = grid.nodes[snR][snC].type;\n\t\t\t\tif (snNodeType === NodeType.Hexagon || snNodeType === NodeType.HexagonSymmetry) {\n\t\t\t\t\tstartHexMask |= 1n << BigInt(hexIdMap.get(`n${snC},${snR}`)!);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet visitedMask = 1n << BigInt(startIdx);\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snStart = this.getSymmetricalPointIndex(grid, startIdx);\n\t\t\t\tif (snStart === startIdx) continue;\n\t\t\t\tvisitedMask |= 1n << BigInt(snStart);\n\t\t\t}\n\n\t\t\tthis.exploreSearchSpace(grid, startIdx, visitedMask, [startIdx], startHexMask, totalHexagons, adj, endNodes, isEndNode, fingerprints, stats, searchLimit, externalCells, hasCellMarks, hexIdMap);\n\t\t}\n\n\t\tif (stats.solutions === 0) return 0;\n\n\t\tlet constraintCount = hexagonEdges.size + hexagonNodes.size;\n\t\tconst constraintTypes = new Set<number>();\n\t\tif (hexagonEdges.size > 0) constraintTypes.add(999);\n\n\t\tlet tetrisCount = 0;\n\t\tlet rotatedTetrisCount = 0;\n\t\tlet triangleCount = 0;\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tconst cell = grid.cells[r][c];\n\t\t\t\tif (cell.type !== CellType.None) {\n\t\t\t\t\tconstraintCount++;\n\t\t\t\t\tconstraintTypes.add(cell.type);\n\t\t\t\t\tif (cell.type === CellType.Tetris) tetrisCount++;\n\t\t\t\t\telse if (cell.type === CellType.TetrisRotated) {\n\t\t\t\t\t\ttetrisCount++;\n\t\t\t\t\t\trotatedTetrisCount++;\n\t\t\t\t\t} else if (cell.type === CellType.Triangle) {\n\t\t\t\t\t\ttriangleCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst branchingFactor = stats.branchingPoints / (stats.totalNodesVisited || 1);\n\t\tconst searchComplexity = Math.log10(stats.totalNodesVisited + 1);\n\t\t// \u89E3\u306E\u6570\u304C\u591A\u3044\u307B\u3069\u96E3\u6613\u5EA6\u3092\u4E0B\u3052\u308B\u3002\u30B9\u30B1\u30FC\u30EB\u3092\u8ABF\u6574\n\t\tlet difficulty = (branchingFactor * 10 + searchComplexity * 1.5) / (Math.log2(stats.solutions + 1) * 0.5 + 1);\n\n\t\t// \u30A8\u30C3\u30B8\u306E\u516D\u89D2\u5F62\u304C\u591A\u3044\u307B\u3069\u7C21\u5358\u306B\u306A\u308B\uFF08\u30AC\u30A4\u30C9\u306B\u306A\u308B\u305F\u3081\uFF09\n\t\tdifficulty -= hexagonEdges.size * 0.05;\n\t\t// \u30CE\u30FC\u30C9\u306E\u516D\u89D2\u5F62\u306F\u96E3\u6613\u5EA6\u3092\u4E0A\u3052\u308B\uFF08\u901A\u904E\u304C\u5F37\u5236\u3055\u308C\u308B\u305F\u3081\uFF09\n\t\tdifficulty += hexagonNodes.size * 0.12;\n\n\t\tif (tetrisCount > 0) {\n\t\t\t// \u56DE\u8EE2\u4E0D\u53EF\u304C\u591A\u3044\u307B\u3069\u96E3\u3057\u304F\u3001\u56DE\u8EE2\u53EF\u80FD\u304C\u591A\u3044\u307B\u3069\u7C21\u5358\n\t\t\tdifficulty += (tetrisCount - rotatedTetrisCount) * 0.5;\n\t\t\tdifficulty += rotatedTetrisCount * 0.2;\n\t\t}\n\n\t\t// \u6E1B\u7B97\u30C6\u30C8\u30EA\u30B9\uFF08\u67A0\uFF09\u306E\u96E3\u6613\u5EA6\u8A55\u4FA1\n\t\tlet negTetrisCount = 0;\n\t\tlet rotatedNegTetrisCount = 0;\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tconst cell = grid.cells[r][c];\n\t\t\t\tif (cell.type === CellType.TetrisNegative) negTetrisCount++;\n\t\t\t\telse if (cell.type === CellType.TetrisNegativeRotated) {\n\t\t\t\t\tnegTetrisCount++;\n\t\t\t\t\trotatedNegTetrisCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (negTetrisCount > 0) {\n\t\t\tdifficulty += (negTetrisCount - rotatedNegTetrisCount) * 0.6; // \u6E1B\u7B97\u306F\u914D\u7F6E\u304C\u3088\u308A\u30B7\u30D3\u30A2\u306A\u305F\u3081\u5C11\u3057\u9AD8\u3081\u306B\u8A2D\u5B9A\n\t\t\tdifficulty += rotatedNegTetrisCount * 0.3;\n\t\t}\n\n\t\tif (triangleCount > 0) {\n\t\t\tdifficulty += triangleCount * 0.25;\n\t\t}\n\n\t\tconst cellCount = rows * cols;\n\t\tconst density = constraintCount / cellCount;\n\t\t// \u5BC6\u5EA6\u304C\u4F4E\u3059\u304E\u308B\u3068\u6025\u6FC0\u306B\u96E3\u6613\u5EA6\u304C\u4E0B\u304C\u308B\u3088\u3046\u306B\u8ABF\u6574\u3002\u3088\u308A\u53B3\u3057\u304F\u3002\n\t\tconst densityFactor = density < 0.25 ? Math.pow(density / 0.25, 4) : 1.0;\n\t\tconst typeFactor = constraintTypes.size <= 1 ? 0.5 : 1.0;\n\n\t\tdifficulty *= densityFactor * typeFactor;\n\t\t// \u76E4\u9762\u30B5\u30A4\u30BA\u306B\u3088\u308B\u88DC\u6B63\u3092\u7DE9\u3084\u304B\u306B\n\t\tconst sizeFactor = Math.log2(cellCount) / 5;\n\t\tdifficulty *= sizeFactor;\n\n\t\treturn Math.max(0.01, Math.min(1.0, difficulty / 4));\n\t}\n\n\t/**\n\t * \u63A2\u7D22\u7A7A\u9593\u3092\u8D70\u67FB\u3057\u3066\u7D71\u8A08\u60C5\u5831\u3092\u53CE\u96C6\u3059\u308B\n\t */\n\tprivate exploreSearchSpace(\n\t\tgrid: Grid,\n\t\tcurrIdx: number,\n\t\tvisitedMask: bigint,\n\t\tpath: number[],\n\t\thexMask: bigint,\n\t\ttotalHexagons: number,\n\t\tadj: { next: number; hexType: EdgeType; isBroken: boolean }[][],\n\t\tendNodes: number[],\n\t\tisEndNode: boolean[],\n\t\tfingerprints: Set<string>,\n\t\tstats: { totalNodesVisited: number; branchingPoints: number; solutions: number; maxDepth: number; backtracks: number },\n\t\tlimit: number,\n\t\texternalCells?: Set<string>,\n\t\thasCellMarks: boolean = true,\n\t\thexIdMap?: Map<string, number>,\n\t): void {\n\t\tstats.totalNodesVisited++;\n\t\tstats.maxDepth = Math.max(stats.maxDepth, path.length);\n\t\tif (stats.totalNodesVisited > limit) return;\n\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\n\t\tif (isEndNode[currIdx]) {\n\t\t\tlet setBits = 0;\n\t\t\tlet temp = hexMask;\n\t\t\twhile (temp > 0n) {\n\t\t\t\tif (temp & 1n) setBits++;\n\t\t\t\ttemp >>= 1n;\n\t\t\t}\n\n\t\t\tif (setBits === totalHexagons) {\n\t\t\t\tconst points = path.map((idx) => ({ x: idx % (grid.cols + 1), y: Math.floor(idx / (grid.cols + 1)) }));\n\t\t\t\tconst solutionPath = { points };\n\t\t\t\t// symmetry\u30E2\u30FC\u30C9\u306E\u969B\u3001\u3082\u3046\u4E00\u65B9\u3082EndNode\u306B\u3044\u308B\u5FC5\u8981\u304C\u3042\u308B\n\t\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\t\tconst snEnd = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\t\tconst nodeCols = grid.cols + 1;\n\t\t\t\t\tif (grid.nodes[Math.floor(snEnd / nodeCols)][snEnd % nodeCols].type !== NodeType.End) return;\n\t\t\t\t}\n\n\t\t\t\tconst symPathPoints = symmetry !== SymmetryType.None ? points.map((p) => this.getSymmetricalPoint(grid, p)) : [];\n\t\t\t\t// \u30BB\u30EB\u30DE\u30FC\u30AF\u304C\u306A\u3044\u5834\u5408\u306F\u3001\u3053\u306E\u6642\u70B9\u3067\u6709\u52B9\u306A\u89E3\u3068\u3057\u3066\u78BA\u5B9A\u3067\u304D\u308B\uFF08DFS\u306B\u3088\u308A\u30D1\u30B9\u306E\u6B63\u5F53\u6027\u3068\u5168\u516D\u89D2\u5F62\u901A\u904E\u306F\u4FDD\u8A3C\u6E08\u307F\uFF09\n\t\t\t\tif (!hasCellMarks) {\n\t\t\t\t\tconst fp = this.getFingerprint(grid, points, symPathPoints, undefined, externalCells);\n\t\t\t\t\tif (!fingerprints.has(fp)) {\n\t\t\t\t\t\tfingerprints.add(fp);\n\t\t\t\t\t\tstats.solutions++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// \u30BB\u30EB\u30DE\u30FC\u30AF\u304C\u3042\u308B\u5834\u5408\u306F\u8A73\u7D30\u306A\u691C\u8A3C\u3092\u884C\u3046\n\t\t\t\t\tconst result = this.validateFast(grid, points, symPathPoints, externalCells);\n\t\t\t\t\tif (result.isValid) {\n\t\t\t\t\t\tconst fp = this.getFingerprint(grid, points, symPathPoints, result.regions, externalCells);\n\t\t\t\t\t\tif (!fingerprints.has(fp)) {\n\t\t\t\t\t\t\tfingerprints.add(fp);\n\t\t\t\t\t\t\tstats.solutions++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.canReachEndOptimized(currIdx, visitedMask, adj, isEndNode)) {\n\t\t\tstats.backtracks++;\n\t\t\treturn;\n\t\t}\n\n\t\tconst validMoves = [];\n\t\tfor (const edge of adj[currIdx]) {\n\t\t\tif (edge.isBroken) continue;\n\t\t\tif (visitedMask & (1n << BigInt(edge.next))) continue;\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snCurr = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\n\t\t\t\t// \u5BFE\u79F0\u70B9\u3068\u306E\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\n\t\t\t\tif (edge.next === snNext) continue; // \u30CE\u30FC\u30C9\u885D\u7A81\n\t\t\t\tif (currIdx === snNext && edge.next === snCurr) continue; // \u30A8\u30C3\u30B8\u885D\u7A81\uFF08\u53CD\u5BFE\u5411\u304D\uFF09\n\t\t\t}\n\n\t\t\t// \u516D\u89D2\u5F62\u306E\u679D\u5208\u308A\n\t\t\tlet possible = true;\n\t\t\tfor (const otherEdge of adj[currIdx]) {\n\t\t\t\tconst isMandatoryForMain = otherEdge.hexType === EdgeType.Hexagon || otherEdge.hexType === EdgeType.HexagonMain;\n\t\t\t\tif (isMandatoryForMain) {\n\t\t\t\t\tconst isAlreadyOnPath = path.length >= 2 && otherEdge.next === path[path.length - 2];\n\t\t\t\t\tconst isNextMove = otherEdge.next === edge.next;\n\t\t\t\t\tif (!isAlreadyOnPath && !isNextMove) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!possible) continue;\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snCurr = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\t\t\t\tfor (const otherEdge of adj[snCurr]) {\n\t\t\t\t\tconst isMandatoryForSym = otherEdge.hexType === EdgeType.Hexagon || otherEdge.hexType === EdgeType.HexagonSymmetry;\n\t\t\t\t\tif (isMandatoryForSym) {\n\t\t\t\t\t\tconst snPrev = path.length >= 2 ? this.getSymmetricalPointIndex(grid, path[path.length - 2]) : -1;\n\t\t\t\t\t\tconst isAlreadyOnSymPath = otherEdge.next === snPrev;\n\t\t\t\t\t\tconst isSymNextMove = otherEdge.next === snNext;\n\t\t\t\t\t\tif (!isAlreadyOnSymPath && !isSymNextMove) {\n\t\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (possible) validMoves.push(edge);\n\t\t}\n\n\t\tif (validMoves.length > 1) stats.branchingPoints++;\n\n\t\t// \u5927\u304D\u306A\u76E4\u9762\u3067\u306F\u63A2\u7D22\u304C\u30EA\u30DF\u30C3\u30C8\u306B\u9054\u3057\u3084\u3059\u3044\u305F\u3081\u3001\u63A2\u7D22\u9806\u5E8F\u3092\u30E9\u30F3\u30C0\u30E0\u5316\u3057\u3066\n\t\t// \u5C11\u306A\u304F\u3068\u3082\u3044\u304F\u3064\u304B\u306E\u89E3\u3092\u898B\u3064\u3051\u3084\u3059\u304F\u3059\u308B\n\t\tif (grid.rows * grid.cols > 30) {\n\t\t\tfor (let i = validMoves.length - 1; i > 0; i--) {\n\t\t\t\tconst rnd = this.rng ? this.rng.next() : Math.random();\n\t\t\t\tconst j = Math.floor(rnd * (i + 1));\n\t\t\t\t[validMoves[i], validMoves[j]] = [validMoves[j], validMoves[i]];\n\t\t\t}\n\t\t}\n\n\t\tconst nodeCols = grid.cols + 1;\n\t\tfor (const move of validMoves) {\n\t\t\tlet nextHexMask = hexMask;\n\t\t\tconst r = Math.floor(move.next / nodeCols);\n\t\t\tconst c = move.next % nodeCols;\n\t\t\tconst nodeType = grid.nodes[r][c].type;\n\n\t\t\tif (nodeType === NodeType.Hexagon || nodeType === NodeType.HexagonMain) {\n\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`n${c},${r}`)!);\n\t\t\t}\n\n\t\t\t// \u30A8\u30C3\u30B8\u306E\u30C1\u30A7\u30C3\u30AF\n\t\t\tconst prevIdx = path[path.length - 1];\n\t\t\tconst pr = Math.floor(prevIdx / nodeCols);\n\t\t\tconst pc = prevIdx % nodeCols;\n\t\t\tif (pr === r) {\n\t\t\t\tconst ec = Math.min(pc, c);\n\t\t\t\tif (move.hexType === EdgeType.Hexagon || move.hexType === EdgeType.HexagonMain) {\n\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`eh${ec},${r}`)!);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst er = Math.min(pr, r);\n\t\t\t\tif (move.hexType === EdgeType.Hexagon || move.hexType === EdgeType.HexagonMain) {\n\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`ev${c},${er}`)!);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, move.next);\n\t\t\t\tconst snR = Math.floor(snNext / nodeCols);\n\t\t\t\tconst snC = snNext % nodeCols;\n\t\t\t\tconst snNodeType = grid.nodes[snR][snC].type;\n\t\t\t\tif (snNodeType === NodeType.Hexagon || snNodeType === NodeType.HexagonSymmetry) {\n\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`n${snC},${snR}`)!);\n\t\t\t\t}\n\n\t\t\t\tconst snPrev = this.getSymmetricalPointIndex(grid, prevIdx);\n\t\t\t\tconst spr = Math.floor(snPrev / nodeCols);\n\t\t\t\tconst spc = snPrev % nodeCols;\n\t\t\t\tif (spr === snR) {\n\t\t\t\t\tconst ec = Math.min(spc, snC);\n\t\t\t\t\tconst et = grid.hEdges[snR][ec].type;\n\t\t\t\t\tif (et === EdgeType.Hexagon || et === EdgeType.HexagonSymmetry) {\n\t\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`eh${ec},${snR}`)!);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst er = Math.min(spr, snR);\n\t\t\t\t\tconst et = grid.vEdges[er][snC].type;\n\t\t\t\t\tif (et === EdgeType.Hexagon || et === EdgeType.HexagonSymmetry) {\n\t\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`ev${snC},${er}`)!);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpath.push(move.next);\n\n\t\t\tlet nextVisitedMask = visitedMask | (1n << BigInt(move.next));\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, move.next);\n\t\t\t\tnextVisitedMask |= 1n << BigInt(snNext);\n\t\t\t}\n\n\t\t\tthis.exploreSearchSpace(grid, move.next, nextVisitedMask, path, nextHexMask, totalHexagons, adj, endNodes, isEndNode, fingerprints, stats, limit, externalCells, hasCellMarks, hexIdMap);\n\t\t\tpath.pop();\n\t\t\tif (stats.totalNodesVisited > limit) return;\n\t\t}\n\t}\n\n\t/**\n\t * \u6B63\u89E3\u6570\u3092\u30AB\u30A6\u30F3\u30C8\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param limit \u30AB\u30A6\u30F3\u30C8\u30EA\u30DF\u30C3\u30C8\n\t * @param starts \u63A2\u7D22\u3092\u958B\u59CB\u3059\u308B\u30B9\u30BF\u30FC\u30C8\u30CE\u30FC\u30C9\u306E\u30EA\u30B9\u30C8\uFF08\u7701\u7565\u6642\u306F\u5168\u30B9\u30BF\u30FC\u30C8\u30CE\u30FC\u30C9\uFF09\n\t */\n\tpublic countSolutions(grid: Grid, limit: number = 100, starts?: Point[]): number {\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst nodeCols = cols + 1;\n\t\tconst nodeCount = (rows + 1) * nodeCols;\n\t\tconst adj = Array.from({ length: nodeCount }, () => [] as { next: number; hexType: EdgeType; isBroken: boolean }[]);\n\t\tconst startNodes: number[] = [];\n\t\tconst endNodes: number[] = [];\n\t\tconst isEndNode = Array(nodeCount).fill(false);\n\t\tconst hexIdMap = new Map<string, number>();\n\t\tlet nextHexId = 0;\n\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tconst u = r * nodeCols + c;\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Start) startNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.End) {\n\t\t\t\t\tendNodes.push(u);\n\t\t\t\t\tisEndNode[u] = true;\n\t\t\t\t}\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Hexagon || grid.nodes[r][c].type === NodeType.HexagonMain || grid.nodes[r][c].type === NodeType.HexagonSymmetry) {\n\t\t\t\t\thexIdMap.set(`n${c},${r}`, nextHexId++);\n\t\t\t\t}\n\n\t\t\t\tif (c < cols) {\n\t\t\t\t\tconst v = u + 1;\n\t\t\t\t\tconst type = grid.hEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon || type === EdgeType.HexagonMain || type === EdgeType.HexagonSymmetry;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, hexType: type, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, hexType: type, isBroken });\n\t\t\t\t\tif (isHexagon) hexIdMap.set(`eh${c},${r}`, nextHexId++);\n\t\t\t\t}\n\t\t\t\tif (r < rows) {\n\t\t\t\t\tconst v = u + nodeCols;\n\t\t\t\t\tconst type = grid.vEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon || type === EdgeType.HexagonMain || type === EdgeType.HexagonSymmetry;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, hexType: type, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, hexType: type, isBroken });\n\t\t\t\t\tif (isHexagon) hexIdMap.set(`ev${c},${r}`, nextHexId++);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst fingerprints = new Set<string>();\n\t\tconst totalHexagons = nextHexId;\n\t\tconst externalCells = this.getExternalCells(grid);\n\n\t\t// \u30BB\u30EB\u30DE\u30FC\u30AF\uFF08\u56DB\u89D2\u3001\u661F\u3001\u30C6\u30C8\u30EA\u30B9\u3001\u6D88\u3057\u30B4\u30E0\uFF09\u304C\u3042\u308B\u304B\u4E8B\u524D\u306B\u30C1\u30A7\u30C3\u30AF\n\t\tlet hasCellMarks = false;\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tif (grid.cells[r][c].type !== CellType.None) {\n\t\t\t\t\thasCellMarks = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasCellMarks) break;\n\t\t}\n\n\t\tthis.tetrisCache.clear();\n\t\tthis.reachabilityCache.clear();\n\n\t\tconst targetStartIndices = starts ? starts.map((p) => p.y * nodeCols + p.x) : startNodes;\n\n\t\tfor (const startIdx of targetStartIndices) {\n\t\t\tconst nodeCols = grid.cols + 1;\n\t\t\tconst r = Math.floor(startIdx / nodeCols);\n\t\t\tconst c = startIdx % nodeCols;\n\t\t\tlet startHexMask = 0n;\n\t\t\tconst nodeType = grid.nodes[r][c].type;\n\t\t\tif (nodeType === NodeType.Hexagon || nodeType === NodeType.HexagonMain) {\n\t\t\t\tstartHexMask |= 1n << BigInt(hexIdMap.get(`n${c},${r}`)!);\n\t\t\t}\n\n\t\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snStart = this.getSymmetricalPointIndex(grid, startIdx);\n\t\t\t\tconst snR = Math.floor(snStart / nodeCols);\n\t\t\t\tconst snC = snStart % nodeCols;\n\t\t\t\tconst snNodeType = grid.nodes[snR][snC].type;\n\t\t\t\tif (snNodeType === NodeType.Hexagon || snNodeType === NodeType.HexagonSymmetry) {\n\t\t\t\t\tstartHexMask |= 1n << BigInt(hexIdMap.get(`n${snC},${snR}`)!);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet visitedMask = 1n << BigInt(startIdx);\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snStart = this.getSymmetricalPointIndex(grid, startIdx);\n\t\t\t\tif (snStart === startIdx) continue;\n\t\t\t\tvisitedMask |= 1n << BigInt(snStart);\n\t\t\t}\n\t\t\tthis.findPathsOptimized(grid, startIdx, visitedMask, [startIdx], startHexMask, totalHexagons, adj, endNodes, isEndNode, fingerprints, limit, externalCells, hasCellMarks, hexIdMap);\n\t\t}\n\t\treturn fingerprints.size;\n\t}\n\n\tprivate findPathsOptimized(grid: Grid, currIdx: number, visitedMask: bigint, path: number[], hexMask: bigint, totalHexagons: number, adj: { next: number; hexType: EdgeType; isBroken: boolean }[][], endNodes: number[], isEndNode: boolean[], fingerprints: Set<string>, limit: number, externalCells?: Set<string>, hasCellMarks: boolean = true, hexIdMap?: Map<string, number>): void {\n\t\tif (fingerprints.size >= limit) return;\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\n\t\tif (isEndNode[currIdx]) {\n\t\t\tlet setBits = 0;\n\t\t\tlet temp = hexMask;\n\t\t\twhile (temp > 0n) {\n\t\t\t\tif (temp & 1n) setBits++;\n\t\t\t\ttemp >>= 1n;\n\t\t\t}\n\t\t\tif (setBits === totalHexagons) {\n\t\t\t\tconst points = path.map((idx) => ({ x: idx % (grid.cols + 1), y: Math.floor(idx / (grid.cols + 1)) }));\n\t\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\t\tconst snEnd = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\t\tconst nodeCols = grid.cols + 1;\n\t\t\t\t\tif (grid.nodes[Math.floor(snEnd / nodeCols)][snEnd % nodeCols].type !== NodeType.End) return;\n\t\t\t\t}\n\n\t\t\t\tconst symPathPoints = symmetry !== SymmetryType.None ? points.map((p) => this.getSymmetricalPoint(grid, p)) : [];\n\t\t\t\tif (!hasCellMarks) {\n\t\t\t\t\tfingerprints.add(this.getFingerprint(grid, points, symPathPoints, undefined, externalCells));\n\t\t\t\t} else {\n\t\t\t\t\tconst result = this.validateFast(grid, points, symPathPoints, externalCells);\n\t\t\t\t\tif (result.isValid) {\n\t\t\t\t\t\tfingerprints.add(this.getFingerprint(grid, points, symPathPoints, result.regions, externalCells));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (!this.canReachEndOptimized(currIdx, visitedMask, adj, isEndNode)) return;\n\t\tfor (const edge of adj[currIdx]) {\n\t\t\tif (edge.isBroken) continue;\n\t\t\tif (visitedMask & (1n << BigInt(edge.next))) continue;\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snCurr = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\t\t\t\tif (edge.next === snNext) continue;\n\t\t\t\tif (currIdx === snNext && edge.next === snCurr) continue;\n\t\t\t}\n\n\t\t\tlet possible = true;\n\t\t\tfor (const otherEdge of adj[currIdx]) {\n\t\t\t\tconst isMandatoryForMain = otherEdge.hexType === EdgeType.Hexagon || otherEdge.hexType === EdgeType.HexagonMain;\n\t\t\t\tif (isMandatoryForMain) {\n\t\t\t\t\tconst isAlreadyOnPath = path.length >= 2 && otherEdge.next === path[path.length - 2];\n\t\t\t\t\tconst isNextMove = otherEdge.next === edge.next;\n\t\t\t\t\tif (!isAlreadyOnPath && !isNextMove) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!possible) continue;\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snCurr = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\t\t\t\tfor (const otherEdge of adj[snCurr]) {\n\t\t\t\t\tconst isMandatoryForSym = otherEdge.hexType === EdgeType.Hexagon || otherEdge.hexType === EdgeType.HexagonSymmetry;\n\t\t\t\t\tif (isMandatoryForSym) {\n\t\t\t\t\t\tconst snPrev = path.length >= 2 ? this.getSymmetricalPointIndex(grid, path[path.length - 2]) : -1;\n\t\t\t\t\t\tconst isAlreadyOnSymPath = otherEdge.next === snPrev;\n\t\t\t\t\t\tconst isSymNextMove = otherEdge.next === snNext;\n\t\t\t\t\t\tif (!isAlreadyOnSymPath && !isSymNextMove) {\n\t\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!possible) continue;\n\n\t\t\tconst nodeCols = grid.cols + 1;\n\t\t\tlet nextHexMask = hexMask;\n\t\t\tconst r = Math.floor(edge.next / nodeCols);\n\t\t\tconst c = edge.next % nodeCols;\n\t\t\tconst nodeType = grid.nodes[r][c].type;\n\n\t\t\tif (nodeType === NodeType.Hexagon || nodeType === NodeType.HexagonMain) {\n\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`n${c},${r}`)!);\n\t\t\t}\n\n\t\t\t// \u30A8\u30C3\u30B8\u306E\u30C1\u30A7\u30C3\u30AF\n\t\t\tconst pr = Math.floor(currIdx / nodeCols);\n\t\t\tconst pc = currIdx % nodeCols;\n\t\t\tif (pr === r) {\n\t\t\t\tconst ec = Math.min(pc, c);\n\t\t\t\tif (edge.hexType === EdgeType.Hexagon || edge.hexType === EdgeType.HexagonMain) {\n\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`eh${ec},${r}`)!);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst er = Math.min(pr, r);\n\t\t\t\tif (edge.hexType === EdgeType.Hexagon || edge.hexType === EdgeType.HexagonMain) {\n\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`ev${c},${er}`)!);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\t\t\t\tconst snR = Math.floor(snNext / nodeCols);\n\t\t\t\tconst snC = snNext % nodeCols;\n\t\t\t\tconst snNodeType = grid.nodes[snR][snC].type;\n\t\t\t\tif (snNodeType === NodeType.Hexagon || snNodeType === NodeType.HexagonSymmetry) {\n\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`n${snC},${snR}`)!);\n\t\t\t\t}\n\n\t\t\t\tconst snCurr = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\tconst spr = Math.floor(snCurr / nodeCols);\n\t\t\t\tconst spc = snCurr % nodeCols;\n\t\t\t\tif (spr === snR) {\n\t\t\t\t\tconst ec = Math.min(spc, snC);\n\t\t\t\t\tconst et = grid.hEdges[snR][ec].type;\n\t\t\t\t\tif (et === EdgeType.Hexagon || et === EdgeType.HexagonSymmetry) {\n\t\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`eh${ec},${snR}`)!);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst er = Math.min(spr, snR);\n\t\t\t\t\tconst et = grid.vEdges[er][snC].type;\n\t\t\t\t\tif (et === EdgeType.Hexagon || et === EdgeType.HexagonSymmetry) {\n\t\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`ev${snC},${er}`)!);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpath.push(edge.next);\n\n\t\t\tlet nextVisitedMask = visitedMask | (1n << BigInt(edge.next));\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\t\t\t\tnextVisitedMask |= 1n << BigInt(snNext);\n\t\t\t}\n\n\t\t\tthis.findPathsOptimized(grid, edge.next, nextVisitedMask, path, nextHexMask, totalHexagons, adj, endNodes, isEndNode, fingerprints, limit, externalCells, hasCellMarks, hexIdMap);\n\t\t\tpath.pop();\n\t\t\tif (fingerprints.size >= limit) return;\n\t\t}\n\t}\n\n\t/**\n\t * \u7D42\u7AEF\u307E\u3067\u5230\u9054\u53EF\u80FD\u304B\u30D3\u30C3\u30C8\u30DE\u30B9\u30AFBFS\u3067\u9AD8\u901F\u306B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate canReachEndOptimized(curr: number, visitedMask: bigint, adj: { next: number; isBroken: boolean }[][], isEndNode: boolean[]): boolean {\n\t\tconst cacheKey = `${curr}:${visitedMask.toString()}`;\n\t\tconst cached = this.reachabilityCache.get(cacheKey);\n\t\tif (cached !== undefined) return cached;\n\t\tlet queue = [curr];\n\t\tlet localVisited = visitedMask;\n\t\tlet head = 0;\n\t\twhile (head < queue.length) {\n\t\t\tconst u = queue[head++];\n\t\t\tif (isEndNode[u]) {\n\t\t\t\tthis.reachabilityCache.set(cacheKey, true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (const edge of adj[u])\n\t\t\t\tif (!edge.isBroken && !(localVisited & (1n << BigInt(edge.next)))) {\n\t\t\t\t\tlocalVisited |= 1n << BigInt(edge.next);\n\t\t\t\t\tqueue.push(edge.next);\n\t\t\t\t}\n\t\t}\n\t\tthis.reachabilityCache.set(cacheKey, false);\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u30D1\u30B9\u306E\u8AD6\u7406\u7684\u306A\u6307\u7D0B\u3092\u53D6\u5F97\u3059\u308B\uFF08\u533A\u753B\u5206\u3051\u306B\u57FA\u3065\u304D\u3001\u540C\u4E00\u89E3\u3092\u6392\u9664\u3059\u308B\u305F\u3081\uFF09\n\t */\n\tprivate getFingerprint(grid: Grid, path: Point[], symPath: Point[], precalculatedRegions?: Point[][], externalCells?: Set<string>): string {\n\t\tconst regions = precalculatedRegions || this.calculateRegions(grid, path, symPath, externalCells);\n\t\tconst regionFingerprints = regions\n\t\t\t.map((region) => {\n\t\t\t\tlet regionStr = \"\";\n\t\t\t\tconst marks = [];\n\t\t\t\tfor (const p of region) {\n\t\t\t\t\tconst c = grid.cells[p.y][p.x];\n\t\t\t\t\tif (c.type !== CellType.None) {\n\t\t\t\t\t\tmarks.push((c.type << 8) | c.color);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmarks.sort((a, b) => a - b);\n\t\t\t\tfor (const m of marks) regionStr += m.toString(36) + \",\";\n\t\t\t\treturn regionStr;\n\t\t\t})\n\t\t\t.sort();\n\n\t\tlet finalFp = \"\";\n\t\tfor (const rf of regionFingerprints) {\n\t\t\tif (rf.length > 0) finalFp += rf + \"|\";\n\t\t}\n\t\treturn finalFp || \"empty\";\n\t}\n}\n", "import { Grid } from \"./grid\";\r\nimport { IRng, createRng } from \"./rng\";\r\nimport { CellType, Color, type EdgeConstraint, EdgeType, type GenerationOptions, NodeType, type Point, RngType, SymmetryType } from \"./types\";\r\nimport { PuzzleValidator } from \"./validator\";\r\n\r\ninterface TiledPiece {\r\n\tshape: number[][];\r\n\tdisplayShape: number[][];\r\n\tisRotated: boolean;\r\n\tisNegative?: boolean;\r\n}\r\n\r\n/**\r\n * \u30D1\u30BA\u30EB\u3092\u81EA\u52D5\u751F\u6210\u3059\u308B\u30AF\u30E9\u30B9\r\n */\r\nexport class PuzzleGenerator {\r\n\tprivate isWorker: boolean;\r\n\tprivate TETRIS_SHAPES_WITH_ROTATIONS: number[][][][] = [];\r\n\tprivate rng: IRng | null = null;\r\n\r\n\tconstructor() {\r\n\t\tthis.isWorker = typeof self !== \"undefined\" && \"postMessage\" in self && !(\"document\" in self);\r\n\t\t// \u30C6\u30C8\u30EA\u30B9\u30D4\u30FC\u30B9\u306E\u5168\u56DE\u8EE2\u30D1\u30BF\u30FC\u30F3\u3092\u4E8B\u524D\u306B\u8A08\u7B97\u3057\u3066\u304A\u304F\r\n\t\tfor (const shape of this.TETRIS_SHAPES) {\r\n\t\t\tthis.TETRIS_SHAPES_WITH_ROTATIONS.push(this.getAllRotations(shape));\r\n\t\t}\r\n\t}\r\n\r\n\tprivate stringToSeed(seedStr: string): bigint {\r\n\t\ttry {\r\n\t\t\tif (/^[0-9a-fA-F]+$/.test(seedStr)) {\r\n\t\t\t\treturn BigInt(\"0x\" + seedStr);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\t// ignore\r\n\t\t}\r\n\t\t// \u6587\u5B57\u30B3\u30FC\u30C9\u5909\u63DB\r\n\t\tlet seed = 0n;\r\n\t\tfor (let i = 0; i < seedStr.length; i++) {\r\n\t\t\tseed = (seed << 5n) - seed + BigInt(seedStr.charCodeAt(i));\r\n\t\t}\r\n\t\treturn seed;\r\n\t}\r\n\r\n\t/**\r\n\t * \u30D1\u30BA\u30EB\u3092\u751F\u6210\u3059\u308B\r\n\t * @param rows \u884C\u6570\r\n\t * @param cols \u5217\u6570\r\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\r\n\t * @returns \u751F\u6210\u3055\u308C\u305F\u30B0\u30EA\u30C3\u30C9\r\n\t */\r\n\tpublic generate(rows: number, cols: number, options: GenerationOptions = {}): Grid {\r\n\t\tconst rngType = options.rngType ?? RngType.Mulberry32;\r\n\t\tlet currentSeedStr = options.seed;\r\n\t\tif (!currentSeedStr) {\r\n\t\t\tcurrentSeedStr = Math.floor(Math.random() * 0xffffffff).toString(16);\r\n\t\t}\r\n\t\tconst initialSeedStr = currentSeedStr;\r\n\t\tlet currentSeed = this.stringToSeed(currentSeedStr);\r\n\r\n\t\tconst targetDifficulty = options.difficulty ?? 0.5;\r\n\t\tconst validator = new PuzzleValidator();\r\n\t\tlet bestGrid: Grid | null = null;\r\n\t\tlet bestScore = -1;\r\n\r\n\t\t// \u8A66\u884C\u56DE\u6570\u306E\u8A2D\u5B9A\r\n\t\t// Worker\u6642\u306F\u3001\u30E1\u30A4\u30F3\u30B9\u30EC\u30C3\u30C9\u3092\u6B62\u3081\u306A\u3044\u305F\u3081\u3001\u3088\u308A\u591A\u304F\u306E\u8A66\u884C\u3092\u9AD8\u901F\u306B\u884C\u3046\r\n\t\t// \u5C0F\u3055\u306A\u76E4\u9762\u3084\u5236\u7D04\u304C\u591A\u3044\u5834\u5408\u306F\u5931\u6557\u3057\u3084\u3059\u3044\u305F\u3081\u3001\u8A66\u884C\u56DE\u6570\u3092\u8ABF\u6574\r\n\t\tconst isSmall = rows * cols <= 16;\r\n\t\tconst maxAttempts = this.isWorker ? (rows * cols > 30 ? 120 : isSmall ? 250 : 150) : rows * cols > 30 ? 80 : isSmall ? 200 : 100;\r\n\t\tconst markAttemptsPerPath = this.isWorker ? 8 : isSmall ? 12 : 6;\r\n\r\n\t\tconst symmetry = options.symmetry || SymmetryType.None;\r\n\r\n\t\t// \u30B9\u30BF\u30FC\u30C8\u5730\u70B9\u306E\u8A2D\u5B9A\r\n\t\tlet starts = options.starts ? [...options.starts] : [{ x: 0, y: rows }];\r\n\t\t// \u5BFE\u79F0\u30E2\u30FC\u30C9\u306E\u5834\u5408\u306F\u5BFE\u79F0\u70B9\u3082\u30B9\u30BF\u30FC\u30C8\u5730\u70B9\u306B\u542B\u3081\u308B\r\n\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\tconst symStarts: Point[] = [];\r\n\t\t\tfor (const s of starts) {\r\n\t\t\t\tconst ss = this.getSymmetricalPoint({ rows, cols } as any, s, symmetry);\r\n\t\t\t\tif (!starts.some((p) => p.x === ss.x && p.y === ss.y)) symStarts.push(ss);\r\n\t\t\t}\r\n\t\t\tstarts.push(...symStarts);\r\n\t\t}\r\n\r\n\t\t// \u30B4\u30FC\u30EB\u5730\u70B9\u306E\u8A2D\u5B9A\r\n\t\tlet ends = options.ends ? [...options.ends] : [];\r\n\t\tif (ends.length === 0) {\r\n\t\t\tif (symmetry === SymmetryType.Horizontal) {\r\n\t\t\t\tends = [{ x: 0, y: 0 }];\r\n\t\t\t} else if (symmetry === SymmetryType.Vertical) {\r\n\t\t\t\tends = [{ x: cols, y: rows }];\r\n\t\t\t} else if (symmetry === SymmetryType.Rotational) {\r\n\t\t\t\tends = [{ x: cols, y: rows }];\r\n\t\t\t} else {\r\n\t\t\t\tends = [{ x: cols, y: 0 }];\r\n\t\t\t}\r\n\t\t}\r\n\t\t// \u5BFE\u79F0\u30E2\u30FC\u30C9\u306E\u5834\u5408\u306F\u5BFE\u79F0\u70B9\u3082\u30B4\u30FC\u30EB\u5730\u70B9\u306B\u542B\u3081\u308B\r\n\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\tconst symEnds: Point[] = [];\r\n\t\t\tfor (const e of ends) {\r\n\t\t\t\tconst se = this.getSymmetricalPoint({ rows, cols } as any, e, symmetry);\r\n\t\t\t\tif (!ends.some((p) => p.x === se.x && p.y === se.y)) symEnds.push(se);\r\n\t\t\t}\r\n\t\t\tends.push(...symEnds);\r\n\t\t}\r\n\r\n\t\tlet currentPath: Point[] | null = null;\r\n\t\tlet precalculatedRegions: Point[][] | null = null;\r\n\t\tlet precalculatedBoundaryEdges: { type: \"h\" | \"v\"; r: number; c: number }[][] | null = null;\r\n\r\n\t\tfor (let attempt = 0; attempt < maxAttempts; attempt++) {\r\n\t\t\tconst nextSeed = (currentSeed ^ 0x5deece66dn) + 0xbn;\r\n\t\t\tthis.rng = createRng(rngType, currentSeed ^ 0x5deece66dn);\r\n\t\t\tvalidator.setRng(this.rng);\r\n\t\t\t// \u4E00\u5B9A\u56DE\u6570\u3054\u3068\u306B\u65B0\u3057\u3044\u30D1\u30B9\u3092\u751F\u6210\u3059\u308B\r\n\t\t\tif (attempt % markAttemptsPerPath === 0) {\r\n\t\t\t\tcurrentPath = this.generateRandomPath(new Grid(rows, cols), starts, ends, options.pathLength, symmetry);\r\n\r\n\t\t\t\t// \u30D1\u30B9\u304C\u6C7A\u307E\u3063\u305F\u6642\u70B9\u3067\u3001\u533A\u753B\u3068\u5883\u754C\u30A8\u30C3\u30B8\u3092\u8A08\u7B97\u3057\u3066\u304A\u304F\uFF08\u30DE\u30FC\u30AF\u751F\u6210\u3067\u6D41\u7528\uFF09\r\n\t\t\t\tconst tempGrid = new Grid(rows, cols);\r\n\t\t\t\tconst symPath = symmetry !== SymmetryType.None ? currentPath.map((p) => this.getSymmetricalPoint(tempGrid, p, symmetry)) : [];\r\n\t\t\t\tprecalculatedRegions = this.calculateRegions(tempGrid, currentPath, symPath);\r\n\t\t\t\tprecalculatedBoundaryEdges = precalculatedRegions.map((region) => this.getRegionBoundaryEdges(tempGrid, region, currentPath!, symPath));\r\n\t\t\t}\r\n\r\n\t\t\tconst grid = this.generateFromPath(rows, cols, currentPath!, options, starts, ends, precalculatedRegions!, precalculatedBoundaryEdges!);\r\n\r\n\t\t\t// \u610F\u56F3\u3057\u305F\u30D1\u30B9\u3067\u30AF\u30EA\u30A2\u53EF\u80FD\u304B\u691C\u8A3C\r\n\t\t\tconst validation = validator.validate(grid, { points: currentPath! });\r\n\t\t\tif (!validation.isValid) {\r\n\t\t\t\tcurrentSeed = nextSeed;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// \u4ED6\u306E\u30B9\u30BF\u30FC\u30C8\u5730\u70B9\u304B\u3089\u306E\u89E3\u3092\u30C1\u30A7\u30C3\u30AF\r\n\t\t\tconst chosenStart = currentPath![0];\r\n\t\t\tconst validStarts = [chosenStart];\r\n\t\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\t\tconst ss = this.getSymmetricalPoint(grid, chosenStart, symmetry);\r\n\t\t\t\tif (ss.x !== chosenStart.x || ss.y !== chosenStart.y) validStarts.push(ss);\r\n\t\t\t}\r\n\t\t\tconst otherStarts = starts.filter((s) => !validStarts.some((v) => v.x === s.x && v.y === s.y));\r\n\t\t\tif (otherStarts.length > 0) {\r\n\t\t\t\t// \u4ED6\u306E\u30B9\u30BF\u30FC\u30C8\u304B\u3089\u7C21\u5358\u306B\u89E3\u3051\u3066\u3057\u307E\u3046\u5834\u5408\u306F\u30EA\u30C8\u30E9\u30A4\r\n\t\t\t\tconst otherSolutions = validator.countSolutions(grid, 10, otherStarts);\r\n\t\t\t\tif (otherSolutions > 2) {\r\n\t\t\t\t\tcurrentSeed = nextSeed;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// \u5FC5\u9808\u5236\u7D04\u304C\u542B\u307E\u308C\u3066\u3044\u308B\u304B\u78BA\u8A8D\r\n\t\t\tif (!this.checkAllRequestedConstraintsPresent(grid, options)) {\r\n\t\t\t\tcurrentSeed = nextSeed;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// \u96E3\u6613\u5EA6\u306E\u7B97\u51FA\r\n\t\t\tconst difficulty = validator.calculateDifficulty(grid);\r\n\t\t\tif (difficulty === 0) {\r\n\t\t\t\tcurrentSeed = nextSeed;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tconst diffFromTarget = Math.abs(difficulty - targetDifficulty);\r\n\t\t\tif (bestGrid === null || diffFromTarget < Math.abs(bestScore - targetDifficulty)) {\r\n\t\t\t\tbestScore = difficulty;\r\n\t\t\t\tbestGrid = grid;\r\n\t\t\t\tbestGrid.seed = initialSeedStr;\r\n\t\t\t}\r\n\r\n\t\t\t// \u30BF\u30FC\u30B2\u30C3\u30C8\u306B\u8FD1\u3044\u5834\u5408\u306F\u65E9\u671F\u7D42\u4E86\r\n\t\t\tif (targetDifficulty > 0.8 && difficulty > 0.8) {\r\n\t\t\t\tbestGrid.seed = initialSeedStr;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (diffFromTarget < 0.01) {\r\n\t\t\t\tbestGrid.seed = initialSeedStr;\r\n\t\t\t\tbreak; // \u3088\u308A\u53B3\u3057\u304F\u65E9\u671F\u7D42\u4E86\u5224\u5B9A\r\n\t\t\t}\r\n\r\n\t\t\t// \u6B21\u306E\u8A66\u884C\u3078\u5411\u3051\u3066\u30B7\u30FC\u30C9\u3092\u66F4\u65B0\r\n\t\t\tcurrentSeed = nextSeed;\r\n\t\t}\r\n\r\n\t\t// \u898B\u3064\u304B\u3089\u306A\u304B\u3063\u305F\u5834\u5408\u306F\u6700\u5F8C\u306B\u751F\u6210\u306B\u6210\u529F\u3057\u305F\u3082\u306E\u3092\u8FD4\u3059\r\n\t\tif (!bestGrid) {\r\n\t\t\t// \u6700\u4F4E1\u56DE\u306F\u6210\u529F\u3059\u308B\u307E\u3067\u30EB\u30FC\u30D7\uFF08\u901A\u5E38\u306F\u6570\u56DE\u3067\u7D42\u308F\u308B\uFF09\r\n\t\t\tfor (let i = 0; i < 50; i++) {\r\n\t\t\t\tthis.rng = createRng(rngType, currentSeed);\r\n\t\t\t\tvalidator.setRng(this.rng);\r\n\t\t\t\tconst path = this.generateRandomPath(new Grid(rows, cols), starts, ends, options.pathLength, symmetry);\r\n\t\t\t\tconst grid = this.generateFromPath(rows, cols, path, options, starts, ends);\r\n\t\t\t\tif (validator.validate(grid, { points: path }).isValid) {\r\n\t\t\t\t\tgrid.seed = initialSeedStr;\r\n\t\t\t\t\treturn grid;\r\n\t\t\t\t}\r\n\t\t\t\tcurrentSeed = (currentSeed ^ 0x5deece66dn) + 0xbn;\r\n\t\t\t}\r\n\t\t\t// \u305D\u308C\u3067\u3082\u30C0\u30E1\u306A\u5834\u5408\u306F\u305D\u308C\u3063\u307D\u3044\u76E4\u9762\u3092\u8FD4\u3059\r\n\t\t\tthis.rng = createRng(rngType, currentSeed);\r\n\t\t\tvalidator.setRng(this.rng);\r\n\t\t\tconst path = this.generateRandomPath(new Grid(rows, cols), starts, ends, options.pathLength, symmetry);\r\n\t\t\tconst grid = this.generateFromPath(rows, cols, path, options, starts, ends);\r\n\t\t\tgrid.seed = initialSeedStr;\r\n\t\t\treturn grid;\r\n\t\t}\r\n\t\treturn bestGrid;\r\n\t}\r\n\r\n\t/**\r\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u30D1\u30BA\u30EB\u3092\u69CB\u7BC9\u3059\u308B\r\n\t * @param rows \u884C\u6570\r\n\t * @param cols \u5217\u6570\r\n\t * @param solutionPath \u89E3\u7B54\u30D1\u30B9\r\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\r\n\t * @param starts \u5168\u3066\u306E\u30B9\u30BF\u30FC\u30C8\u5730\u70B9\r\n\t * @param ends \u5168\u3066\u306E\u30B4\u30FC\u30EB\u5730\u70B9\r\n\t * @param precalculatedRegions \u4E8B\u524D\u8A08\u7B97\u3055\u308C\u305F\u533A\u753B\r\n\t * @param precalculatedBoundaryEdges \u4E8B\u524D\u8A08\u7B97\u3055\u308C\u305F\u5883\u754C\u30A8\u30C3\u30B8\r\n\t * @returns \u69CB\u7BC9\u3055\u308C\u305F\u30B0\u30EA\u30C3\u30C9\r\n\t */\r\n\tprivate generateFromPath(rows: number, cols: number, solutionPath: Point[], options: GenerationOptions, starts: Point[], ends: Point[], precalculatedRegions?: Point[][], precalculatedBoundaryEdges?: { type: \"h\" | \"v\"; r: number; c: number }[][]): Grid {\r\n\t\tconst grid = new Grid(rows, cols);\r\n\t\tconst symmetry = options.symmetry || SymmetryType.None;\r\n\t\tgrid.symmetry = symmetry;\r\n\r\n\t\tfor (const s of starts) {\r\n\t\t\tgrid.nodes[s.y][s.x].type = NodeType.Start;\r\n\t\t}\r\n\t\tfor (const e of ends) {\r\n\t\t\tgrid.nodes[e.y][e.x].type = NodeType.End;\r\n\t\t}\r\n\r\n\t\t// \u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u5236\u7D04\uFF08\u8A18\u53F7\uFF09\u3092\u914D\u7F6E\r\n\t\tconst symPath = symmetry !== SymmetryType.None ? solutionPath.map((p) => this.getSymmetricalPoint(grid, p, symmetry)) : [];\r\n\t\tthis.applyConstraintsBasedOnPath(grid, solutionPath, options, symPath, precalculatedRegions, precalculatedBoundaryEdges);\r\n\r\n\t\t// \u65AD\u7DDA\u30A8\u30C3\u30B8\u306E\u9069\u7528\r\n\t\tif (options.useBrokenEdges) {\r\n\t\t\tthis.applyBrokenEdges(grid, solutionPath, options);\r\n\t\t}\r\n\r\n\t\t// \u4E0D\u8981\u306A\u30A8\u30C3\u30B8\u306E\u524A\u9664\uFF08Absent\u5316\uFF09\u3068\u30AF\u30EA\u30FC\u30CB\u30F3\u30B0\r\n\t\tthis.cleanGrid(grid);\r\n\t\treturn grid;\r\n\t}\r\n\r\n\t/**\r\n\t * \u30E9\u30F3\u30C0\u30E0\u306A\u6B63\u89E3\u30D1\u30B9\u3092\u751F\u6210\u3059\u308B\r\n\t * @param targetLengthFactor 0.0 (\u6700\u77ED) - 1.0 (\u6700\u9577)\r\n\t */\r\n\tprivate generateRandomPath(grid: Grid, starts: Point[], ends: Point[], targetLengthFactor?: number, symmetry: SymmetryType = SymmetryType.None): Point[] {\r\n\t\tif (targetLengthFactor === undefined) {\r\n\t\t\treturn this.generateSingleRandomPath(grid, starts, ends, undefined, symmetry);\r\n\t\t}\r\n\r\n\t\t// \u6307\u5B9A\u3055\u308C\u305F\u9577\u3055\u306B\u8FD1\u3044\u30D1\u30B9\u3092\u63A2\u3059\r\n\t\tconst minLen = grid.rows + grid.cols;\r\n\t\tconst maxLen = (grid.rows + 1) * (grid.cols + 1) - 1;\r\n\t\tconst targetLen = minLen + targetLengthFactor * (maxLen - minLen);\r\n\r\n\t\tlet bestPath: Point[] = [];\r\n\t\tlet bestDiff = Infinity;\r\n\r\n\t\tconst attempts = grid.rows * grid.cols > 30 ? 30 : 50;\r\n\t\tfor (let i = 0; i < attempts; i++) {\r\n\t\t\t// \u6700\u521D\u306E\u65B9\u306E\u8A66\u884C\u306F\u30D0\u30A4\u30A2\u30B9\u3092\u5F37\u3081\u306B\u304B\u3051\u308B\r\n\t\t\tconst currentPath = this.generateSingleRandomPath(grid, starts, ends, targetLengthFactor, symmetry);\r\n\t\t\tif (currentPath.length === 0) continue;\r\n\r\n\t\t\tconst currentLen = currentPath.length - 1;\r\n\t\t\tconst diff = Math.abs(currentLen - targetLen);\r\n\r\n\t\t\tif (diff < bestDiff) {\r\n\t\t\t\tbestDiff = diff;\r\n\t\t\t\tbestPath = currentPath;\r\n\t\t\t}\r\n\r\n\t\t\t// \u5341\u5206\u306B\u8FD1\u3044\u30D1\u30B9\u304C\u898B\u3064\u304B\u3063\u305F\u3089\u7D42\u4E86\r\n\t\t\tif (bestDiff <= 2) break;\r\n\t\t}\r\n\r\n\t\treturn bestPath;\r\n\t}\r\n\r\n\t/**\r\n\t * 1\u672C\u306E\u30E9\u30F3\u30C0\u30E0\u30D1\u30B9\u3092\u751F\u6210\u3059\u308B\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t * @param starts \u958B\u59CB\u5019\u88DC\u70B9\u30EA\u30B9\u30C8\r\n\t * @param ends \u7D42\u4E86\u5019\u88DC\u70B9\u30EA\u30B9\u30C8\r\n\t * @param biasFactor \u9577\u3055\u306E\u30D0\u30A4\u30A2\u30B9\r\n\t * @param symmetry \u5BFE\u79F0\u6027\r\n\t * @returns \u751F\u6210\u3055\u308C\u305F\u30D1\u30B9\r\n\t */\r\n\tprivate generateSingleRandomPath(grid: Grid, starts: Point[], ends: Point[], biasFactor?: number, symmetry: SymmetryType = SymmetryType.None): Point[] {\r\n\t\tconst pointCount = (grid.rows + 1) * (grid.cols + 1);\r\n\t\tconst visited = new Array<boolean>(pointCount).fill(false);\r\n\t\tconst path: Point[] = [];\r\n\t\tlet nodesVisited = 0;\r\n\t\t// \u63A2\u7D22\u30EA\u30DF\u30C3\u30C8\u3092\u5927\u5E45\u306B\u5F15\u304D\u4E0A\u3052\u3001\u7279\u306B\u5BFE\u79F0\u30D1\u30BA\u30EB\u3067\u306E\u5230\u9054\u53EF\u80FD\u6027\u3092\u9AD8\u3081\u308B\r\n\t\tconst limit = grid.rows * grid.cols * 200;\r\n\r\n\t\tconst start = starts[Math.floor(this.rng!.next() * starts.length)];\r\n\t\tconst endLookup = new Array<boolean>(pointCount).fill(false);\r\n\t\tfor (const end of ends) endLookup[this.toPointIndex(grid, end.x, end.y)] = true;\r\n\r\n\t\tconst findPath = (current: Point): boolean => {\r\n\t\t\tnodesVisited++;\r\n\t\t\tif (nodesVisited > limit) return false;\r\n\r\n\t\t\tconst currentIndex = this.toPointIndex(grid, current.x, current.y);\r\n\t\t\tvisited[currentIndex] = true;\r\n\t\t\tconst snCurrent = this.getSymmetricalPoint(grid, current, symmetry);\r\n\t\t\tconst snCurrentIndex = this.toPointIndex(grid, snCurrent.x, snCurrent.y);\r\n\t\t\tvisited[snCurrentIndex] = true;\r\n\r\n\t\t\tpath.push(current);\r\n\r\n\t\t\tif (endLookup[currentIndex]) {\r\n\t\t\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\t\t\tif (endLookup[snCurrentIndex]) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet neighbors = this.getValidNeighbors(grid, current, visited);\r\n\r\n\t\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\t\tneighbors = neighbors.filter((n) => {\r\n\t\t\t\t\tconst sn = this.getSymmetricalPoint(grid, n, symmetry);\r\n\t\t\t\t\tif (sn.x < 0 || sn.x > grid.cols || sn.y < 0 || sn.y > grid.rows) return false;\r\n\t\t\t\t\tif (visited[this.toPointIndex(grid, sn.x, sn.y)]) return false;\r\n\t\t\t\t\t// \u30CE\u30FC\u30C9\u885D\u7A81\uFF08\u73FE\u5728\u306E\u79FB\u52D5\u5148\u304C\u81EA\u5206\u81EA\u8EAB\u306E\u5BFE\u79F0\u70B9\u3067\u3042\u308B\u5834\u5408\u3082NG\uFF09\r\n\t\t\t\t\tif (n.x === sn.x && n.y === sn.y) return false;\r\n\t\t\t\t\t// \u30A8\u30C3\u30B8\u885D\u7A81\r\n\t\t\t\t\tconst edgeKey = this.getEdgeKey(current, n);\r\n\t\t\t\t\tconst symEdgeKey = this.getEdgeKey(snCurrent, sn);\r\n\t\t\t\t\tif (edgeKey === symEdgeKey) return false;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tif (biasFactor !== undefined) {\r\n\t\t\t\tneighbors.sort((a, b) => {\r\n\t\t\t\t\tconst getMinDist = (p: Point) => Math.min(...ends.map((e) => Math.abs(p.x - e.x) + Math.abs(p.y - e.y)));\r\n\t\t\t\t\tconst da = getMinDist(a);\r\n\t\t\t\t\tconst db = getMinDist(b);\r\n\t\t\t\t\tconst score = (da - db) * (1 - biasFactor * 2);\r\n\t\t\t\t\treturn score + (this.rng!.next() - 0.5) * 1.5;\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tthis.shuffleArray(neighbors);\r\n\t\t\t}\r\n\r\n\t\t\tfor (const next of neighbors) {\r\n\t\t\t\tif (findPath(next)) return true;\r\n\t\t\t}\r\n\r\n\t\t\tpath.pop();\r\n\t\t\tvisited[currentIndex] = false;\r\n\t\t\tvisited[snCurrentIndex] = false;\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\tfindPath(start);\r\n\t\treturn path;\r\n\t}\r\n\r\n\tprivate toPointIndex(grid: Grid, x: number, y: number): number {\r\n\t\treturn y * (grid.cols + 1) + x;\r\n\t}\r\n\r\n\tprivate getValidNeighbors(grid: Grid, p: Point, visited?: boolean[]): Point[] {\r\n\t\tconst candidates: Point[] = [];\r\n\t\tconst directions = [\r\n\t\t\t{ x: 0, y: -1 },\r\n\t\t\t{ x: 1, y: 0 },\r\n\t\t\t{ x: 0, y: 1 },\r\n\t\t\t{ x: -1, y: 0 },\r\n\t\t];\r\n\t\tfor (const d of directions) {\r\n\t\t\tconst nx = p.x + d.x;\r\n\t\t\tconst ny = p.y + d.y;\r\n\t\t\tif (nx >= 0 && nx <= grid.cols && ny >= 0 && ny <= grid.rows) {\r\n\t\t\t\tif (!visited || !visited[this.toPointIndex(grid, nx, ny)]) candidates.push({ x: nx, y: ny });\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn candidates;\r\n\t}\r\n\r\n\t/**\r\n\t * \u89E3\u30D1\u30B9\u304C\u901A\u3063\u3066\u3044\u306A\u3044\u5834\u6240\u306B\u30E9\u30F3\u30C0\u30E0\u306B\u65AD\u7DDA\uFF08Broken/Absent\uFF09\u3092\u914D\u7F6E\u3059\u308B\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t * @param path \u89E3\u7B54\u30D1\u30B9\r\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\r\n\t */\r\n\tprivate applyBrokenEdges(grid: Grid, path: Point[], options: GenerationOptions) {\r\n\t\tconst complexity = options.complexity ?? 0.5;\r\n\t\tconst symmetry = options.symmetry ?? SymmetryType.None;\r\n\t\tconst pathEdges = new Set<string>();\r\n\r\n\t\t// \u30E1\u30A4\u30F3\u30D1\u30B9\u3068\u5BFE\u79F0\u30D1\u30B9\u306E\u4E21\u65B9\u306E\u30A8\u30C3\u30B8\u3092\u7981\u6B62\u30EA\u30B9\u30C8\u306B\u5165\u308C\u308B\r\n\t\tfor (let i = 0; i < path.length - 1; i++) {\r\n\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\r\n\t\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\t\tconst p1 = this.getSymmetricalPoint(grid, path[i], symmetry);\r\n\t\t\t\tconst p2 = this.getSymmetricalPoint(grid, path[i + 1], symmetry);\r\n\t\t\t\tpathEdges.add(this.getEdgeKey(p1, p2));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst unusedEdges: { type: \"h\" | \"v\"; r: number; c: number; p1: Point; p2: Point }[] = [];\r\n\t\tfor (let r = 0; r <= grid.rows; r++) {\r\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\r\n\t\t\t\tconst p1 = { x: c, y: r };\r\n\t\t\t\tconst p2 = { x: c + 1, y: r };\r\n\t\t\t\tif (!pathEdges.has(this.getEdgeKey(p1, p2))) unusedEdges.push({ type: \"h\", r, c, p1, p2 });\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let r = 0; r < grid.rows; r++) {\r\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\r\n\t\t\t\tconst p1 = { x: c, y: r };\r\n\t\t\t\tconst p2 = { x: c, y: r + 1 };\r\n\t\t\t\tif (!pathEdges.has(this.getEdgeKey(p1, p2))) unusedEdges.push({ type: \"v\", r, c, p1, p2 });\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.shuffleArray(unusedEdges);\r\n\t\t// \u76E4\u9762\u30B5\u30A4\u30BA\u306B\u5FDC\u3058\u3066\u65AD\u7DDA\u6570\u3092\u30B9\u30B1\u30FC\u30EB\u3055\u305B\u308B\r\n\t\tconst targetCount = Math.max(1, Math.floor((complexity * (grid.rows * grid.cols)) / 4));\r\n\t\tlet placed = 0;\r\n\t\tfor (const edge of unusedEdges) {\r\n\t\t\tif (placed >= targetCount) break;\r\n\t\t\t// \u307E\u305A\u306FBroken\u3068\u3057\u3066\u914D\u7F6E\r\n\t\t\tif (edge.type === \"h\") grid.hEdges[edge.r][edge.c].type = EdgeType.Broken;\r\n\t\t\telse grid.vEdges[edge.r][edge.c].type = EdgeType.Broken;\r\n\t\t\tplaced++;\r\n\t\t}\r\n\r\n\t\t// \u5916\u5468\u307E\u305F\u306FAbsent\u306B\u63A5\u89E6\u3057\u3066\u3044\u308BBroken\u3092Absent\u306B\u7F6E\u304D\u63DB\u3048\u308B\uFF08\u4F1D\u64AD\uFF09\r\n\t\tlet changed = true;\r\n\t\twhile (changed) {\r\n\t\t\tchanged = false;\r\n\t\t\t// Horizontal edges\r\n\t\t\tfor (let r = 0; r <= grid.rows; r++) {\r\n\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\r\n\t\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Broken) {\r\n\t\t\t\t\t\tif (this.canBecomeAbsent(grid, { type: \"h\", r, c })) {\r\n\t\t\t\t\t\t\tgrid.hEdges[r][c].type = EdgeType.Absent;\r\n\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Vertical edges\r\n\t\t\tfor (let r = 0; r < grid.rows; r++) {\r\n\t\t\t\tfor (let c = 0; c <= grid.cols; c++) {\r\n\t\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Broken) {\r\n\t\t\t\t\t\tif (this.canBecomeAbsent(grid, { type: \"v\", r, c })) {\r\n\t\t\t\t\t\t\tgrid.vEdges[r][c].type = EdgeType.Absent;\r\n\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// \u5468\u56F2\u304C\u5168\u3066\u65AD\u7DDA\u3057\u3066\u3044\u308B\u30CE\u30FC\u30C9\u306E\u5168\u30A8\u30C3\u30B8\u3092Absent\u5316\u3059\u308B\uFF08\u65E2\u5B58\u30ED\u30B8\u30C3\u30AF\u306E\u7DAD\u6301\uFF09\r\n\t\tfor (let r = 0; r <= grid.rows; r++) {\r\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\r\n\t\t\t\tconst edgesWithMeta: { e: EdgeConstraint; type: \"h\" | \"v\"; r: number; c: number }[] = [];\r\n\t\t\t\tif (c > 0) edgesWithMeta.push({ e: grid.hEdges[r][c - 1], type: \"h\", r, c: c - 1 });\r\n\t\t\t\tif (c < grid.cols) edgesWithMeta.push({ e: grid.hEdges[r][c], type: \"h\", r, c });\r\n\t\t\t\tif (r > 0) edgesWithMeta.push({ e: grid.vEdges[r - 1][c], type: \"v\", r: r - 1, c });\r\n\t\t\t\tif (r < grid.rows) edgesWithMeta.push({ e: grid.vEdges[r][c], type: \"v\", r, c });\r\n\r\n\t\t\t\tif (edgesWithMeta.length > 0 && edgesWithMeta.every((m) => m.e.type === EdgeType.Broken || m.e.type === EdgeType.Absent)) {\r\n\t\t\t\t\tif (edgesWithMeta.every((m) => !this.isAdjacentToMark(grid, m))) {\r\n\t\t\t\t\t\tfor (const m of edgesWithMeta) m.e.type = EdgeType.Absent;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u30A8\u30C3\u30B8\u304CAbsent\u306B\u5909\u63DB\u53EF\u80FD\u304B\u5224\u5B9A\u3059\u308B\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t * @param edge \u5224\u5B9A\u5BFE\u8C61\u306E\u30A8\u30C3\u30B8\r\n\t * @returns \u5909\u63DB\u53EF\u80FD\u304B\u3069\u3046\u304B\r\n\t */\r\n\tprivate canBecomeAbsent(grid: Grid, edge: { type: \"h\" | \"v\"; r: number; c: number }): boolean {\r\n\t\t// \u30DE\u30FC\u30AF\u306B\u96A3\u63A5\u3057\u3066\u3044\u308B\u5834\u5408\u306FAbsent\u7981\u6B62\r\n\t\tif (this.isAdjacentToMark(grid, edge)) return false;\r\n\r\n\t\t// 1. \u5916\u5468\u306B\u3042\u308B\u304B\r\n\t\tif (edge.type === \"h\") {\r\n\t\t\tif (edge.r === 0 || edge.r === grid.rows) return true;\r\n\t\t} else {\r\n\t\t\tif (edge.c === 0 || edge.c === grid.cols) return true;\r\n\t\t}\r\n\r\n\t\t// 2. \u4ED6\u306EAbsent\u30A8\u30C3\u30B8\u306B\u63A5\u89E6\uFF08\u30CE\u30FC\u30C9\u3092\u5171\u6709\uFF09\u3057\u3066\u3044\u308B\u304B\r\n\t\tconst nodes =\r\n\t\t\tedge.type === \"h\"\r\n\t\t\t\t? [\r\n\t\t\t\t\t\t{ x: edge.c, y: edge.r },\r\n\t\t\t\t\t\t{ x: edge.c + 1, y: edge.r },\r\n\t\t\t\t\t]\r\n\t\t\t\t: [\r\n\t\t\t\t\t\t{ x: edge.c, y: edge.r },\r\n\t\t\t\t\t\t{ x: edge.c, y: edge.r + 1 },\r\n\t\t\t\t\t];\r\n\r\n\t\tfor (const node of nodes) {\r\n\t\t\tconst adjEdges = [\r\n\t\t\t\t{ type: \"h\", r: node.y, c: node.x - 1 },\r\n\t\t\t\t{ type: \"h\", r: node.y, c: node.x },\r\n\t\t\t\t{ type: \"v\", r: node.y - 1, c: node.x },\r\n\t\t\t\t{ type: \"v\", r: node.y, c: node.x },\r\n\t\t\t];\r\n\t\t\tfor (const adj of adjEdges) {\r\n\t\t\t\tif (adj.c >= 0 && adj.c <= grid.cols && adj.r >= 0 && adj.r <= grid.rows) {\r\n\t\t\t\t\tif (adj.type === \"h\" && adj.c < grid.cols) {\r\n\t\t\t\t\t\tif (grid.hEdges[adj.r][adj.c].type === EdgeType.Absent) return true;\r\n\t\t\t\t\t} else if (adj.type === \"v\" && adj.r < grid.rows) {\r\n\t\t\t\t\t\tif (grid.vEdges[adj.r][adj.c].type === EdgeType.Absent) return true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * \u5230\u9054\u4E0D\u53EF\u80FD\u306A\u30A8\u30EA\u30A2\u3092Absent\u5316\u3057\u3001\u5916\u90E8\u306B\u6F0F\u308C\u305F\u30BB\u30EB\u3092\u30AF\u30EA\u30A2\u3059\u308B\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t */\r\n\tprivate cleanGrid(grid: Grid) {\r\n\t\tconst startNodes: { x: number; y: number }[] = [];\r\n\t\tfor (let r = 0; r <= grid.rows; r++) {\r\n\t\t\tfor (let c = 0; c <= grid.cols; c++) if (grid.nodes[r][c].type === NodeType.Start) startNodes.push({ x: c, y: r });\r\n\t\t}\r\n\r\n\t\tconst reachableNodes = new Set<string>();\r\n\t\tconst queue: { x: number; y: number }[] = [...startNodes];\r\n\t\tfor (const p of startNodes) reachableNodes.add(`${p.x},${p.y}`);\r\n\r\n\t\twhile (queue.length > 0) {\r\n\t\t\tconst curr = queue.shift()!;\r\n\t\t\tconst neighbors = [\r\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.vEdges[curr.y - 1]?.[curr.x] },\r\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.vEdges[curr.y]?.[curr.x] },\r\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.hEdges[curr.y]?.[curr.x - 1] },\r\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.hEdges[curr.y]?.[curr.x] },\r\n\t\t\t];\r\n\t\t\tfor (const n of neighbors) {\r\n\t\t\t\tif (n.edge && n.edge.type !== EdgeType.Absent) {\r\n\t\t\t\t\tif (!reachableNodes.has(`${n.nx},${n.ny}`)) {\r\n\t\t\t\t\t\treachableNodes.add(`${n.nx},${n.ny}`);\r\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (let r = 0; r <= grid.rows; r++) {\r\n\t\t\tfor (let c = 0; c < grid.cols; c++) if (!reachableNodes.has(`${c},${r}`) || !reachableNodes.has(`${c + 1},${r}`)) grid.hEdges[r][c].type = EdgeType.Absent;\r\n\t\t}\r\n\t\tfor (let r = 0; r < grid.rows; r++) {\r\n\t\t\tfor (let c = 0; c <= grid.cols; c++) if (!reachableNodes.has(`${c},${r}`) || !reachableNodes.has(`${c},${r + 1}`)) grid.vEdges[r][c].type = EdgeType.Absent;\r\n\t\t}\r\n\r\n\t\tconst external = this.getExternalCells(grid);\r\n\t\tfor (const cellKey of external) {\r\n\t\t\tconst [c, r] = cellKey.split(\",\").map(Number);\r\n\t\t\tgrid.cells[r][c].type = CellType.None;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate getExternalCells(grid: Grid): Set<string> {\r\n\t\tconst external = new Set<string>();\r\n\t\tconst queue: { x: number; y: number }[] = [];\r\n\t\tfor (let c = 0; c < grid.cols; c++) {\r\n\t\t\tif (grid.hEdges[0][c].type === EdgeType.Absent) {\r\n\t\t\t\tif (!external.has(`${c},0`)) {\r\n\t\t\t\t\texternal.add(`${c},0`);\r\n\t\t\t\t\tqueue.push({ x: c, y: 0 });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (grid.hEdges[grid.rows][c].type === EdgeType.Absent) {\r\n\t\t\t\tif (!external.has(`${c},${grid.rows - 1}`)) {\r\n\t\t\t\t\texternal.add(`${c},${grid.rows - 1}`);\r\n\t\t\t\t\tqueue.push({ x: c, y: grid.rows - 1 });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let r = 0; r < grid.rows; r++) {\r\n\t\t\tif (grid.vEdges[r][0].type === EdgeType.Absent) {\r\n\t\t\t\tif (!external.has(`0,${r}`)) {\r\n\t\t\t\t\texternal.add(`0,${r}`);\r\n\t\t\t\t\tqueue.push({ x: 0, y: r });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (grid.vEdges[r][grid.cols].type === EdgeType.Absent) {\r\n\t\t\t\tif (!external.has(`${grid.cols - 1},${r}`)) {\r\n\t\t\t\t\texternal.add(`${grid.cols - 1},${r}`);\r\n\t\t\t\t\tqueue.push({ x: grid.cols - 1, y: r });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile (queue.length > 0) {\r\n\t\t\tconst curr = queue.shift()!;\r\n\t\t\tconst neighbors = [\r\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.hEdges[curr.y][curr.x] },\r\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.hEdges[curr.y + 1][curr.x] },\r\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x] },\r\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x + 1] },\r\n\t\t\t];\r\n\t\t\tfor (const n of neighbors) {\r\n\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\r\n\t\t\t\t\tif (!external.has(`${n.nx},${n.ny}`) && n.edge.type === EdgeType.Absent) {\r\n\t\t\t\t\t\texternal.add(`${n.nx},${n.ny}`);\r\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn external;\r\n\t}\r\n\r\n\tprivate isAdjacentToMark(grid: Grid, edge: { type: \"h\" | \"v\"; r: number; c: number }): boolean {\r\n\t\tif (edge.type === \"h\") {\r\n\t\t\tif (edge.r > 0 && grid.cells[edge.r - 1][edge.c].type !== CellType.None) return true;\r\n\t\t\tif (edge.r < grid.rows && grid.cells[edge.r][edge.c].type !== CellType.None) return true;\r\n\t\t} else {\r\n\t\t\tif (edge.c > 0 && grid.cells[edge.r][edge.c - 1].type !== CellType.None) return true;\r\n\t\t\tif (edge.c < grid.cols && grid.cells[edge.r][edge.c].type !== CellType.None) return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * \u30DE\u30FC\u30AF\u304C\u5B8C\u5168\u306B\u65AD\u7D76\u3055\u308C\u305F\u30BB\u30EB\u306B\u3044\u306A\u3044\u304B\u78BA\u8A8D\u3059\u308B\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t * @returns \u5B64\u7ACB\u3057\u305F\u30DE\u30FC\u30AF\u304C\u3042\u308B\u304B\u3069\u3046\u304B\r\n\t */\r\n\tprivate hasIsolatedMark(grid: Grid): boolean {\r\n\t\tfor (let r = 0; r < grid.rows; r++)\r\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\r\n\t\t\t\tif (grid.cells[r][c].type === CellType.None) continue;\r\n\t\t\t\tconst edges = [grid.hEdges[r][c], grid.hEdges[r + 1][c], grid.vEdges[r][c], grid.vEdges[r][c + 1]];\r\n\t\t\t\tif (edges.every((e) => e.type === EdgeType.Broken || e.type === EdgeType.Absent)) return true;\r\n\t\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprivate getSymmetricalPoint(grid: Grid, p: Point, symmetry: SymmetryType): Point {\r\n\t\tif (symmetry === SymmetryType.Horizontal) {\r\n\t\t\treturn { x: grid.cols - p.x, y: p.y };\r\n\t\t} else if (symmetry === SymmetryType.Vertical) {\r\n\t\t\treturn { x: p.x, y: grid.rows - p.y };\r\n\t\t} else if (symmetry === SymmetryType.Rotational) {\r\n\t\t\treturn { x: grid.cols - p.x, y: grid.rows - p.y };\r\n\t\t}\r\n\t\treturn { ...p };\r\n\t}\r\n\r\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\r\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\r\n\t}\r\n\r\n\tprivate TETRIS_SHAPES = [\r\n\t\t[[1]],\r\n\t\t[[1, 1]],\r\n\t\t[[1, 1, 1]],\r\n\t\t[[1, 1, 1, 1]],\r\n\t\t[[1, 1, 1, 1, 1]],\r\n\t\t[\r\n\t\t\t[1, 1],\r\n\t\t\t[1, 1],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1],\r\n\t\t\t[1, 0],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1, 1],\r\n\t\t\t[1, 0, 0],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1, 1],\r\n\t\t\t[0, 0, 1],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[0, 1],\r\n\t\t\t[1, 0],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1, 1],\r\n\t\t\t[0, 1, 0],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1, 1],\r\n\t\t\t[0, 1, 0],\r\n\t\t\t[0, 1, 0],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1, 0],\r\n\t\t\t[0, 1, 1],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[0, 1, 1],\r\n\t\t\t[1, 1, 0],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1, 0],\r\n\t\t\t[0, 1, 0],\r\n\t\t\t[0, 1, 1],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[0, 1, 1],\r\n\t\t\t[0, 1, 0],\r\n\t\t\t[1, 1, 0],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1, 1],\r\n\t\t\t[1, 0, 1],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[0, 1, 0],\r\n\t\t\t[1, 0, 1],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 0, 0, 1],\r\n\t\t\t[1, 0, 0, 1],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1, 1],\r\n\t\t\t[1, 0, 1],\r\n\t\t\t[1, 1, 1],\r\n\t\t],\r\n\t];\r\n\r\n\t/**\r\n\t * \u89E3\u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u5404\u533A\u753B\u306B\u30EB\u30FC\u30EB\u3092\u914D\u7F6E\u3059\u308B\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t * @param path \u89E3\u7B54\u30D1\u30B9\r\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\r\n\t * @param symPath \u5BFE\u79F0\u30D1\u30B9\r\n\t * @param precalculatedRegions \u4E8B\u524D\u8A08\u7B97\u3055\u308C\u305F\u533A\u753B\r\n\t * @param precalculatedBoundaryEdges \u4E8B\u524D\u8A08\u7B97\u3055\u308C\u305F\u5883\u754C\u30A8\u30C3\u30B8\r\n\t */\r\n\tprivate applyConstraintsBasedOnPath(grid: Grid, path: Point[], options: GenerationOptions, symPath: Point[] = [], precalculatedRegions?: Point[][], precalculatedBoundaryEdges?: { type: \"h\" | \"v\"; r: number; c: number }[][]) {\r\n\t\tconst complexity = options.complexity ?? 0.5;\r\n\t\tconst useHexagons = options.useHexagons ?? true;\r\n\t\tconst useSquares = options.useSquares ?? true;\r\n\t\tconst useStars = options.useStars ?? true;\r\n\t\tconst useTetris = options.useTetris ?? false;\r\n\t\tconst useTetrisNegative = options.useTetrisNegative ?? false;\r\n\t\tconst useEraser = options.useEraser ?? false;\r\n\t\tconst useTriangles = options.useTriangles ?? false;\r\n\r\n\t\tlet hexagonsPlaced = 0;\r\n\t\tlet squaresPlaced = 0;\r\n\t\tlet starsPlaced = 0;\r\n\t\tlet tetrisPlaced = 0;\r\n\t\tlet erasersPlaced = 0;\r\n\t\tlet totalTetrisArea = 0;\r\n\t\tconst maxTotalTetrisArea = Math.floor(grid.rows * grid.cols * 0.6);\r\n\r\n\t\t// \u516D\u89D2\u5F62\u306E\u914D\u7F6E\r\n\t\tif (useHexagons) {\r\n\t\t\tconst targetDifficulty = options.difficulty ?? 0.5;\r\n\t\t\tconst symmetry = options.symmetry || SymmetryType.None;\r\n\r\n\t\t\t// \u30A8\u30C3\u30B8\u516D\u89D2\u5F62 (\u7DDA\u4E0A\u30FB\u4E2D\u5FC3)\r\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\r\n\t\t\t\tconst neighbors = this.getValidNeighbors(grid, path[i]);\r\n\t\t\t\tconst isBranching = neighbors.length > 2;\r\n\t\t\t\t// \u96E3\u6613\u5EA6\u304C\u4F4E\u3044\u3068\u304D\u306F\u30A8\u30C3\u30B8\u516D\u89D2\u5F62\u3092\u591A\u304F\u3057\u3066\u30AC\u30A4\u30C9\u306B\u3059\u308B\r\n\t\t\t\tlet prob = complexity * (targetDifficulty < 0.4 ? 0.6 : 0.3);\r\n\t\t\t\tif (isBranching) prob = targetDifficulty < 0.4 ? prob * 1.0 : prob * 0.5;\r\n\t\t\t\tif (this.rng!.next() < prob) {\r\n\t\t\t\t\tlet type = EdgeType.Hexagon;\r\n\t\t\t\t\tlet p1 = path[i];\r\n\t\t\t\t\tlet p2 = path[i + 1];\r\n\r\n\t\t\t\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\t\t\t\tconst r = this.rng!.next();\r\n\t\t\t\t\t\tif (r < 0.3) type = EdgeType.HexagonMain;\r\n\t\t\t\t\t\telse if (r < 0.6) {\r\n\t\t\t\t\t\t\ttype = EdgeType.HexagonSymmetry;\r\n\t\t\t\t\t\t\tp1 = this.getSymmetricalPoint(grid, path[i], symmetry);\r\n\t\t\t\t\t\t\tp2 = this.getSymmetricalPoint(grid, path[i + 1], symmetry);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.setEdgeHexagon(grid, p1, p2, type);\r\n\t\t\t\t\thexagonsPlaced++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// \u30CE\u30FC\u30C9\u516D\u89D2\u5F62 (\u7DDA\u4E0A\u30FB\u4EA4\u70B9)\r\n\t\t\tfor (let i = 0; i < path.length; i++) {\r\n\t\t\t\tconst node = path[i];\r\n\t\t\t\tif (grid.nodes[node.y][node.x].type !== NodeType.Normal) continue;\r\n\t\t\t\t// Edge\u306EHexagon\u3068\u96A3\u63A5\u3057\u3066\u3044\u308B\u5834\u5408\u306F\u30B9\u30AD\u30C3\u30D7\r\n\t\t\t\tif (this.hasIncidentHexagonEdge(grid, node)) continue;\r\n\r\n\t\t\t\t// \u96E3\u6613\u5EA6\u304C\u9AD8\u3044\u3068\u304D\u306B\u30CE\u30FC\u30C9\u516D\u89D2\u5F62\u3092\u914D\u7F6E\r\n\t\t\t\tlet prob = complexity * (targetDifficulty > 0.6 ? 0.15 : 0.05);\r\n\t\t\t\tif (this.rng!.next() < prob) {\r\n\t\t\t\t\tlet type = NodeType.Hexagon;\r\n\t\t\t\t\tlet targetNode = node;\r\n\r\n\t\t\t\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\t\t\t\tconst r = this.rng!.next();\r\n\t\t\t\t\t\tif (r < 0.3) type = NodeType.HexagonMain;\r\n\t\t\t\t\t\telse if (r < 0.6) {\r\n\t\t\t\t\t\t\ttype = NodeType.HexagonSymmetry;\r\n\t\t\t\t\t\t\ttargetNode = this.getSymmetricalPoint(grid, node, symmetry);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgrid.nodes[targetNode.y][targetNode.x].type = type;\r\n\t\t\t\t\thexagonsPlaced++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (hexagonsPlaced === 0 && path.length >= 2) {\r\n\t\t\t\tconst idx = Math.floor(this.rng!.next() * (path.length - 1));\r\n\t\t\t\tconst symmetry = options.symmetry || SymmetryType.None;\r\n\t\t\t\tlet type = EdgeType.Hexagon;\r\n\t\t\t\tlet p1 = path[idx];\r\n\t\t\t\tlet p2 = path[idx + 1];\r\n\r\n\t\t\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\t\t\tconst r = this.rng!.next();\r\n\t\t\t\t\tif (r < 0.3) type = EdgeType.HexagonMain;\r\n\t\t\t\t\telse if (r < 0.6) {\r\n\t\t\t\t\t\ttype = EdgeType.HexagonSymmetry;\r\n\t\t\t\t\t\tp1 = this.getSymmetricalPoint(grid, path[idx], symmetry);\r\n\t\t\t\t\t\tp2 = this.getSymmetricalPoint(grid, path[idx + 1], symmetry);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.setEdgeHexagon(grid, p1, p2, type);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// \u533A\u753B\u30EB\u30FC\u30EB\u306E\u914D\u7F6E\r\n\t\tif (useSquares || useStars || useTetris || useEraser || useTriangles) {\r\n\t\t\tconst regions = precalculatedRegions || this.calculateRegions(grid, path, symPath);\r\n\t\t\tconst availableColors = options.availableColors ?? [Color.Black, Color.White, Color.Red, Color.Blue];\r\n\t\t\tconst defaultColors = options.defaultColors ?? {};\r\n\t\t\tconst getDefColor = (type: CellType, fallback: Color): Color => {\r\n\t\t\t\tif (defaultColors[type] !== undefined) return defaultColors[type] as Color;\r\n\t\t\t\tconst name = CellType[type] as keyof typeof CellType;\r\n\t\t\t\tif (name && defaultColors[name] !== undefined) return defaultColors[name] as Color;\r\n\r\n\t\t\t\t// Rotated variants fallback to their base types\r\n\t\t\t\tif (type === CellType.TetrisRotated) return getDefColor(CellType.Tetris, fallback);\r\n\t\t\t\tif (type === CellType.TetrisNegativeRotated) return getDefColor(CellType.TetrisNegative, fallback);\r\n\r\n\t\t\t\treturn fallback;\r\n\t\t\t};\r\n\t\t\tconst regionIndices = Array.from({ length: regions.length }, (_, i) => i);\r\n\t\t\tthis.shuffleArray(regionIndices);\r\n\t\t\tconst squareColorsUsed = new Set<number>();\r\n\r\n\t\t\t// \u5FC5\u8981\u306A\u6700\u5C0F\u9650\u306E\u5236\u7D04\u3092\u5206\u6563\u3057\u3066\u914D\u7F6E\u3059\u308B\u305F\u3081\u306E\u30D5\u30E9\u30B0\r\n\t\t\tconst needs = {\r\n\t\t\t\tsquare: useSquares,\r\n\t\t\t\tstar: useStars,\r\n\t\t\t\ttetris: useTetris,\r\n\t\t\t\ttetrisNegative: useTetrisNegative,\r\n\t\t\t\teraser: useEraser,\r\n\t\t\t\ttriangle: useTriangles,\r\n\t\t\t};\r\n\r\n\t\t\tlet tetrisNegativePlaced = 0;\r\n\t\t\tlet trianglesPlaced = 0;\r\n\r\n\t\t\tconst pathEdges = new Set<string>();\r\n\t\t\tfor (let i = 0; i < path.length - 1; i++) pathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\r\n\t\t\tfor (let i = 0; i < symPath.length - 1; i++) pathEdges.add(this.getEdgeKey(symPath[i], symPath[i + 1]));\r\n\r\n\t\t\tfor (let rIdx = 0; rIdx < regionIndices.length; rIdx++) {\r\n\t\t\t\tconst idx = regionIndices[rIdx];\r\n\t\t\t\tconst region = regions[idx];\r\n\r\n\t\t\t\t// \u76E4\u9762\u304C\u5927\u304D\u304F\u533A\u753B\u304C\u591A\u3044\u5834\u5408\u3001\u5F8C\u534A\u306B\u504F\u308B\u306E\u3092\u9632\u3050\u305F\u3081\u78BA\u7387\u3092\u8ABF\u6574\r\n\t\t\t\tconst remainingRegions = regionIndices.length - rIdx;\r\n\t\t\t\tconst forceOne = (needs.square && squaresPlaced === 0) || (needs.star && starsPlaced === 0) || (needs.tetris && tetrisPlaced === 0) || (needs.tetrisNegative && tetrisNegativePlaced === 0) || (needs.eraser && erasersPlaced === 0) || (needs.triangle && trianglesPlaced === 0);\r\n\r\n\t\t\t\t// \u5FC5\u9808\u306A\u3082\u306E\u304C\u307E\u3060\u914D\u7F6E\u3055\u308C\u3066\u3044\u306A\u3044\u5834\u5408\u3001\u6B8B\u308A\u533A\u753B\u6570\u304C\u5C11\u306A\u304F\u306A\u3063\u3066\u304D\u305F\u3089\u78BA\u7387\u3092\u4E0A\u3052\u308B\r\n\t\t\t\tlet placementProb = 0.2 + complexity * 0.6;\r\n\t\t\t\tif (forceOne && remainingRegions <= 3) placementProb = 1.0;\r\n\t\t\t\telse if (forceOne && remainingRegions <= 6) placementProb = 0.7;\r\n\r\n\t\t\t\tif (this.rng!.next() > placementProb) continue;\r\n\r\n\t\t\t\tconst potentialCells = [...region];\r\n\t\t\t\tthis.shuffleArray(potentialCells);\r\n\t\t\t\t// \u3053\u306E\u533A\u753B\u5185\u3067\u610F\u56F3\u7684\u306B\uFF08\u30C8\u30B2\u3068\u306E\u30DA\u30A2\u30EA\u30F3\u30B0\u7B49\u306E\u305F\u3081\u306B\uFF09\u5272\u308A\u5F53\u3066\u3089\u308C\u305F\u975E\u30C7\u30D5\u30A9\u30EB\u30C8\u8272\r\n\t\t\t\tconst intendedColors = new Set<number>();\r\n\r\n\t\t\t\t// \u56DB\u89D2\u5F62\u306E\u914D\u7F6E\r\n\t\t\t\tlet squareColor = availableColors[Math.floor(this.rng!.next() * availableColors.length)];\r\n\t\t\t\t// \u5FC5\u9808\u304B\u3064\u672A\u914D\u7F6E\u306E\u5834\u5408\u306F\u3001\u307E\u3060\u4F7F\u3063\u3066\u3044\u306A\u3044\u8272\u3092\u512A\u5148\u7684\u306B\u9078\u3076\r\n\t\t\t\tif (useSquares && squareColorsUsed.size < 2) {\r\n\t\t\t\t\tconst unusedColors = availableColors.filter((c) => !squareColorsUsed.has(c));\r\n\t\t\t\t\tif (unusedColors.length > 0) {\r\n\t\t\t\t\t\tsquareColor = unusedColors[Math.floor(this.rng!.next() * unusedColors.length)];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet shouldPlaceSquare = useSquares && this.rng!.next() < 0.5 + complexity * 0.3;\r\n\t\t\t\tif (useSquares && squaresPlaced === 0 && remainingRegions <= 2) shouldPlaceSquare = true;\r\n\t\t\t\tif (useSquares && !useStars && remainingRegions <= 2 && squareColorsUsed.size < 2 && squaresPlaced > 0) shouldPlaceSquare = true;\r\n\r\n\t\t\t\tif (shouldPlaceSquare && potentialCells.length > 0) {\r\n\t\t\t\t\t// \u533A\u57DF\u306E\u5927\u304D\u3055\u306B\u5FDC\u3058\u3066\u914D\u7F6E\u3059\u308B\u6570\u3092\u5897\u3084\u3059\r\n\t\t\t\t\tconst maxSquares = Math.min(potentialCells.length, Math.max(4, Math.floor(region.length / 4)));\r\n\t\t\t\t\tconst numSquares = Math.floor(this.rng!.next() * (maxSquares / 2)) + Math.ceil(maxSquares / 2);\r\n\t\t\t\t\tfor (let i = 0; i < numSquares; i++) {\r\n\t\t\t\t\t\tif (potentialCells.length === 0) break;\r\n\t\t\t\t\t\tconst cell = potentialCells.pop()!;\r\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Square;\r\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = squareColor;\r\n\t\t\t\t\t\tsquaresPlaced++;\r\n\t\t\t\t\t\tsquareColorsUsed.add(squareColor);\r\n\t\t\t\t\t\tintendedColors.add(squareColor);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// \u30C6\u30C8\u30EA\u30B9\u306E\u914D\u7F6E\r\n\t\t\t\tif (useTetris || useTetrisNegative) {\r\n\t\t\t\t\tlet shouldPlaceTetris = this.rng!.next() < 0.1 + complexity * 0.4;\r\n\t\t\t\t\t// \u672A\u914D\u7F6E\u306E\u5834\u5408\u306F\u78BA\u7387\u3092\u4E0A\u3052\u308B\r\n\t\t\t\t\tif (tetrisPlaced === 0 && remainingRegions <= 3) shouldPlaceTetris = true;\r\n\t\t\t\t\tif (useTetrisNegative && tetrisNegativePlaced === 0 && remainingRegions <= 2) shouldPlaceTetris = true;\r\n\r\n\t\t\t\t\tconst maxTetrisPerRegion = tetrisPlaced === 0 && remainingRegions <= 2 ? 6 : 4;\r\n\r\n\t\t\t\t\t// \u9762\u7A4D\u5236\u9650\u306E\u7DE9\u548C: \u5FC5\u9808\u304B\u3064\u672A\u914D\u7F6E\u306E\u5834\u5408\u306F\u5236\u9650\u3092\u7121\u8996\u3059\u308B\u3002\u305F\u3060\u3057\u63A2\u7D22\u7206\u767A\u3092\u9632\u3050\u305F\u3081\u6700\u592730\u30BB\u30EB\u7A0B\u5EA6\u306B\u5236\u9650\r\n\t\t\t\t\tconst isAreaOk = totalTetrisArea + region.length <= maxTotalTetrisArea || (forceOne && useTetris && tetrisPlaced === 0 && region.length <= 30) || (forceOne && useTetrisNegative && tetrisNegativePlaced === 0 && region.length <= 30);\r\n\r\n\t\t\t\t\tif (shouldPlaceTetris && potentialCells.length > 0 && isAreaOk) {\r\n\t\t\t\t\t\t// \u5DE8\u5927\u306A\u9818\u57DF\u3067\u306E\u30BF\u30A4\u30EA\u30F3\u30B0\u63A2\u7D22\u306F\u975E\u5E38\u306B\u91CD\u3044\u305F\u3081\u3001\u5236\u9650\u3092\u304B\u3051\u308B\r\n\t\t\t\t\t\tlet tiledPieces = region.length <= 25 ? (this.generateTiling(region, maxTetrisPerRegion, options) as TiledPiece[] | null) : null;\r\n\t\t\t\t\t\tif (tiledPieces) {\r\n\t\t\t\t\t\t\t// \u6E1B\u7B97\u30C6\u30C8\u30EA\u30B9\u306E\u9069\u7528\r\n\t\t\t\t\t\t\tconst negativePiecesToPlace: TiledPiece[] = [];\r\n\t\t\t\t\t\t\t// \u672A\u914D\u7F6E\u306E\u5834\u5408\u306F\u78BA\u7387\u3092\u4E0A\u3052\u308B\r\n\t\t\t\t\t\t\tlet negProb = 0.2 + complexity * 0.3;\r\n\t\t\t\t\t\t\tif (useTetrisNegative && tetrisNegativePlaced === 0 && remainingRegions <= 3) negProb = 0.9;\r\n\r\n\t\t\t\t\t\t\tif (useTetrisNegative && this.rng!.next() < negProb) {\r\n\t\t\t\t\t\t\t\tconst difficulty = options.difficulty ?? 0.5;\r\n\t\t\t\t\t\t\t\tconst prob0 = 0.1; // area-0 case probability\r\n\t\t\t\t\t\t\t\tif (this.rng!.next() < prob0 && potentialCells.length >= 2) {\r\n\t\t\t\t\t\t\t\t\t// Case: Net area 0.\r\n\t\t\t\t\t\t\t\t\tlet complexFound = false;\r\n\t\t\t\t\t\t\t\t\tif (potentialCells.length >= 3 && this.rng!.next() < 0.8) {\r\n\t\t\t\t\t\t\t\t\t\t// Try 2:1 or 1:2 complex cancellation\r\n\t\t\t\t\t\t\t\t\t\tconst is2pos1neg = this.rng!.next() < 0.5;\r\n\t\t\t\t\t\t\t\t\t\tconst baseArea = 1 + Math.floor(this.rng!.next() * 2); // 1 or 2\r\n\t\t\t\t\t\t\t\t\t\tconst baseShapes = this.TETRIS_SHAPES.filter((s) => this.getShapeArea(s) === baseArea);\r\n\t\t\t\t\t\t\t\t\t\tconst base = baseShapes[Math.floor(this.rng!.next() * baseShapes.length)];\r\n\r\n\t\t\t\t\t\t\t\t\t\tconst triple = this.findStandardTriple(base);\r\n\t\t\t\t\t\t\t\t\t\tif (triple) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (is2pos1neg) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// P1(base) + P2(triple.n) = N(triple.p)\r\n\t\t\t\t\t\t\t\t\t\t\t\ttiledPieces.push({ shape: base, displayShape: base, isRotated: !this.isRotationallyInvariant(base) && this.rng!.next() < difficulty * 0.7, isNegative: false });\r\n\t\t\t\t\t\t\t\t\t\t\t\ttiledPieces.push({ shape: triple.n, displayShape: triple.n, isRotated: !this.isRotationallyInvariant(triple.n) && this.rng!.next() < difficulty * 0.7, isNegative: false });\r\n\t\t\t\t\t\t\t\t\t\t\t\tnegativePiecesToPlace.push({ shape: triple.p, displayShape: triple.p, isRotated: !this.isRotationallyInvariant(triple.p) && this.rng!.next() < difficulty * 0.7, isNegative: true });\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// P(triple.p) = N1(base) + N2(triple.n)\r\n\t\t\t\t\t\t\t\t\t\t\t\ttiledPieces.push({ shape: triple.p, displayShape: triple.p, isRotated: !this.isRotationallyInvariant(triple.p) && this.rng!.next() < difficulty * 0.7, isNegative: false });\r\n\t\t\t\t\t\t\t\t\t\t\t\tnegativePiecesToPlace.push({ shape: base, displayShape: base, isRotated: !this.isRotationallyInvariant(base) && this.rng!.next() < difficulty * 0.7, isNegative: true });\r\n\t\t\t\t\t\t\t\t\t\t\t\tnegativePiecesToPlace.push({ shape: triple.n, displayShape: triple.n, isRotated: !this.isRotationallyInvariant(triple.n) && this.rng!.next() < difficulty * 0.7, isNegative: true });\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tcomplexFound = true;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tif (!complexFound) {\r\n\t\t\t\t\t\t\t\t\t\t// Case: 1:1 Net area 0.\r\n\t\t\t\t\t\t\t\t\t\t// To cancel to zero, combined shapes must match.\r\n\t\t\t\t\t\t\t\t\t\tconst area = 3 + Math.floor(this.rng!.next() * 2); // area 3 or 4\r\n\t\t\t\t\t\t\t\t\t\tconst candidates = this.TETRIS_SHAPES.filter((s) => this.getShapeArea(s) === area);\r\n\t\t\t\t\t\t\t\t\t\tthis.shuffleArray(candidates);\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (candidates.length > 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tconst pShape = candidates[0];\r\n\t\t\t\t\t\t\t\t\t\t\tconst nShape = candidates[0];\r\n\t\t\t\t\t\t\t\t\t\t\ttiledPieces.push({ shape: pShape, displayShape: pShape, isRotated: !this.isRotationallyInvariant(pShape) && this.rng!.next() < difficulty * 0.7, isNegative: false });\r\n\t\t\t\t\t\t\t\t\t\t\tnegativePiecesToPlace.push({ shape: nShape, displayShape: nShape, isRotated: !this.isRotationallyInvariant(nShape) && this.rng!.next() < difficulty * 0.7, isNegative: true });\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else if (tiledPieces.length > 0) {\r\n\t\t\t\t\t\t\t\t\t// Case: Net area > 0 using standard triples\r\n\t\t\t\t\t\t\t\t\tconst numSubtractions = this.rng!.next() < 0.3 ? 2 : 1;\r\n\t\t\t\t\t\t\t\t\tfor (let i = 0; i < numSubtractions; i++) {\r\n\t\t\t\t\t\t\t\t\t\tif (potentialCells.length < 1) break;\r\n\t\t\t\t\t\t\t\t\t\tconst targetIdx = Math.floor(this.rng!.next() * tiledPieces.length);\r\n\t\t\t\t\t\t\t\t\t\tconst original = tiledPieces[targetIdx];\r\n\t\t\t\t\t\t\t\t\t\tif (original.isNegative) continue;\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Occasionally try a 1:2 subtraction (P = T + N1 + N2)\r\n\t\t\t\t\t\t\t\t\t\tlet complexSubtraction = false;\r\n\t\t\t\t\t\t\t\t\t\tif (potentialCells.length >= 2 && this.rng!.next() < 0.2) {\r\n\t\t\t\t\t\t\t\t\t\t\tconst triple1 = this.findStandardTriple(original.shape);\r\n\t\t\t\t\t\t\t\t\t\t\tif (triple1) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tconst triple2 = this.findStandardTriple(triple1.p);\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (triple2) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// T(orig) + N1(triple1.n) + N2(triple2.n) = P(triple2.p)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// So P - N1 - N2 = T\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ttiledPieces[targetIdx] = { shape: triple2.p, displayShape: triple2.p, isRotated: !this.isRotationallyInvariant(triple2.p) && this.rng!.next() < difficulty * 0.7, isNegative: false };\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tnegativePiecesToPlace.push({ shape: triple1.n, displayShape: triple1.n, isRotated: !this.isRotationallyInvariant(triple1.n) && this.rng!.next() < difficulty * 0.7, isNegative: true });\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tnegativePiecesToPlace.push({ shape: triple2.n, displayShape: triple2.n, isRotated: !this.isRotationallyInvariant(triple2.n) && this.rng!.next() < difficulty * 0.7, isNegative: true });\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcomplexSubtraction = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (!complexSubtraction) {\r\n\t\t\t\t\t\t\t\t\t\t\tconst triple = this.findStandardTriple(original.shape);\r\n\t\t\t\t\t\t\t\t\t\t\tif (triple) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Check if triple.n matches any existing positive piece in tiledPieces to avoid triviality\r\n\t\t\t\t\t\t\t\t\t\t\t\tconst isDuplicate = tiledPieces.some((tp) => !tp.isNegative && this.isSameShape(tp.shape, triple.n));\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (!isDuplicate) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ttiledPieces[targetIdx] = {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape: triple.p,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdisplayShape: triple.p,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tisRotated: !this.isRotationallyInvariant(triple.p) && this.rng!.next() < difficulty * 0.7,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tisNegative: false,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tnegativePiecesToPlace.push({\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape: triple.n,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdisplayShape: triple.n,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tisRotated: !this.isRotationallyInvariant(triple.n) && this.rng!.next() < difficulty * 0.7,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tisNegative: true,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tconst allPieces: TiledPiece[] = [...tiledPieces, ...negativePiecesToPlace];\r\n\t\t\t\t\t\t\tif (allPieces.length > potentialCells.length) continue;\r\n\t\t\t\t\t\t\tfor (const p of allPieces) {\r\n\t\t\t\t\t\t\t\tif (potentialCells.length === 0) break;\r\n\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\tconst isNeg = p.isNegative;\r\n\r\n\t\t\t\t\t\t\t\tif (isNeg) {\r\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = p.isRotated ? CellType.TetrisNegativeRotated : CellType.TetrisNegative;\r\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = getDefColor(CellType.TetrisNegative, Color.None);\r\n\t\t\t\t\t\t\t\t\ttetrisNegativePlaced++;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = p.isRotated ? CellType.TetrisRotated : CellType.Tetris;\r\n\t\t\t\t\t\t\t\t\tconst defColor = getDefColor(CellType.Tetris, Color.None);\r\n\t\t\t\t\t\t\t\t\tlet tetrisColor = defColor;\r\n\t\t\t\t\t\t\t\t\t// \u30C8\u30B2(Star)\u3068\u306E\u30DA\u30A2\u30EA\u30F3\u30B0\u3092\u610F\u56F3\u3059\u308B\u5834\u5408\u306E\u307F\u8272\u3092\u4ED8\u3051\u308B\r\n\t\t\t\t\t\t\t\t\tif (useStars && this.rng!.next() < 0.3) {\r\n\t\t\t\t\t\t\t\t\t\tconst candidates = availableColors.filter((c) => c !== defColor && !intendedColors.has(c));\r\n\t\t\t\t\t\t\t\t\t\tif (candidates.length > 0) {\r\n\t\t\t\t\t\t\t\t\t\t\ttetrisColor = candidates[Math.floor(this.rng!.next() * candidates.length)];\r\n\t\t\t\t\t\t\t\t\t\t\tintendedColors.add(tetrisColor);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = tetrisColor;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].shape = p.isRotated ? p.displayShape : p.shape;\r\n\t\t\t\t\t\t\t\ttetrisPlaced++;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\ttotalTetrisArea += region.length;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// \u4E09\u89D2\u5F62\u306E\u914D\u7F6E\r\n\t\t\t\tif (useTriangles) {\r\n\t\t\t\t\tlet shouldPlaceTriangle = this.rng!.next() < 0.2 + complexity * 0.5;\r\n\t\t\t\t\tif (trianglesPlaced === 0 && remainingRegions <= 2) shouldPlaceTriangle = true;\r\n\r\n\t\t\t\t\tif (shouldPlaceTriangle && potentialCells.length > 0) {\r\n\t\t\t\t\t\tthis.shuffleArray(potentialCells);\r\n\t\t\t\t\t\tconst numToTry = Math.min(potentialCells.length, Math.max(1, Math.floor(region.length / 3)));\r\n\t\t\t\t\t\tlet placedInRegion = 0;\r\n\r\n\t\t\t\t\t\tfor (let i = 0; i < potentialCells.length && placedInRegion < numToTry; i++) {\r\n\t\t\t\t\t\t\tconst cell = potentialCells[i];\r\n\t\t\t\t\t\t\tconst cellEdges = [this.getEdgeKey({ x: cell.x, y: cell.y }, { x: cell.x + 1, y: cell.y }), this.getEdgeKey({ x: cell.x, y: cell.y + 1 }, { x: cell.x + 1, y: cell.y + 1 }), this.getEdgeKey({ x: cell.x, y: cell.y }, { x: cell.x, y: cell.y + 1 }), this.getEdgeKey({ x: cell.x + 1, y: cell.y }, { x: cell.x + 1, y: cell.y + 1 })];\r\n\t\t\t\t\t\t\tlet count = 0;\r\n\t\t\t\t\t\t\tfor (const edge of cellEdges) {\r\n\t\t\t\t\t\t\t\tif (pathEdges.has(edge)) count++;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (count >= 1 && count <= 3) {\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Triangle;\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].count = count;\r\n\r\n\t\t\t\t\t\t\t\tconst defColor = getDefColor(CellType.Triangle, Color.None);\r\n\t\t\t\t\t\t\t\tlet triangleColor = defColor;\r\n\t\t\t\t\t\t\t\tif (useStars && this.rng!.next() < 0.3) {\r\n\t\t\t\t\t\t\t\t\tconst candidates = availableColors.filter((c) => c !== defColor && !intendedColors.has(c));\r\n\t\t\t\t\t\t\t\t\tif (candidates.length > 0) {\r\n\t\t\t\t\t\t\t\t\t\ttriangleColor = candidates[Math.floor(this.rng!.next() * candidates.length)];\r\n\t\t\t\t\t\t\t\t\t\tintendedColors.add(triangleColor);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = triangleColor;\r\n\r\n\t\t\t\t\t\t\t\tpotentialCells.splice(i, 1);\r\n\t\t\t\t\t\t\t\ti--;\r\n\t\t\t\t\t\t\t\ttrianglesPlaced++;\r\n\t\t\t\t\t\t\t\tplacedInRegion++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// \u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF08\u30A8\u30E9\u30FC\u524A\u9664\uFF09\u306E\u914D\u7F6E\r\n\t\t\t\tif (useEraser && erasersPlaced < 1) {\r\n\t\t\t\t\tconst prob = 0.05 + complexity * 0.2;\r\n\t\t\t\t\tlet shouldPlaceEraser = this.rng!.next() < prob;\r\n\t\t\t\t\tif (remainingRegions <= 2) shouldPlaceEraser = true;\r\n\r\n\t\t\t\t\tif (shouldPlaceEraser && potentialCells.length >= 1) {\r\n\t\t\t\t\t\tlet errorTypes: string[] = [];\r\n\t\t\t\t\t\tif (useStars) errorTypes.push(\"star\");\r\n\t\t\t\t\t\tif (useSquares) errorTypes.push(\"square\");\r\n\t\t\t\t\t\tlet boundaryEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\r\n\t\t\t\t\t\tif (useHexagons) {\r\n\t\t\t\t\t\t\tboundaryEdges = precalculatedBoundaryEdges ? precalculatedBoundaryEdges[idx] : this.getRegionBoundaryEdges(grid, region, path, symPath);\r\n\t\t\t\t\t\t\tif (boundaryEdges.length > 0) errorTypes.push(\"hexagon\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (useTetris) errorTypes.push(\"tetris\");\r\n\t\t\t\t\t\tif (useTetrisNegative) errorTypes.push(\"tetrisNegative\");\r\n\t\t\t\t\t\tif (useTriangles) errorTypes.push(\"triangle\");\r\n\r\n\t\t\t\t\t\tthis.shuffleArray(errorTypes);\r\n\t\t\t\t\t\tif (potentialCells.length >= 2) errorTypes.push(\"eraser\");\r\n\r\n\t\t\t\t\t\tlet errorPlaced = false;\r\n\r\n\t\t\t\t\t\tfor (const errorType of errorTypes) {\r\n\t\t\t\t\t\t\tif (errorPlaced) break;\r\n\r\n\t\t\t\t\t\t\tif (errorType === \"hexagon\") {\r\n\t\t\t\t\t\t\t\tconst validEdges = boundaryEdges.filter((e) => !this.isEdgeAdjacentToHexagonNode(grid, e));\r\n\t\t\t\t\t\t\t\tif (validEdges.length > 0) {\r\n\t\t\t\t\t\t\t\t\tconst edge = validEdges[Math.floor(this.rng!.next() * validEdges.length)];\r\n\t\t\t\t\t\t\t\t\tif (edge.type === \"h\") grid.hEdges[edge.r][edge.c].type = EdgeType.Hexagon;\r\n\t\t\t\t\t\t\t\t\telse grid.vEdges[edge.r][edge.c].type = EdgeType.Hexagon;\r\n\t\t\t\t\t\t\t\t\thexagonsPlaced++;\r\n\t\t\t\t\t\t\t\t\terrorPlaced = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else if (errorType === \"square\" && potentialCells.length >= 2) {\r\n\t\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Square;\r\n\t\t\t\t\t\t\t\tconst existingSquare = region.find((p) => grid.cells[p.y][p.x].type === CellType.Square);\r\n\t\t\t\t\t\t\t\tconst existingSquareColor = existingSquare ? grid.cells[existingSquare.y][existingSquare.x].color : undefined;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = availableColors.find((c) => c !== existingSquareColor) || Color.Red;\r\n\t\t\t\t\t\t\t\tsquaresPlaced++;\r\n\t\t\t\t\t\t\t\terrorPlaced = true;\r\n\t\t\t\t\t\t\t} else if (errorType === \"star\" && potentialCells.length >= 2) {\r\n\t\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Star;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = availableColors[Math.floor(this.rng!.next() * availableColors.length)];\r\n\t\t\t\t\t\t\t\tstarsPlaced++;\r\n\t\t\t\t\t\t\t\terrorPlaced = true;\r\n\t\t\t\t\t\t\t} else if (errorType === \"tetris\" && potentialCells.length >= 2) {\r\n\t\t\t\t\t\t\t\tconst tiledPieces = this.generateTiling(region, 4, options);\r\n\t\t\t\t\t\t\t\tlet piecesToPlace = [];\r\n\t\t\t\t\t\t\t\tif (tiledPieces && tiledPieces.length > 0) {\r\n\t\t\t\t\t\t\t\t\tlet currentArea = 0;\r\n\t\t\t\t\t\t\t\t\tfor (const p of tiledPieces) {\r\n\t\t\t\t\t\t\t\t\t\tconst area = this.getShapeArea(p.shape);\r\n\t\t\t\t\t\t\t\t\t\tif (currentArea + area < region.length) {\r\n\t\t\t\t\t\t\t\t\t\t\tpiecesToPlace.push(p);\r\n\t\t\t\t\t\t\t\t\t\t\tcurrentArea += area;\r\n\t\t\t\t\t\t\t\t\t\t} else break;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (piecesToPlace.length === 0 && region.length > 1) {\r\n\t\t\t\t\t\t\t\t\tpiecesToPlace = [{ shape: [[1]], displayShape: [[1]], isRotated: false }];\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (piecesToPlace.length > 0) {\r\n\t\t\t\t\t\t\t\t\tfor (const p of piecesToPlace) {\r\n\t\t\t\t\t\t\t\t\t\tif (potentialCells.length < 2) break;\r\n\t\t\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = p.isRotated ? CellType.TetrisRotated : CellType.Tetris;\r\n\t\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].shape = p.isRotated ? p.displayShape : p.shape;\r\n\t\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = getDefColor(grid.cells[cell.y][cell.x].type, Color.None);\r\n\t\t\t\t\t\t\t\t\t\ttetrisPlaced++;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\terrorPlaced = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else if (errorType === \"tetrisNegative\" && this.canPlaceGeneratedTetrisNegative(grid, region, potentialCells)) {\r\n\t\t\t\t\t\t\t\tif (!this.hasRegionTetrisSymbol(grid, region)) {\r\n\t\t\t\t\t\t\t\t\tconst posCell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\t\tgrid.cells[posCell.y][posCell.x].type = CellType.Tetris;\r\n\t\t\t\t\t\t\t\t\tgrid.cells[posCell.y][posCell.x].shape = [[1]];\r\n\t\t\t\t\t\t\t\t\tgrid.cells[posCell.y][posCell.x].color = getDefColor(CellType.Tetris, Color.None);\r\n\t\t\t\t\t\t\t\t\ttetrisPlaced++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.TetrisNegative;\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].shape = [[1]];\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = getDefColor(CellType.TetrisNegative, Color.None);\r\n\t\t\t\t\t\t\t\ttetrisNegativePlaced++;\r\n\t\t\t\t\t\t\t} else if (errorType === \"triangle\" && potentialCells.length >= 2) {\r\n\t\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Triangle;\r\n\t\t\t\t\t\t\t\tconst cellEdges = [this.getEdgeKey({ x: errCell.x, y: errCell.y }, { x: errCell.x + 1, y: errCell.y }), this.getEdgeKey({ x: errCell.x, y: errCell.y + 1 }, { x: errCell.x + 1, y: errCell.y + 1 }), this.getEdgeKey({ x: errCell.x, y: errCell.y }, { x: errCell.x, y: errCell.y + 1 }), this.getEdgeKey({ x: errCell.x + 1, y: errCell.y }, { x: errCell.x + 1, y: errCell.y + 1 })];\r\n\t\t\t\t\t\t\t\tlet actualCount = 0;\r\n\t\t\t\t\t\t\t\tfor (const edge of cellEdges) if (pathEdges.has(edge)) actualCount++;\r\n\r\n\t\t\t\t\t\t\t\t// \u5B9F\u969B\u306E\u6570\u3068\u7570\u306A\u308B\u6570\u3092\u8A2D\u5B9A\r\n\t\t\t\t\t\t\t\tlet errorCount = (actualCount + 1) % 4;\r\n\t\t\t\t\t\t\t\tif (errorCount === 0) errorCount = 1;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].count = errorCount;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = getDefColor(CellType.Triangle, Color.None);\r\n\t\t\t\t\t\t\t\ttrianglesPlaced++;\r\n\t\t\t\t\t\t\t\terrorPlaced = true;\r\n\t\t\t\t\t\t\t} else if (errorType === \"eraser\" && this.canPlaceGeneratedEraser(grid, region, potentialCells)) {\r\n\t\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Eraser;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = getDefColor(CellType.Eraser, Color.White);\r\n\t\t\t\t\t\t\t\terasersPlaced++;\r\n\t\t\t\t\t\t\t\terrorPlaced = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (errorPlaced && this.canPlaceGeneratedEraser(grid, region, potentialCells)) {\r\n\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Eraser;\r\n\t\t\t\t\t\t\tconst defColor = getDefColor(CellType.Eraser, Color.White);\r\n\t\t\t\t\t\t\tlet eraserColor = defColor;\r\n\t\t\t\t\t\t\t// \u30C8\u30B2(Star)\u3068\u306E\u30DA\u30A2\u30EA\u30F3\u30B0\u3092\u610F\u56F3\u3059\u308B\u5834\u5408\u306E\u307F\u8272\u3092\u4ED8\u3051\u308B\r\n\t\t\t\t\t\t\tif (useStars && this.rng!.next() < 0.3) {\r\n\t\t\t\t\t\t\t\tconst candidates = availableColors.filter((c) => c !== defColor && !intendedColors.has(c));\r\n\t\t\t\t\t\t\t\tif (candidates.length > 0) {\r\n\t\t\t\t\t\t\t\t\teraserColor = candidates[Math.floor(this.rng!.next() * candidates.length)];\r\n\t\t\t\t\t\t\t\t\tintendedColors.add(eraserColor);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = eraserColor;\r\n\t\t\t\t\t\t\terasersPlaced++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// \u661F\u306E\u914D\u7F6E\r\n\t\t\t\tif (useStars) {\r\n\t\t\t\t\t// 1. \u307E\u305A\u975E\u30C7\u30D5\u30A9\u30EB\u30C8\u8272\u306E\u8A18\u53F7\u3001\u307E\u305F\u306F\u610F\u56F3\u7684\u306B\u8272\u4ED8\u3051\u3055\u308C\u305F\u8A18\u53F7\u3092\u30C8\u30B2\u3067\u30DA\u30A2\u30EA\u30F3\u30B0\u3059\u308B\uFF08\u5FC5\u9808\uFF09\r\n\t\t\t\t\tfor (const color of availableColors) {\r\n\t\t\t\t\t\tif (potentialCells.length < 1) break;\r\n\t\t\t\t\t\tconst colorCount = region.filter((p) => grid.cells[p.y][p.x].color === color).length;\r\n\t\t\t\t\t\t// \u975E\u30C7\u30D5\u30A9\u30EB\u30C8\u8272\u3001\u307E\u305F\u306F\u610F\u56F3\u7684\u306B\u5272\u308A\u5F53\u3066\u3089\u308C\u305F\u8272\u304C1\u3064\u3060\u3051\u3042\u308B\u5834\u5408\u3001\u30C8\u30B2\u3092\u8FFD\u52A0\u3057\u3066\u30DA\u30A2\u306B\u3059\u308B\r\n\t\t\t\t\t\tif (colorCount === 1 && (color !== Color.White || intendedColors.has(color))) {\r\n\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\r\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\r\n\t\t\t\t\t\t\tstarsPlaced++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// 2. \u8FFD\u52A0\u3067\u30C8\u30B2\u306E\u30DA\u30A2\u3092\u914D\u7F6E\u3059\u308B\uFF08\u30E9\u30F3\u30C0\u30E0\uFF09\r\n\t\t\t\t\tconst maxPairs = Math.max(1, Math.floor(region.length / 8));\r\n\t\t\t\t\tfor (let p = 0; p < maxPairs; p++) {\r\n\t\t\t\t\t\tif (potentialCells.length < 2) break;\r\n\t\t\t\t\t\tfor (const color of availableColors) {\r\n\t\t\t\t\t\t\tif (potentialCells.length < 2) break;\r\n\t\t\t\t\t\t\tif (this.rng!.next() > 0.3 + complexity * 0.4) continue;\r\n\r\n\t\t\t\t\t\t\tconst colorCount = region.filter((p) => grid.cells[p.y][p.x].color === color).length;\r\n\t\t\t\t\t\t\tif (colorCount === 0) {\r\n\t\t\t\t\t\t\t\tfor (let i = 0; i < 2; i++) {\r\n\t\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\r\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\r\n\t\t\t\t\t\t\t\t\tstarsPlaced++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// \u56DB\u89D2\u5F62\u306E\u8272\u304C1\u8272\u3057\u304B\u4F7F\u308F\u308C\u306A\u304B\u3063\u305F\u5834\u5408\u306E\u88DC\u6B63\r\n\t\t\tif (useSquares && squareColorsUsed.size < 2) {\r\n\t\t\t\tconst onlyColor = squareColorsUsed.values().next().value;\r\n\t\t\t\tconst hasMatchingStar =\r\n\t\t\t\t\tonlyColor !== undefined &&\r\n\t\t\t\t\tstarsPlaced > 0 &&\r\n\t\t\t\t\tArray.from({ length: grid.rows * grid.cols }).some((_, i) => {\r\n\t\t\t\t\t\tconst r = Math.floor(i / grid.cols);\r\n\t\t\t\t\t\tconst c = i % grid.cols;\r\n\t\t\t\t\t\treturn grid.cells[r][c].type === CellType.Star && grid.cells[r][c].color === onlyColor;\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\tif (!hasMatchingStar) {\r\n\t\t\t\t\tfor (const region of regions) {\r\n\t\t\t\t\t\tif (squareColorsUsed.size >= 2) break;\r\n\t\t\t\t\t\tif (region.some((p) => grid.cells[p.y][p.x].type === CellType.Square)) continue;\r\n\r\n\t\t\t\t\t\tconst availableCells = region.filter((p) => grid.cells[p.y][p.x].type === CellType.None);\r\n\t\t\t\t\t\tif (availableCells.length > 0) {\r\n\t\t\t\t\t\t\tconst otherColor = availableColors.find((c) => !squareColorsUsed.has(c)) || Color.White;\r\n\t\t\t\t\t\t\tconst cell = availableCells[Math.floor(this.rng!.next() * availableCells.length)];\r\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Square;\r\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = otherColor;\r\n\t\t\t\t\t\t\tsquareColorsUsed.add(otherColor);\r\n\t\t\t\t\t\t\tsquaresPlaced++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// \u307E\u30601\u8272\u306E\u5834\u5408\u306F\u3001\u540C\u8272\u306E\u661F\u3092\u7121\u7406\u3084\u308A\u7F6E\u304F\r\n\t\t\t\t\tif (squareColorsUsed.size < 2 && useStars && onlyColor !== undefined) {\r\n\t\t\t\t\t\tfor (const region of regions) {\r\n\t\t\t\t\t\t\tconst availableCells = region.filter((p) => grid.cells[p.y][p.x].type === CellType.None);\r\n\t\t\t\t\t\t\tif (availableCells.length > 0) {\r\n\t\t\t\t\t\t\t\tconst cell = availableCells[Math.floor(this.rng!.next() * availableCells.length)];\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = onlyColor;\r\n\t\t\t\t\t\t\t\tstarsPlaced++;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u533A\u753B\u5206\u3051\u3092\u884C\u3046\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t * @param path \u89E3\u7B54\u30D1\u30B9\r\n\t * @param symPath \u5BFE\u79F0\u30D1\u30B9\r\n\t * @returns \u533A\u753B\u30EA\u30B9\u30C8\r\n\t */\r\n\tprivate calculateRegions(grid: Grid, path: Point[], symPath: Point[] = []): Point[][] {\r\n\t\tconst regions: Point[][] = [];\r\n\t\tconst rows = grid.rows;\r\n\t\tconst cols = grid.cols;\r\n\t\tconst visitedCells = new Uint8Array(rows * cols);\r\n\r\n\t\tconst hEdgesMask = new Uint8Array((rows + 1) * cols);\r\n\t\tconst vEdgesMask = new Uint8Array(rows * (cols + 1));\r\n\r\n\t\tconst setEdge = (p1: Point, p2: Point) => {\r\n\t\t\tif (p1.x === p2.x) {\r\n\t\t\t\tvEdgesMask[Math.min(p1.y, p2.y) * (cols + 1) + p1.x] = 1;\r\n\t\t\t} else {\r\n\t\t\t\thEdgesMask[p1.y * cols + Math.min(p1.x, p2.x)] = 1;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfor (let i = 0; i < path.length - 1; i++) setEdge(path[i], path[i + 1]);\r\n\t\tfor (let i = 0; i < symPath.length - 1; i++) setEdge(symPath[i], symPath[i + 1]);\r\n\r\n\t\tfor (let r = 0; r <= rows; r++) {\r\n\t\t\tfor (let c = 0; c < cols; c++) {\r\n\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Absent) hEdgesMask[r * cols + c] = 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let r = 0; r < rows; r++) {\r\n\t\t\tfor (let c = 0; c <= cols; c++) {\r\n\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Absent) vEdgesMask[r * (cols + 1) + c] = 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (let r = 0; r < rows; r++) {\r\n\t\t\tfor (let c = 0; c < cols; c++) {\r\n\t\t\t\tconst idx = r * cols + c;\r\n\t\t\t\tif (visitedCells[idx]) continue;\r\n\r\n\t\t\t\tconst region: Point[] = [];\r\n\t\t\t\tconst queue: number[] = [idx];\r\n\t\t\t\tvisitedCells[idx] = 1;\r\n\r\n\t\t\t\tlet head = 0;\r\n\t\t\t\twhile (head < queue.length) {\r\n\t\t\t\t\tconst currIdx = queue[head++];\r\n\t\t\t\t\tconst cx = currIdx % cols;\r\n\t\t\t\t\tconst cy = Math.floor(currIdx / cols);\r\n\t\t\t\t\tregion.push({ x: cx, y: cy });\r\n\r\n\t\t\t\t\tif (cy > 0 && !hEdgesMask[cy * cols + cx]) {\r\n\t\t\t\t\t\tconst nIdx = (cy - 1) * cols + cx;\r\n\t\t\t\t\t\tif (!visitedCells[nIdx]) {\r\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\r\n\t\t\t\t\t\t\tqueue.push(nIdx);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (cy < rows - 1 && !hEdgesMask[(cy + 1) * cols + cx]) {\r\n\t\t\t\t\t\tconst nIdx = (cy + 1) * cols + cx;\r\n\t\t\t\t\t\tif (!visitedCells[nIdx]) {\r\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\r\n\t\t\t\t\t\t\tqueue.push(nIdx);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (cx > 0 && !vEdgesMask[cy * (cols + 1) + cx]) {\r\n\t\t\t\t\t\tconst nIdx = cy * cols + (cx - 1);\r\n\t\t\t\t\t\tif (!visitedCells[nIdx]) {\r\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\r\n\t\t\t\t\t\t\tqueue.push(nIdx);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (cx < cols - 1 && !vEdgesMask[cy * (cols + 1) + (cx + 1)]) {\r\n\t\t\t\t\t\tconst nIdx = cy * cols + (cx + 1);\r\n\t\t\t\t\t\tif (!visitedCells[nIdx]) {\r\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\r\n\t\t\t\t\t\t\tqueue.push(nIdx);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tregions.push(region);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn regions;\r\n\t}\r\n\r\n\tprivate isAbsentEdge(grid: Grid, p1: Point, p2: Point): boolean {\r\n\t\tif (p1.x === p2.x) {\r\n\t\t\tconst y = Math.min(p1.y, p2.y);\r\n\t\t\treturn grid.vEdges[y][p1.x].type === EdgeType.Absent;\r\n\t\t} else {\r\n\t\t\tconst x = Math.min(p1.x, p2.x);\r\n\t\t\treturn grid.hEdges[p1.y][x].type === EdgeType.Absent;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u533A\u753B\u306E\u5883\u754C\u30A8\u30C3\u30B8\u306E\u3046\u3061\u3001\u89E3\u30D1\u30B9\u304C\u901A\u3063\u3066\u3044\u306A\u3044\u3082\u306E\u3092\u53D6\u5F97\u3059\u308B\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t * @param region \u533A\u753B\r\n\t * @param path \u89E3\u7B54\u30D1\u30B9\r\n\t * @param symPath \u5BFE\u79F0\u30D1\u30B9\r\n\t * @returns \u5883\u754C\u30A8\u30C3\u30B8\u306E\u30EA\u30B9\u30C8\r\n\t */\r\n\tprivate getRegionBoundaryEdges(grid: Grid, region: Point[], path: Point[], symPath: Point[] = []): { type: \"h\" | \"v\"; r: number; c: number }[] {\r\n\t\tconst pathEdges = new Set<string>();\r\n\t\tfor (let i = 0; i < path.length - 1; i++) pathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\r\n\t\tfor (let i = 0; i < symPath.length - 1; i++) pathEdges.add(this.getEdgeKey(symPath[i], symPath[i + 1]));\r\n\r\n\t\tconst boundary: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\r\n\t\tfor (const cell of region) {\r\n\t\t\tconst edges = [\r\n\t\t\t\t{ type: \"h\" as const, r: cell.y, c: cell.x },\r\n\t\t\t\t{ type: \"h\" as const, r: cell.y + 1, c: cell.x },\r\n\t\t\t\t{ type: \"v\" as const, r: cell.y, c: cell.x },\r\n\t\t\t\t{ type: \"v\" as const, r: cell.y, c: cell.x + 1 },\r\n\t\t\t];\r\n\t\t\tfor (const e of edges) {\r\n\t\t\t\tconst p1 = e.type === \"h\" ? { x: e.c, y: e.r } : { x: e.c, y: e.r };\r\n\t\t\t\tconst p2 = e.type === \"h\" ? { x: e.c + 1, y: e.r } : { x: e.c, y: e.r + 1 };\r\n\t\t\t\tconst key = this.getEdgeKey(p1, p2);\r\n\t\t\t\tif (!pathEdges.has(key) && !this.isAbsentEdge(grid, p1, p2)) {\r\n\t\t\t\t\tboundary.push(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// \u91CD\u8907\u3092\u524A\u9664\r\n\t\tconst unique = new Map<string, { type: \"h\" | \"v\"; r: number; c: number }>();\r\n\t\tfor (const e of boundary) unique.set(`${e.type},${e.r},${e.c}`, e);\r\n\t\treturn Array.from(unique.values());\r\n\t}\r\n\r\n\tprivate setEdgeHexagon(grid: Grid, p1: Point, p2: Point, type: EdgeType = EdgeType.Hexagon) {\r\n\t\tif (p1.x === p2.x) grid.vEdges[Math.min(p1.y, p2.y)][p1.x].type = type;\r\n\t\telse grid.hEdges[p1.y][Math.min(p1.x, p2.x)].type = type;\r\n\t}\r\n\r\n\tprivate hasIncidentHexagonEdge(grid: Grid, p: Point): boolean {\r\n\t\tconst isHex = (t: EdgeType) => t === EdgeType.Hexagon || t === EdgeType.HexagonMain || t === EdgeType.HexagonSymmetry;\r\n\t\tif (p.x > 0 && isHex(grid.hEdges[p.y][p.x - 1].type)) return true;\r\n\t\tif (p.x < grid.cols && isHex(grid.hEdges[p.y][p.x].type)) return true;\r\n\t\tif (p.y > 0 && isHex(grid.vEdges[p.y - 1][p.x].type)) return true;\r\n\t\tif (p.y < grid.rows && isHex(grid.vEdges[p.y][p.x].type)) return true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprivate isEdgeAdjacentToHexagonNode(grid: Grid, edge: { type: \"h\" | \"v\"; r: number; c: number }): boolean {\r\n\t\tconst isHex = (t: NodeType) => t === NodeType.Hexagon || t === NodeType.HexagonMain || t === NodeType.HexagonSymmetry;\r\n\t\tif (edge.type === \"h\") {\r\n\t\t\treturn isHex(grid.nodes[edge.r][edge.c].type) || isHex(grid.nodes[edge.r][edge.c + 1].type);\r\n\t\t} else {\r\n\t\t\treturn isHex(grid.nodes[edge.r][edge.c].type) || isHex(grid.nodes[edge.r + 1][edge.c].type);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u8981\u6C42\u3055\u308C\u305F\u5236\u7D04\u304C\u5168\u3066\u542B\u307E\u308C\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\r\n\t * @returns \u5168\u3066\u306E\u8981\u6C42\u3055\u308C\u305F\u5236\u7D04\u304C\u542B\u307E\u308C\u3066\u3044\u308B\u304B\r\n\t */\r\n\tprivate checkAllRequestedConstraintsPresent(grid: Grid, options: GenerationOptions): boolean {\r\n\t\tconst useHexagons = options.useHexagons ?? true;\r\n\t\tconst useSquares = options.useSquares ?? true;\r\n\t\tconst useStars = options.useStars ?? true;\r\n\t\tconst useTetris = options.useTetris ?? false;\r\n\t\tconst useTetrisNegative = options.useTetrisNegative ?? false;\r\n\t\tconst useEraser = options.useEraser ?? false;\r\n\t\tconst useTriangles = options.useTriangles ?? false;\r\n\t\tconst useBrokenEdges = options.useBrokenEdges ?? false;\r\n\r\n\t\tif (useBrokenEdges) {\r\n\t\t\tlet found = false;\r\n\t\t\tfor (let r = 0; r <= grid.rows; r++)\r\n\t\t\t\tfor (let c = 0; c < grid.cols; c++)\r\n\t\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Broken || grid.hEdges[r][c].type === EdgeType.Absent) {\r\n\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\tif (!found)\r\n\t\t\t\tfor (let r = 0; r < grid.rows; r++)\r\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++)\r\n\t\t\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Broken || grid.vEdges[r][c].type === EdgeType.Absent) {\r\n\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\tif (!found) return false;\r\n\t\t}\r\n\t\tif (useHexagons) {\r\n\t\t\tlet found = false;\r\n\t\t\tconst isHexEdge = (t: EdgeType) => t === EdgeType.Hexagon || t === EdgeType.HexagonMain || t === EdgeType.HexagonSymmetry;\r\n\t\t\tconst isHexNode = (t: NodeType) => t === NodeType.Hexagon || t === NodeType.HexagonMain || t === NodeType.HexagonSymmetry;\r\n\r\n\t\t\tfor (let r = 0; r <= grid.rows; r++)\r\n\t\t\t\tfor (let c = 0; c < grid.cols; c++)\r\n\t\t\t\t\tif (isHexEdge(grid.hEdges[r][c].type)) {\r\n\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\tif (!found)\r\n\t\t\t\tfor (let r = 0; r < grid.rows; r++)\r\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++)\r\n\t\t\t\t\t\tif (isHexEdge(grid.vEdges[r][c].type)) {\r\n\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\tif (!found)\r\n\t\t\t\tfor (let r = 0; r <= grid.rows; r++)\r\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++)\r\n\t\t\t\t\t\tif (isHexNode(grid.nodes[r][c].type)) {\r\n\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\tif (!found) return false;\r\n\t\t}\r\n\t\tif (useSquares || useStars || useTetris || useEraser) {\r\n\t\t\tlet fSq = false;\r\n\t\t\tlet fSt = false;\r\n\t\t\tlet fT = false;\r\n\t\t\tlet fTN = false;\r\n\t\t\tlet fE = false;\r\n\t\t\tlet fTri = false;\r\n\t\t\tconst sqC = new Set<number>();\r\n\t\t\tconst stC = new Set<number>();\r\n\t\t\tfor (let r = 0; r < grid.rows; r++)\r\n\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\r\n\t\t\t\t\tconst type = grid.cells[r][c].type;\r\n\t\t\t\t\tif (type === CellType.Square) {\r\n\t\t\t\t\t\tfSq = true;\r\n\t\t\t\t\t\tsqC.add(grid.cells[r][c].color);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (type === CellType.Star) {\r\n\t\t\t\t\t\tfSt = true;\r\n\t\t\t\t\t\tstC.add(grid.cells[r][c].color);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (type === CellType.Tetris || type === CellType.TetrisRotated) fT = true;\r\n\t\t\t\t\tif (type === CellType.TetrisNegative || type === CellType.TetrisNegativeRotated) fTN = true;\r\n\t\t\t\t\tif (type === CellType.Eraser) fE = true;\r\n\t\t\t\t\tif (type === CellType.Triangle) fTri = true;\r\n\t\t\t\t}\r\n\t\t\tif (useSquares && !fSq) return false;\r\n\t\t\tif (useStars && !fSt) return false;\r\n\t\t\tif (useTetris && !fT) return false;\r\n\t\t\tif (useTetrisNegative && !fTN) return false;\r\n\t\t\tif (useEraser && !fE) return false;\r\n\t\t\tif (useTriangles && !fTri) return false;\r\n\r\n\t\t\t// \u56DB\u89D2\u5F62\u306E\u8FFD\u52A0\u5236\u7D04: \u4ED6\u306E\u8272\u306E\u56DB\u89D2\u5F62\u3001\u307E\u305F\u306F\u540C\u8272\u306E\u661F\u304C\u5B58\u5728\u3057\u306A\u3044\u5834\u5408\u306F2\u8272\u4EE5\u4E0A\u5FC5\u8981\r\n\t\t\tif (useSquares && fSq) {\r\n\t\t\t\tif (sqC.size < 2) {\r\n\t\t\t\t\tconst onlyColor = sqC.values().next().value;\r\n\t\t\t\t\tif (onlyColor === undefined || !stC.has(onlyColor)) return false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this.hasIsolatedMark(grid)) return false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * \u6307\u5B9A\u3055\u308C\u305F\u533A\u753B\u3092\u30D4\u30FC\u30B9\u3067\u57CB\u3081\u5C3D\u304F\u3059\u30BF\u30A4\u30EA\u30F3\u30B0\u3092\u751F\u6210\u3059\u308B\r\n\t * @param region \u533A\u753B\r\n\t * @param maxPieces \u6700\u5927\u30D4\u30FC\u30B9\u6570\r\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\r\n\t * @returns \u30BF\u30A4\u30EA\u30F3\u30B0\u7D50\u679C\r\n\t */\r\n\tprivate generateTiling(region: Point[], maxPieces: number, options: GenerationOptions): { shape: number[][]; displayShape: number[][]; isRotated: boolean }[] | null {\r\n\t\tconst minX = Math.min(...region.map((p) => p.x));\r\n\t\tconst minY = Math.min(...region.map((p) => p.y));\r\n\t\tconst maxX = Math.max(...region.map((p) => p.x));\r\n\t\tconst maxY = Math.max(...region.map((p) => p.y));\r\n\t\tconst width = maxX - minX + 1;\r\n\t\tconst height = maxY - minY + 1;\r\n\t\tconst regionGrid = Array.from({ length: height }, () => Array(width).fill(false));\r\n\t\tfor (const p of region) regionGrid[p.y - minY][p.x - minX] = true;\r\n\t\treturn this.tilingDfs(regionGrid, [], maxPieces, options);\r\n\t}\r\n\r\n\t/**\r\n\t * \u30BF\u30A4\u30EA\u30F3\u30B0\u3092\u6DF1\u3055\u512A\u5148\u63A2\u7D22\u3067\u751F\u6210\u3059\u308B\r\n\t * @param regionGrid \u9818\u57DF\u306E\u30B0\u30EA\u30C3\u30C9\u8868\u73FE\r\n\t * @param currentPieces \u73FE\u5728\u914D\u7F6E\u6E08\u307F\u306E\u30D4\u30FC\u30B9\r\n\t * @param maxPieces \u6700\u5927\u30D4\u30FC\u30B9\u6570\r\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\r\n\t * @returns \u6210\u529F\u3057\u305F\u5834\u5408\u306F\u30D4\u30FC\u30B9\u306E\u30EA\u30B9\u30C8\u3001\u5931\u6557\u3057\u305F\u5834\u5408\u306Fnull\r\n\t */\r\n\tprivate tilingDfs(regionGrid: boolean[][], currentPieces: { shape: number[][]; displayShape: number[][]; isRotated: boolean }[], maxPieces: number, options: GenerationOptions): { shape: number[][]; displayShape: number[][]; isRotated: boolean }[] | null {\r\n\t\tlet r0 = -1;\r\n\t\tlet c0 = -1;\r\n\t\tfor (let r = 0; r < regionGrid.length; r++) {\r\n\t\t\tfor (let c = 0; c < regionGrid[0].length; c++)\r\n\t\t\t\tif (regionGrid[r][c]) {\r\n\t\t\t\t\tr0 = r;\r\n\t\t\t\t\tc0 = c;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\tif (r0 !== -1) break;\r\n\t\t}\r\n\t\tif (r0 === -1) return currentPieces;\r\n\t\tif (currentPieces.length >= maxPieces) return null;\r\n\r\n\t\tconst difficulty = options.difficulty ?? 0.5;\r\n\t\tconst indices = Array.from({ length: this.TETRIS_SHAPES.length }, (_, i) => i);\r\n\t\tthis.shuffleArray(indices);\r\n\t\tif (difficulty > 0.6) indices.sort((a, b) => this.getShapeArea(this.TETRIS_SHAPES[b]) - this.getShapeArea(this.TETRIS_SHAPES[a]));\r\n\r\n\t\tfor (const idx of indices) {\r\n\t\t\tconst baseShape = this.TETRIS_SHAPES[idx];\r\n\t\t\tconst rotations = this.TETRIS_SHAPES_WITH_ROTATIONS[idx];\r\n\t\t\tconst rotIndices = Array.from({ length: rotations.length }, (_, i) => i);\r\n\t\t\tthis.shuffleArray(rotIndices);\r\n\r\n\t\t\tfor (const rotIdx of rotIndices) {\r\n\t\t\t\tconst shape = rotations[rotIdx];\r\n\t\t\t\tconst blocks: { r: number; c: number }[] = [];\r\n\t\t\t\tfor (let pr = 0; pr < shape.length; pr++) for (let pc = 0; pc < shape[0].length; pc++) if (shape[pr][pc]) blocks.push({ r: pr, c: pc });\r\n\t\t\t\tfor (const anchor of blocks) {\r\n\t\t\t\t\tconst dr = r0 - anchor.r;\r\n\t\t\t\t\tconst dc = c0 - anchor.c;\r\n\t\t\t\t\tif (this.canPlace(regionGrid, shape, dr, dc)) {\r\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, false);\r\n\t\t\t\t\t\tconst isRotated = rotations.length > 1 && this.rng!.next() < 0.3 + difficulty * 0.6;\r\n\t\t\t\t\t\tconst result = this.tilingDfs(regionGrid, [...currentPieces, { shape, displayShape: baseShape, isRotated }], maxPieces, options);\r\n\t\t\t\t\t\tif (result) return result;\r\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tprivate getShapeArea(shape: number[][]): number {\r\n\t\tlet area = 0;\r\n\t\tfor (const row of shape) for (const cell of row) if (cell) area++;\r\n\t\treturn area;\r\n\t}\r\n\tprivate isRotationallyInvariant(shape: number[][]): boolean {\r\n\t\treturn this.getAllRotations(shape).length === 1;\r\n\t}\r\n\tprivate getAllRotations(shape: number[][]): number[][][] {\r\n\t\tconst results: number[][][] = [];\r\n\t\tconst keys = new Set<string>();\r\n\t\tlet curr = shape;\r\n\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\tconst key = JSON.stringify(curr);\r\n\t\t\tif (!keys.has(key)) {\r\n\t\t\t\tresults.push(curr);\r\n\t\t\t\tkeys.add(key);\r\n\t\t\t}\r\n\t\t\tcurr = this.rotate90(curr);\r\n\t\t}\r\n\t\treturn results;\r\n\t}\r\n\tprivate rotate90(shape: number[][]): number[][] {\r\n\t\tconst rows = shape.length;\r\n\t\tconst cols = shape[0].length;\r\n\t\tconst newShape = Array.from({ length: cols }, () => Array(rows).fill(0));\r\n\t\tfor (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) newShape[c][rows - 1 - r] = shape[r][c];\r\n\t\treturn newShape;\r\n\t}\r\n\tprivate canPlace(regionGrid: boolean[][], shape: number[][], r: number, c: number): boolean {\r\n\t\tfor (let i = 0; i < shape.length; i++)\r\n\t\t\tfor (let j = 0; j < shape[0].length; j++)\r\n\t\t\t\tif (shape[i][j]) {\r\n\t\t\t\t\tconst nr = r + i,\r\n\t\t\t\t\t\tnc = c + j;\r\n\t\t\t\t\tif (nr < 0 || nr >= regionGrid.length || nc < 0 || nc >= regionGrid[0].length || !regionGrid[nr][nc]) return false;\r\n\t\t\t\t}\r\n\t\treturn true;\r\n\t}\r\n\tprivate placePiece(regionGrid: boolean[][], shape: number[][], r: number, c: number, value: boolean) {\r\n\t\tfor (let i = 0; i < shape.length; i++) for (let j = 0; j < shape[0].length; j++) if (shape[i][j]) regionGrid[r + i][c + j] = value;\r\n\t}\r\n\tprivate isSameShape(s1: number[][], s2: number[][]): boolean {\r\n\t\tconst rotations = this.getAllRotations(s1);\r\n\t\tconst s2Str = JSON.stringify(s2);\r\n\t\treturn rotations.some((r) => JSON.stringify(r) === s2Str);\r\n\t}\r\n\tprivate countRegionNonEraserSymbols(grid: Grid, region: Point[]): number {\r\n\t\tlet count = 0;\r\n\t\tfor (const cell of region) {\r\n\t\t\tconst type = grid.cells[cell.y][cell.x].type;\r\n\t\t\tif (type !== CellType.None && type !== CellType.Eraser) count++;\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\r\n\tprivate hasRegionTetrisSymbol(grid: Grid, region: Point[]): boolean {\r\n\t\tfor (const cell of region) {\r\n\t\t\tconst type = grid.cells[cell.y][cell.x].type;\r\n\t\t\tif (type === CellType.Tetris || type === CellType.TetrisRotated) return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprivate canPlaceGeneratedTetrisNegative(grid: Grid, region: Point[], potentialCells: Point[]): boolean {\r\n\t\tif (potentialCells.length < 1) return false;\r\n\t\tif (this.hasRegionTetrisSymbol(grid, region)) return true;\r\n\t\t// \u65E2\u5B58\u30C6\u30C8\u30EA\u30B9\u304C\u7121\u3044\u5834\u5408\u306F\u3001\u5BFE\u5FDC\u3059\u308B\u30C6\u30C8\u30EA\u30B9\u3092\u5225\u30BB\u30EB\u306B\u7F6E\u3051\u308B\u7A7A\u304D\u304C\u5FC5\u8981\r\n\t\treturn potentialCells.length >= 2;\r\n\t}\r\n\r\n\tprivate canPlaceGeneratedEraser(grid: Grid, region: Point[], potentialCells: Point[]): boolean {\r\n\t\tif (potentialCells.length < 1) return false;\r\n\t\tif (this.countRegionNonEraserSymbols(grid, region) > 0) return true;\r\n\t\t// \u65E2\u5B58\u306E\u6D88\u53BB\u5BFE\u8C61\u304C\u7121\u3044\u5834\u5408\u306F\u3001\u5BFE\u5FDC\u8981\u7D20\u3092\u7F6E\u304F\u305F\u3081\u306E\u7A7A\u304D\u3092\u6700\u4F4E1\u30BB\u30EB\u78BA\u4FDD\u3059\u308B\r\n\t\treturn potentialCells.length >= 2;\r\n\t}\r\n\tprivate canTilePieceWith(p: number[][], t: number[][], n: number[][]): boolean {\r\n\t\tconst areaP = this.getShapeArea(p);\r\n\t\tconst areaT = this.getShapeArea(t);\r\n\t\tconst areaN = this.getShapeArea(n);\r\n\t\tif (areaP !== areaT + areaN) return false;\r\n\r\n\t\tconst rotationsT = this.getAllRotations(t);\r\n\t\tconst rotationsN = this.getAllRotations(n);\r\n\t\tconst hP = p.length,\r\n\t\t\twP = p[0].length;\r\n\r\n\t\tfor (const rt of rotationsT) {\r\n\t\t\tfor (const rn of rotationsN) {\r\n\t\t\t\tconst hT = rt.length,\r\n\t\t\t\t\twT = rt[0].length;\r\n\t\t\t\tconst hN = rn.length,\r\n\t\t\t\t\twN = rn[0].length;\r\n\t\t\t\tfor (let rT = 0; rT <= hP - hT; rT++) {\r\n\t\t\t\t\tfor (let cT = 0; cT <= wP - wT; cT++) {\r\n\t\t\t\t\t\tfor (let rN = 0; rN <= hP - hN; rN++) {\r\n\t\t\t\t\t\t\tfor (let cN = 0; cN <= wP - wN; cN++) {\r\n\t\t\t\t\t\t\t\tconst grid = Array.from({ length: hP }, () => Array(wP).fill(0));\r\n\t\t\t\t\t\t\t\tlet possible = true;\r\n\t\t\t\t\t\t\t\t// Place T\r\n\t\t\t\t\t\t\t\tfor (let r = 0; r < hT; r++) {\r\n\t\t\t\t\t\t\t\t\tfor (let c = 0; c < wT; c++) {\r\n\t\t\t\t\t\t\t\t\t\tif (rt[r][c]) grid[rT + r][cT + c] = 1;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// Place N\r\n\t\t\t\t\t\t\t\tfor (let r = 0; r < hN; r++) {\r\n\t\t\t\t\t\t\t\t\tfor (let c = 0; c < wN; c++) {\r\n\t\t\t\t\t\t\t\t\t\tif (rn[r][c]) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (grid[rN + r][cN + c]) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tpossible = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tgrid[rN + r][cN + c] = 1;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!possible) break;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (possible) {\r\n\t\t\t\t\t\t\t\t\t// Check if matches P\r\n\t\t\t\t\t\t\t\t\tlet matches = true;\r\n\t\t\t\t\t\t\t\t\tfor (let r = 0; r < hP; r++) {\r\n\t\t\t\t\t\t\t\t\t\tfor (let c = 0; c < wP; c++) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (grid[r][c] !== p[r][c]) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tmatches = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (!matches) break;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (matches) return true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\tprivate findStandardTriple(t: number[][]): { p: number[][]; n: number[][] } | null {\r\n\t\tconst areaT = this.getShapeArea(t);\r\n\t\tconst nCandidates = [...this.TETRIS_SHAPES];\r\n\t\tthis.shuffleArray(nCandidates);\r\n\r\n\t\tfor (const n of nCandidates) {\r\n\t\t\tconst areaN = this.getShapeArea(n);\r\n\t\t\tconst areaP = areaT + areaN;\r\n\t\t\tif (areaP > 5) continue;\r\n\t\t\tconst pCandidates = this.TETRIS_SHAPES.filter((s) => this.getShapeArea(s) === areaP);\r\n\t\t\tfor (const p of pCandidates) {\r\n\t\t\t\tif (this.canTilePieceWith(p, t, n)) return { p, n };\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\tprivate shuffleArray<T>(array: T[]) {\r\n\t\tfor (let i = array.length - 1; i > 0; i--) {\r\n\t\t\tconst j = Math.floor(this.rng!.next() * (i + 1));\r\n\t\t\t[array[i], array[j]] = [array[j], array[i]];\r\n\t\t}\r\n\t}\r\n}\r\n", "import { CellType, Color, EdgeType, NodeType, SymmetryType, type CellConstraint, type Point, type PuzzleData, type ValidationResult } from \"./types\";\n\n/**\n * UI\u8868\u793A\u8A2D\u5B9A\n */\nexport interface WitnessUIOptions {\n\t/** \u30B0\u30EA\u30C3\u30C9\u5468\u56F2\u306E\u4F59\u767D */\n\tgridPadding?: number;\n\t/** \u30BB\u30EB1\u8FBA\u306E\u30B5\u30A4\u30BA */\n\tcellSize?: number;\n\t/** \u901A\u5E38\u30CE\u30FC\u30C9\u306E\u534A\u5F84 */\n\tnodeRadius?: number;\n\t/** \u958B\u59CB\u30CE\u30FC\u30C9\u306E\u534A\u5F84 */\n\tstartNodeRadius?: number;\n\t/** \u30D1\u30B9\u306E\u592A\u3055 */\n\tpathWidth?: number;\n\t/** \u51FA\u53E3\u306E\u9577\u3055 */\n\texitLength?: number;\n\t/** \u30D1\u30BA\u30EB\u306E\u30B5\u30A4\u30BA\u306B\u5408\u308F\u305B\u3066Canvas\u30B5\u30A4\u30BA\u3092\u81EA\u52D5\u8ABF\u6574\u3059\u308B\u304B */\n\tautoResize?: boolean;\n\t/** \u5931\u6557\u6642\u306B\u30DE\u30FC\u30AF\u3092\u8D64\u304F\u70B9\u6EC5\u3055\u305B\u308B\u304B */\n\tblinkMarksOnError?: boolean;\n\t/** \u5931\u6557\u6642\u306B\u5F15\u3044\u305F\u7DDA\uFF08\u5BFE\u79F0\u7DDA\u542B\u3080\uFF09\u3092\u6B8B\u3059\u304B\uFF08false\u306E\u5834\u5408\u306F\u30D5\u30A7\u30FC\u30C9\u30A2\u30A6\u30C8\u3059\u308B\uFF09 */\n\tstayPathOnError?: boolean;\n\t/** \u30D1\u30B9\u304C\u5B8C\u4E86\u3057\u305F\u969B\u306B\u81EA\u52D5\u7684\u306B\u30D0\u30EA\u30C7\u30FC\u30B7\u30E7\u30F3\u3092\u5B9F\u884C\u3059\u308B\u304B (Worker\u30E2\u30FC\u30C9\u6642\u306E\u307F\u6709\u52B9) */\n\tautoValidate?: boolean;\n\t/** WebWorker\u3092\u4F7F\u7528\u3057\u3066\u751F\u6210\u30FB\u691C\u8A3C\u3092\u884C\u3046\u304B */\n\tuseWorker?: boolean;\n\t/** Worker\u30B9\u30AF\u30EA\u30D7\u30C8\u306E\u30D1\u30B9 (\u30C7\u30D5\u30A9\u30EB\u30C8\u306F import.meta.url) */\n\tworkerScript?: string;\n\t/** \u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u8A2D\u5B9A */\n\tanimations?: {\n\t\t/** \u70B9\u6EC5\u30FB\u524D\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u306E\u6642\u9593(ms) */\n\t\tblinkDuration: number;\n\t\t/** \u7121\u52B9\u5316\u30D5\u30A7\u30FC\u30C9\u306E\u6642\u9593(ms) */\n\t\tfadeDuration: number;\n\t\t/** \u70B9\u6EC5\u306E\u5468\u671F(ms) */\n\t\tblinkPeriod: number;\n\t};\n\t/** \u8272\u8A2D\u5B9A */\n\tcolors?: {\n\t\t/** \u901A\u5E38\u306E\u30D1\u30B9\u306E\u8272 */\n\t\tpath?: string;\n\t\t/** \u30A8\u30E9\u30FC\u6642\u306E\u8272 */\n\t\terror?: string;\n\t\t/** \u6210\u529F\u6642\u306E\u30D5\u30E9\u30C3\u30B7\u30E5/\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u7528 */\n\t\tsuccess?: string;\n\t\t/** \u5BFE\u79F0\u30D1\u30B9\u306E\u8272 */\n\t\tsymmetry?: string;\n\t\t/** \u9014\u4E2D\u3067\u96E2\u3057\u305F\u969B\u306E\u30D5\u30A7\u30FC\u30C9\u8272 */\n\t\tinterrupted?: string;\n\t\t/** \u30B0\u30EA\u30C3\u30C9\u306E\u8272 */\n\t\tgrid?: string;\n\t\t/** \u30CE\u30FC\u30C9\u306E\u8272 */\n\t\tnode?: string;\n\t\t/** \u516D\u89D2\u5F62\uFF08\u901A\u904E\u5FC5\u9808\uFF09\u306E\u8272 */\n\t\thexagon?: string;\n\t\t/** \u30E1\u30A4\u30F3\u7DDA\u306E\u307F\u306E\u516D\u89D2\u5F62\u306E\u8272 */\n\t\thexagonMain?: string;\n\t\t/** \u5BFE\u79F0\u7DDA\u306E\u307F\u306E\u516D\u89D2\u5F62\u306E\u8272 */\n\t\thexagonSymmetry?: string;\n\t\t/** \u5404\u8272\u306E\u30AB\u30E9\u30FC\u30B3\u30FC\u30C9\u30DE\u30C3\u30D7 */\n\t\tcolorMap?: Record<number, string>;\n\t\t/** \u5404\u8272\u306E\u30AB\u30E9\u30FC\u30B3\u30FC\u30C9\u30EA\u30B9\u30C8\uFF08\u30A4\u30F3\u30C7\u30C3\u30AF\u30B9\u304CColor\u5024\u306B\u5BFE\u5FDC\uFF09 */\n\t\tcolorList?: string[];\n\t};\n\t/** \u9AD8\u89E3\u50CF\u5EA6\u30C7\u30A3\u30B9\u30D7\u30EC\u30A4(Retina\u7B49)\u306B\u5BFE\u5FDC\u3055\u305B\u308B\u305F\u3081\u306E\u30D4\u30AF\u30BB\u30EB\u6BD4\u3002\u7701\u7565\u6642\u306Fwindow.devicePixelRatio\u304C\u4F7F\u7528\u3055\u308C\u307E\u3059\u3002 */\n\tpixelRatio?: number;\n}\n\n/**\n * WitnessUI\u304C\u767A\u884C\u3059\u308B\u30A4\u30D9\u30F3\u30C8\u306E\u30DE\u30C3\u30D7\n */\nexport interface WitnessEventMap {\n\t/** \u63CF\u753B\u306E\u76F4\u524D (\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u304C\u6E21\u3055\u308C\u308B) */\n\t\"render:before\": { ctx: WitnessContext };\n\t/** \u63CF\u753B\u306E\u76F4\u5F8C (\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u304C\u6E21\u3055\u308C\u308B) */\n\t\"render:after\": { ctx: WitnessContext };\n\t/** \u30D1\u30B9\u306E\u63CF\u304D\u59CB\u3081 (\u30B0\u30EA\u30C3\u30C9\u5EA7\u6A19) */\n\t\"path:start\": { x: number; y: number };\n\t/** \u30D1\u30B9\u306E\u79FB\u52D5\u4E2D (\u30B0\u30EA\u30C3\u30C9\u5EA7\u6A19\u3001\u30D1\u30B9\u5168\u4F53\u3001\u73FE\u5728\u306E\u30DE\u30A6\u30B9\u4F4D\u7F6E) */\n\t\"path:move\": { x: number; y: number; path: Point[]; currentMousePos: Point };\n\t/** \u30D1\u30B9\u306E\u7D42\u4E86 (\u30D1\u30B9\u5168\u4F53\u3001\u51FA\u53E3\u306B\u5230\u9054\u3057\u305F\u304B) */\n\t\"path:end\": { path: Point[]; isExit: boolean };\n\t/** \u30D1\u30B9\u304C\u5B8C\u4E86\u3057\u3001\u51FA\u53E3\u306B\u5230\u9054\u3057\u305F\u77AC\u9593 */\n\t\"path:complete\": { path: Point[] };\n\t/** \u30B4\u30FC\u30EB\u53EF\u80FD\u72B6\u614B\uFF08\u5148\u7AEF\u304C\u30B4\u30FC\u30EB\u306E\u51FA\u3063\u5F35\u308A\u306B\u8FD1\u3044\uFF09\u306E\u5909\u5316 */\n\t\"goal:reachable\": { reachable: boolean };\n\t/** \u30B4\u30FC\u30EB\u306B\u5230\u9054\u3057\u3001\u6210\u529F\u307E\u305F\u306F\u5931\u6557\u306E\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u304C\u958B\u59CB\u3055\u308C\u305F\u6642 */\n\t\"goal:reached\": { path: Point[]; isValid: boolean };\n\t/** \u7121\u52B9\u5316\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\uFF08\u6D88\u3057\u30B4\u30E0\u7B49\uFF09\u304C\u7D42\u4E86\u3057\u3001\u5B8C\u5168\u306B\u30D0\u30EA\u30C7\u30FC\u30B7\u30E7\u30F3\u8868\u793A\u304C\u5B8C\u4E86\u3057\u305F\u6642 */\n\t\"goal:validated\": { result: ValidationResult };\n\t/** \u65B0\u3057\u3044\u30D1\u30BA\u30EB\u304C\u30BB\u30C3\u30C8\u3055\u308C\u305F\u6642 */\n\t\"puzzle:created\": { puzzle: PuzzleData; genOptions?: any };\n}\n\nexport type WitnessEventName = keyof WitnessEventMap;\n\ntype WitnessContext = CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\n\n/**\n * the witness\u30D1\u30BA\u30EB\u306E\u63CF\u753B\u3068\u30E6\u30FC\u30B6\u30FC\u64CD\u4F5C\u3092\u7BA1\u7406\u3059\u308B\u30AF\u30E9\u30B9\n */\nexport class WitnessUI {\n\tprivate canvas: HTMLCanvasElement | OffscreenCanvas;\n\tprivate ctx: WitnessContext | null = null;\n\tprivate worker: Worker | null = null;\n\tprivate puzzle: PuzzleData | null = null;\n\tprivate options: Required<WitnessUIOptions>;\n\tprivate listeners: Map<string, Set<Function>> = new Map();\n\n\tprivate path: Point[] = [];\n\tprivate isDrawing = false;\n\tprivate currentMousePos: Point = { x: 0, y: 0 };\n\tprivate exitTipPos: Point | null = null;\n\tprivate isInvalidPath = false;\n\tprivate isValidPath = false;\n\n\t// \u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u30FB\u72B6\u614B\u8868\u793A\u7528\n\tprivate invalidatedCells: Point[] = [];\n\tprivate invalidatedEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\tprivate invalidatedNodes: Point[] = [];\n\tprivate errorCells: Point[] = [];\n\tprivate errorEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\tprivate errorNodes: Point[] = [];\n\tprivate eraserAnimationStartTime = 0;\n\tprivate isFading = false;\n\tprivate fadeOpacity = 1.0;\n\tprivate fadeColor = \"#ff4444\";\n\tprivate fadingPath: Point[] = [];\n\tprivate fadingTipPos: Point | null = null;\n\n\tprivate isSuccessFading = false;\n\tprivate successFadeStartTime = 0;\n\tprivate startTime = Date.now();\n\n\t// \u900F\u904E\u63CF\u753B\u7528\u306E\u30AA\u30D5\u30B9\u30AF\u30EA\u30FC\u30F3Canvas\n\tprivate offscreenCanvas: HTMLCanvasElement | OffscreenCanvas | null = null;\n\tprivate offscreenCtx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D | null = null;\n\n\tprivate canvasRect: { left: number; top: number; width: number; height: number } | null = null;\n\tprivate isDestroyed = false;\n\tprivate animationFrameId: number | null = null;\n\tprivate timeoutId: any = null;\n\n\t// \u30A4\u30D9\u30F3\u30C8\u30CF\u30F3\u30C9\u30E9\u306E\u53C2\u7167\uFF08\u89E3\u9664\u7528\uFF09\n\tprivate boundMouseDown: ((e: MouseEvent) => void) | null = null;\n\tprivate boundMouseMove: ((e: MouseEvent) => void) | null = null;\n\tprivate boundMouseUp: ((e: MouseEvent) => void) | null = null;\n\tprivate boundTouchStart: ((e: TouchEvent) => void) | null = null;\n\tprivate boundTouchMove: ((e: TouchEvent) => void) | null = null;\n\tprivate boundTouchEnd: ((e: TouchEvent) => void) | null = null;\n\tprivate boundUpdateRect: (() => void) | null = null;\n\n\tconstructor(canvasOrId: HTMLCanvasElement | OffscreenCanvas | string, puzzle?: PuzzleData, options: WitnessUIOptions = {}) {\n\t\tif (typeof canvasOrId === \"string\") {\n\t\t\tif (typeof document === \"undefined\") {\n\t\t\t\tthrow new Error(\"Cannot look up canvas by ID in a non-browser environment.\");\n\t\t\t}\n\t\t\tconst el = document.getElementById(canvasOrId);\n\t\t\tif (!(el instanceof HTMLCanvasElement)) {\n\t\t\t\tthrow new Error(`Element with id \"${canvasOrId}\" is not a canvas.`);\n\t\t\t}\n\t\t\tthis.canvas = el;\n\t\t} else {\n\t\t\tthis.canvas = canvasOrId;\n\t\t}\n\n\t\tthis.options = this.mergeOptions(options);\n\n\t\t// Worker\u3092\u4F7F\u7528\u3059\u308B\u5834\u5408\u306E\u521D\u671F\u5316\n\t\tif (this.options.useWorker && typeof window !== \"undefined\" && this.canvas instanceof HTMLCanvasElement && this.canvas.transferControlToOffscreen) {\n\t\t\tconst script = this.options.workerScript ?? (import.meta as any).url;\n\t\t\tif (script) {\n\t\t\t\tthis.worker = new Worker(script, { type: \"module\" });\n\t\t\t\tconst offscreen = this.canvas.transferControlToOffscreen();\n\t\t\t\tconst sanitizedOptions = this.sanitizeOptions(this.options);\n\t\t\t\tthis.worker.postMessage(\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: \"init\",\n\t\t\t\t\t\tpayload: {\n\t\t\t\t\t\t\tcanvas: offscreen,\n\t\t\t\t\t\t\toptions: sanitizedOptions,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t[offscreen],\n\t\t\t\t);\n\n\t\t\t\tthis.worker.addEventListener(\"message\", (e) => {\n\t\t\t\t\tconst { type, payload } = e.data;\n\t\t\t\t\tif (type === \"drawingStarted\") {\n\t\t\t\t\t\tthis.isDrawing = payload !== false; // payload\u304Cfalse\u306A\u3089\u958B\u59CB\u5931\u6557\n\t\t\t\t\t} else if (type === \"drawingEnded\") {\n\t\t\t\t\t\tthis.isDrawing = false;\n\t\t\t\t\t} else if (type === \"pathComplete\") {\n\t\t\t\t\t\tthis.emit(\"path:complete\", { path: payload });\n\t\t\t\t\t} else if (type === \"puzzleCreated\") {\n\t\t\t\t\t} else if (type === \"validationResult\") {\n\t\t\t\t\t\tthis.emit(\"goal:validated\", { result: payload });\n\t\t\t\t\t} else if (type === \"uiEvent\") {\n\t\t\t\t\t\tthis.emit(payload.type, payload.data);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (!this.worker) {\n\t\t\tconst context = (this.canvas as any).getContext(\"2d\") as WitnessContext | null;\n\t\t\tif (!context) throw new Error(\"Could not get 2D context.\");\n\t\t\tthis.ctx = context;\n\t\t\tthis.ctx.imageSmoothingEnabled = false;\n\t\t\tthis.animate();\n\t\t}\n\n\t\tif (puzzle) {\n\t\t\tthis.setPuzzle(puzzle);\n\t\t}\n\n\t\tthis.initEvents();\n\t}\n\n\t/**\n\t * \u30C7\u30D5\u30A9\u30EB\u30C8\u30AA\u30D7\u30B7\u30E7\u30F3\u3068\u30E6\u30FC\u30B6\u30FC\u6307\u5B9A\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u30DE\u30FC\u30B8\u3059\u308B\n\t * @param options \u6307\u5B9A\u3055\u308C\u305F\u30AA\u30D7\u30B7\u30E7\u30F3\n\t * @returns \u30DE\u30FC\u30B8\u5F8C\u306E\u5168\u30AA\u30D7\u30B7\u30E7\u30F3\n\t */\n\tprivate mergeOptions(options: WitnessUIOptions): Required<WitnessUIOptions> {\n\t\tconst animations = {\n\t\t\tblinkDuration: options.animations?.blinkDuration ?? this.options?.animations?.blinkDuration ?? 1000,\n\t\t\tfadeDuration: options.animations?.fadeDuration ?? this.options?.animations?.fadeDuration ?? 1000,\n\t\t\tblinkPeriod: options.animations?.blinkPeriod ?? this.options?.animations?.blinkPeriod ?? 800,\n\t\t};\n\n\t\tconst colors = {\n\t\t\tpath: options.colors?.path ?? this.options?.colors?.path ?? \"#ffcc00\",\n\t\t\terror: options.colors?.error ?? this.options?.colors?.error ?? \"#ff4444\",\n\t\t\tsuccess: options.colors?.success ?? this.options?.colors?.success ?? \"#ffcc00\",\n\t\t\tsymmetry: options.colors?.symmetry ?? this.options?.colors?.symmetry ?? \"rgba(255, 255, 255, 0.5)\",\n\t\t\tinterrupted: options.colors?.interrupted ?? this.options?.colors?.interrupted ?? \"#ffcc00\",\n\t\t\tgrid: options.colors?.grid ?? this.options?.colors?.grid ?? \"#555\",\n\t\t\tnode: options.colors?.node ?? this.options?.colors?.node ?? \"#555\",\n\t\t\thexagon: options.colors?.hexagon ?? this.options?.colors?.hexagon ?? \"#000\",\n\t\t\thexagonMain: options.colors?.hexagonMain ?? this.options?.colors?.hexagonMain ?? \"#00ffff\",\n\t\t\thexagonSymmetry: options.colors?.hexagonSymmetry ?? this.options?.colors?.hexagonSymmetry ?? \"#ffff00\",\n\t\t\tcolorMap: options.colors?.colorMap ??\n\t\t\t\tthis.options?.colors?.colorMap ?? {\n\t\t\t\t\t[Color.Black]: \"#000\",\n\t\t\t\t\t[Color.White]: \"#fff\",\n\t\t\t\t\t[Color.Red]: \"#f00\",\n\t\t\t\t\t[Color.Blue]: \"#00f\",\n\t\t\t\t\t[Color.None]: \"#ffcc00\",\n\t\t\t\t},\n\t\t\tcolorList: options.colors?.colorList ?? this.options?.colors?.colorList,\n\t\t};\n\n\t\treturn {\n\t\t\tgridPadding: options.gridPadding ?? this.options?.gridPadding ?? 60,\n\t\t\tcellSize: options.cellSize ?? this.options?.cellSize ?? 80,\n\t\t\tnodeRadius: options.nodeRadius ?? this.options?.nodeRadius ?? 6,\n\t\t\tstartNodeRadius: options.startNodeRadius ?? this.options?.startNodeRadius ?? 22,\n\t\t\tpathWidth: options.pathWidth ?? this.options?.pathWidth ?? 18,\n\t\t\texitLength: options.exitLength ?? this.options?.exitLength ?? 25,\n\t\t\tautoResize: options.autoResize ?? this.options?.autoResize ?? true,\n\t\t\tblinkMarksOnError: options.blinkMarksOnError ?? this.options?.blinkMarksOnError ?? true,\n\t\t\tstayPathOnError: options.stayPathOnError ?? this.options?.stayPathOnError ?? true,\n\t\t\tautoValidate: options.autoValidate ?? this.options?.autoValidate ?? false,\n\t\t\tuseWorker: options.useWorker ?? this.options?.useWorker ?? false,\n\t\t\tworkerScript: options.workerScript ?? this.options?.workerScript,\n\t\t\tanimations,\n\t\t\tcolors,\n\t\t\tpixelRatio: options.pixelRatio ?? this.options?.pixelRatio ?? (typeof window !== \"undefined\" ? window.devicePixelRatio : 1),\n\t\t};\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\u3092\u8A2D\u5B9A\u3057\u3001\u518D\u63CF\u753B\u3059\u308B\n\t */\n\tpublic setPuzzle(puzzle: PuzzleData) {\n\t\tif (this.worker) {\n\t\t\tthis.puzzle = puzzle;\n\t\t\tif (this.options.autoResize) {\n\t\t\t\tthis.resizeCanvas();\n\t\t\t}\n\t\t\tthis.worker.postMessage({ type: \"setPuzzle\", payload: { puzzle } });\n\t\t\tthis.emit(\"puzzle:created\", { puzzle });\n\t\t\treturn;\n\t\t}\n\n\t\tthis.puzzle = puzzle;\n\t\tthis.path = [];\n\t\tthis.isDrawing = false;\n\t\tthis.exitTipPos = null;\n\t\tthis.isInvalidPath = false;\n\t\tthis.isValidPath = false;\n\t\tthis.invalidatedCells = [];\n\t\tthis.invalidatedEdges = [];\n\t\tthis.invalidatedNodes = [];\n\t\tthis.errorCells = [];\n\t\tthis.errorEdges = [];\n\t\tthis.errorNodes = [];\n\t\tthis.cancelFade();\n\n\t\tif (this.options.autoResize) {\n\t\t\tthis.resizeCanvas();\n\t\t}\n\t\tthis.draw();\n\t\tthis.emit(\"puzzle:created\", { puzzle });\n\t}\n\n\t/**\n\t * \u5916\u90E8\u304B\u3089\u30D1\u30B9\uFF08\u89E3\u7B54\u7D4C\u8DEF\uFF09\u3092\u5F37\u5236\u7684\u306B\u8A2D\u5B9A\u3059\u308B\n\t * @param path \u7D4C\u8DEF\u306E\u70B9\u914D\u5217\n\t */\n\tpublic setPath(path: Point[]) {\n\t\tif (this.worker) {\n\t\t\tthis.worker.postMessage({ type: \"setPath\", payload: { path } });\n\t\t\treturn;\n\t\t}\n\n\t\tthis.cancelFade();\n\t\tthis.isInvalidPath = false;\n\t\tthis.isValidPath = false;\n\t\tthis.isSuccessFading = false;\n\n\t\tif (path.length > 0) {\n\t\t\tthis.path = [...path];\n\t\t\tconst lastPoint = this.path[this.path.length - 1];\n\t\t\tconst lastPos = this.getCanvasCoords(lastPoint.x, lastPoint.y);\n\t\t\tconst exitDir = this.getExitDir(lastPoint.x, lastPoint.y);\n\n\t\t\tif (exitDir) {\n\t\t\t\tthis.exitTipPos = {\n\t\t\t\t\tx: lastPos.x + exitDir.x * this.options.exitLength,\n\t\t\t\t\ty: lastPos.y + exitDir.y * this.options.exitLength,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthis.exitTipPos = null;\n\t\t\t}\n\t\t\tthis.currentMousePos = lastPos;\n\t\t} else {\n\t\t\tthis.path = [];\n\t\t\tthis.exitTipPos = null;\n\t\t}\n\n\t\tthis.draw();\n\t}\n\n\t/**\n\t * \u8868\u793A\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u66F4\u65B0\u3059\u308B\n\t */\n\tpublic setOptions(options: WitnessUIOptions) {\n\t\tthis.options = this.mergeOptions({ ...this.options, ...options });\n\t\tif (this.worker) {\n\t\t\tif (this.options.autoResize && this.puzzle) {\n\t\t\t\tthis.resizeCanvas();\n\t\t\t}\n\t\t\tconst sanitizedOptions = this.sanitizeOptions(options);\n\t\t\tthis.worker.postMessage({ type: \"setOptions\", payload: sanitizedOptions });\n\t\t\treturn;\n\t\t}\n\t\tif (this.options.autoResize && this.puzzle) {\n\t\t\tthis.resizeCanvas();\n\t\t}\n\t\tthis.draw();\n\t}\n\n\t// --- Event Emitter ---\n\n\t/**\n\t * \u30A4\u30D9\u30F3\u30C8\u30EA\u30B9\u30CA\u30FC\u3092\u8FFD\u52A0\u3059\u308B\n\t */\n\tpublic addEventListener<K extends WitnessEventName>(type: K, listener: (data: WitnessEventMap[K]) => void) {\n\t\tif (!this.listeners.has(type)) {\n\t\t\tthis.listeners.set(type, new Set());\n\t\t}\n\t\tthis.listeners.get(type)!.add(listener);\n\t}\n\n\t/**\n\t * \u30A4\u30D9\u30F3\u30C8\u30EA\u30B9\u30CA\u30FC\u3092\u524A\u9664\u3059\u308B\n\t */\n\tpublic removeEventListener<K extends WitnessEventName>(type: K, listener: (data: WitnessEventMap[K]) => void) {\n\t\tconst set = this.listeners.get(type);\n\t\tif (set) {\n\t\t\tset.delete(listener);\n\t\t}\n\t}\n\n\t/**\n\t * \u30A4\u30D9\u30F3\u30C8\u30EA\u30B9\u30CA\u30FC\u3092\u8FFD\u52A0\u3059\u308B (\u30A8\u30A4\u30EA\u30A2\u30B9)\n\t */\n\tpublic on<K extends WitnessEventName>(type: K, listener: (data: WitnessEventMap[K]) => void) {\n\t\tthis.addEventListener(type, listener);\n\t\treturn this;\n\t}\n\n\t/**\n\t * \u30A4\u30D9\u30F3\u30C8\u30EA\u30B9\u30CA\u30FC\u3092\u524A\u9664\u3059\u308B (\u30A8\u30A4\u30EA\u30A2\u30B9)\n\t */\n\tpublic off<K extends WitnessEventName>(type: K, listener: (data: WitnessEventMap[K]) => void) {\n\t\tthis.removeEventListener(type, listener);\n\t\treturn this;\n\t}\n\n\t/**\n\t * \u5185\u90E8\u30A4\u30D9\u30F3\u30C8\u3092\u767A\u884C\u3059\u308B\n\t */\n\tprivate emit<K extends WitnessEventName>(type: K, data: WitnessEventMap[K]) {\n\t\tconst set = this.listeners.get(type);\n\t\tif (set) {\n\t\t\tset.forEach((l) => l(data));\n\t\t}\n\n\t\t// Worker\u30E2\u30FC\u30C9\u3067\u3001\u81EA\u8EAB\u304CWorker\u5185\u3067\u52D5\u4F5C\u3057\u3066\u3044\u308B\u5834\u5408\u3001\u30E1\u30A4\u30F3\u30B9\u30EC\u30C3\u30C9\u306B\u30A4\u30D9\u30F3\u30C8\u3092\u8EE2\u9001\u3059\u308B\n\t\t// \u305F\u3060\u3057\u3001\u975E\u30B7\u30EA\u30A2\u30E9\u30A4\u30BA\u53EF\u80FD\u306A\u30C7\u30FC\u30BF\uFF08CanvasRenderingContext2D\u306A\u3069\uFF09\u3092\u542B\u3080\u30A4\u30D9\u30F3\u30C8\u306F\u8EE2\u9001\u3057\u306A\u3044\n\t\tif (typeof self !== \"undefined\" && (self as any).postMessage && !this.worker) {\n\t\t\tconst isOffscreen = typeof OffscreenCanvas !== \"undefined\" && this.canvas instanceof OffscreenCanvas;\n\t\t\tif (isOffscreen) {\n\t\t\t\tconst nonSerializableEvents = [\"render:before\", \"render:after\"];\n\t\t\t\t// \u4EE5\u4E0B\u306E\u30A4\u30D9\u30F3\u30C8\u306F\u500B\u5225\u306E\u30E1\u30C3\u30BB\u30FC\u30B8(pathComplete\u7B49)\u3067\u3082\u9001\u4FE1\u3055\u308C\u308B\u305F\u3081\u3001\n\t\t\t\t// \u4E8C\u91CD\u767A\u884C\u3092\u9632\u3050\u305F\u3081\u306BuiEvent\u3068\u3057\u3066\u306F\u9001\u4FE1\u3057\u306A\u3044\n\t\t\t\tconst redundantEvents = [\"path:complete\", \"puzzle:created\", \"goal:validated\"];\n\t\t\t\tif (!nonSerializableEvents.includes(type) && !redundantEvents.includes(type)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t(self as any).postMessage({ type: \"uiEvent\", payload: { type, data } });\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// \u30B7\u30EA\u30A2\u30E9\u30A4\u30BA\u4E0D\u53EF\u306A\u30C7\u30FC\u30BF\u304C\u542B\u307E\u308C\u3066\u3044\u305F\u5834\u5408\u306F\u7121\u8996\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u691C\u8A3C\u7D50\u679C\u3092\u53CD\u6620\u3055\u305B\u308B\uFF08\u4E0D\u6B63\u89E3\u6642\u306E\u8D64\u70B9\u6EC5\u3084\u3001\u6D88\u3057\u30B4\u30E0\u306B\u3088\u308B\u7121\u52B9\u5316\u306E\u8868\u793A\uFF09\n\t */\n\tpublic setValidationResult(isValid: boolean, invalidatedCells: Point[] = [], invalidatedEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [], errorCells: Point[] = [], errorEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [], invalidatedNodes: Point[] = [], errorNodes: Point[] = []) {\n\t\tif (this.worker) {\n\t\t\tthis.worker.postMessage({\n\t\t\t\ttype: \"setValidationResult\",\n\t\t\t\tpayload: { isValid, invalidatedCells, invalidatedEdges, errorCells, errorEdges, invalidatedNodes, errorNodes },\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tthis.invalidatedCells = invalidatedCells;\n\t\tthis.invalidatedEdges = invalidatedEdges;\n\t\tthis.invalidatedNodes = invalidatedNodes;\n\t\tthis.errorCells = errorCells;\n\t\tthis.errorEdges = errorEdges;\n\t\tthis.errorNodes = errorNodes;\n\t\tthis.eraserAnimationStartTime = Date.now();\n\n\t\tif (isValid) {\n\t\t\tthis.isValidPath = true;\n\t\t\tthis.isSuccessFading = true;\n\t\t\tthis.successFadeStartTime = Date.now();\n\t\t} else {\n\t\t\tthis.isInvalidPath = true;\n\t\t\t// \u5931\u6557\u6642\u306E\u30D5\u30A7\u30FC\u30C9\u30A2\u30A6\u30C8\u8A2D\u5B9A\u304C\u6709\u52B9\u306A\u5834\u5408\u3001\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\uFF08\u70B9\u6EC5\uFF09\u5F85\u3061\u306E\u5F8C\u306B startFade \u304C\u547C\u3070\u308C\u308B\u3088\u3046\u306B\u3059\u308B\n\t\t}\n\n\t\tthis.emit(\"goal:reached\", { path: this.path, isValid });\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u306E\u30B5\u30A4\u30BA\u306B\u5408\u308F\u305B\u3066Canvas\u306E\u7269\u7406\u30B5\u30A4\u30BA\u3092\u8ABF\u6574\u3059\u308B\n\t */\n\tprivate resizeCanvas() {\n\t\tif (!this.puzzle || !this.canvas) return;\n\t\tconst w = this.puzzle.cols * this.options.cellSize + this.options.gridPadding * 2;\n\t\tconst h = this.puzzle.rows * this.options.cellSize + this.options.gridPadding * 2;\n\n\t\tconst dpr = this.options.pixelRatio;\n\n\t\tif (typeof HTMLCanvasElement !== \"undefined\" && this.canvas instanceof HTMLCanvasElement) {\n\t\t\ttry {\n\t\t\t\tthis.canvas.width = w * dpr;\n\t\t\t\tthis.canvas.height = h * dpr;\n\t\t\t} catch (e) {\n\t\t\t\t// InvalidStateError occurs after transferControlToOffscreen()\n\t\t\t}\n\t\t} else {\n\t\t\tthis.canvas.width = w * dpr;\n\t\t\tthis.canvas.height = h * dpr;\n\t\t}\n\n\t\t// \u30B5\u30A4\u30BA\u5909\u66F4\u5F8C\u306B\u77E9\u5F62\u60C5\u5831\u3092\u518D\u8A08\u7B97\u3057\u3066Worker\u306B\u901A\u77E5\n\t\tif (this.worker && this.boundUpdateRect) {\n\t\t\tthis.boundUpdateRect();\n\t\t}\n\t}\n\n\t/**\n\t * Canvas\u306E\u8868\u793A\u4E0A\u306E\u77E9\u5F62\u60C5\u5831\u3092\u8A2D\u5B9A\u3059\u308B\uFF08Worker\u6642\u306A\u3069\u306B\u5FC5\u8981\uFF09\n\t */\n\tpublic setCanvasRect(rect: { left: number; top: number; width: number; height: number }) {\n\t\t// DOMRect\u7B49\u306E\u5834\u5408\u3001\u30B7\u30EA\u30A2\u30E9\u30A4\u30BA\u3067\u304D\u306A\u3044\u53EF\u80FD\u6027\u304C\u3042\u308B\u305F\u3081\u30D7\u30EC\u30FC\u30F3\u306A\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u306B\u5909\u63DB\n\t\tconst plainRect = {\n\t\t\tleft: rect.left,\n\t\t\ttop: rect.top,\n\t\t\twidth: rect.width,\n\t\t\theight: rect.height,\n\t\t};\n\t\tthis.canvasRect = plainRect;\n\t\tif (this.worker) {\n\t\t\tthis.worker.postMessage({ type: \"setCanvasRect\", payload: plainRect });\n\t\t}\n\t}\n\n\t/**\n\t * Worker\u306B\u30D1\u30BA\u30EB\u751F\u6210\u3092\u4F9D\u983C\u3059\u308B (Worker\u30E2\u30FC\u30C9\u6642\u306E\u307F\u6709\u52B9)\n\t */\n\tpublic createPuzzle(rows: number, cols: number, genOptions: any) {\n\t\tif (this.worker) {\n\t\t\tthis.worker.postMessage({ type: \"createPuzzle\", payload: { rows, cols, genOptions } });\n\t\t}\n\t}\n\n\t/**\n\t * \u30DE\u30A6\u30B9\u30FB\u30BF\u30C3\u30C1\u30A4\u30D9\u30F3\u30C8\u3092\u521D\u671F\u5316\u3059\u308B\n\t */\n\tprivate initEvents() {\n\t\tif (typeof window === \"undefined\" || typeof HTMLCanvasElement === \"undefined\" || !(this.canvas instanceof HTMLCanvasElement)) return;\n\n\t\tthis.boundMouseDown = (e: MouseEvent) => {\n\t\t\tif (this.handleStart(e)) {\n\t\t\t\tif (e.cancelable) e.preventDefault();\n\t\t\t}\n\t\t};\n\t\tthis.boundMouseMove = (e: MouseEvent) => {\n\t\t\tif (this.isDrawing) {\n\t\t\t\tif (e.cancelable) e.preventDefault();\n\t\t\t}\n\t\t\tthis.handleMove(e);\n\t\t};\n\t\tthis.boundMouseUp = (e: MouseEvent) => {\n\t\t\tif (this.isDrawing) {\n\t\t\t\tif (e.cancelable) e.preventDefault();\n\t\t\t}\n\t\t\tthis.handleEnd(e);\n\t\t};\n\n\t\tthis.boundTouchStart = (e: TouchEvent) => {\n\t\t\tif (this.handleStart(e.touches[0])) {\n\t\t\t\tif (e.cancelable) e.preventDefault();\n\t\t\t}\n\t\t};\n\t\tthis.boundTouchMove = (e: TouchEvent) => {\n\t\t\tif (this.isDrawing) {\n\t\t\t\tif (e.cancelable) e.preventDefault();\n\t\t\t\tthis.handleMove(e.touches[0]);\n\t\t\t}\n\t\t};\n\t\tthis.boundTouchEnd = (e: TouchEvent) => {\n\t\t\tif (this.isDrawing) {\n\t\t\t\tif (e.cancelable) e.preventDefault();\n\t\t\t\tthis.handleEnd(e.changedTouches[0]);\n\t\t\t}\n\t\t};\n\n\t\tthis.canvas.addEventListener(\"mousedown\", this.boundMouseDown);\n\t\twindow.addEventListener(\"mousemove\", this.boundMouseMove, { passive: false });\n\t\twindow.addEventListener(\"mouseup\", this.boundMouseUp, { passive: false });\n\n\t\tthis.canvas.addEventListener(\"touchstart\", this.boundTouchStart, { passive: false });\n\t\twindow.addEventListener(\"touchmove\", this.boundTouchMove, { passive: false });\n\t\twindow.addEventListener(\"touchend\", this.boundTouchEnd, { passive: false });\n\n\t\tif (this.worker) {\n\t\t\tthis.boundUpdateRect = () => {\n\t\t\t\tif (this.canvas instanceof HTMLCanvasElement) {\n\t\t\t\t\tconst rect = this.canvas.getBoundingClientRect();\n\t\t\t\t\tthis.setCanvasRect(rect);\n\t\t\t\t}\n\t\t\t};\n\t\t\twindow.addEventListener(\"resize\", this.boundUpdateRect);\n\t\t\twindow.addEventListener(\"scroll\", this.boundUpdateRect);\n\t\t\tthis.boundUpdateRect();\n\t\t}\n\t}\n\n\t/**\n\t * \u30A4\u30D9\u30F3\u30C8\u30EA\u30B9\u30CA\u30FC\u3092\u89E3\u9664\u3057\u3001\u30EA\u30BD\u30FC\u30B9\u3092\u89E3\u653E\u3059\u308B\n\t */\n\tpublic destroy() {\n\t\tthis.isDestroyed = true;\n\t\tif (this.worker) {\n\t\t\tthis.worker.terminate();\n\t\t\tthis.worker = null;\n\t\t}\n\n\t\tif (this.animationFrameId !== null && typeof cancelAnimationFrame !== \"undefined\") {\n\t\t\tcancelAnimationFrame(this.animationFrameId);\n\t\t}\n\t\tif (this.timeoutId !== null) {\n\t\t\tclearTimeout(this.timeoutId);\n\t\t}\n\n\t\tif (typeof window === \"undefined\" || typeof HTMLCanvasElement === \"undefined\" || !(this.canvas instanceof HTMLCanvasElement)) return;\n\n\t\tif (this.boundMouseDown) this.canvas.removeEventListener(\"mousedown\", this.boundMouseDown);\n\t\tif (this.boundMouseMove) window.removeEventListener(\"mousemove\", this.boundMouseMove);\n\t\tif (this.boundMouseUp) window.removeEventListener(\"mouseup\", this.boundMouseUp);\n\n\t\tif (this.boundTouchStart) this.canvas.removeEventListener(\"touchstart\", this.boundTouchStart);\n\t\tif (this.boundTouchMove) window.removeEventListener(\"touchmove\", this.boundTouchMove);\n\t\tif (this.boundTouchEnd) window.removeEventListener(\"touchend\", this.boundTouchEnd);\n\n\t\tif (this.boundUpdateRect) {\n\t\t\twindow.removeEventListener(\"resize\", this.boundUpdateRect);\n\t\t\twindow.removeEventListener(\"scroll\", this.boundUpdateRect);\n\t\t}\n\n\t\tthis.boundMouseDown = null;\n\t\tthis.boundMouseMove = null;\n\t\tthis.boundMouseUp = null;\n\t\tthis.boundTouchStart = null;\n\t\tthis.boundTouchMove = null;\n\t\tthis.boundTouchEnd = null;\n\t}\n\n\t// --- \u5EA7\u6A19\u5909\u63DB ---\n\n\t/**\n\t * \u30B0\u30EA\u30C3\u30C9\u5EA7\u6A19\u3092Canvas\u4E0A\u306E\u30D4\u30AF\u30BB\u30EB\u5EA7\u6A19\u306B\u5909\u63DB\u3059\u308B\n\t * @param gridX \u30B0\u30EA\u30C3\u30C9X\n\t * @param gridY \u30B0\u30EA\u30C3\u30C9Y\n\t * @returns Canvas\u5EA7\u6A19\n\t */\n\tprivate getCanvasCoords(gridX: number, gridY: number): Point {\n\t\treturn {\n\t\t\tx: this.options.gridPadding + gridX * this.options.cellSize,\n\t\t\ty: this.options.gridPadding + gridY * this.options.cellSize,\n\t\t};\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30CE\u30FC\u30C9\u304C\u51FA\u53E3\u306E\u5834\u5408\u3001\u305D\u306E\u51FA\u3063\u5F35\u308A\u306E\u65B9\u5411\u30D9\u30AF\u30C8\u30EB\u3092\u8FD4\u3059\n\t * @param x \u30B0\u30EA\u30C3\u30C9X\n\t * @param y \u30B0\u30EA\u30C3\u30C9Y\n\t * @returns \u65B9\u5411\u30D9\u30AF\u30C8\u30EB\u3001\u307E\u305F\u306Fnull\n\t */\n\tprivate getExitDir(x: number, y: number): Point | null {\n\t\tif (!this.puzzle) return null;\n\t\tif (this.puzzle.nodes[y]?.[x]?.type !== NodeType.End) return null;\n\n\t\tconst { cols, rows } = this.puzzle;\n\t\tconst isLeft = x === 0;\n\t\tconst isRight = x === cols;\n\t\tconst isTop = y === 0;\n\t\tconst isBottom = y === rows;\n\n\t\t// \u5916\u5468\u30C1\u30A7\u30C3\u30AF\n\t\tif (!isLeft && !isRight && !isTop && !isBottom) return null;\n\n\t\t// \u89D2\u306E\u30C1\u30A7\u30C3\u30AF\n\t\tconst isCorner = (isLeft || isRight) && (isTop || isBottom);\n\t\tif (isCorner) {\n\t\t\tif (cols >= rows) {\n\t\t\t\treturn isLeft ? { x: -1, y: 0 } : { x: 1, y: 0 };\n\t\t\t} else {\n\t\t\t\treturn isTop ? { x: 0, y: -1 } : { x: 0, y: 1 };\n\t\t\t}\n\t\t}\n\n\t\tif (isLeft) return { x: -1, y: 0 };\n\t\tif (isRight) return { x: 1, y: 0 };\n\t\tif (isTop) return { x: 0, y: -1 };\n\t\tif (isBottom) return { x: 0, y: 1 };\n\n\t\treturn null;\n\t}\n\n\t// --- \u30A4\u30D9\u30F3\u30C8\u30CF\u30F3\u30C9\u30E9 ---\n\n\tpublic handleStart(e: { clientX: number; clientY: number }): boolean {\n\t\tconst shouldStartDrawing = this.isStartNodeHit(e);\n\n\t\tif (this.worker) {\n\t\t\tif (!shouldStartDrawing) {\n\t\t\t\tthis.isDrawing = false;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis.isDrawing = true; // \u5148\u884C\u3057\u3066\u30D5\u30E9\u30B0\u3092\u7ACB\u3066\u308B\n\t\t\tthis.worker.postMessage({ type: \"event\", payload: { eventType: \"mousedown\", eventData: { clientX: e.clientX, clientY: e.clientY } } });\n\t\t\treturn true;\n\t\t}\n\t\tif (!shouldStartDrawing) return false;\n\n\t\t// \u30B9\u30BF\u30FC\u30C8\u5730\u70B9\u304C\u30AF\u30EA\u30C3\u30AF\u3055\u308C\u305F\u5834\u5408\u306E\u307F\u3001\u524D\u56DE\u306E\u72B6\u614B\u3092\u30EA\u30BB\u30C3\u30C8\u3057\u3066\u958B\u59CB\u3059\u308B\n\t\tthis.cancelFade();\n\t\tthis.isSuccessFading = false;\n\t\tthis.isInvalidPath = false;\n\t\tthis.isValidPath = false;\n\t\tthis.invalidatedCells = [];\n\t\tthis.invalidatedEdges = [];\n\t\tthis.invalidatedNodes = [];\n\t\tthis.errorCells = [];\n\t\tthis.errorEdges = [];\n\t\tthis.errorNodes = [];\n\n\t\tthis.isDrawing = true;\n\t\tthis.path = [{ x: shouldStartDrawing.x, y: shouldStartDrawing.y }];\n\t\tthis.currentMousePos = this.getCanvasCoords(shouldStartDrawing.x, shouldStartDrawing.y);\n\t\tthis.exitTipPos = null;\n\t\tthis.draw();\n\t\tthis.emit(\"path:start\", { x: shouldStartDrawing.x, y: shouldStartDrawing.y });\n\t\treturn true;\n\t}\n\n\tprivate isStartNodeHit(e: { clientX: number; clientY: number }): Point | null {\n\t\tif (!this.puzzle) return null;\n\t\tconst dpr = this.options.pixelRatio;\n\t\tconst rect = this.canvasRect || (typeof HTMLCanvasElement !== \"undefined\" && this.canvas instanceof HTMLCanvasElement ? this.canvas.getBoundingClientRect() : { left: 0, top: 0, width: this.canvas.width / dpr, height: this.canvas.height / dpr });\n\t\tconst mouseX = (e.clientX - rect.left) * (this.canvas.width / dpr / rect.width);\n\t\tconst mouseY = (e.clientY - rect.top) * (this.canvas.height / dpr / rect.height);\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tif (this.puzzle.nodes[r][c].type !== NodeType.Start) continue;\n\t\t\t\tconst nodePos = this.getCanvasCoords(c, r);\n\t\t\t\tif (Math.hypot(nodePos.x - mouseX, nodePos.y - mouseY) < this.options.startNodeRadius) {\n\t\t\t\t\treturn { x: c, y: r };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic handleMove(e: { clientX: number; clientY: number }) {\n\t\tif (this.worker) {\n\t\t\tif (this.isDrawing) {\n\t\t\t\tthis.worker.postMessage({ type: \"event\", payload: { eventType: \"mousemove\", eventData: { clientX: e.clientX, clientY: e.clientY } } });\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (!this.puzzle || !this.isDrawing) return;\n\n\t\tconst dpr = this.options.pixelRatio;\n\t\tconst rect = this.canvasRect || (typeof HTMLCanvasElement !== \"undefined\" && this.canvas instanceof HTMLCanvasElement ? this.canvas.getBoundingClientRect() : { left: 0, top: 0, width: this.canvas.width / dpr, height: this.canvas.height / dpr });\n\t\tconst mouseX = (e.clientX - rect.left) * (this.canvas.width / dpr / rect.width);\n\t\tconst mouseY = (e.clientY - rect.top) * (this.canvas.height / dpr / rect.height);\n\n\t\tconst lastPoint = this.path[this.path.length - 1];\n\t\tconst lastPos = this.getCanvasCoords(lastPoint.x, lastPoint.y);\n\n\t\tconst dx = mouseX - lastPos.x;\n\t\tconst dy = mouseY - lastPos.y;\n\n\t\tconst symmetry = this.puzzle.symmetry || SymmetryType.None;\n\n\t\tconst exitDir = this.getExitDir(lastPoint.x, lastPoint.y);\n\t\tconst intendedDir = Math.abs(dx) > Math.abs(dy) ? { x: dx > 0 ? 1 : -1, y: 0 } : { x: 0, y: dy > 0 ? 1 : -1 };\n\n\t\t// \u30B4\u30FC\u30EB\u306E\u51FA\u3063\u5F35\u308A\u65B9\u5411\u3078\u306E\u79FB\u52D5\n\t\tif (exitDir && intendedDir.x === exitDir.x && intendedDir.y === exitDir.y) {\n\t\t\tconst dot = dx * exitDir.x + dy * exitDir.y;\n\t\t\tconst length = Math.max(0, Math.min(dot, this.options.exitLength));\n\t\t\tthis.currentMousePos = {\n\t\t\t\tx: lastPos.x + exitDir.x * length,\n\t\t\t\ty: lastPos.y + exitDir.y * length,\n\t\t\t};\n\t\t\tthis.draw();\n\t\t\treturn;\n\t\t}\n\n\t\tconst tryMoveTo = (target: Point, d: number) => {\n\t\t\tconst edgeType = this.getEdgeType(lastPoint, target);\n\t\t\tif (target.x < 0 || target.x > this.puzzle!.cols || target.y < 0 || target.y > this.puzzle!.rows || edgeType === EdgeType.Absent) {\n\t\t\t\tthis.currentMousePos = lastPos;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet maxMove = edgeType === EdgeType.Broken ? this.options.cellSize * 0.35 : this.options.cellSize;\n\n\t\t\t// \u81EA\u5DF1\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\uFF08\u30E1\u30A4\u30F3\u30D1\u30B9\u306E\u30A8\u30C3\u30B8\uFF09\n\t\t\tconst targetEdgeKey = this.getEdgeKey(lastPoint, target);\n\t\t\tconst isBacktracking = this.path.length >= 2 && target.x === this.path[this.path.length - 2].x && target.y === this.path[this.path.length - 2].y;\n\n\t\t\tif (!isBacktracking) {\n\t\t\t\tfor (let i = 0; i < this.path.length - 1; i++) {\n\t\t\t\t\tif (this.getEdgeKey(this.path[i], this.path[i + 1]) === targetEdgeKey) {\n\t\t\t\t\t\t// \u65E2\u306B\u4F7F\u7528\u4E2D\u306E\u30A8\u30C3\u30B8\u306B\u5411\u304B\u3046\u5834\u5408\u306F\u3001\u5373\u5EA7\u306B\u30D6\u30ED\u30C3\u30AF\uFF08\u623B\u308B\u52D5\u4F5C\u306F\u5225\u9014 handleMove \u3067 snap \u51E6\u7406\u3055\u308C\u308B\uFF09\n\t\t\t\t\t\tmaxMove = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// \u81EA\u5DF1\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\uFF08\u30E1\u30A4\u30F3\u30D1\u30B9\u306E\u30CE\u30FC\u30C9\uFF09\n\t\t\tconst isTargetInPath = this.path.some((p) => p.x === target.x && p.y === target.y);\n\t\t\tif (isTargetInPath && this.path.length >= 2) {\n\t\t\t\tconst secondToLast = this.path[this.path.length - 2];\n\t\t\t\tif (target.x !== secondToLast.x || target.y !== secondToLast.y) {\n\t\t\t\t\tmaxMove = Math.min(maxMove, this.options.cellSize * 0.5 - this.options.pathWidth * 0.5);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst symLast = this.getSymmetricalPoint(lastPoint);\n\t\t\t\tconst symTarget = this.getSymmetricalPoint(target);\n\t\t\t\tconst symEdgeType = this.getEdgeType(symLast, symTarget);\n\t\t\t\tconst symPath = this.getSymmetryPath(this.path);\n\t\t\t\tconst symEdgeKey = this.getEdgeKey(symLast, symTarget);\n\n\t\t\t\tif (symTarget.x < 0 || symTarget.x > this.puzzle!.cols || symTarget.y < 0 || symTarget.y > this.puzzle!.rows || symEdgeType === EdgeType.Absent) {\n\t\t\t\t\tthis.currentMousePos = lastPos;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (symEdgeType === EdgeType.Broken) {\n\t\t\t\t\tmaxMove = Math.min(maxMove, this.options.cellSize * 0.35);\n\t\t\t\t}\n\n\t\t\t\t// \u5BFE\u79F0\u30D1\u30B9\u3068\u306E\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\n\t\t\t\tconst isNodeOccupiedBySym = symPath.some((p) => p.x === target.x && p.y === target.y);\n\t\t\t\tconst isSymNodeOccupiedByMain = this.path.some((p) => p.x === symTarget.x && p.y === symTarget.y);\n\t\t\t\tconst isMeetingAtNode = target.x === symTarget.x && target.y === symTarget.y;\n\t\t\t\tconst isEdgeOccupiedBySym = symPath.some((p, i) => i < symPath.length - 1 && this.getEdgeKey(symPath[i], symPath[i + 1]) === targetEdgeKey);\n\t\t\t\tconst isMirrorEdgeOccupiedByMain = this.path.some((p, i) => i < this.path.length - 1 && this.getEdgeKey(this.path[i], this.path[i + 1]) === symEdgeKey);\n\t\t\t\tconst isSelfMirrorEdge = targetEdgeKey === symEdgeKey;\n\n\t\t\t\tif (isNodeOccupiedBySym || isSymNodeOccupiedByMain || isMeetingAtNode || isEdgeOccupiedBySym || isMirrorEdgeOccupiedByMain || isSelfMirrorEdge) {\n\t\t\t\t\tmaxMove = Math.min(maxMove, this.options.cellSize * 0.5 - this.options.pathWidth * 0.5);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (target.x !== lastPoint.x) {\n\t\t\t\tthis.currentMousePos = {\n\t\t\t\t\tx: lastPos.x + Math.max(-maxMove, Math.min(maxMove, d)),\n\t\t\t\t\ty: lastPos.y,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthis.currentMousePos = {\n\t\t\t\t\tx: lastPos.x,\n\t\t\t\t\ty: lastPos.y + Math.max(-maxMove, Math.min(maxMove, d)),\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\n\t\tif (Math.abs(dx) > Math.abs(dy)) {\n\t\t\tconst dir = dx > 0 ? 1 : -1;\n\t\t\ttryMoveTo({ x: lastPoint.x + dir, y: lastPoint.y }, dx);\n\t\t} else {\n\t\t\tconst dir = dy > 0 ? 1 : -1;\n\t\t\ttryMoveTo({ x: lastPoint.x, y: lastPoint.y + dir }, dy);\n\t\t}\n\n\t\tconst neighbors = [\n\t\t\t{ x: lastPoint.x + 1, y: lastPoint.y },\n\t\t\t{ x: lastPoint.x - 1, y: lastPoint.y },\n\t\t\t{ x: lastPoint.x, y: lastPoint.y + 1 },\n\t\t\t{ x: lastPoint.x, y: lastPoint.y - 1 },\n\t\t];\n\n\t\tconst symPath = this.getSymmetryPath(this.path);\n\n\t\tfor (const n of neighbors) {\n\t\t\tif (n.x >= 0 && n.x <= this.puzzle.cols && n.y >= 0 && n.y <= this.puzzle.rows) {\n\t\t\t\tconst nPos = this.getCanvasCoords(n.x, n.y);\n\t\t\t\tconst dist = Math.hypot(nPos.x - this.currentMousePos.x, nPos.y - this.currentMousePos.y);\n\n\t\t\t\tif (dist < this.options.cellSize * 0.3) {\n\t\t\t\t\tconst idx = this.path.findIndex((p) => p.x === n.x && p.y === n.y);\n\t\t\t\t\tif (idx === -1) {\n\t\t\t\t\t\t// \u885D\u7A81\u30C1\u30A7\u30C3\u30AF\n\t\t\t\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\t\t\t\tconst sn = this.getSymmetricalPoint(n);\n\t\t\t\t\t\t\t// \u30CE\u30FC\u30C9\u81EA\u4F53\u304C\u5BFE\u79F0\u70B9\u306E\u5834\u5408\n\t\t\t\t\t\t\tif (n.x === sn.x && n.y === sn.y) continue;\n\t\t\t\t\t\t\t// \u4ED6\u306E\u7DDA\u3078\u306E\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\n\t\t\t\t\t\t\tif (this.path.some((p) => p.x === sn.x && p.y === sn.y)) continue;\n\t\t\t\t\t\t\tif (symPath.some((p) => p.x === n.x && p.y === n.y)) continue;\n\t\t\t\t\t\t\t// \u30A8\u30C3\u30B8\u306E\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\n\t\t\t\t\t\t\tconst edgeKey = this.getEdgeKey(lastPoint, n);\n\t\t\t\t\t\t\tconst symEdgeKey = this.getEdgeKey(this.getSymmetricalPoint(lastPoint), sn);\n\t\t\t\t\t\t\tif (edgeKey === symEdgeKey) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.path.push(n);\n\t\t\t\t\t\tthis.emit(\"path:move\", { x: n.x, y: n.y, path: this.path, currentMousePos: this.currentMousePos });\n\t\t\t\t\t} else if (idx === this.path.length - 2) {\n\t\t\t\t\t\tconst popped = this.path.pop();\n\t\t\t\t\t\tif (popped) {\n\t\t\t\t\t\t\tthis.emit(\"path:move\", { x: popped.x, y: popped.y, path: this.path, currentMousePos: this.currentMousePos });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.draw();\n\t}\n\n\tpublic handleEnd(e: { clientX: number; clientY: number }) {\n\t\tif (this.worker) {\n\t\t\tif (this.isDrawing) {\n\t\t\t\tthis.isDrawing = false;\n\t\t\t\tthis.worker.postMessage({ type: \"event\", payload: { eventType: \"mouseup\", eventData: { clientX: e.clientX, clientY: e.clientY } } });\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (!this.puzzle || !this.isDrawing) return;\n\t\tthis.isDrawing = false;\n\n\t\tconst lastPoint = this.path[this.path.length - 1];\n\t\tconst lastPos = this.getCanvasCoords(lastPoint.x, lastPoint.y);\n\t\tconst exitDir = this.getExitDir(lastPoint.x, lastPoint.y);\n\n\t\tlet isExit = false;\n\t\tif (exitDir) {\n\t\t\tconst dx_exit = this.currentMousePos.x - lastPos.x;\n\t\t\tconst dy_exit = this.currentMousePos.y - lastPos.y;\n\t\t\tconst dot = dx_exit * exitDir.x + dy_exit * exitDir.y;\n\n\t\t\tif (dot > 0) {\n\t\t\t\t// \u51FA\u3063\u5F35\u308A\u306E\u7BC4\u56F2\u306B\u5165\u3063\u3066\u3044\u308C\u3070\u3001\u6700\u5F8C\u307E\u3067\u4F38\u3070\u3057\u3066\u30B4\u30FC\u30EB\u3068\u3059\u308B\n\t\t\t\tthis.exitTipPos = {\n\t\t\t\t\tx: lastPos.x + exitDir.x * this.options.exitLength,\n\t\t\t\t\ty: lastPos.y + exitDir.y * this.options.exitLength,\n\t\t\t\t};\n\t\t\t\tisExit = true;\n\t\t\t\tthis.emit(\"path:complete\", { path: this.path });\n\t\t\t\tthis.emit(\"path:end\", { path: this.path, isExit: true });\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.exitTipPos = exitDir ? { ...this.currentMousePos } : null;\n\t\tthis.emit(\"path:end\", { path: this.path, isExit: false });\n\t\tthis.startFade(this.options.colors.interrupted); // \u9014\u4E2D\u3067\u96E2\u3057\u305F\u5834\u5408\u306F\u6307\u5B9A\u3055\u308C\u305F\u30D5\u30A7\u30FC\u30C9\u8272\u3067\u6D88\u3048\u308B\n\t}\n\n\t/**\n\t * \u4E8C\u70B9\u9593\u306E\u30A8\u30C3\u30B8\u30BF\u30A4\u30D7\u3092\u53D6\u5F97\u3059\u308B\n\t * @param p1 \u70B91\n\t * @param p2 \u70B92\n\t * @returns \u30A8\u30C3\u30B8\u30BF\u30A4\u30D7\n\t */\n\tprivate getEdgeType(p1: Point, p2: Point): EdgeType {\n\t\tif (!this.puzzle) return EdgeType.Absent;\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\tif (y < 0 || y >= this.puzzle.rows) return EdgeType.Absent;\n\t\t\treturn this.puzzle.vEdges[y][p1.x].type;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\tif (x < 0 || x >= this.puzzle.cols) return EdgeType.Absent;\n\t\t\treturn this.puzzle.hEdges[p1.y][x].type;\n\t\t}\n\t}\n\n\t/**\n\t * \u30D1\u30B9\u306E\u30D5\u30A7\u30FC\u30C9\u30A2\u30A6\u30C8\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u3092\u958B\u59CB\u3059\u308B\n\t * @param color \u30D5\u30A7\u30FC\u30C9\u6642\u306E\u8272\n\t */\n\tprivate startFade(color = \"#ff4444\") {\n\t\tthis.isFading = true;\n\t\tthis.fadeOpacity = 1.0;\n\t\tthis.fadeColor = color;\n\t\tthis.fadingPath = [...this.path];\n\t\tthis.fadingTipPos = this.exitTipPos ? { ...this.exitTipPos } : null;\n\t\tthis.path = [];\n\t}\n\n\t/**\n\t * \u73FE\u5728\u306E\u30D5\u30A7\u30FC\u30C9\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u3092\u4E2D\u6B62\u3059\u308B\n\t */\n\tprivate cancelFade() {\n\t\tthis.isFading = false;\n\t}\n\n\t/**\n\t * \u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u30EB\u30FC\u30D7\n\t */\n\tprivate animate() {\n\t\tif (this.isDestroyed) return;\n\t\tconst now = Date.now();\n\n\t\tif (this.isFading) {\n\t\t\t// \u30D5\u30A7\u30FC\u30C9\u901F\u5EA6\u3092 fadeDuration \u306B\u57FA\u3065\u3044\u3066\u8A08\u7B97\n\t\t\tconst step = 1000 / (this.options.animations.fadeDuration * 60); // 60FPS\u60F3\u5B9A\n\t\t\tthis.fadeOpacity -= step;\n\t\t\tif (this.fadeOpacity <= 0) {\n\t\t\t\tthis.isFading = false;\n\t\t\t\tthis.fadeOpacity = 0;\n\t\t\t\tif (this.isInvalidPath) {\n\t\t\t\t\tthis.isInvalidPath = false;\n\t\t\t\t\tthis.emit(\"goal:validated\", { result: { isValid: false } as any });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.isSuccessFading) {\n\t\t\tconst elapsed = now - this.successFadeStartTime;\n\t\t\tif (elapsed > this.options.animations.blinkDuration + this.options.animations.fadeDuration) {\n\t\t\t\tthis.isSuccessFading = false;\n\t\t\t\tthis.emit(\"goal:validated\", { result: { isValid: true } as any });\n\t\t\t}\n\t\t}\n\n\t\t// \u5931\u6557\u6642\u304B\u3064\u30D5\u30A7\u30FC\u30C9\u8A2D\u5B9A\u3042\u308A\u306E\u5834\u5408\u3001\u5373\u5EA7\u306B\u30D5\u30A7\u30FC\u30C9\u30A2\u30A6\u30C8\u3092\u958B\u59CB\u3059\u308B\n\t\tif (this.isInvalidPath && !this.options.stayPathOnError && !this.isFading && this.path.length > 0) {\n\t\t\tthis.startFade(this.options.colors.error);\n\t\t}\n\n\t\tthis.draw();\n\n\t\tif (typeof requestAnimationFrame !== \"undefined\") {\n\t\t\tthis.animationFrameId = requestAnimationFrame(() => this.animate());\n\t\t} else {\n\t\t\tthis.timeoutId = setTimeout(() => this.animate(), 1000 / 60);\n\t\t\tif (this.timeoutId && (this.timeoutId as any).unref) {\n\t\t\t\t(this.timeoutId as any).unref();\n\t\t\t}\n\t\t}\n\t}\n\n\t// --- Drawing Logic ---\n\n\tprivate lastGoalReachable = false;\n\n\tpublic draw() {\n\t\tif (!this.puzzle || !this.ctx) return;\n\n\t\tconst ctx = this.ctx;\n\t\tthis.emit(\"render:before\", { ctx });\n\n\t\tconst now = Date.now();\n\t\tconst dpr = this.options.pixelRatio;\n\n\t\tctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t\tctx.globalAlpha = 1.0;\n\t\tctx.clearRect(0, 0, this.canvas.width / dpr, this.canvas.height / dpr);\n\n\t\tthis.drawGrid(ctx);\n\t\tthis.drawConstraints(ctx);\n\t\tthis.drawNodes(ctx);\n\n\t\tif (this.path.length === 0 && !this.isDrawing) {\n\t\t\tthis.drawRipples(ctx);\n\t\t}\n\n\t\tif (this.isFading) {\n\t\t\tthis.drawPath(ctx, this.fadingPath, false, this.fadeColor, this.fadeOpacity, this.fadingTipPos);\n\t\t\tif (this.puzzle.symmetry !== undefined && this.puzzle.symmetry !== SymmetryType.None) {\n\t\t\t\tconst symFadingPath = this.getSymmetryPath(this.fadingPath);\n\t\t\t\tlet symColor = this.options.colors.symmetry as string;\n\t\t\t\tif (this.isInvalidPath) {\n\t\t\t\t\tconst originalSymAlpha = this.colorToRgba(symColor).a;\n\t\t\t\t\tsymColor = this.setAlpha(this.options.colors.error as string, originalSymAlpha);\n\t\t\t\t}\n\n\t\t\t\tlet symTipPos: Point | null = null;\n\t\t\t\tif (this.fadingTipPos) {\n\t\t\t\t\tconst gridRelX = (this.fadingTipPos.x - this.options.gridPadding) / this.options.cellSize;\n\t\t\t\t\tconst gridRelY = (this.fadingTipPos.y - this.options.gridPadding) / this.options.cellSize;\n\t\t\t\t\tconst symGridRel = this.getSymmetricalPoint({ x: gridRelX, y: gridRelY });\n\t\t\t\t\tsymTipPos = {\n\t\t\t\t\t\tx: symGridRel.x * this.options.cellSize + this.options.gridPadding,\n\t\t\t\t\t\ty: symGridRel.y * this.options.cellSize + this.options.gridPadding,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// \u9014\u4E2D\u3067\u96E2\u3057\u305F\u5834\u5408\u306F\u30E1\u30A4\u30F3\u3068\u540C\u3058\u8272\u3067\u6D88\u3048\u3066\u3082\u826F\u3044\u304C\u3001\u4E00\u5FDC\u5BFE\u79F0\u5074\u306E\u8272\u3067\u30D5\u30A7\u30FC\u30C9\u3055\u305B\u308B\n\t\t\t\tthis.drawPath(ctx, symFadingPath, false, symColor, this.fadeOpacity, symTipPos);\n\t\t\t}\n\t\t} else if (this.path.length > 0) {\n\t\t\tconst originalPathColor = this.options.colors.path as string;\n\t\t\tconst originalPathAlpha = this.colorToRgba(originalPathColor).a;\n\t\t\tconst errorColor = this.options.colors.error as string;\n\n\t\t\tlet color = this.isInvalidPath ? this.setAlpha(errorColor, originalPathAlpha) : originalPathColor;\n\n\t\t\t// \u6210\u529F\u6642\u306F\u6210\u529F\u6642\u306E\u8272\u3092\u30C7\u30D5\u30A9\u30EB\u30C8\u3068\u3059\u308B\uFF08\u5BFE\u79F0\u30E2\u30FC\u30C9\u6642\u306F\u5143\u306E\u8272\u3092\u7DAD\u6301\uFF09\n\t\t\tif ((this.isSuccessFading || this.isValidPath) && !this.puzzle.symmetry) {\n\t\t\t\tcolor = this.setAlpha(this.options.colors.success as string, originalPathAlpha);\n\t\t\t}\n\n\t\t\t// Eraser\u7121\u52B9\u5316\u524D\u306E\u70B9\u6EC5\u6642\u306A\u3069\u306E\u8272\u5236\u5FA1\n\t\t\tlet pathOpacity = 1.0;\n\t\t\tif (!this.isDrawing && this.exitTipPos && !this.isInvalidPath) {\n\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\t\t\t\tif (elapsed < blinkDuration) {\n\t\t\t\t\tif (this.isSuccessFading) {\n\t\t\t\t\t\tconst hasNegation = this.invalidatedCells.length > 0 || this.invalidatedEdges.length > 0 || this.invalidatedNodes.length > 0;\n\t\t\t\t\t\tif (hasNegation && this.options.blinkMarksOnError) {\n\t\t\t\t\t\t\t// \u6D88\u3057\u30B4\u30E0\u7121\u52B9\u5316\u304C\u3042\u308B\u6210\u529F\u6642\u306F\u3001\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u4E2D\u306E\u307F\u8D64\u8272\uFF08\u4E00\u77AC\u3067\u5207\u308A\u66FF\u3048\uFF09\n\t\t\t\t\t\t\tcolor = this.setAlpha(this.options.colors.error as string, originalPathAlpha);\n\t\t\t\t\t\t\tif (!this.options.stayPathOnError) {\n\t\t\t\t\t\t\t\tpathOpacity = Math.max(0, 1.0 - elapsed / this.options.animations.fadeDuration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet symTipPos: Point | null = null;\n\t\t\tif (this.isDrawing || this.exitTipPos) {\n\t\t\t\tconst tip = this.isDrawing ? this.currentMousePos : this.exitTipPos!;\n\t\t\t\tif (this.puzzle.symmetry !== undefined && this.puzzle.symmetry !== SymmetryType.None) {\n\t\t\t\t\tconst gridRelX = (tip.x - this.options.gridPadding) / this.options.cellSize;\n\t\t\t\t\tconst gridRelY = (tip.y - this.options.gridPadding) / this.options.cellSize;\n\t\t\t\t\tconst symGridRel = this.getSymmetricalPoint({ x: gridRelX, y: gridRelY }, true);\n\t\t\t\t\tsymTipPos = {\n\t\t\t\t\t\tx: symGridRel.x * this.options.cellSize + this.options.gridPadding,\n\t\t\t\t\t\ty: symGridRel.y * this.options.cellSize + this.options.gridPadding,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// \u30B4\u30FC\u30EB\u5230\u9054\u6642\u306E\u767A\u5149\u51E6\u7406\uFF08\u70B9\u6EC5\uFF09\n\t\t\tconst isAtExit = this.isPathAtExit(this.path, this.isDrawing ? this.currentMousePos : this.exitTipPos);\n\n\t\t\tif (isAtExit !== this.lastGoalReachable) {\n\t\t\t\tthis.lastGoalReachable = isAtExit;\n\t\t\t\tthis.emit(\"goal:reachable\", { reachable: isAtExit });\n\t\t\t}\n\n\t\t\tif (isAtExit && !this.isInvalidPath && !this.isSuccessFading && !this.isValidPath) {\n\t\t\t\tconst originalAlpha = this.colorToRgba(color).a;\n\t\t\t\tconst pulseFactor = (Math.sin((now * Math.PI * 2) / 600) + 1) / 2;\n\t\t\t\tcolor = this.lerpColor(color, \"#ffffff\", pulseFactor * 0.6);\n\t\t\t\tcolor = this.setAlpha(color, originalAlpha);\n\t\t\t}\n\n\t\t\tthis.drawPath(ctx, this.path, this.isDrawing, color, pathOpacity, this.isDrawing ? this.currentMousePos : this.exitTipPos);\n\n\t\t\tif (this.puzzle.symmetry !== undefined && this.puzzle.symmetry !== SymmetryType.None) {\n\t\t\t\tconst symPath = this.getSymmetryPath(this.path);\n\t\t\t\tconst originalSymColor = this.options.colors.symmetry as string;\n\t\t\t\tconst originalSymAlpha = this.colorToRgba(originalSymColor).a;\n\t\t\t\tlet symColor = originalSymColor;\n\t\t\t\tlet symPathOpacity = pathOpacity;\n\n\t\t\t\t// \u30A8\u30E9\u30FC\u6642\u3084\u6210\u529F\u6642\u306F\u8272\u3092\u4E0A\u66F8\u304D\uFF08\u5BFE\u79F0\u30E2\u30FC\u30C9\u6210\u529F\u6642\u306F\u5143\u306E\u8272\u3092\u7DAD\u6301\uFF09\n\t\t\t\tif (this.isInvalidPath) {\n\t\t\t\t\tsymColor = this.setAlpha(errorColor, originalSymAlpha);\n\t\t\t\t}\n\n\t\t\t\tif (!this.isDrawing && this.exitTipPos && !this.isInvalidPath) {\n\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\t\t\t\t\tif (elapsed < blinkDuration) {\n\t\t\t\t\t\tif (this.isSuccessFading) {\n\t\t\t\t\t\t\tconst hasNegation = this.invalidatedCells.length > 0 || this.invalidatedEdges.length > 0 || this.invalidatedNodes.length > 0;\n\t\t\t\t\t\t\tif (hasNegation && this.options.blinkMarksOnError) {\n\t\t\t\t\t\t\t\tsymColor = this.setAlpha(this.options.colors.error as string, originalSymAlpha);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// \u5BFE\u79F0\u30D1\u30B9\u306E\u767A\u5149\u51E6\u7406\n\t\t\t\tif (isAtExit && !this.isInvalidPath && !this.isSuccessFading && !this.isValidPath) {\n\t\t\t\t\tconst pulseFactor = (Math.sin((now * Math.PI * 2) / 400) + 1) / 2;\n\t\t\t\t\tsymColor = this.lerpColor(symColor, \"#ffffff\", pulseFactor * 0.6);\n\t\t\t\t\tsymColor = this.setAlpha(symColor, originalSymAlpha);\n\t\t\t\t}\n\n\t\t\t\tthis.drawPath(ctx, symPath, this.isDrawing, symColor, symPathOpacity, symTipPos);\n\t\t\t}\n\t\t}\n\t\tthis.emit(\"render:after\", { ctx });\n\t}\n\n\t/**\n\t * \u30B4\u30FC\u30EB\u5730\u70B9\u306E\u6CE2\u7D0B\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u3092\u63CF\u753B\u3059\u308B\n\t * @param ctx \u63CF\u753B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\n\t */\n\tprivate drawRipples(ctx: WitnessContext) {\n\t\tif (!this.puzzle) return;\n\t\tconst time = (Date.now() - this.startTime) / 500;\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tconst node = this.puzzle.nodes[r][c];\n\t\t\t\tif (node.type === NodeType.End) {\n\t\t\t\t\tconst pos = this.getCanvasCoords(c, r);\n\t\t\t\t\tconst dir = this.getExitDir(c, r);\n\t\t\t\t\tif (!dir) continue;\n\t\t\t\t\tconst exitPos = {\n\t\t\t\t\t\tx: pos.x + dir.x * this.options.exitLength,\n\t\t\t\t\t\ty: pos.y + dir.y * this.options.exitLength,\n\t\t\t\t\t};\n\n\t\t\t\t\tconst t = time % 4.0;\n\t\t\t\t\tconst radius = t * 5;\n\t\t\t\t\tconst opacity = Math.max(0, 1 - t / 3.0);\n\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(exitPos.x, exitPos.y, radius, 0, Math.PI * 2);\n\t\t\t\t\tctx.strokeStyle = `rgba(170, 170, 170, ${opacity * 0.4})`;\n\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u30B0\u30EA\u30C3\u30C9\uFF08\u80CC\u666F\u306E\u7DDA\uFF09\u3092\u63CF\u753B\u3059\u308B\n\t * @param ctx \u63CF\u753B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\n\t */\n\tprivate drawGrid(ctx: WitnessContext) {\n\t\tif (!this.puzzle || !this.options.colors.grid) return;\n\t\tctx.strokeStyle = this.options.colors.grid;\n\t\tctx.lineWidth = 12;\n\t\tctx.lineCap = \"round\";\n\n\t\tconst drawEdge = (p1: Point, p2: Point, type: EdgeType) => {\n\t\t\tif (type === EdgeType.Absent) return;\n\n\t\t\tif (type === EdgeType.Broken) {\n\t\t\t\tconst gapSize = 0.15;\n\t\t\t\tconst q1 = {\n\t\t\t\t\tx: p1.x + (p2.x - p1.x) * (0.5 - gapSize),\n\t\t\t\t\ty: p1.y + (p2.y - p1.y) * (0.5 - gapSize),\n\t\t\t\t};\n\t\t\t\tconst q2 = {\n\t\t\t\t\tx: p1.x + (p2.x - p1.x) * (0.5 + gapSize),\n\t\t\t\t\ty: p1.y + (p2.y - p1.y) * (0.5 + gapSize),\n\t\t\t\t};\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(p1.x, p1.y);\n\t\t\t\tctx.lineTo(q1.x, q1.y);\n\t\t\t\tctx.stroke();\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(q2.x, q2.y);\n\t\t\t\tctx.lineTo(p2.x, p2.y);\n\t\t\t\tctx.stroke();\n\t\t\t} else {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(p1.x, p1.y);\n\t\t\t\tctx.lineTo(p2.x, p2.y);\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t};\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c < this.puzzle.cols; c++) {\n\t\t\t\tdrawEdge(this.getCanvasCoords(c, r), this.getCanvasCoords(c + 1, r), this.puzzle.hEdges[r][c].type);\n\t\t\t}\n\t\t}\n\n\t\tfor (let r = 0; r < this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tdrawEdge(this.getCanvasCoords(c, r), this.getCanvasCoords(c, r + 1), this.puzzle.vEdges[r][c].type);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u5168\u3066\u306E\u5236\u7D04\u8A18\u53F7\uFF08\u56DB\u89D2\u3001\u661F\u3001\u516D\u89D2\u5F62\u306A\u3069\uFF09\u3092\u63CF\u753B\u3059\u308B\n\t * @param ctx \u63CF\u753B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\n\t */\n\tprivate drawConstraints(ctx: WitnessContext) {\n\t\tif (!this.puzzle) return;\n\t\tconst now = Date.now();\n\t\tconst blinkFactor = (Math.sin((now * Math.PI * 2) / this.options.animations.blinkPeriod!) + 1) / 2;\n\t\tconst invalidatedCellSet = new Set(this.invalidatedCells.map((p) => `${p.x},${p.y}`));\n\t\tconst errorCellSet = new Set(this.errorCells.map((p) => `${p.x},${p.y}`));\n\t\tconst invalidatedEdgeSet = new Set(this.invalidatedEdges.map((e) => `${e.type},${e.r},${e.c}`));\n\t\tconst errorEdgeSet = new Set(this.errorEdges.map((e) => `${e.type},${e.r},${e.c}`));\n\t\tconst invalidatedNodeSet = new Set(this.invalidatedNodes.map((p) => `${p.x},${p.y}`));\n\t\tconst errorNodeSet = new Set(this.errorNodes.map((p) => `${p.x},${p.y}`));\n\n\t\tfor (let r = 0; r < this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c < this.puzzle.cols; c++) {\n\t\t\t\tconst cell = this.puzzle.cells[r][c];\n\t\t\t\tconst pos = this.getCanvasCoords(c + 0.5, r + 0.5);\n\t\t\t\tconst cellKey = `${c},${r}`;\n\n\t\t\t\tconst isInvalidated = invalidatedCellSet.has(cellKey);\n\t\t\t\tconst isError = errorCellSet.has(cellKey);\n\n\t\t\t\tlet opacity = 1.0;\n\t\t\t\tlet overrideColor: string | undefined = undefined;\n\n\t\t\t\tconst originalColor = this.getColorCode(cell.color);\n\t\t\t\tconst errorColor = this.options.colors.error as string;\n\n\t\t\t\tif (isError && this.options.blinkMarksOnError) {\n\t\t\t\t\toverrideColor = this.lerpColor(originalColor, errorColor, blinkFactor);\n\t\t\t\t}\n\n\t\t\t\tif (isInvalidated) {\n\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\n\t\t\t\t\tif (elapsed < blinkDuration) {\n\t\t\t\t\t\tif (this.options.blinkMarksOnError) {\n\t\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\n\t\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\n\t\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\n\t\t\t\t\t\t\toverrideColor = this.lerpColor(originalColor, errorColor, blinkFactor * transitionFactor);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\topacity = Math.max(0.3, 1.0 - (elapsed - blinkDuration) / this.options.animations.fadeDuration!);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tctx.save();\n\t\t\t\tif (opacity < 1.0) {\n\t\t\t\t\tctx.globalAlpha *= opacity;\n\t\t\t\t}\n\t\t\t\tthis.drawConstraintItem(ctx, cell, pos, overrideColor);\n\t\t\t\tctx.restore();\n\t\t\t}\n\t\t}\n\n\t\tctx.lineWidth = 2;\n\t\tconst hexRadius = 8;\n\t\tconst getHexColor = (type: EdgeType | NodeType) => {\n\t\t\tif (type === EdgeType.Hexagon || type === NodeType.Hexagon) return this.options.colors.hexagon as string;\n\t\t\tif (type === EdgeType.HexagonMain || type === NodeType.HexagonMain) return this.options.colors.hexagonMain as string;\n\t\t\tif (type === EdgeType.HexagonSymmetry || type === NodeType.HexagonSymmetry) return this.options.colors.hexagonSymmetry as string;\n\t\t\treturn this.options.colors.hexagon as string;\n\t\t};\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c < this.puzzle.cols; c++) {\n\t\t\t\tconst type = this.puzzle.hEdges[r][c].type;\n\t\t\t\tif (type === EdgeType.Hexagon || type === EdgeType.HexagonMain || type === EdgeType.HexagonSymmetry) {\n\t\t\t\t\tconst pos = this.getCanvasCoords(c + 0.5, r);\n\t\t\t\t\tctx.save();\n\t\t\t\t\tconst edgeKey = `h,${r},${c}`;\n\t\t\t\t\tconst isInvalidated = invalidatedEdgeSet.has(edgeKey);\n\t\t\t\t\tconst isError = errorEdgeSet.has(edgeKey);\n\t\t\t\t\tconst baseColor = getHexColor(type);\n\n\t\t\t\t\tif (isError && this.options.blinkMarksOnError) {\n\t\t\t\t\t\tconst color = this.lerpColor(baseColor, this.options.colors.error as string, blinkFactor);\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t} else if (isInvalidated) {\n\t\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\t\t\t\t\t\tif (elapsed < blinkDuration) {\n\t\t\t\t\t\t\tif (this.options.blinkMarksOnError) {\n\t\t\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\n\t\t\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\n\t\t\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\n\t\t\t\t\t\t\t\tconst color = this.lerpColor(baseColor, this.options.colors.error as string, blinkFactor * transitionFactor);\n\t\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.globalAlpha *= Math.max(0.3, 1.0 - (elapsed - blinkDuration) / this.options.animations.fadeDuration!);\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\n\t\t\t\t\t}\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tconst type = this.puzzle.vEdges[r][c].type;\n\t\t\t\tif (type === EdgeType.Hexagon || type === EdgeType.HexagonMain || type === EdgeType.HexagonSymmetry) {\n\t\t\t\t\tconst pos = this.getCanvasCoords(c, r + 0.5);\n\t\t\t\t\tctx.save();\n\t\t\t\t\tconst edgeKey = `v,${r},${c}`;\n\t\t\t\t\tconst isInvalidated = invalidatedEdgeSet.has(edgeKey);\n\t\t\t\t\tconst isError = errorEdgeSet.has(edgeKey);\n\t\t\t\t\tconst baseColor = getHexColor(type);\n\n\t\t\t\t\tif (isError && this.options.blinkMarksOnError) {\n\t\t\t\t\t\tconst color = this.lerpColor(baseColor, this.options.colors.error as string, blinkFactor);\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t} else if (isInvalidated) {\n\t\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\t\t\t\t\t\tif (elapsed < blinkDuration) {\n\t\t\t\t\t\t\tif (this.options.blinkMarksOnError) {\n\t\t\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\n\t\t\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\n\t\t\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\n\t\t\t\t\t\t\t\tconst color = this.lerpColor(baseColor, this.options.colors.error as string, blinkFactor * transitionFactor);\n\t\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.globalAlpha *= Math.max(0.3, 1.0 - (elapsed - blinkDuration) / this.options.animations.fadeDuration!);\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\n\t\t\t\t\t}\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tconst type = this.puzzle.nodes[r][c].type;\n\t\t\t\tif (type === NodeType.Hexagon || type === NodeType.HexagonMain || type === NodeType.HexagonSymmetry) {\n\t\t\t\t\tconst pos = this.getCanvasCoords(c, r);\n\t\t\t\t\tctx.save();\n\t\t\t\t\tconst nodeKey = `${c},${r}`;\n\t\t\t\t\tconst isInvalidated = invalidatedNodeSet.has(nodeKey);\n\t\t\t\t\tconst isError = errorNodeSet.has(nodeKey);\n\t\t\t\t\tconst baseColor = getHexColor(type);\n\n\t\t\t\t\tif (isError && this.options.blinkMarksOnError) {\n\t\t\t\t\t\tconst color = this.lerpColor(baseColor, this.options.colors.error as string, blinkFactor);\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t} else if (isInvalidated) {\n\t\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\t\t\t\t\t\tif (elapsed < blinkDuration) {\n\t\t\t\t\t\t\tif (this.options.blinkMarksOnError) {\n\t\t\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\n\t\t\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\n\t\t\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\n\t\t\t\t\t\t\t\tconst color = this.lerpColor(baseColor, this.options.colors.error as string, blinkFactor * transitionFactor);\n\t\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.globalAlpha *= Math.max(0.3, 1.0 - (elapsed - blinkDuration) / this.options.animations.fadeDuration!);\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\n\t\t\t\t\t}\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u5358\u4E00\u306E\u5236\u7D04\u30A2\u30A4\u30C6\u30E0\u3092\u63CF\u753B\uFF08\u5EA7\u6A19\u306F\u30AD\u30E3\u30F3\u30D0\u30B9\u5168\u4F53\u306B\u5BFE\u3059\u308B\u7D76\u5BFE\u5EA7\u6A19\uFF09\n\t */\n\tprivate drawConstraintItem(ctx: WitnessContext, cell: CellConstraint, pos: Point, overrideColor?: string) {\n\t\tif (cell.type === CellType.Square) {\n\t\t\tconst size = 26;\n\t\t\tconst radius = 8;\n\t\t\tctx.fillStyle = overrideColor || this.getColorCode(cell.color);\n\t\t\tthis.drawRoundedRect(ctx, pos.x - size / 2, pos.y - size / 2, size, size, radius);\n\t\t} else if (cell.type === CellType.Star) {\n\t\t\tthis.drawStar(ctx, pos.x, pos.y, 12, 16, 8, cell.color, overrideColor);\n\t\t} else if (cell.type === CellType.Tetris || cell.type === CellType.TetrisRotated) {\n\t\t\tthis.drawTetris(ctx, pos.x, pos.y, cell.shape || [], cell.type === CellType.TetrisRotated, cell.color, false, overrideColor);\n\t\t} else if (cell.type === CellType.TetrisNegative || cell.type === CellType.TetrisNegativeRotated) {\n\t\t\tthis.drawTetris(ctx, pos.x, pos.y, cell.shape || [], cell.type === CellType.TetrisNegativeRotated, cell.color, true, overrideColor);\n\t\t} else if (cell.type === CellType.Eraser) {\n\t\t\tthis.drawEraser(ctx, pos.x, pos.y, 14, 3, cell.color, overrideColor);\n\t\t} else if (cell.type === CellType.Triangle) {\n\t\t\tthis.drawTriangle(ctx, pos.x, pos.y, cell.count || 0, cell.color, overrideColor);\n\t\t}\n\t}\n\n\t/**\n\t * \u5168\u3066\u306E\u30CE\u30FC\u30C9\uFF08\u4EA4\u70B9\u3001\u59CB\u70B9\u3001\u7D42\u70B9\uFF09\u3092\u63CF\u753B\u3059\u308B\n\t * @param ctx \u63CF\u753B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\n\t */\n\tprivate drawNodes(ctx: WitnessContext) {\n\t\tif (!this.puzzle) return;\n\t\tconst isNodeIsolated = (c: number, r: number) => {\n\t\t\tconst connectedEdges: EdgeType[] = [];\n\t\t\tif (c > 0) connectedEdges.push(this.puzzle!.hEdges[r][c - 1].type);\n\t\t\tif (c < this.puzzle!.cols) connectedEdges.push(this.puzzle!.hEdges[r][c].type);\n\t\t\tif (r > 0) connectedEdges.push(this.puzzle!.vEdges[r - 1][c].type);\n\t\t\tif (r < this.puzzle!.rows) connectedEdges.push(this.puzzle!.vEdges[r][c].type);\n\t\t\treturn connectedEdges.length > 0 && connectedEdges.every((e) => e === EdgeType.Absent);\n\t\t};\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tif (isNodeIsolated(c, r)) continue;\n\n\t\t\t\tconst node = this.puzzle.nodes[r][c];\n\t\t\t\tif (node.type === NodeType.Hexagon || node.type === NodeType.HexagonMain || node.type === NodeType.HexagonSymmetry) continue;\n\n\t\t\t\tconst pos = this.getCanvasCoords(c, r);\n\n\t\t\t\tif (node.type === NodeType.Start) {\n\t\t\t\t\tif (this.options.colors.node) ctx.fillStyle = this.options.colors.node;\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(pos.x, pos.y, this.options.startNodeRadius, 0, Math.PI * 2);\n\t\t\t\t\tctx.fill();\n\t\t\t\t} else if (node.type === NodeType.End) {\n\t\t\t\t\tconst dir = this.getExitDir(c, r);\n\t\t\t\t\tif (!dir) continue;\n\t\t\t\t\tif (this.options.colors.node) ctx.strokeStyle = this.options.colors.node;\n\t\t\t\t\tctx.lineWidth = 12;\n\t\t\t\t\tctx.lineCap = \"round\";\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(pos.x, pos.y);\n\t\t\t\t\tctx.lineTo(pos.x + dir.x * this.options.exitLength, pos.y + dir.y * this.options.exitLength);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t} else {\n\t\t\t\t\tif (this.options.colors.node) ctx.fillStyle = this.options.colors.node;\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(pos.x, pos.y, this.options.nodeRadius, 0, Math.PI * 2);\n\t\t\t\t\tctx.fill();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u89E3\u7B54\u30D1\u30B9\u3092\u63CF\u753B\u3059\u308B\uFF08\u30AA\u30D5\u30B9\u30AF\u30EA\u30FC\u30F3\u5408\u6210\u306B\u3088\u308A\u91CD\u306A\u308A\u3092\u9632\u6B62\uFF09\n\t * @param ctx \u63CF\u753B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\n\t * @param path \u30D1\u30B9\u5EA7\u6A19\u914D\u5217\n\t * @param isDrawing \u63CF\u753B\u4E2D\u304B\u3069\u3046\u304B\n\t * @param color \u30D1\u30B9\u306E\u8272\n\t * @param opacity \u4E0D\u900F\u660E\u5EA6\n\t * @param tipPos \u5148\u7AEF\u306E\u5EA7\u6A19\uFF08\u63CF\u753B\u4E2D\u7528\uFF09\n\t */\n\tprivate drawPath(ctx: WitnessContext, path: Point[], isDrawing: boolean, color: string | undefined, opacity: number, tipPos: Point | null = null) {\n\t\tif (path.length === 0 || !color || color === \"transparent\") return;\n\n\t\tconst rgba = this.colorToRgba(color);\n\t\tconst finalColor = `rgb(${rgba.r},${rgba.g},${rgba.b})`;\n\t\tconst finalOpacity = opacity * rgba.a;\n\n\t\t// \u91CD\u306A\u308A\u90E8\u5206\u306E\u8272\u304C\u6FC3\u304F\u306A\u308B\u306E\u3092\u9632\u3050\u305F\u3081\u3001\u5E38\u306B\u30AA\u30D5\u30B9\u30AF\u30EA\u30FC\u30F3\u3067\u4E0D\u900F\u660E\u306B\u63CF\u753B\u3057\u3066\u304B\u3089\u900F\u904E\u3067\u5408\u6210\u3059\u308B\n\t\tconst { canvas: tempCanvas, ctx: tempCtx } = this.prepareOffscreen();\n\t\tthis.drawPathInternal(tempCtx, path, isDrawing, finalColor, tipPos);\n\t\tctx.save();\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\tctx.globalAlpha = finalOpacity;\n\t\tctx.drawImage(tempCanvas, 0, 0);\n\t\tctx.restore();\n\t}\n\n\t/**\n\t * \u89E3\u7B54\u30D1\u30B9\u306E\u5B9F\u969B\u306E\u63CF\u753B\u51E6\u7406\n\t * @param ctx \u63CF\u753B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\n\t * @param path \u30D1\u30B9\u5EA7\u6A19\u914D\u5217\n\t * @param isDrawing \u63CF\u753B\u4E2D\u304B\u3069\u3046\u304B\n\t * @param color \u30D1\u30B9\u306E\u8272\n\t * @param tipPos \u5148\u7AEF\u306E\u5EA7\u6A19\n\t */\n\tprivate drawPathInternal(ctx: WitnessContext, path: Point[], isDrawing: boolean, color: string, tipPos: Point | null = null) {\n\t\tctx.save();\n\t\tctx.strokeStyle = color;\n\t\tctx.fillStyle = color;\n\t\tctx.lineWidth = this.options.pathWidth;\n\t\tctx.lineCap = \"round\";\n\t\tctx.lineJoin = \"round\";\n\n\t\tctx.beginPath();\n\t\tconst startPos = this.getCanvasCoords(path[0].x, path[0].y);\n\t\tctx.moveTo(startPos.x, startPos.y);\n\n\t\tfor (let i = 1; i < path.length; i++) {\n\t\t\tconst pos = this.getCanvasCoords(path[i].x, path[i].y);\n\t\t\tctx.lineTo(pos.x, pos.y);\n\t\t}\n\n\t\tconst actualTipPos = tipPos || this.currentMousePos;\n\t\tif (isDrawing || tipPos) {\n\t\t\tctx.lineTo(actualTipPos.x, actualTipPos.y);\n\t\t}\n\n\t\tctx.stroke();\n\n\t\tctx.beginPath();\n\t\tctx.arc(startPos.x, startPos.y, this.options.startNodeRadius, 0, Math.PI * 2);\n\t\tctx.fill();\n\n\t\tif (isDrawing || tipPos) {\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(actualTipPos.x, actualTipPos.y, this.options.pathWidth / 2, 0, Math.PI * 2);\n\t\t\tctx.fill();\n\t\t}\n\t\tctx.restore();\n\t}\n\n\t/**\n\t * \u89D2\u4E38\u9577\u65B9\u5F62\u3092\u63CF\u753B\u3059\u308B\n\t */\n\tprivate drawRoundedRect(ctx: WitnessContext, x: number, y: number, width: number, height: number, radius: number) {\n\t\tctx.beginPath();\n\t\tctx.moveTo(x + radius, y);\n\t\tctx.lineTo(x + width - radius, y);\n\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\tctx.lineTo(x + width, y + height - radius);\n\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\tctx.lineTo(x + radius, y + height);\n\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\tctx.lineTo(x, y + radius);\n\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\tctx.closePath();\n\t\tctx.fill();\n\t}\n\n\t/**\n\t * \u516D\u89D2\u5F62\uFF08\u901A\u904E\u5FC5\u9808\u30DE\u30FC\u30AF\uFF09\u3092\u63CF\u753B\u3059\u308B\n\t */\n\tprivate drawHexagon(ctx: WitnessContext, x: number, y: number, radius: number, overrideColor?: string) {\n\t\tif (!this.options.colors.hexagon && !overrideColor) return;\n\t\tctx.fillStyle = (overrideColor || this.options.colors.hexagon) as string;\n\t\tctx.beginPath();\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tconst angle = (Math.PI / 3) * i;\n\t\t\tconst px = x + radius * Math.cos(angle);\n\t\t\tconst py = y + radius * Math.sin(angle);\n\t\t\tif (i === 0) ctx.moveTo(px, py);\n\t\t\telse ctx.lineTo(px, py);\n\t\t}\n\t\tctx.closePath();\n\t\tctx.fill();\n\t}\n\n\t/**\n\t * \u6D88\u3057\u30B4\u30E0\uFF08\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF09\u3092\u63CF\u753B\u3059\u308B\n\t */\n\tprivate drawEraser(ctx: WitnessContext, x: number, y: number, radius: number, points: number, colorEnum: Color, overrideColor?: string) {\n\t\tctx.strokeStyle = overrideColor || this.getColorCode(colorEnum);\n\t\tctx.lineWidth = radius * 0.5;\n\t\tctx.lineCap = \"butt\";\n\t\tconst rotation = 0.5;\n\t\tctx.beginPath();\n\t\tfor (let i = 0; i < points; i++) {\n\t\t\tconst angle = ((Math.PI * 2) / points) * i + rotation;\n\t\t\tconst px = x + radius * Math.cos(angle);\n\t\t\tconst py = y + radius * Math.sin(angle);\n\n\t\t\tctx.moveTo(x, y);\n\t\t\tctx.lineTo(px, py);\n\t\t}\n\t\tctx.stroke();\n\t}\n\n\t/**\n\t * \u661F\u3092\u63CF\u753B\u3059\u308B\n\t */\n\tprivate drawStar(ctx: WitnessContext, x: number, y: number, innerRadius: number, outerRadius: number, points: number, colorEnum: Color, overrideColor?: string) {\n\t\tctx.fillStyle = overrideColor || this.getColorCode(colorEnum);\n\t\tctx.beginPath();\n\t\tfor (let i = 0; i < points * 2; i++) {\n\t\t\tconst radius = i % 2 === 0 ? outerRadius : innerRadius;\n\t\t\tconst angle = (Math.PI / points) * i;\n\t\t\tconst px = x + radius * Math.cos(angle);\n\t\t\tconst py = y + radius * Math.sin(angle);\n\t\t\tif (i === 0) ctx.moveTo(px, py);\n\t\t\telse ctx.lineTo(px, py);\n\t\t}\n\t\tctx.closePath();\n\t\tctx.fill();\n\t}\n\n\t/**\n\t * \u4E09\u89D2\u5F62\u3092\u63CF\u753B\u3059\u308B\n\t */\n\tprivate drawTriangle(ctx: WitnessContext, x: number, y: number, count: number, colorEnum: Color, overrideColor?: string) {\n\t\tif (count <= 0) return;\n\t\tconst color = overrideColor || this.getColorCode(colorEnum, \"#ffcc00\");\n\t\tctx.fillStyle = color;\n\n\t\tconst size = 12; // \u4E09\u89D2\u5F62\u306E\u5916\u63A5\u5186\u534A\u5F84\u306B\u8FD1\u3044\u30B5\u30A4\u30BA\n\t\tconst r = size * 0.8;\n\t\tconst spacing = r * 2.2;\n\n\t\tconst drawSingleTriangle = (tx: number, ty: number) => {\n\t\t\tctx.beginPath();\n\t\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t\tconst angle = (Math.PI * 2 * i) / 3 - Math.PI / 2;\n\t\t\t\tconst px = tx + r * Math.cos(angle);\n\t\t\t\tconst py = ty + r * Math.sin(angle);\n\t\t\t\tif (i === 0) ctx.moveTo(px, py);\n\t\t\t\telse ctx.lineTo(px, py);\n\t\t\t}\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t};\n\n\t\tconst offset = (count - 1) * spacing * 0.5;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tdrawSingleTriangle(x - offset + i * spacing, y);\n\t\t}\n\t}\n\n\t/**\n\t * \u30C6\u30C8\u30EA\u30B9\u30D4\u30FC\u30B9\u3092\u63CF\u753B\u3059\u308B\n\t */\n\tprivate drawTetris(ctx: WitnessContext, x: number, y: number, shape: number[][], rotated: boolean, colorEnum: Color, isNegative: boolean, overrideColor?: string) {\n\t\tif (!shape || shape.length === 0) return;\n\t\tconst cellSize = 12;\n\t\tconst gap = 2;\n\t\tconst totalW = shape[0].length * cellSize + (shape[0].length - 1) * gap;\n\t\tconst totalH = shape.length * cellSize + (shape.length - 1) * gap;\n\n\t\tctx.save();\n\t\tctx.translate(x, y);\n\t\tif (rotated) {\n\t\t\tctx.rotate(Math.PI / 8);\n\t\t}\n\n\t\tconst color = overrideColor || this.getColorCode(colorEnum, isNegative ? \"#00ffff\" : \"#ffcc00\");\n\n\t\tif (isNegative) {\n\t\t\tctx.strokeStyle = color;\n\t\t\tctx.lineWidth = 2;\n\t\t\tfor (let r = 0; r < shape.length; r++) {\n\t\t\t\tfor (let c = 0; c < shape[r].length; c++) {\n\t\t\t\t\tif (shape[r][c]) {\n\t\t\t\t\t\tconst px = c * (cellSize + gap) - totalW / 2;\n\t\t\t\t\t\tconst py = r * (cellSize + gap) - totalH / 2;\n\t\t\t\t\t\tctx.strokeRect(px + 1, py + 1, cellSize - 2, cellSize - 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tctx.fillStyle = color;\n\t\t\tfor (let r = 0; r < shape.length; r++) {\n\t\t\t\tfor (let c = 0; c < shape[r].length; c++) {\n\t\t\t\t\tif (shape[r][c]) {\n\t\t\t\t\t\tconst px = c * (cellSize + gap) - totalW / 2;\n\t\t\t\t\t\tconst py = r * (cellSize + gap) - totalH / 2;\n\t\t\t\t\t\tctx.fillRect(px, py, cellSize, cellSize);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx.restore();\n\t}\n\n\t/**\n\t * Color\u5024\u306B\u5BFE\u5FDC\u3059\u308B\u30AB\u30E9\u30FC\u30B3\u30FC\u30C9\u3092\u53D6\u5F97\u3059\u308B\n\t * @param colorEnum Color\u5024\n\t * @param defaultFallback \u898B\u3064\u304B\u3089\u306A\u3044\u5834\u5408\u306E\u30C7\u30D5\u30A9\u30EB\u30C8\n\t * @returns \u30AB\u30E9\u30FC\u30B3\u30FC\u30C9\u6587\u5B57\u5217\n\t */\n\tprivate getColorCode(colorEnum: Color, defaultFallback = \"#666\"): string {\n\t\tif (this.options.colors.colorList && this.options.colors.colorList[colorEnum] !== undefined) {\n\t\t\treturn this.options.colors.colorList[colorEnum];\n\t\t}\n\t\tif (this.options.colors.colorMap && this.options.colors.colorMap[colorEnum] !== undefined) {\n\t\t\treturn this.options.colors.colorMap[colorEnum];\n\t\t}\n\t\treturn defaultFallback;\n\t}\n\n\t/**\n\t * \u30AB\u30E9\u30FC\u6587\u5B57\u5217\u3092RGBA\u6210\u5206\u306B\u5206\u89E3\u3059\u308B\n\t * @param color #hex \u307E\u305F\u306F rgba() \u6587\u5B57\u5217\n\t * @returns RGBA\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\n\t */\n\tprivate colorToRgba(color: string): { r: number; g: number; b: number; a: number } {\n\t\tif (!color || color === \"transparent\") {\n\t\t\treturn { r: 0, g: 0, b: 0, a: 0 };\n\t\t}\n\n\t\tif (color.startsWith(\"rgba\") || color.startsWith(\"rgb\")) {\n\t\t\tconst match = color.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\n\t\t\tif (match) {\n\t\t\t\treturn {\n\t\t\t\t\tr: parseInt(match[1]),\n\t\t\t\t\tg: parseInt(match[2]),\n\t\t\t\t\tb: parseInt(match[3]),\n\t\t\t\t\ta: match[4] ? parseFloat(match[4]) : 1.0,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tlet c = color.startsWith(\"#\") ? color.slice(1) : color;\n\t\tif (c.length === 3 || c.length === 4) {\n\t\t\tc = c\n\t\t\t\t.split(\"\")\n\t\t\t\t.map((s) => s + s)\n\t\t\t\t.join(\"\");\n\t\t}\n\n\t\tif (c.length === 6) {\n\t\t\tconst i = parseInt(c, 16);\n\t\t\treturn {\n\t\t\t\tr: (i >> 16) & 255,\n\t\t\t\tg: (i >> 8) & 255,\n\t\t\t\tb: i & 255,\n\t\t\t\ta: 1.0,\n\t\t\t};\n\t\t} else if (c.length === 8) {\n\t\t\tconst i = parseInt(c, 16);\n\t\t\treturn {\n\t\t\t\tr: (i >> 24) & 255,\n\t\t\t\tg: (i >> 16) & 255,\n\t\t\t\tb: (i >> 8) & 255,\n\t\t\t\ta: (i & 255) / 255,\n\t\t\t};\n\t\t}\n\t\treturn { r: 0, g: 0, b: 0, a: 1.0 };\n\t}\n\n\t/**\n\t * \u4E8C\u3064\u306E\u8272\u3092\u7DDA\u5F62\u88DC\u9593\u3059\u308B\n\t * @param c1 \u82721\n\t * @param c2 \u82722\n\t * @param t \u5272\u5408 (0.0 - 1.0)\n\t * @returns \u88DC\u9593\u5F8C\u306E\u8272 (rgba\u5F62\u5F0F)\n\t */\n\tprivate lerpColor(c1: string, c2: string, t: number): string {\n\t\ttry {\n\t\t\tconst rgba1 = this.colorToRgba(c1);\n\t\t\tconst rgba2 = this.colorToRgba(c2);\n\t\t\tconst r = Math.round(rgba1.r + (rgba2.r - rgba1.r) * t);\n\t\t\tconst g = Math.round(rgba1.g + (rgba2.g - rgba1.g) * t);\n\t\t\tconst b = Math.round(rgba1.b + (rgba2.b - rgba1.b) * t);\n\t\t\tconst a = rgba1.a + (rgba2.a - rgba1.a) * t;\n\t\t\treturn `rgba(${r},${g},${b},${a})`;\n\t\t} catch (e) {\n\t\t\treturn c1;\n\t\t}\n\t}\n\n\t/**\n\t * \u8272\u306E\u30A2\u30EB\u30D5\u30A1\u5024\u3092\u4E0A\u66F8\u304D\u3059\u308B\n\t * @param color \u5143\u306E\u8272\n\t * @param alpha \u65B0\u3057\u3044\u30A2\u30EB\u30D5\u30A1\u5024\n\t * @returns \u5909\u66F4\u5F8C\u306E\u8272\n\t */\n\tprivate setAlpha(color: string, alpha: number): string {\n\t\tconst rgba = this.colorToRgba(color);\n\t\treturn `rgba(${rgba.r},${rgba.g},${rgba.b},${alpha})`;\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30D1\u30B9\u306E\u5BFE\u79F0\u30D1\u30B9\u3092\u751F\u6210\u3059\u308B\n\t * @param path \u30E1\u30A4\u30F3\u30D1\u30B9\n\t * @returns \u5BFE\u79F0\u30D1\u30B9\n\t */\n\tprivate getSymmetryPath(path: Point[]): Point[] {\n\t\tif (!this.puzzle || !this.puzzle.symmetry) return [];\n\t\treturn path.map((p) => this.getSymmetricalPoint(p));\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u70B9\u306E\u5BFE\u79F0\u70B9\u3092\u53D6\u5F97\u3059\u308B\n\t * @param p \u5143\u306E\u70B9\n\t * @param isFloat \u5C0F\u6570\u70B9\u5EA7\u6A19\u3092\u7DAD\u6301\u3059\u308B\u304B\n\t * @returns \u5BFE\u79F0\u70B9\n\t */\n\tprivate getSymmetricalPoint(p: Point, isFloat = false): Point {\n\t\tif (!this.puzzle || !this.puzzle.symmetry) return { ...p };\n\t\tconst { cols, rows, symmetry } = this.puzzle;\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\treturn { x: cols - p.x, y: p.y };\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\treturn { x: p.x, y: rows - p.y };\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\treturn { x: cols - p.x, y: rows - p.y };\n\t\t}\n\t\treturn { ...p };\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30D1\u30B9\u306E\u5148\u7AEF\u304C\u51FA\u53E3\u306E\u51FA\u3063\u5F35\u308A\u306B\u3042\u308B\u304B\u5224\u5B9A\u3059\u308B\n\t */\n\tprivate isPathAtExit(path: Point[], tipPos: Point | null): boolean {\n\t\tif (path.length === 0 || !tipPos) return false;\n\t\tconst lastPoint = path[path.length - 1];\n\t\tconst exitDir = this.getExitDir(lastPoint.x, lastPoint.y);\n\t\tif (!exitDir) return false;\n\n\t\tconst lastPos = this.getCanvasCoords(lastPoint.x, lastPoint.y);\n\t\tconst dx = tipPos.x - lastPos.x;\n\t\tconst dy = tipPos.y - lastPos.y;\n\t\tconst dot = dx * exitDir.x + dy * exitDir.y;\n\n\t\treturn dot >= this.options.exitLength * 0.9; // 90%\u4EE5\u4E0A\u5F15\u304D\u5207\u3063\u3066\u3044\u305F\u3089\n\t}\n\n\t/**\n\t * \u4E8C\u70B9\u9593\u306E\u30A8\u30C3\u30B8\u3092\u8B58\u5225\u3059\u308B\u30E6\u30CB\u30FC\u30AF\u306A\u30AD\u30FC\u3092\u53D6\u5F97\u3059\u308B\n\t */\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t}\n\n\t/**\n\t * \u5408\u6210\u7528\u306E\u30AA\u30D5\u30B9\u30AF\u30EA\u30FC\u30F3Canvas\u3092\u6E96\u5099\u3059\u308B\n\t */\n\t/**\n\t * Worker\u306B\u9001\u4FE1\u3067\u304D\u306A\u3044\u95A2\u6570\u306A\u3069\u306E\u30D7\u30ED\u30D1\u30C6\u30A3\u3092\u9664\u53BB\u3057\u305F\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u751F\u6210\u3059\u308B\n\t */\n\tprivate sanitizeOptions(options: WitnessUIOptions): any {\n\t\tconst sanitized: any = {};\n\t\tfor (const key in options) {\n\t\t\tconst value = (options as any)[key];\n\t\t\tif (value && typeof value === \"object\" && !Array.isArray(value)) {\n\t\t\t\tsanitized[key] = {};\n\t\t\t\tfor (const subKey in value) {\n\t\t\t\t\tif (typeof (value as any)[subKey] !== \"function\") {\n\t\t\t\t\t\t(sanitized[key] as any)[subKey] = (value as any)[subKey];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (typeof value !== \"function\") {\n\t\t\t\tsanitized[key] = value;\n\t\t\t}\n\t\t}\n\t\treturn sanitized;\n\t}\n\n\tprivate prepareOffscreen(): { canvas: HTMLCanvasElement | OffscreenCanvas; ctx: WitnessContext } {\n\t\tconst dpr = this.options.pixelRatio;\n\t\tif (!this.offscreenCanvas) {\n\t\t\tif (typeof document !== \"undefined\") {\n\t\t\t\tthis.offscreenCanvas = document.createElement(\"canvas\");\n\t\t\t} else if (typeof OffscreenCanvas !== \"undefined\") {\n\t\t\t\tthis.offscreenCanvas = new OffscreenCanvas(this.canvas.width, this.canvas.height);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Offscreen canvas not supported in this environment.\");\n\t\t\t}\n\t\t\tthis.offscreenCtx = (this.offscreenCanvas as any).getContext(\"2d\") as WitnessContext | null;\n\t\t}\n\t\tif (this.offscreenCanvas.width !== this.canvas.width || this.offscreenCanvas.height !== this.canvas.height) {\n\t\t\tthis.offscreenCanvas.width = this.canvas.width;\n\t\t\tthis.offscreenCanvas.height = this.canvas.height;\n\t\t}\n\t\tif (!this.offscreenCtx) throw new Error(\"Could not get offscreen 2D context.\");\n\t\tthis.offscreenCtx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t\tthis.offscreenCtx.clearRect(0, 0, this.offscreenCanvas.width / dpr, this.offscreenCanvas.height / dpr);\n\t\treturn { canvas: this.offscreenCanvas, ctx: this.offscreenCtx };\n\t}\n}\n", "import { CellType, RngType, type CellConstraint, type DeserializedData, type GenerationOptions, type Point, type PuzzleData, type SerializationOptions, type SolutionPath } from \"./types\";\n\n/* ================= Bit IO ================= */\n\nclass BitWriter {\n\tprivate bytes: number[] = [];\n\tprivate cur = 0;\n\tprivate bit = 0;\n\n\twrite(value: number, bits: number) {\n\t\tfor (let i = 0; i < bits; i++) {\n\t\t\tif (value & (1 << i)) this.cur |= 1 << this.bit;\n\t\t\tthis.bit++;\n\t\t\tif (this.bit === 8) {\n\t\t\t\tthis.bytes.push(this.cur);\n\t\t\t\tthis.cur = 0;\n\t\t\t\tthis.bit = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfinish(): Uint8Array {\n\t\tif (this.bit > 0) this.bytes.push(this.cur);\n\t\treturn new Uint8Array(this.bytes);\n\t}\n}\n\nclass BitReader {\n\tprivate i = 0;\n\tprivate bit = 0;\n\tconstructor(private buf: Uint8Array) {}\n\n\tread(bits: number): number {\n\t\tlet v = 0;\n\t\tfor (let i = 0; i < bits; i++) {\n\t\t\tif (this.buf[this.i] & (1 << this.bit)) v |= 1 << i;\n\t\t\tthis.bit++;\n\t\t\tif (this.bit === 8) {\n\t\t\t\tthis.bit = 0;\n\t\t\t\tthis.i++;\n\t\t\t}\n\t\t}\n\t\treturn v;\n\t}\n\n\tget hasMore(): boolean {\n\t\treturn this.i < this.buf.length;\n\t}\n}\n\n/* ================= ECC (Reed-Solomon lite) ================= */\n\nconst GF256_EXP = new Uint8Array(512);\nconst GF256_LOG = new Uint8Array(256);\n{\n\tlet x = 1;\n\tfor (let i = 0; i < 255; i++) {\n\t\tGF256_EXP[i] = x;\n\t\tGF256_EXP[i + 255] = x;\n\t\tGF256_LOG[x] = i;\n\t\tx <<= 1;\n\t\tif (x & 0x100) x ^= 0x11d; // x^8 + x^4 + x^3 + x^2 + 1\n\t}\n}\n\nfunction gf_mul(a: number, b: number): number {\n\tif (a === 0 || b === 0) return 0;\n\treturn GF256_EXP[GF256_LOG[a] + GF256_LOG[b]];\n}\n\nfunction rs_encode(data: Uint8Array, nsym: number): Uint8Array {\n\tlet gen = new Uint8Array([1]);\n\tfor (let i = 0; i < nsym; i++) {\n\t\tconst next = new Uint8Array(gen.length + 1);\n\t\tconst root = GF256_EXP[i];\n\t\tfor (let j = 0; j < gen.length; j++) {\n\t\t\tnext[j] ^= gf_mul(gen[j], root);\n\t\t\tnext[j + 1] ^= gen[j];\n\t\t}\n\t\tgen = next;\n\t}\n\tconst poly = gen.slice(0, nsym + 1).reverse();\n\n\tconst res = new Uint8Array(nsym);\n\tfor (let i = 0; i < data.length; i++) {\n\t\tconst m = data[i] ^ res[0];\n\t\tfor (let j = 0; j < nsym - 1; j++) res[j] = res[j + 1] ^ gf_mul(m, poly[j + 1]);\n\t\tres[nsym - 1] = gf_mul(m, poly[nsym]);\n\t}\n\treturn res;\n}\n\n// Simple syndrome check\nfunction rs_check(data: Uint8Array, parity: Uint8Array): boolean {\n\tconst msg = new Uint8Array(data.length + parity.length);\n\tmsg.set(data);\n\tmsg.set(parity, data.length);\n\tfor (let i = 0; i < parity.length; i++) {\n\t\tlet s = 0;\n\t\tconst x = GF256_EXP[i];\n\t\tfor (let j = 0; j < msg.length; j++) s = gf_mul(s, x) ^ msg[j];\n\t\tif (s !== 0) return false;\n\t}\n\treturn true;\n}\n\n/* ================= Utils ================= */\n\nfunction collectShapes(cells: CellConstraint[][]): number[][][] {\n\tconst map = new Map<string, number[][]>();\n\tfor (const row of cells) {\n\t\tfor (const c of row) {\n\t\t\tif (c.shape) {\n\t\t\t\tconst key = JSON.stringify(c.shape);\n\t\t\t\tif (!map.has(key)) map.set(key, c.shape);\n\t\t\t}\n\t\t}\n\t}\n\treturn [...map.values()];\n}\n\n/* ================= Serializer ================= */\n\n/**\n * \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\u3001\u8A2D\u5B9A\u3001\u30B7\u30FC\u30C9\u3001\u7D4C\u8DEF\u306A\u3069\u3092\u30B7\u30EA\u30A2\u30E9\u30A4\u30BA/\u30C7\u30B7\u30EA\u30A2\u30E9\u30A4\u30BA\u3059\u308B\u30AF\u30E9\u30B9\n */\nexport class PuzzleSerializer {\n\t/**\n\t * \u30C7\u30FC\u30BF\u3092\u5727\u7E2E\u3055\u308C\u305FBase64\u6587\u5B57\u5217\u306B\u5909\u63DB\u3059\u308B\n\t */\n\tstatic async serialize(data: SerializationOptions | PuzzleData, legacyOptions?: GenerationOptions): Promise<string> {\n\t\tlet input: SerializationOptions;\n\t\t// Detect legacy call: data is PuzzleData if it has rows/cols/cells and no puzzle/options keys (unless they are from PuzzleData properties, which they aren't)\n\t\tconst d = data as any;\n\t\tconst isLegacy = typeof d === \"object\" && d !== null && \"rows\" in d && \"cells\" in d && !(\"puzzle\" in d) && !(\"options\" in d) && !(\"path\" in d) && !(\"seed\" in d);\n\n\t\tif (isLegacy) {\n\t\t\tinput = { puzzle: data as PuzzleData, options: legacyOptions };\n\t\t} else {\n\t\t\tinput = data as SerializationOptions;\n\t\t}\n\n\t\tconst bw = new BitWriter();\n\n\t\t// Header: Flags (8 bits)\n\t\tlet flags = 0;\n\t\tif (input.puzzle) flags |= 1 << 0;\n\t\tif (input.seed) flags |= 1 << 1;\n\t\tif (input.options) flags |= 1 << 2;\n\t\tif (input.path) flags |= 1 << 3;\n\t\tconst recovery = input.parityMode === \"recovery\";\n\t\tif (recovery) flags |= 1 << 4;\n\n\t\tbw.write(flags, 8);\n\n\t\tif (input.puzzle) this.writePuzzle(bw, input.puzzle);\n\t\tif (input.seed) this.writeSeed(bw, input.seed);\n\t\tif (input.options) this.writeOptions(bw, input.options);\n\t\tif (input.path) this.writePath(bw, input.path);\n\n\t\tconst raw = bw.finish();\n\t\tconst gz = new Uint8Array(await new Response(new Blob([raw.buffer as ArrayBuffer]).stream().pipeThrough(new CompressionStream(\"gzip\"))).arrayBuffer());\n\n\t\tlet final: Uint8Array;\n\t\tif (recovery) {\n\t\t\t// Strong recovery: Reed-Solomon (nsym=10)\n\t\t\tconst parity = rs_encode(gz, 10);\n\t\t\tfinal = new Uint8Array(gz.length + 10 + 2);\n\t\t\tfinal.set(gz);\n\t\t\tfinal.set(parity, gz.length);\n\t\t\tfinal[final.length - 2] = gz.length & 0xff;\n\t\t\tfinal[final.length - 1] = (gz.length >> 8) & 0xff;\n\t\t} else {\n\t\t\t// Detection mode: simple XOR parity\n\t\t\tlet p = 0;\n\t\t\tfor (const b of gz) p ^= b;\n\t\t\tfinal = new Uint8Array(gz.length + 1);\n\t\t\tfinal.set(gz);\n\t\t\tfinal[gz.length] = p;\n\t\t}\n\n\t\treturn btoa(String.fromCharCode(...final))\n\t\t\t.replace(/\\+/g, \"-\")\n\t\t\t.replace(/\\//g, \"_\")\n\t\t\t.replace(/=+$/, \"\");\n\t}\n\n\t/**\n\t * \u30B7\u30EA\u30A2\u30E9\u30A4\u30BA\u3055\u308C\u305F\u6587\u5B57\u5217\u304B\u3089\u30C7\u30FC\u30BF\u3092\u5FA9\u5143\u3059\u308B\n\t */\n\tstatic async deserialize(str: string): Promise<DeserializedData> {\n\t\tconst tryDecode = async (s: string): Promise<Uint8Array | null> => {\n\t\t\ttry {\n\t\t\t\tlet b64 = s.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\t\t\t\twhile (b64.length % 4) b64 += \"=\";\n\t\t\t\tconst bin = atob(b64);\n\t\t\t\treturn Uint8Array.from(bin, (c) => c.charCodeAt(0));\n\t\t\t} catch {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\n\t\tconst attemptRecovery = async (data: Uint8Array): Promise<Uint8Array | null> => {\n\t\t\tif (data.length === 0) return null;\n\t\t\t// 1. Detection mode check\n\t\t\tlet p = 0;\n\t\t\tfor (let i = 0; i < data.length - 1; i++) p ^= data[i];\n\t\t\tif (p === data[data.length - 1]) return data.slice(0, -1);\n\n\t\t\t// 2. Strong recovery mode check\n\t\t\tif (data.length > 12) {\n\t\t\t\tconst gzLen = data[data.length - 2] | (data[data.length - 1] << 8);\n\t\t\t\tif (gzLen + 12 === data.length) {\n\t\t\t\t\tconst gz = data.slice(0, gzLen);\n\t\t\t\t\tconst parity = data.slice(gzLen, gzLen + 10);\n\t\t\t\t\tif (rs_check(gz, parity)) return gz;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\n\t\tlet buf = await tryDecode(str);\n\t\tlet gz: Uint8Array | null = buf ? await attemptRecovery(buf) : null;\n\n\t\t// 3. Handle deletion (heuristic)\n\t\tif (!gz && str.length < 1000) {\n\t\t\tconst chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\t\t\tfor (let i = 0; i <= str.length; i++) {\n\t\t\t\tfor (let j = 0; j < chars.length; j++) {\n\t\t\t\t\tconst s = str.slice(0, i) + chars[j] + str.slice(i);\n\t\t\t\t\tconst b = await tryDecode(s);\n\t\t\t\t\tif (b) {\n\t\t\t\t\t\tconst g = await attemptRecovery(b);\n\t\t\t\t\t\tif (g) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn await this.finalizeDeserialize(g);\n\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t/* continue */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!gz) throw new Error(\"Invalid parity data or unrecoverable corruption\");\n\t\treturn this.finalizeDeserialize(gz);\n\t}\n\n\tprivate static async finalizeDeserialize(gz: Uint8Array): Promise<DeserializedData> {\n\t\tconst raw = new Uint8Array(await new Response(new Blob([gz.buffer as ArrayBuffer]).stream().pipeThrough(new DecompressionStream(\"gzip\"))).arrayBuffer());\n\t\tconst br = new BitReader(raw);\n\n\t\tconst flags = br.read(8);\n\t\tconst result: DeserializedData = {};\n\n\t\tif (flags & (1 << 0)) result.puzzle = this.readPuzzle(br);\n\t\tif (flags & (1 << 1)) result.seed = this.readSeed(br);\n\t\tif (flags & (1 << 2)) result.options = this.readOptions(br);\n\t\tif (flags & (1 << 3)) result.path = this.readPath(br);\n\n\t\treturn result;\n\t}\n\n\tprivate static writePuzzle(bw: BitWriter, puzzle: PuzzleData) {\n\t\tbw.write(puzzle.rows, 6);\n\t\tbw.write(puzzle.cols, 6);\n\t\tbw.write(puzzle.symmetry ?? 0, 2);\n\n\t\tconst shapes = collectShapes(puzzle.cells);\n\t\tbw.write(shapes.length, 5);\n\t\tfor (const s of shapes) {\n\t\t\tbw.write(s.length, 4);\n\t\t\tbw.write(s[0].length, 4);\n\t\t\tfor (const r of s) for (const v of r) bw.write(v, 1);\n\t\t}\n\n\t\tconst shapeIndex = new Map<string, number>();\n\t\tshapes.forEach((s, i) => shapeIndex.set(JSON.stringify(s), i));\n\n\t\tfor (const row of puzzle.cells) {\n\t\t\tfor (const c of row) {\n\t\t\t\tbw.write(c.type, 4);\n\t\t\t\tbw.write(c.color, 3);\n\t\t\t\tif (c.type === CellType.Triangle) {\n\t\t\t\t\tbw.write(c.count || 0, 2);\n\t\t\t\t} else if (c.shape) {\n\t\t\t\t\tbw.write(1, 1);\n\t\t\t\t\tbw.write(shapeIndex.get(JSON.stringify(c.shape))!, 5);\n\t\t\t\t} else {\n\t\t\t\t\tbw.write(0, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let y = 0; y < puzzle.rows; y++) for (let x = 0; x < puzzle.cols + 1; x++) bw.write(puzzle.vEdges[y][x].type, 3);\n\t\tfor (let y = 0; y < puzzle.rows + 1; y++) for (let x = 0; x < puzzle.cols; x++) bw.write(puzzle.hEdges[y][x].type, 3);\n\t\tfor (let y = 0; y < puzzle.rows + 1; y++) for (let x = 0; x < puzzle.cols + 1; x++) bw.write(puzzle.nodes[y][x].type, 3);\n\t}\n\n\tprivate static readPuzzle(br: BitReader): PuzzleData {\n\t\tconst rows = br.read(6);\n\t\tconst cols = br.read(6);\n\t\tconst symmetry = br.read(2);\n\n\t\tconst shapeCount = br.read(5);\n\t\tconst shapes: number[][][] = [];\n\t\tfor (let i = 0; i < shapeCount; i++) {\n\t\t\tconst h = br.read(4);\n\t\t\tconst w = br.read(4);\n\t\t\tconst s: number[][] = [];\n\t\t\tfor (let y = 0; y < h; y++) {\n\t\t\t\tconst r: number[] = [];\n\t\t\t\tfor (let x = 0; x < w; x++) r.push(br.read(1));\n\t\t\t\ts.push(r);\n\t\t\t}\n\t\t\tshapes.push(s);\n\t\t}\n\n\t\tconst cells: CellConstraint[][] = [];\n\t\tfor (let y = 0; y < rows; y++) {\n\t\t\tconst row: CellConstraint[] = [];\n\t\t\tfor (let x = 0; x < cols; x++) {\n\t\t\t\tconst type = br.read(4) as CellType;\n\t\t\t\tconst color = br.read(3);\n\t\t\t\tconst cell: CellConstraint = { type, color };\n\t\t\t\tif (type === CellType.Triangle) {\n\t\t\t\t\tcell.count = br.read(2);\n\t\t\t\t} else {\n\t\t\t\t\tif (br.read(1)) cell.shape = shapes[br.read(5)].map((r) => r.slice());\n\t\t\t\t}\n\t\t\t\trow.push(cell);\n\t\t\t}\n\t\t\tcells.push(row);\n\t\t}\n\n\t\tconst vEdges = Array.from({ length: rows }, () => Array.from({ length: cols + 1 }, () => ({ type: br.read(3) })));\n\t\tconst hEdges = Array.from({ length: rows + 1 }, () => Array.from({ length: cols }, () => ({ type: br.read(3) })));\n\t\tconst nodes = Array.from({ length: rows + 1 }, () => Array.from({ length: cols + 1 }, () => ({ type: br.read(3) })));\n\n\t\treturn { rows, cols, cells, vEdges, hEdges, nodes, symmetry };\n\t}\n\n\tprivate static writeSeed(bw: BitWriter, seed: { type: RngType; value: string }) {\n\t\tbw.write(seed.type, 2);\n\t\tbw.write(seed.value.length, 8);\n\t\tfor (let i = 0; i < seed.value.length; i++) {\n\t\t\tbw.write(parseInt(seed.value[i], 16), 4);\n\t\t}\n\t}\n\n\tprivate static readSeed(br: BitReader): { type: RngType; value: string } {\n\t\tconst type = br.read(2) as RngType;\n\t\tconst len = br.read(8);\n\t\tlet value = \"\";\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tvalue += br.read(4).toString(16);\n\t\t}\n\t\treturn { type, value };\n\t}\n\n\tprivate static writeOptions(bw: BitWriter, options: GenerationOptions) {\n\t\tbw.write(options.rows ?? 0, 6);\n\t\tbw.write(options.cols ?? 0, 6);\n\t\tbw.write(+!!options.useHexagons, 1);\n\t\tbw.write(+!!options.useSquares, 1);\n\t\tbw.write(+!!options.useStars, 1);\n\t\tbw.write(+!!options.useTetris, 1);\n\t\tbw.write(+!!options.useTetrisNegative, 1);\n\t\tbw.write(+!!options.useEraser, 1);\n\t\tbw.write(+!!options.useTriangles, 1);\n\t\tbw.write(+!!options.useBrokenEdges, 1);\n\t\tbw.write(options.symmetry ?? 0, 2);\n\t\tbw.write(Math.round((options.complexity ?? 0) * 254), 8);\n\t\tbw.write(Math.round((options.difficulty ?? 0) * 254), 8);\n\t\tbw.write(Math.round((options.pathLength ?? 0) * 254), 8);\n\n\t\tif (options.availableColors && options.availableColors.length > 0) {\n\t\t\tbw.write(1, 1);\n\t\t\tbw.write(options.availableColors.length, 4);\n\t\t\tfor (const c of options.availableColors) bw.write(c, 3);\n\t\t} else {\n\t\t\tbw.write(0, 1);\n\t\t}\n\n\t\tif (options.defaultColors) {\n\t\t\tconst entries = Object.entries(options.defaultColors);\n\t\t\tbw.write(entries.length, 4);\n\t\t\tfor (const [key, val] of entries) {\n\t\t\t\tconst type = isNaN(Number(key)) ? (CellType as any)[key] : Number(key);\n\t\t\t\tbw.write(type, 4);\n\t\t\t\tbw.write(val as number, 3);\n\t\t\t}\n\t\t} else {\n\t\t\tbw.write(0, 4);\n\t\t}\n\t}\n\n\tprivate static readOptions(br: BitReader): GenerationOptions {\n\t\tconst options: GenerationOptions = {};\n\t\tconst rows = br.read(6);\n\t\tconst cols = br.read(6);\n\t\tif (rows > 0) options.rows = rows;\n\t\tif (cols > 0) options.cols = cols;\n\n\t\tif (br.read(1)) options.useHexagons = true;\n\t\tif (br.read(1)) options.useSquares = true;\n\t\tif (br.read(1)) options.useStars = true;\n\t\tif (br.read(1)) options.useTetris = true;\n\t\tif (br.read(1)) options.useTetrisNegative = true;\n\t\tif (br.read(1)) options.useEraser = true;\n\t\tif (br.read(1)) options.useTriangles = true;\n\t\tif (br.read(1)) options.useBrokenEdges = true;\n\t\toptions.symmetry = br.read(2);\n\n\t\tconst readRatio = () => Math.round((br.read(8) / 254) * 1000) / 1000;\n\t\toptions.complexity = readRatio();\n\t\toptions.difficulty = readRatio();\n\t\toptions.pathLength = readRatio();\n\n\t\tif (br.read(1)) {\n\t\t\tconst len = br.read(4);\n\t\t\toptions.availableColors = [];\n\t\t\tfor (let i = 0; i < len; i++) options.availableColors.push(br.read(3));\n\t\t}\n\n\t\tconst defLen = br.read(4);\n\t\tif (defLen > 0) {\n\t\t\toptions.defaultColors = {};\n\t\t\tfor (let i = 0; i < defLen; i++) {\n\t\t\t\tconst type = br.read(4);\n\t\t\t\tconst color = br.read(3);\n\t\t\t\t(options.defaultColors as any)[type] = color;\n\t\t\t}\n\t\t}\n\n\t\treturn options;\n\t}\n\n\tprivate static writePath(bw: BitWriter, path: SolutionPath) {\n\t\tbw.write(path.points.length, 12);\n\t\tif (path.points.length === 0) return;\n\t\tbw.write(path.points[0].x, 6);\n\t\tbw.write(path.points[0].y, 6);\n\t\tfor (let i = 1; i < path.points.length; i++) {\n\t\t\tconst p1 = path.points[i - 1];\n\t\t\tconst p2 = path.points[i];\n\t\t\tconst dx = p2.x - p1.x;\n\t\t\tconst dy = p2.y - p1.y;\n\t\t\tlet dir = 0;\n\t\t\tif (dy === -1) dir = 0;\n\t\t\telse if (dx === 1) dir = 1;\n\t\t\telse if (dy === 1) dir = 2;\n\t\t\telse if (dx === -1) dir = 3;\n\t\t\tbw.write(dir, 2);\n\t\t}\n\t}\n\n\tprivate static readPath(br: BitReader): SolutionPath {\n\t\tconst len = br.read(12);\n\t\tif (len === 0) return { points: [] };\n\t\tconst points: Point[] = [];\n\t\tlet x = br.read(6);\n\t\tlet y = br.read(6);\n\t\tpoints.push({ x, y });\n\t\tfor (let i = 1; i < len; i++) {\n\t\t\tconst dir = br.read(2);\n\t\t\tif (dir === 0) y--;\n\t\t\telse if (dir === 1) x++;\n\t\t\telse if (dir === 2) y++;\n\t\t\telse if (dir === 3) x--;\n\t\t\tpoints.push({ x, y });\n\t\t}\n\t\treturn { points };\n\t}\n}\n", "import { PuzzleGenerator } from \"./generator\";\nimport { Grid } from \"./grid\";\nimport { type GenerationOptions, type Point, type PuzzleData, type SolutionPath, type ValidationResult } from \"./types\";\nimport { WitnessUI } from \"./ui\";\nimport { PuzzleValidator } from \"./validator\";\n\n// \u30E9\u30A4\u30D6\u30E9\u30EA\u306E\u30D5\u30A1\u30B5\u30FC\u30C9\u30AF\u30E9\u30B9\nexport { PuzzleGenerator } from \"./generator\";\nexport { Grid } from \"./grid\";\nexport { PuzzleSerializer } from \"./serializer\";\nexport { WitnessUI } from \"./ui\";\nexport { PuzzleValidator } from \"./validator\";\n\n/**\n * the witness\u30D1\u30BA\u30EB\u306E\u30B3\u30A2\u6A5F\u80FD\uFF08\u751F\u6210\u30FB\u691C\u8A3C\u30FB\u96E3\u6613\u5EA6\u8A08\u7B97\uFF09\u3092\u63D0\u4F9B\u3059\u308B\u30E1\u30A4\u30F3\u30AF\u30E9\u30B9\n */\nexport class WitnessCore {\n\tprivate generator: PuzzleGenerator;\n\tprivate validator: PuzzleValidator;\n\n\t/**\n\t * \u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u3092\u751F\u6210\u3059\u308B\n\t */\n\tconstructor() {\n\t\tthis.generator = new PuzzleGenerator();\n\t\tthis.validator = new PuzzleValidator();\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30B5\u30A4\u30BA\u3068\u30AA\u30D7\u30B7\u30E7\u30F3\u3067\u65B0\u3057\u3044\u30D1\u30BA\u30EB\u3092\u751F\u6210\u3059\u308B\n\t * @param rows \u884C\u6570\n\t * @param cols \u5217\u6570\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\n\t * @returns \u751F\u6210\u3055\u308C\u305F\u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\n\t */\n\tpublic createPuzzle(rows: number, cols: number, options: GenerationOptions = {}): PuzzleData {\n\t\tconst grid = this.generator.generate(rows, cols, options);\n\t\treturn grid.export();\n\t}\n\n\t/**\n\t * \u4E0E\u3048\u3089\u308C\u305F\u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\u306B\u5BFE\u3057\u3066\u89E3\u7B54\u30D1\u30B9\u3092\u691C\u8A3C\u3059\u308B\n\t * @param puzzleData \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\n\t * @param solution \u89E3\u7B54\u30D1\u30B9\n\t * @returns \u691C\u8A3C\u7D50\u679C\n\t */\n\tpublic validateSolution(puzzleData: PuzzleData, solution: SolutionPath): ValidationResult {\n\t\tconst grid = Grid.fromData(puzzleData);\n\t\treturn this.validator.validate(grid, solution);\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\u306E\u96E3\u6613\u5EA6\u3092\u7B97\u51FA\u3059\u308B\n\t * @param puzzleData \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\n\t * @returns \u96E3\u6613\u5EA6\u30B9\u30B3\u30A2 (0.0 - 1.0)\n\t */\n\tpublic calculateDifficulty(puzzleData: PuzzleData): number {\n\t\tconst grid = Grid.fromData(puzzleData);\n\t\treturn this.validator.calculateDifficulty(grid);\n\t}\n}\n\n// \u30D6\u30E9\u30A6\u30B6/Node.js\u74B0\u5883\u4E21\u5BFE\u5FDC\u306E\u305F\u3081\u306E\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\nexport * from \"./types\";\n\n/**\n * Worker\u74B0\u5883\u3067\u306E\u81EA\u52D5\u30BB\u30C3\u30C8\u30A2\u30C3\u30D7\n * MiniWitness\u81EA\u4F53\u3092Worker\u3068\u3057\u3066\u6307\u5B9A\u3057\u305F\u5834\u5408\uFF08new Worker(\"MiniWitness.js\")\uFF09\u306B\n * \u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u30CF\u30F3\u30C9\u30EB\u3057\u3066\u30D1\u30BA\u30EB\u751F\u6210\u3084UI\u7BA1\u7406\u3092\u81EA\u52D5\u3067\u884C\u3046\u6A5F\u80FD\n */\nif (typeof self !== \"undefined\" && \"postMessage\" in self && !(\"document\" in self)) {\n\tconst core = new WitnessCore();\n\tlet ui: WitnessUI | null = null;\n\tlet currentPuzzle: PuzzleData | null = null;\n\n\t(self as any).addEventListener(\"message\", (e: MessageEvent) => {\n\t\tconst { type, payload } = e.data;\n\n\t\tswitch (type) {\n\t\t\tcase \"init\": {\n\t\t\t\tconst { canvas, options } = payload;\n\t\t\t\tui = new WitnessUI(canvas, undefined, options);\n\t\t\t\tui.on(\"path:complete\", ({ path }: { path: Point[] }) => {\n\t\t\t\t\t(self as any).postMessage({ type: \"drawingEnded\" });\n\t\t\t\t\t// Always send pathComplete to allow the main thread to track the current path\n\t\t\t\t\t(self as any).postMessage({ type: \"pathComplete\", payload: path });\n\n\t\t\t\t\tif (options.autoValidate && currentPuzzle) {\n\t\t\t\t\t\tconst result = core.validateSolution(currentPuzzle, { points: path });\n\t\t\t\t\t\tui!.setValidationResult(result.isValid, result.invalidatedCells, result.invalidatedEdges, result.errorCells, result.errorEdges, result.invalidatedNodes, result.errorNodes);\n\t\t\t\t\t\t(self as any).postMessage({ type: \"validationResult\", payload: result });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"createPuzzle\": {\n\t\t\t\tconst { rows, cols, genOptions } = payload;\n\t\t\t\tconst puzzle = core.createPuzzle(rows, cols, genOptions);\n\t\t\t\tself.postMessage({ type: \"puzzleCreated\", payload: { puzzle, genOptions } });\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"setPuzzle\": {\n\t\t\t\tcurrentPuzzle = payload.puzzle;\n\t\t\t\tif (ui && currentPuzzle) {\n\t\t\t\t\tui.setPuzzle(currentPuzzle);\n\t\t\t\t\tif (payload.options) {\n\t\t\t\t\t\tui.setOptions(payload.options);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"setOptions\": {\n\t\t\t\tif (ui) ui.setOptions(payload);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"setPath\": {\n\t\t\t\tif (ui) ui.setPath(payload.path);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"setValidationResult\": {\n\t\t\t\tif (ui) {\n\t\t\t\t\tui.setValidationResult(payload.isValid, payload.invalidatedCells, payload.invalidatedEdges, payload.errorCells, payload.errorEdges, payload.invalidatedNodes, payload.errorNodes);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"setCanvasRect\": {\n\t\t\t\tif (ui) ui.setCanvasRect(payload);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"validate\": {\n\t\t\t\tif (currentPuzzle) {\n\t\t\t\t\tconst result = core.validateSolution(currentPuzzle, { points: payload.path });\n\t\t\t\t\tif (ui) {\n\t\t\t\t\t\tui.setValidationResult(result.isValid, result.invalidatedCells, result.invalidatedEdges, result.errorCells, result.errorEdges, result.invalidatedNodes, result.errorNodes);\n\t\t\t\t\t}\n\t\t\t\t\tself.postMessage({ type: \"validationResult\", payload: result });\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"event\": {\n\t\t\t\tconst { eventType, eventData } = payload;\n\t\t\t\tif (ui) {\n\t\t\t\t\tif (eventType === \"mousedown\" || eventType === \"touchstart\") {\n\t\t\t\t\t\tconst started = ui.handleStart(eventData);\n\t\t\t\t\t\t(self as any).postMessage({ type: \"drawingStarted\", payload: started });\n\t\t\t\t\t} else if (eventType === \"mousemove\" || eventType === \"touchmove\") {\n\t\t\t\t\t\tui.handleMove(eventData);\n\t\t\t\t\t} else if (eventType === \"mouseup\" || eventType === \"touchend\") {\n\t\t\t\t\t\tui.handleEnd(eventData);\n\t\t\t\t\t\t(self as any).postMessage({ type: \"drawingEnded\" });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n}\n"],
  "mappings": "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",
  "names": ["Direction", "CellType", "EdgeType", "NodeType", "SymmetryType", "Color", "RngType", "Grid", "_Grid", "rows", "cols", "Color", "data", "grid", "Mulberry32", "seed", "t", "XorShift128Plus", "seedLo", "seedHi", "x", "y", "MathRandomRng", "createRng", "type", "PuzzleValidator", "rng", "grid", "solution", "externalCellsPrecalculated", "path", "symmetry", "symPath", "p", "start", "end", "symStart", "symEnd", "visitedNodes", "visitedEdges", "i", "p1", "p2", "key", "sp1", "sp2", "symKey", "edgeKey", "regions", "missed", "pathEdges", "result", "externalCells", "type", "y", "x", "mainPathEdges", "mainPathNodes", "symPathEdges", "symPathNodes", "missedEdges", "r", "c", "passed", "missedNodes", "posKey", "missedHexagons", "missedNodeHexagons", "regionResults", "allRegionsPossiblyValid", "region", "erasers", "otherMarks", "adjacentMissedHexagons", "j", "adjacentMissedNodeHexagons", "possible", "bestEffort", "a", "b", "costA", "costB", "hexPriorityA", "hexPriorityB", "assignment", "idx", "errorCells", "invalidatedCells", "invalidatedHexIndices", "invalidatedNodeHexIndices", "options", "best", "errorEdges", "errorNodes", "hex", "regionCells", "node", "adjCells", "cell", "results", "numErasers", "itemsToNegate", "initiallyValid", "N", "negatedEraserCombinations", "negatedErasers", "negatedErasersSet", "e", "activeErasers", "K", "itemCombinations", "negatedItems", "negatedCells", "it", "negatedHexIndices", "negatedNodeHexIndices", "isUseful", "subset", "subsetCells", "subsetHexIndices", "subsetNodeHexIndices", "allHexSatisfied", "allNodeHexSatisfied", "naturalErrors", "bestResult", "minErrorCount", "tryNegate", "priorityItems", "toInvalidateCells", "toInvalidateHexagons", "toInvalidateNodeHexagons", "usedErasersCount", "item", "remainingForPairs", "unresolvedHexagons", "unresolvedNodeHexagons", "totalErrorCount", "errCell", "items", "n", "backtrack", "current", "erasedCells", "erasedSet", "colorCounts", "colorCells", "starColors", "squareColors", "tetrisPieces", "tetrisNegativePieces", "triangleCells", "constraint", "color", "Color", "cells", "tri", "passedEdges", "cellEdges", "edge", "totalMissedHexagons", "totalMissedNodeHexagons", "numRegions", "currentHexErasures", "currentNodeHexErasures", "allInvalidatedCells", "allInvalidatedHexIndices", "allInvalidatedNodeHexIndices", "regionIdx", "count", "option", "hexIdx", "gridObj", "pieces", "negativePieces", "positiveArea", "sum", "negativeArea", "netArea", "rows", "cols", "regionMask", "pieceKey", "sign", "piecesKey", "cacheKey", "target", "pieceGroups", "allPieces", "rotations", "baseShapeKey", "group", "g", "posMismatch", "negMismatch", "totalPositiveAreaLeft", "totalNegativeAreaLeft", "groupIdx", "countInGroup", "lastPos", "nextCount", "isLastInGroup", "rot", "h", "w", "startPos", "pos", "placedIndices", "pr", "pc", "tidx", "res", "shape", "area", "row", "keys", "curr", "newShape", "visitedCells", "hEdgesMask", "vEdgesMask", "setEdge", "queue", "head", "currIdx", "cx", "cy", "nIdx", "external", "neighbors", "nodeCols", "sr", "sc", "starts", "nodeCount", "adj", "startNodes", "endNodes", "isEndNode", "hexIdMap", "nextHexId", "hexagonEdges", "hexagonNodes", "u", "v", "isHexagon", "isBroken", "stats", "totalHexagons", "fingerprints", "searchLimit", "hasCellMarks", "targetStartIndices", "startIdx", "startHexMask", "nodeType", "snStart", "snR", "snC", "snNodeType", "visitedMask", "constraintCount", "constraintTypes", "tetrisCount", "rotatedTetrisCount", "triangleCount", "branchingFactor", "searchComplexity", "difficulty", "negTetrisCount", "rotatedNegTetrisCount", "cellCount", "density", "densityFactor", "typeFactor", "sizeFactor", "hexMask", "limit", "setBits", "temp", "points", "solutionPath", "snEnd", "symPathPoints", "fp", "validMoves", "snCurr", "snNext", "otherEdge", "isAlreadyOnPath", "isNextMove", "snPrev", "isAlreadyOnSymPath", "isSymNextMove", "rnd", "move", "nextHexMask", "prevIdx", "ec", "er", "spr", "spc", "et", "nextVisitedMask", "cached", "localVisited", "precalculatedRegions", "regionFingerprints", "regionStr", "marks", "m", "finalFp", "rf", "PuzzleGenerator", "shape", "seedStr", "seed", "i", "rows", "cols", "options", "rngType", "currentSeedStr", "initialSeedStr", "currentSeed", "targetDifficulty", "validator", "PuzzleValidator", "bestGrid", "bestScore", "isSmall", "maxAttempts", "markAttemptsPerPath", "symmetry", "starts", "symStarts", "s", "ss", "p", "ends", "symEnds", "e", "se", "currentPath", "precalculatedRegions", "precalculatedBoundaryEdges", "attempt", "nextSeed", "createRng", "Grid", "tempGrid", "symPath", "region", "grid", "chosenStart", "validStarts", "otherStarts", "v", "difficulty", "diffFromTarget", "path", "solutionPath", "targetLengthFactor", "minLen", "maxLen", "targetLen", "bestPath", "bestDiff", "attempts", "currentLen", "diff", "biasFactor", "pointCount", "visited", "nodesVisited", "limit", "start", "endLookup", "end", "findPath", "current", "currentIndex", "snCurrent", "snCurrentIndex", "neighbors", "n", "sn", "edgeKey", "symEdgeKey", "a", "b", "getMinDist", "da", "db", "next", "x", "y", "candidates", "directions", "d", "nx", "ny", "complexity", "pathEdges", "p1", "p2", "unusedEdges", "r", "c", "targetCount", "placed", "edge", "changed", "edgesWithMeta", "m", "nodes", "node", "adjEdges", "adj", "startNodes", "reachableNodes", "queue", "curr", "external", "cellKey", "useHexagons", "useSquares", "useStars", "useTetris", "useTetrisNegative", "useEraser", "useTriangles", "hexagonsPlaced", "squaresPlaced", "starsPlaced", "tetrisPlaced", "erasersPlaced", "totalTetrisArea", "maxTotalTetrisArea", "isBranching", "prob", "type", "targetNode", "idx", "regions", "availableColors", "Color", "defaultColors", "getDefColor", "fallback", "name", "CellType", "regionIndices", "_", "squareColorsUsed", "needs", "tetrisNegativePlaced", "trianglesPlaced", "rIdx", "remainingRegions", "forceOne", "placementProb", "potentialCells", "intendedColors", "squareColor", "unusedColors", "shouldPlaceSquare", "maxSquares", "numSquares", "cell", "shouldPlaceTetris", "maxTetrisPerRegion", "isAreaOk", "tiledPieces", "negativePiecesToPlace", "negProb", "complexFound", "is2pos1neg", "baseArea", "baseShapes", "base", "triple", "area", "pShape", "nShape", "numSubtractions", "targetIdx", "original", "complexSubtraction", "triple1", "triple2", "tp", "allPieces", "defColor", "tetrisColor", "shouldPlaceTriangle", "numToTry", "placedInRegion", "cellEdges", "count", "triangleColor", "shouldPlaceEraser", "errorTypes", "boundaryEdges", "errorPlaced", "errorType", "validEdges", "errCell", "existingSquare", "existingSquareColor", "piecesToPlace", "currentArea", "posCell", "actualCount", "errorCount", "eraserColor", "color", "maxPairs", "onlyColor", "availableCells", "otherColor", "visitedCells", "hEdgesMask", "vEdgesMask", "setEdge", "head", "currIdx", "cx", "cy", "nIdx", "boundary", "edges", "key", "unique", "isHex", "t", "found", "isHexEdge", "isHexNode", "fSq", "fSt", "fT", "fTN", "fE", "fTri", "sqC", "stC", "maxPieces", "minX", "minY", "maxX", "maxY", "width", "height", "regionGrid", "currentPieces", "r0", "c0", "indices", "baseShape", "rotations", "rotIndices", "rotIdx", "blocks", "pr", "pc", "anchor", "dr", "dc", "isRotated", "result", "row", "results", "keys", "newShape", "j", "nr", "nc", "value", "s1", "s2", "s2Str", "areaP", "areaT", "areaN", "rotationsT", "rotationsN", "hP", "wP", "rt", "rn", "hT", "wT", "hN", "wN", "rT", "cT", "rN", "cN", "possible", "matches", "nCandidates", "pCandidates", "array", "WitnessUI", "canvasOrId", "puzzle", "options", "el", "script", "offscreen", "sanitizedOptions", "e", "type", "payload", "context", "animations", "colors", "Color", "path", "lastPoint", "lastPos", "exitDir", "listener", "set", "data", "l", "nonSerializableEvents", "redundantEvents", "isValid", "invalidatedCells", "invalidatedEdges", "errorCells", "errorEdges", "invalidatedNodes", "errorNodes", "w", "h", "dpr", "rect", "plainRect", "rows", "cols", "genOptions", "gridX", "gridY", "x", "y", "isLeft", "isRight", "isTop", "isBottom", "shouldStartDrawing", "mouseX", "mouseY", "r", "c", "nodePos", "dx", "dy", "symmetry", "intendedDir", "dot", "length", "tryMoveTo", "target", "d", "edgeType", "maxMove", "targetEdgeKey", "i", "p", "secondToLast", "symLast", "symTarget", "symEdgeType", "symPath", "symEdgeKey", "isNodeOccupiedBySym", "isSymNodeOccupiedByMain", "isMeetingAtNode", "isEdgeOccupiedBySym", "isMirrorEdgeOccupiedByMain", "dir", "neighbors", "n", "nPos", "idx", "sn", "edgeKey", "popped", "isExit", "dx_exit", "dy_exit", "p1", "p2", "color", "now", "step", "ctx", "symFadingPath", "symColor", "originalSymAlpha", "symTipPos", "gridRelX", "gridRelY", "symGridRel", "originalPathColor", "originalPathAlpha", "errorColor", "pathOpacity", "elapsed", "blinkDuration", "tip", "isAtExit", "originalAlpha", "pulseFactor", "originalSymColor", "symPathOpacity", "time", "pos", "exitPos", "t", "radius", "opacity", "drawEdge", "q1", "q2", "blinkFactor", "invalidatedCellSet", "errorCellSet", "invalidatedEdgeSet", "errorEdgeSet", "invalidatedNodeSet", "errorNodeSet", "cell", "cellKey", "isInvalidated", "isError", "overrideColor", "originalColor", "transitionIn", "transitionOut", "transitionFactor", "hexRadius", "getHexColor", "baseColor", "nodeKey", "isNodeIsolated", "connectedEdges", "node", "isDrawing", "tipPos", "rgba", "finalColor", "finalOpacity", "tempCanvas", "tempCtx", "startPos", "actualTipPos", "width", "height", "angle", "px", "py", "points", "colorEnum", "rotation", "innerRadius", "outerRadius", "count", "spacing", "drawSingleTriangle", "tx", "ty", "offset", "shape", "rotated", "isNegative", "cellSize", "gap", "totalW", "totalH", "defaultFallback", "match", "c1", "c2", "rgba1", "rgba2", "g", "b", "a", "alpha", "isFloat", "sanitized", "key", "value", "subKey", "BitWriter", "value", "bits", "i", "BitReader", "buf", "v", "GF256_EXP", "GF256_LOG", "x", "gf_mul", "a", "b", "rs_encode", "data", "nsym", "gen", "next", "root", "j", "poly", "res", "m", "rs_check", "parity", "msg", "s", "collectShapes", "cells", "map", "row", "c", "key", "PuzzleSerializer", "legacyOptions", "input", "d", "bw", "flags", "recovery", "raw", "gz", "final", "p", "str", "tryDecode", "b64", "bin", "attemptRecovery", "gzLen", "chars", "g", "br", "result", "puzzle", "shapes", "r", "shapeIndex", "y", "rows", "cols", "symmetry", "shapeCount", "h", "w", "type", "color", "cell", "vEdges", "hEdges", "nodes", "seed", "len", "options", "entries", "val", "CellType", "readRatio", "defLen", "path", "p1", "p2", "dx", "dy", "dir", "points", "WitnessCore", "PuzzleGenerator", "PuzzleValidator", "rows", "cols", "options", "puzzleData", "solution", "grid", "Grid", "core", "ui", "currentPuzzle", "e", "type", "payload", "canvas", "WitnessUI", "path", "result", "genOptions", "puzzle", "eventType", "eventData", "started"]
}
