{
  "version": 3,
  "sources": ["../src/types.ts", "../src/grid.ts", "../src/validator.ts", "../src/generator.ts", "../src/serializer.ts", "../src/ui.ts", "../src/index.ts"],
  "sourcesContent": ["export enum Direction {\n\tUp = 0,\n\tRight = 1,\n\tDown = 2,\n\tLeft = 3,\n}\n\nexport enum CellType {\n\tNone = 0,\n\tSquare = 1, // \u8272\u5206\u3051\u304C\u5FC5\u8981\u306A\u30D6\u30ED\u30C3\u30AF\n\tStar = 2, // \u540C\u3058\u8272\u306E\u30DA\u30A2\u4F5C\u6210 (\u661F)\n\tTetris = 3, // \u30C6\u30C8\u30EA\u30B9\n\tTetrisRotated = 4, // \u30C6\u30C8\u30EA\u30B9\uFF08\u56DE\u8EE2\u53EF\u80FD\uFF09\n\tEraser = 5, // \u30C6\u30C8\u30E9\u30DD\u30C3\u30C9 (\u30A8\u30E9\u30FC\u524A\u9664)\n}\n\nexport enum EdgeType {\n\tNormal = 0,\n\tBroken = 1, // \u7DDA\u306E\u771F\u3093\u4E2D\u3067\u65AD\u7DDA (\u901A\u884C\u4E0D\u53EF)\n\tAbsent = 2, // \u305D\u3082\u305D\u3082\u5206\u5C90\u3082\u306A\u3057 (\u901A\u884C\u4E0D\u53EF)\n\tHexagon = 3, // \u901A\u904E\u5FC5\u9808\n}\n\nexport enum NodeType {\n\tNormal = 0,\n\tStart = 1,\n\tEnd = 2,\n\tHexagon = 3, // \u901A\u904E\u5FC5\u9808\n}\n\nexport enum SymmetryType {\n\tNone = 0,\n\tHorizontal = 1, // \u5DE6\u53F3\u5BFE\u79F0\n\tVertical = 2, // \u4E0A\u4E0B\u5BFE\u79F0\n\tRotational = 3, // \u70B9\u5BFE\u79F0\n}\n\n/**\n * \u4F7F\u7528\u53EF\u80FD\u8272\n * Core\u5185\u90E8\u3067\u306F\u6570\u5024\u3067\u7BA1\u7406\u3057\u3001UI\u3067\u5B9F\u969B\u306E\u8272\uFF08\u6587\u5B57\u5217\uFF09\u3068\u7D10\u4ED8\u3051\u308B\n */\nexport type Color = number;\nexport const Color = {\n\tNone: 0 as Color,\n\tBlack: 1 as Color,\n\tWhite: 2 as Color,\n\tRed: 3 as Color,\n\tBlue: 4 as Color,\n} as const;\n\nexport interface Point {\n\tx: number;\n\ty: number;\n}\n\nexport interface CellConstraint {\n\ttype: CellType;\n\tcolor: Color;\n\tshape?: number[][]; // [row][col] 0 or 1\n}\n\nexport interface EdgeConstraint {\n\ttype: EdgeType;\n}\n\nexport interface NodeConstraint {\n\ttype: NodeType;\n}\n\n/**\n * \u30D1\u30BA\u30EB\u306E\u9759\u7684\u306A\u5B9A\u7FA9\u30C7\u30FC\u30BF\n */\nexport interface PuzzleData {\n\trows: number;\n\tcols: number;\n\tcells: CellConstraint[][]; // [row][col]\n\tvEdges: EdgeConstraint[][]; // Vertical edges [row][col] (row: 0..rows-1, col: 0..cols)\n\thEdges: EdgeConstraint[][]; // Horizontal edges [row][col] (row: 0..rows, col: 0..cols-1)\n\tnodes: NodeConstraint[][]; // [row][col]\n\tsymmetry?: SymmetryType;\n}\n\n/**\n * \u30E6\u30FC\u30B6\u30FC\u306E\u5165\u529B\uFF08\u56DE\u7B54\u30D1\u30B9\uFF09\n */\nexport interface SolutionPath {\n\tpoints: Point[]; // \u901A\u904E\u3057\u305F\u30CE\u30FC\u30C9\u306E\u5EA7\u6A19\u914D\u5217\n}\n\nexport interface ValidationResult {\n\tisValid: boolean;\n\terrorReason?: string;\n\tinvalidatedCells?: Point[];\n\tinvalidatedEdges?: { type: \"h\" | \"v\"; r: number; c: number }[];\n\tinvalidatedNodes?: Point[];\n\terrorCells?: Point[];\n\terrorEdges?: { type: \"h\" | \"v\"; r: number; c: number }[];\n\terrorNodes?: Point[];\n\tregions?: Point[][];\n}\n\n/**\n * \u30D1\u30BA\u30EB\u751F\u6210\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\n */\nexport interface GenerationOptions {\n\tuseHexagons?: boolean;\n\tuseSquares?: boolean;\n\tuseStars?: boolean;\n\tuseTetris?: boolean;\n\tuseEraser?: boolean;\n\tuseBrokenEdges?: boolean;\n\tcomplexity?: number; // 0.0 - 1.0 (\u5236\u7D04\u306E\u5BC6\u5EA6)\n\tdifficulty?: number; // 0.0 (Easy) - 1.0 (Hard) (\u89E3\u30D1\u30BF\u30FC\u30F3\u306E\u6570\u306B\u57FA\u3065\u304F)\n\tpathLength?: number; // 0.0 (Shortest) - 1.0 (Longest)\n\tsymmetry?: SymmetryType;\n\t/** \u56DB\u89D2\u5F62\u3084\u661F\u306A\u3069\u306E\u8A18\u53F7\u306B\u4F7F\u7528\u53EF\u80FD\u306A\u8272\u306E\u30EA\u30B9\u30C8\u3002\u6307\u5B9A\u304C\u306A\u3044\u5834\u5408\u306F\u30C7\u30D5\u30A9\u30EB\u30C8\uFF08\u9ED2\u30FB\u767D\u30FB\u8D64\u30FB\u9752\uFF09\u304C\u4F7F\u7528\u3055\u308C\u308B\u3002 */\n\tavailableColors?: Color[];\n\t/** \u5404\u8A18\u53F7\u30BF\u30A4\u30D7\u306E\u30C7\u30D5\u30A9\u30EB\u30C8\u30AB\u30E9\u30FC\u3002\u6307\u5B9A\u304C\u306A\u3044\u5834\u5408\u306F\u305D\u308C\u305E\u308C\u306E\u8A18\u53F7\u306E\u6A19\u6E96\u8272\u304C\u4F7F\u7528\u3055\u308C\u308B\u3002\n\t * \u30AD\u30FC\u306B\u306F CellType \u306E\u6570\u5024\u3001\u307E\u305F\u306F \"Square\", \"Tetris\" \u306A\u3069\u306E\u6587\u5B57\u5217\u304C\u4F7F\u7528\u53EF\u80FD\u3067\u3059\u3002\n\t */\n\tdefaultColors?: Partial<Record<CellType | keyof typeof CellType, Color>>;\n}\n", "import { type CellConstraint, CellType, Color, type EdgeConstraint, EdgeType, type NodeConstraint, NodeType, type PuzzleData } from \"./types\";\n\nexport class Grid {\n\tpublic readonly rows: number;\n\tpublic readonly cols: number;\n\n\t// \u30C7\u30FC\u30BF\u30DE\u30C8\u30EA\u30AF\u30B9\n\tpublic cells: CellConstraint[][] = [];\n\tpublic hEdges: EdgeConstraint[][] = []; // \u6A2A\u68D2\n\tpublic vEdges: EdgeConstraint[][] = []; // \u7E26\u68D2\n\tpublic nodes: NodeConstraint[][] = [];\n\tpublic symmetry: number = 0; // SymmetryType\n\n\tconstructor(rows: number, cols: number) {\n\t\tthis.rows = rows;\n\t\tthis.cols = cols;\n\t\tthis.initializeGrid();\n\t}\n\n\tprivate initializeGrid() {\n\t\t// Cells: rows * cols\n\t\tthis.cells = Array.from({ length: this.rows }, () => Array.from({ length: this.cols }, () => ({ type: CellType.None, color: Color.None })));\n\n\t\t// H-Edges: (rows + 1) * cols\n\t\tthis.hEdges = Array.from({ length: this.rows + 1 }, () => Array.from({ length: this.cols }, () => ({ type: EdgeType.Normal })));\n\n\t\t// V-Edges: rows * (cols + 1)\n\t\tthis.vEdges = Array.from({ length: this.rows }, () => Array.from({ length: this.cols + 1 }, () => ({ type: EdgeType.Normal })));\n\n\t\t// Nodes: (rows + 1) * (cols + 1)\n\t\tthis.nodes = Array.from({ length: this.rows + 1 }, () => Array.from({ length: this.cols + 1 }, () => ({ type: NodeType.Normal })));\n\t}\n\n\tpublic export(): PuzzleData {\n\t\t// \u30C7\u30FC\u30BF\u306E\u30C7\u30A3\u30FC\u30D7\u30B3\u30D4\u30FC\u3092\u8FD4\u3059\n\t\treturn JSON.parse(\n\t\t\tJSON.stringify({\n\t\t\t\trows: this.rows,\n\t\t\t\tcols: this.cols,\n\t\t\t\tcells: this.cells,\n\t\t\t\tvEdges: this.vEdges,\n\t\t\t\thEdges: this.hEdges,\n\t\t\t\tnodes: this.nodes,\n\t\t\t\tsymmetry: this.symmetry,\n\t\t\t}),\n\t\t);\n\t}\n\n\tpublic static fromData(data: PuzzleData): Grid {\n\t\tconst grid = new Grid(data.rows, data.cols);\n\t\tgrid.cells = data.cells;\n\t\tgrid.vEdges = data.vEdges;\n\t\tgrid.hEdges = data.hEdges;\n\t\tgrid.nodes = data.nodes;\n\t\tgrid.symmetry = data.symmetry || 0;\n\t\treturn grid;\n\t}\n}\n", "import { Grid } from \"./grid\";\nimport { CellType, Color, EdgeType, NodeType, SymmetryType, type Point, type SolutionPath, type ValidationResult } from \"./types\";\n\n/**\n * \u30D1\u30BA\u30EB\u306E\u56DE\u7B54\u3092\u691C\u8A3C\u3059\u308B\u30AF\u30E9\u30B9\n */\nexport class PuzzleValidator {\n\t/**\n\t * \u4E0E\u3048\u3089\u308C\u305F\u30B0\u30EA\u30C3\u30C9\u3068\u56DE\u7B54\u30D1\u30B9\u304C\u6B63\u5F53\u304B\u3069\u3046\u304B\u3092\u691C\u8A3C\u3059\u308B\n\t * @param grid \u30D1\u30BA\u30EB\u306E\u30B0\u30EA\u30C3\u30C9\u30C7\u30FC\u30BF\n\t * @param solution \u56DE\u7B54\u30D1\u30B9\n\t * @param externalCellsPrecalculated \u65E2\u77E5\u306E\u5916\u90E8\u30BB\u30EB\uFF08\u9AD8\u901F\u5316\u7528\uFF09\n\t * @returns \u691C\u8A3C\u7D50\u679C\uFF08\u6B63\u8AA4\u3001\u30A8\u30E9\u30FC\u7406\u7531\u3001\u7121\u52B9\u5316\u3055\u308C\u305F\u8A18\u53F7\u306A\u3069\uFF09\n\t */\n\tpublic validate(grid: Grid, solution: SolutionPath, externalCellsPrecalculated?: Set<string>): ValidationResult {\n\t\tconst path = solution.points;\n\t\tif (path.length < 2) return { isValid: false, errorReason: \"Path too short\" };\n\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\tconst symPath: Point[] = [];\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tfor (const p of path) {\n\t\t\t\tsymPath.push(this.getSymmetricalPoint(grid, p));\n\t\t\t}\n\t\t}\n\n\t\tconst start = path[0];\n\t\tconst end = path[path.length - 1];\n\n\t\t// \u958B\u59CB\u30CE\u30FC\u30C9\u3068\u7D42\u4E86\u30CE\u30FC\u30C9\u306E\u30C1\u30A7\u30C3\u30AF\n\t\tif (grid.nodes[start.y][start.x].type !== NodeType.Start) return { isValid: false, errorReason: \"Must start at Start Node\" };\n\t\tif (grid.nodes[end.y][end.x].type !== NodeType.End) return { isValid: false, errorReason: \"Must end at End Node\" };\n\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tconst symStart = symPath[0];\n\t\t\tconst symEnd = symPath[symPath.length - 1];\n\t\t\tif (grid.nodes[symStart.y][symStart.x].type !== NodeType.Start) return { isValid: false, errorReason: \"Symmetrical path must start at Start Node\" };\n\t\t\tif (grid.nodes[symEnd.y][symEnd.x].type !== NodeType.End) return { isValid: false, errorReason: \"Symmetrical path must end at End Node\" };\n\t\t}\n\n\t\t// \u30D1\u30B9\u306E\u9023\u7D9A\u6027\u3068\u81EA\u5DF1\u4EA4\u5DEE\u3001\u65AD\u7DDA\u30C1\u30A7\u30C3\u30AF\n\t\tconst visitedNodes = new Set<string>();\n\t\tconst visitedEdges = new Set<string>();\n\t\tvisitedNodes.add(`${start.x},${start.y}`);\n\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tconst symStart = symPath[0];\n\t\t\tif (visitedNodes.has(`${symStart.x},${symStart.y}`)) return { isValid: false, errorReason: \"Paths collide at start\" };\n\t\t\tvisitedNodes.add(`${symStart.x},${symStart.y}`);\n\t\t}\n\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst p1 = path[i];\n\t\t\tconst p2 = path[i + 1];\n\t\t\tconst dist = Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n\t\t\tif (dist !== 1) return { isValid: false, errorReason: \"Invalid jump in path\" };\n\n\t\t\tconst key = `${p2.x},${p2.y}`;\n\t\t\tif (visitedNodes.has(key)) return { isValid: false, errorReason: \"Self-intersecting path or path collision\" };\n\t\t\tvisitedNodes.add(key);\n\n\t\t\tif (this.isBrokenEdge(grid, p1, p2)) return { isValid: false, errorReason: \"Passed through broken edge\" };\n\t\t\tvisitedEdges.add(this.getEdgeKey(p1, p2));\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst sp1 = symPath[i];\n\t\t\t\tconst sp2 = symPath[i + 1];\n\t\t\t\tconst symKey = `${sp2.x},${sp2.y}`;\n\n\t\t\t\tif (visitedNodes.has(symKey)) return { isValid: false, errorReason: \"Path collision\" };\n\t\t\t\tvisitedNodes.add(symKey);\n\n\t\t\t\tif (this.isBrokenEdge(grid, sp1, sp2)) return { isValid: false, errorReason: \"Symmetrical path passed through broken edge\" };\n\n\t\t\t\tconst edgeKey = this.getEdgeKey(sp1, sp2);\n\t\t\t\tif (visitedEdges.has(edgeKey)) return { isValid: false, errorReason: \"Paths cross the same edge\" };\n\t\t\t\tvisitedEdges.add(edgeKey);\n\t\t\t}\n\t\t}\n\n\t\t// \u533A\u753B\u306E\u8A08\u7B97\n\t\tconst regions = this.calculateRegions(grid, path, symPath, externalCellsPrecalculated);\n\t\t// \u901A\u904E\u3057\u306A\u304B\u3063\u305F\u516D\u89D2\u5F62\u306E\u53D6\u5F97\n\t\tconst missed = this.getMissedHexagons(grid, path, symPath);\n\t\t// \u30A8\u30E9\u30FC\u524A\u9664\uFF08\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF09\u3092\u8003\u616E\u3057\u305F\u5236\u7D04\u691C\u8A3C\n\t\tconst result = this.validateWithErasers(grid, regions, missed.edges, missed.nodes);\n\t\tresult.regions = regions;\n\t\treturn result;\n\t}\n\n\t/**\n\t * \u4E8C\u70B9\u9593\u304C\u65AD\u7DDA\uFF08Broken or Absent\uFF09\u3057\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate isBrokenEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tlet type: EdgeType;\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\ttype = grid.vEdges[y][p1.x].type;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\ttype = grid.hEdges[p1.y][x].type;\n\t\t}\n\t\treturn type === EdgeType.Broken || type === EdgeType.Absent;\n\t}\n\n\t/**\n\t * \u4E8C\u70B9\u9593\u304C Absent\uFF08\u5B58\u5728\u3057\u306A\u3044\uFF09\u30A8\u30C3\u30B8\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate isAbsentEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\treturn grid.vEdges[y][p1.x].type === EdgeType.Absent;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\treturn grid.hEdges[p1.y][x].type === EdgeType.Absent;\n\t\t}\n\t}\n\n\t/**\n\t * \u56DE\u7B54\u30D1\u30B9\u304C\u901A\u904E\u3057\u306A\u304B\u3063\u305F\u516D\u89D2\u5F62\uFF08\u30A8\u30C3\u30B8\u30FB\u30CE\u30FC\u30C9\uFF09\u3092\u30EA\u30B9\u30C8\u30A2\u30C3\u30D7\u3059\u308B\n\t */\n\tprivate getMissedHexagons(grid: Grid, path: Point[], symPath: Point[] = []): { edges: { type: \"h\" | \"v\"; r: number; c: number }[]; nodes: Point[] } {\n\t\tconst pathEdges = new Set<string>();\n\t\tconst pathNodes = new Set<string>();\n\t\tfor (let i = 0; i < path.length; i++) {\n\t\t\tpathNodes.add(`${path[i].x},${path[i].y}`);\n\t\t\tif (i < path.length - 1) {\n\t\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < symPath.length; i++) {\n\t\t\tpathNodes.add(`${symPath[i].x},${symPath[i].y}`);\n\t\t\tif (i < symPath.length - 1) {\n\t\t\t\tpathEdges.add(this.getEdgeKey(symPath[i], symPath[i + 1]));\n\t\t\t}\n\t\t}\n\n\t\tconst missedEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst key = this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r });\n\t\t\t\t\tif (!pathEdges.has(key)) missedEdges.push({ type: \"h\", r, c });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst key = this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 });\n\t\t\t\t\tif (!pathEdges.has(key)) missedEdges.push({ type: \"v\", r, c });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst missedNodes: Point[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Hexagon) {\n\t\t\t\t\tif (!pathNodes.has(`${c},${r}`)) missedNodes.push({ x: c, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { edges: missedEdges, nodes: missedNodes };\n\t}\n\n\t/**\n\t * \u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF08\u30A8\u30E9\u30FC\u524A\u9664\uFF09\u3092\u8003\u616E\u3057\u3066\u30D1\u30BA\u30EB\u306E\u5404\u5236\u7D04\u3092\u691C\u8A3C\u3059\u308B\n\t */\n\tprivate validateWithErasers(grid: Grid, regions: Point[][], missedHexagons: { type: \"h\" | \"v\"; r: number; c: number }[], missedNodeHexagons: Point[]): ValidationResult {\n\t\tconst regionResults: { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] }[][] = [];\n\t\tlet allRegionsPossiblyValid = true;\n\n\t\tfor (let i = 0; i < regions.length; i++) {\n\t\t\tconst region = regions[i];\n\t\t\tconst erasers = region.filter((p) => grid.cells[p.y][p.x].type === CellType.Eraser);\n\t\t\tconst otherMarks = region.filter((p) => grid.cells[p.y][p.x].type !== CellType.None && grid.cells[p.y][p.x].type !== CellType.Eraser);\n\n\t\t\tconst adjacentMissedHexagons: number[] = [];\n\t\t\tfor (let j = 0; j < missedHexagons.length; j++) {\n\t\t\t\tif (this.isHexagonAdjacentToRegion(grid, missedHexagons[j], region)) adjacentMissedHexagons.push(j);\n\t\t\t}\n\n\t\t\tconst adjacentMissedNodeHexagons: number[] = [];\n\t\t\tfor (let j = 0; j < missedNodeHexagons.length; j++) {\n\t\t\t\tif (this.isNodeHexagonAdjacentToRegion(grid, missedNodeHexagons[j], region)) adjacentMissedNodeHexagons.push(j);\n\t\t\t}\n\n\t\t\t// \u5404\u533A\u753B\u3067\u30A8\u30E9\u30FC\u524A\u9664\u306E\u5168\u7D44\u307F\u5408\u308F\u305B\u3092\u8A66\u884C\n\t\t\tconst possible = this.getPossibleErasures(grid, region, erasers, otherMarks, adjacentMissedHexagons, adjacentMissedNodeHexagons);\n\t\t\tif (possible.length === 0) {\n\t\t\t\tallRegionsPossiblyValid = false;\n\t\t\t\t// \u30A8\u30E9\u30FC\u7B87\u6240\u3092\u7279\u5B9A\u3059\u308B\u305F\u3081\u306E\u30D9\u30B9\u30C8\u30A8\u30D5\u30A9\u30FC\u30C8\uFF08\u30E9\u30F3\u30C0\u30E0\u306A\u524A\u9664\uFF09\n\t\t\t\tconst bestEffort = this.getBestEffortErasures(grid, region, erasers, otherMarks, adjacentMissedHexagons, adjacentMissedNodeHexagons);\n\t\t\t\tregionResults.push([bestEffort]);\n\t\t\t} else {\n\t\t\t\t// \u6700\u5C0F\u306E\u524A\u9664\u6570\u3092\u6301\u3064\u89E3\u6C7A\u7B56\u3092\u512A\u5148\u3059\u308B\n\t\t\t\tpossible.sort((a, b) => {\n\t\t\t\t\tconst costA = a.invalidatedCells.length + a.invalidatedHexagons.length + a.invalidatedNodeHexagons.length;\n\t\t\t\t\tconst costB = b.invalidatedCells.length + b.invalidatedHexagons.length + b.invalidatedNodeHexagons.length;\n\t\t\t\t\treturn costA - costB;\n\t\t\t\t});\n\t\t\t\tregionResults.push(possible);\n\t\t\t}\n\t\t}\n\n\t\tif (allRegionsPossiblyValid) {\n\t\t\t// \u8907\u6570\u306E\u533A\u753B\u306B\u307E\u305F\u304C\u308B\u516D\u89D2\u5F62\u306E\u30A8\u30E9\u30FC\u524A\u9664\u5272\u308A\u5F53\u3066\u3092\u6C7A\u5B9A\n\t\t\tconst assignment = this.findGlobalAssignment(regionResults, missedHexagons.length, missedNodeHexagons.length);\n\t\t\tif (assignment) {\n\t\t\t\treturn {\n\t\t\t\t\tisValid: true,\n\t\t\t\t\tinvalidatedCells: assignment.invalidatedCells,\n\t\t\t\t\tinvalidatedEdges: assignment.invalidatedHexIndices.map((idx) => missedHexagons[idx]),\n\t\t\t\t\tinvalidatedNodes: assignment.invalidatedNodeHexIndices.map((idx) => missedNodeHexagons[idx]),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// \u5931\u6557\u6642\uFF1A\u30A8\u30E9\u30FC\u7B87\u6240\u306E\u53CE\u96C6\n\t\tconst errorCells: Point[] = [];\n\t\tconst invalidatedCells: Point[] = [];\n\t\tconst invalidatedHexIndices = new Set<number>();\n\t\tconst invalidatedNodeHexIndices = new Set<number>();\n\n\t\tfor (const options of regionResults) {\n\t\t\tconst best = options[0]; // \u6700\u521D\u306E\uFF08\u6700\u3082\u30B3\u30B9\u30C8\u306E\u4F4E\u3044\u3001\u307E\u305F\u306F\u30D9\u30B9\u30C8\u30A8\u30D5\u30A9\u30FC\u30C8\u306A\uFF09\u3082\u306E\u3092\u9078\u629E\n\t\t\terrorCells.push(...best.errorCells);\n\t\t\tinvalidatedCells.push(...best.invalidatedCells);\n\t\t\tfor (const idx of best.invalidatedHexagons) invalidatedHexIndices.add(idx);\n\t\t\tfor (const idx of best.invalidatedNodeHexagons) invalidatedNodeHexIndices.add(idx);\n\t\t}\n\n\t\t// \u7121\u52B9\u5316\u3055\u308C\u306A\u304B\u3063\u305F\u516D\u89D2\u5F62\u3082\u30A8\u30E9\u30FC\u3068\u3059\u308B\n\t\tconst errorEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\tfor (let i = 0; i < missedHexagons.length; i++) {\n\t\t\tif (!invalidatedHexIndices.has(i)) {\n\t\t\t\terrorEdges.push(missedHexagons[i]);\n\t\t\t}\n\t\t}\n\t\tconst errorNodes: Point[] = [];\n\t\tfor (let i = 0; i < missedNodeHexagons.length; i++) {\n\t\t\tif (!invalidatedNodeHexIndices.has(i)) {\n\t\t\t\terrorNodes.push(missedNodeHexagons[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tisValid: false,\n\t\t\terrorReason: \"Constraints failed\",\n\t\t\terrorCells,\n\t\t\terrorEdges,\n\t\t\terrorNodes,\n\t\t\tinvalidatedCells,\n\t\t\tinvalidatedEdges: Array.from(invalidatedHexIndices).map((idx) => missedHexagons[idx]),\n\t\t\tinvalidatedNodes: Array.from(invalidatedNodeHexIndices).map((idx) => missedNodeHexagons[idx]),\n\t\t};\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30A8\u30C3\u30B8\u304C\u7279\u5B9A\u306E\u533A\u753B\u306B\u96A3\u63A5\u3057\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate isHexagonAdjacentToRegion(grid: Grid, hex: { type: \"h\" | \"v\"; r: number; c: number }, region: Point[]): boolean {\n\t\tconst regionCells = new Set(region.map((p) => `${p.x},${p.y}`));\n\t\tif (hex.type === \"h\") {\n\t\t\tif (hex.r > 0 && regionCells.has(`${hex.c},${hex.r - 1}`)) return true;\n\t\t\tif (hex.r < grid.rows && regionCells.has(`${hex.c},${hex.r}`)) return true;\n\t\t} else {\n\t\t\tif (hex.c > 0 && regionCells.has(`${hex.c - 1},${hex.r}`)) return true;\n\t\t\tif (hex.c < grid.cols && regionCells.has(`${hex.c},${hex.r}`)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30CE\u30FC\u30C9\u304C\u7279\u5B9A\u306E\u533A\u753B\u306B\u96A3\u63A5\u3057\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate isNodeHexagonAdjacentToRegion(grid: Grid, node: Point, region: Point[]): boolean {\n\t\tconst regionCells = new Set(region.map((p) => `${p.x},${p.y}`));\n\t\t// \u30CE\u30FC\u30C9\u306E\u5468\u56F24\u3064\u306E\u30BB\u30EB\u306E\u3044\u305A\u308C\u304B\u304C\u533A\u753B\u306B\u542B\u307E\u308C\u3066\u3044\u308C\u3070\u96A3\u63A5\n\t\tconst adjCells = [\n\t\t\t{ x: node.x - 1, y: node.y - 1 },\n\t\t\t{ x: node.x, y: node.y - 1 },\n\t\t\t{ x: node.x - 1, y: node.y },\n\t\t\t{ x: node.x, y: node.y },\n\t\t];\n\t\tfor (const cell of adjCells) {\n\t\t\tif (cell.x >= 0 && cell.x < grid.cols && cell.y >= 0 && cell.y < grid.rows) {\n\t\t\t\tif (regionCells.has(`${cell.x},${cell.y}`)) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u533A\u753B\u5185\u306E\u30A8\u30E9\u30FC\u524A\u9664\u53EF\u80FD\u306A\u5168\u30D1\u30BF\u30FC\u30F3\u3092\u53D6\u5F97\u3059\u308B\n\t */\n\tprivate getPossibleErasures(grid: Grid, region: Point[], erasers: Point[], otherMarks: Point[], adjacentMissedHexagons: number[], adjacentMissedNodeHexagons: number[]): { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] }[] {\n\t\tconst results: { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] }[] = [];\n\t\tconst numErasers = erasers.length;\n\t\tif (numErasers === 0) {\n\t\t\tconst errorCells = this.getRegionErrors(grid, region, []);\n\t\t\tif (errorCells.length === 0 && adjacentMissedHexagons.length === 0 && adjacentMissedNodeHexagons.length === 0) {\n\t\t\t\tresults.push({ invalidatedCells: [], invalidatedHexagons: [], invalidatedNodeHexagons: [], isValid: true, errorCells: [] });\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\n\t\tconst itemsToNegate = [...otherMarks.map((p) => ({ type: \"cell\" as const, pos: p })), ...adjacentMissedHexagons.map((idx) => ({ type: \"hex\" as const, index: idx })), ...adjacentMissedNodeHexagons.map((idx) => ({ type: \"nodeHex\" as const, index: idx }))];\n\n\t\t// \u521D\u671F\u72B6\u614B\u3067\u30A8\u30E9\u30FC\u304C\u3042\u308B\u304B\u78BA\u8A8D\n\t\tconst initiallyValid = this.getRegionErrors(grid, region, []).length === 0 && adjacentMissedHexagons.length === 0 && adjacentMissedNodeHexagons.length === 0;\n\n\t\tfor (let N = 0; N <= numErasers; N++) {\n\t\t\tconst negatedEraserCombinations = this.getNCombinations(erasers, N);\n\t\t\tfor (const negatedErasers of negatedEraserCombinations) {\n\t\t\t\tconst negatedErasersSet = new Set(negatedErasers.map((e) => `${e.x},${e.y}`));\n\t\t\t\tconst activeErasers = erasers.filter((e) => !negatedErasersSet.has(`${e.x},${e.y}`));\n\n\t\t\t\tfor (let K = 0; K <= itemsToNegate.length; K++) {\n\t\t\t\t\tif (activeErasers.length !== N + K) continue;\n\n\t\t\t\t\tconst itemCombinations = this.getNCombinations(itemsToNegate, K);\n\t\t\t\t\tfor (const negatedItems of itemCombinations) {\n\t\t\t\t\t\tconst negatedCells = negatedItems.filter((it) => it.type === \"cell\").map((it) => it.pos as Point);\n\t\t\t\t\t\tconst negatedHexIndices = negatedItems.filter((it) => it.type === \"hex\").map((it) => it.index as number);\n\t\t\t\t\t\tconst negatedNodeHexIndices = negatedItems.filter((it) => it.type === \"nodeHex\").map((it) => it.index as number);\n\n\t\t\t\t\t\tconst errorCells = this.getRegionErrors(grid, region, [...negatedCells, ...negatedErasers]);\n\t\t\t\t\t\tconst isValid = errorCells.length === 0;\n\n\t\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\t\tlet isUseful = true;\n\t\t\t\t\t\t\tif (initiallyValid) {\n\t\t\t\t\t\t\t\tif (K > 0) isUseful = false;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < negatedItems.length; i++) {\n\t\t\t\t\t\t\t\t\tconst subset = [...negatedItems.slice(0, i), ...negatedItems.slice(i + 1)];\n\t\t\t\t\t\t\t\t\tconst subsetCells = subset.filter((it) => it.type === \"cell\").map((it) => it.pos as Point);\n\t\t\t\t\t\t\t\t\tconst subsetHexIndices = new Set(subset.filter((it) => it.type === \"hex\").map((it) => it.index as number));\n\t\t\t\t\t\t\t\t\tconst subsetNodeHexIndices = new Set(subset.filter((it) => it.type === \"nodeHex\").map((it) => it.index as number));\n\n\t\t\t\t\t\t\t\t\tconst allHexSatisfied = adjacentMissedHexagons.every((idx) => subsetHexIndices.has(idx));\n\t\t\t\t\t\t\t\t\tconst allNodeHexSatisfied = adjacentMissedNodeHexagons.every((idx) => subsetNodeHexIndices.has(idx));\n\n\t\t\t\t\t\t\t\t\tif (this.getRegionErrors(grid, region, subsetCells).length === 0 && allHexSatisfied && allNodeHexSatisfied) {\n\t\t\t\t\t\t\t\t\t\tisUseful = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (isUseful) {\n\t\t\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\t\t\tinvalidatedCells: [...negatedCells, ...negatedErasers],\n\t\t\t\t\t\t\t\t\tinvalidatedHexagons: negatedHexIndices,\n\t\t\t\t\t\t\t\t\tinvalidatedNodeHexagons: negatedNodeHexIndices,\n\t\t\t\t\t\t\t\t\tisValid: true,\n\t\t\t\t\t\t\t\t\terrorCells: [],\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * \u30A8\u30E9\u30FC\u304C\u89E3\u6D88\u3067\u304D\u306A\u304B\u3063\u305F\u5834\u5408\u306E\u30D9\u30B9\u30C8\u30A8\u30D5\u30A9\u30FC\u30C8\u306A\u524A\u9664\uFF08\u53EF\u80FD\u306A\u9650\u308A\u6D88\u3057\u30B4\u30E0\u3092\u9069\u7528\uFF09\u3092\u53D6\u5F97\u3059\u308B\n\t */\n\tprivate getBestEffortErasures(grid: Grid, region: Point[], erasers: Point[], otherMarks: Point[], adjacentMissedHexagons: number[], adjacentMissedNodeHexagons: number[]): { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] } {\n\t\tconst naturalErrors = this.getRegionErrors(grid, region, []);\n\t\tconst initiallyValid = naturalErrors.length === 0 && adjacentMissedHexagons.length === 0 && adjacentMissedNodeHexagons.length === 0;\n\n\t\t// \u521D\u671F\u72B6\u614B\u3067\u6709\u52B9\u306A\u3089\u3001\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\u81EA\u4F53\u304C\u30A8\u30E9\u30FC\u3002\n\t\tif (initiallyValid) {\n\t\t\treturn {\n\t\t\t\tinvalidatedCells: [],\n\t\t\t\tinvalidatedHexagons: [],\n\t\t\t\tinvalidatedNodeHexagons: [],\n\t\t\t\tisValid: false,\n\t\t\t\terrorCells: [...erasers],\n\t\t\t};\n\t\t}\n\n\t\tif (erasers.length > 0) {\n\t\t\tconst itemsToNegate = [...otherMarks.map((p) => ({ type: \"cell\" as const, pos: p })), ...adjacentMissedHexagons.map((idx) => ({ type: \"hex\" as const, index: idx })), ...adjacentMissedNodeHexagons.map((idx) => ({ type: \"nodeHex\" as const, index: idx }))];\n\n\t\t\t// \u30A8\u30E9\u30FC\u89E3\u6D88\u30D1\u30BF\u30FC\u30F3\u3092\u3044\u304F\u3064\u304B\u8A66\u3057\u3001\u6700\u3082\u30A8\u30E9\u30FC\u304C\u5C11\u306A\u304F\u306A\u308B\u3082\u306E\u3092\u63A1\u7528\u3059\u308B\n\t\t\tlet bestResult: { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] } | null = null;\n\t\t\tlet minErrorCount = Infinity;\n\n\t\t\t// \u5358\u7D14\u306A\u512A\u5148\u9806\u4F4D\u306B\u57FA\u3065\u304F\u30D1\u30BF\u30FC\u30F3\n\t\t\tconst tryNegate = (priorityItems: ({ type: \"cell\"; pos: Point } | { type: \"hex\"; index: number } | { type: \"nodeHex\"; index: number })[]) => {\n\t\t\t\tconst toInvalidateCells: Point[] = [];\n\t\t\t\tconst toInvalidateHexagons: number[] = [];\n\t\t\t\tconst toInvalidateNodeHexagons: number[] = [];\n\t\t\t\tlet usedErasersCount = 0;\n\n\t\t\t\tfor (const item of priorityItems) {\n\t\t\t\t\tif (usedErasersCount < erasers.length) {\n\t\t\t\t\t\tif (item.type === \"cell\") toInvalidateCells.push(item.pos);\n\t\t\t\t\t\telse if (item.type === \"hex\") toInvalidateHexagons.push(item.index);\n\t\t\t\t\t\telse toInvalidateNodeHexagons.push(item.index);\n\t\t\t\t\t\tusedErasersCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// \u6B8B\u308A\u306E\u6D88\u3057\u30B4\u30E0\u306F\u30DA\u30A2\u306B\u3057\u3066\u7121\u52B9\u5316\u3092\u8A66\u307F\u308B\n\t\t\t\tconst remainingForPairs = erasers.length - usedErasersCount;\n\t\t\t\tconst N = Math.floor(remainingForPairs / 2);\n\t\t\t\tconst negatedErasers = erasers.slice(usedErasersCount, usedErasersCount + N);\n\t\t\t\tusedErasersCount += N * 2;\n\n\t\t\t\t// \u6D88\u3057\u30B4\u30E0\u81EA\u8EAB\u304C\u30A8\u30E9\u30FC\u304B\u3069\u3046\u304B\u3092\u5224\u5B9A\u3059\u308B\u305F\u3081\u3001getRegionErrors\u3092\u547C\u3076\n\t\t\t\t// \u6D88\u3057\u30B4\u30E0\u81EA\u8EAB\u306F\uFF08\u6D88\u3057\u5408\u3063\u305F\u30DA\u30A2\u3092\u9664\u304D\uFF09\u30DE\u30FC\u30AF\u3068\u3057\u3066\u6B8B\u308B\n\t\t\t\tconst errorCells = this.getRegionErrors(grid, region, [...toInvalidateCells, ...negatedErasers]);\n\t\t\t\t// \u4F7F\u308F\u308C\u306A\u304B\u3063\u305F\u6D88\u3057\u30B4\u30E0\u306F\u30A8\u30E9\u30FC\n\t\t\t\tfor (let i = usedErasersCount; i < erasers.length; i++) {\n\t\t\t\t\terrorCells.push(erasers[i]);\n\t\t\t\t}\n\n\t\t\t\tconst errorCount = errorCells.length;\n\t\t\t\tif (errorCount < minErrorCount) {\n\t\t\t\t\tminErrorCount = errorCount;\n\n\t\t\t\t\tbestResult = {\n\t\t\t\t\t\tinvalidatedCells: [...toInvalidateCells, ...negatedErasers],\n\t\t\t\t\t\tinvalidatedHexagons: toInvalidateHexagons,\n\t\t\t\t\t\tinvalidatedNodeHexagons: toInvalidateNodeHexagons,\n\t\t\t\t\t\tisValid: false,\n\t\t\t\t\t\terrorCells,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// \u30D1\u30BF\u30FC\u30F31: \u81EA\u7136\u767A\u751F\u3057\u305F\u30A8\u30E9\u30FC\u3092\u512A\u5148\n\t\t\ttryNegate([...naturalErrors.map((p) => ({ type: \"cell\" as const, pos: p })), ...adjacentMissedHexagons.map((idx) => ({ type: \"hex\" as const, index: idx })), ...adjacentMissedNodeHexagons.map((idx) => ({ type: \"nodeHex\" as const, index: idx }))]);\n\t\t\t// \u30D1\u30BF\u30FC\u30F32: \u5168\u3066\u306E\u30A2\u30A4\u30C6\u30E0\u3092\u9806\u756A\u306B\n\t\t\ttryNegate(itemsToNegate);\n\t\t\t// \u30D1\u30BF\u30FC\u30F33: \u81EA\u7136\u767A\u751F\u3057\u305F\u5404\u30A8\u30E9\u30FC\u3092\u500B\u5225\u306B1\u3064\u305A\u3064\u6D88\u3057\u3066\u307F\u308B\n\t\t\tfor (const errCell of naturalErrors) {\n\t\t\t\ttryNegate([{ type: \"cell\", pos: errCell }]);\n\t\t\t}\n\n\t\t\tif (bestResult) return bestResult;\n\t\t}\n\n\t\tconst errorCells = [...naturalErrors, ...erasers];\n\t\treturn {\n\t\t\tinvalidatedCells: [],\n\t\t\tinvalidatedHexagons: [],\n\t\t\tinvalidatedNodeHexagons: [],\n\t\t\tisValid: false,\n\t\t\terrorCells,\n\t\t};\n\t}\n\n\t/**\n\t * \u914D\u5217\u304B\u3089N\u500B\u9078\u3076\u7D44\u307F\u5408\u308F\u305B\u3092\u53D6\u5F97\u3059\u308B\n\t */\n\tprivate getNCombinations<T>(items: T[], n: number): T[][] {\n\t\tconst results: T[][] = [];\n\t\tconst backtrack = (start: number, current: T[]) => {\n\t\t\tif (current.length === n) {\n\t\t\t\tresults.push([...current]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (let i = start; i < items.length; i++) {\n\t\t\t\tcurrent.push(items[i]);\n\t\t\t\tbacktrack(i + 1, current);\n\t\t\t\tcurrent.pop();\n\t\t\t}\n\t\t};\n\t\tbacktrack(0, []);\n\t\treturn results;\n\t}\n\n\t/**\n\t * \u7279\u5B9A\u306E\u524A\u9664\u30FB\u7121\u52B9\u5316\u3092\u9069\u7528\u3057\u305F\u72B6\u614B\u3067\u3001\u533A\u753B\u5185\u306E\u5236\u7D04\u304C\u6E80\u305F\u3055\u308C\u3066\u3044\u308B\u304B\u691C\u8A3C\u3059\u308B\n\t */\n\tprivate checkRegionValid(grid: Grid, region: Point[], erasedCells: Point[]): boolean {\n\t\treturn this.getRegionErrors(grid, region, erasedCells).length === 0;\n\t}\n\n\t/**\n\t * \u533A\u753B\u5185\u306E\u30A8\u30E9\u30FC\u3068\u306A\u3063\u3066\u3044\u308B\u30BB\u30EB\u3092\u7279\u5B9A\u3059\u308B\n\t */\n\tprivate getRegionErrors(grid: Grid, region: Point[], erasedCells: Point[]): Point[] {\n\t\tconst erasedSet = new Set(erasedCells.map((p) => `${p.x},${p.y}`));\n\t\tconst colorCounts = new Map<number, number>();\n\t\tconst colorCells = new Map<number, Point[]>();\n\t\tconst starColors = new Set<number>();\n\t\tconst squareColors = new Set<number>();\n\t\tconst tetrisPieces: { shape: number[][]; rotatable: boolean; pos: Point }[] = [];\n\n\t\tfor (const cell of region) {\n\t\t\tif (erasedSet.has(`${cell.x},${cell.y}`)) continue;\n\t\t\tconst constraint = grid.cells[cell.y][cell.x];\n\t\t\tif (constraint.type === CellType.None) continue;\n\n\t\t\tconst color = constraint.color;\n\t\t\tif (color !== Color.None) {\n\t\t\t\tcolorCounts.set(color, (colorCounts.get(color) || 0) + 1);\n\t\t\t\tif (!colorCells.has(color)) colorCells.set(color, []);\n\t\t\t\tcolorCells.get(color)!.push(cell);\n\t\t\t}\n\n\t\t\tif (constraint.type === CellType.Square) squareColors.add(color);\n\t\t\telse if (constraint.type === CellType.Star) starColors.add(color);\n\t\t\telse if (constraint.type === CellType.Tetris || constraint.type === CellType.TetrisRotated) {\n\t\t\t\tif (constraint.shape) tetrisPieces.push({ shape: constraint.shape, rotatable: constraint.type === CellType.TetrisRotated, pos: cell });\n\t\t\t}\n\t\t}\n\n\t\tconst errorCells: Point[] = [];\n\t\t// \u56DB\u89D2\u5F62\u306E\u30EB\u30FC\u30EB\uFF1A\u540C\u533A\u753B\u5185\u306F\u540C\u3058\u8272\n\t\tif (squareColors.size > 1) {\n\t\t\tfor (const cell of region) {\n\t\t\t\tif (erasedSet.has(`${cell.x},${cell.y}`)) continue;\n\t\t\t\tif (grid.cells[cell.y][cell.x].type === CellType.Square) errorCells.push(cell);\n\t\t\t}\n\t\t}\n\n\t\t// \u661F\u306E\u30EB\u30FC\u30EB\uFF1A\u540C\u8272\u306E\u8A18\u53F7\u304C\u3061\u3087\u3046\u30692\u3064\n\t\tfor (const color of starColors) {\n\t\t\tif (colorCounts.get(color) !== 2) {\n\t\t\t\tconst cells = colorCells.get(color) || [];\n\t\t\t\tfor (const p of cells) {\n\t\t\t\t\tconst type = grid.cells[p.y][p.x].type;\n\t\t\t\t\tif (type === CellType.Star) {\n\t\t\t\t\t\terrorCells.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// \u30C6\u30C8\u30EA\u30B9\u306E\u30EB\u30FC\u30EB\uFF1A\u30BF\u30A4\u30EA\u30F3\u30B0\u53EF\u80FD\n\t\tif (tetrisPieces.length > 0) {\n\t\t\tif (\n\t\t\t\t!this.checkTetrisConstraint(\n\t\t\t\t\tregion,\n\t\t\t\t\ttetrisPieces.map((p) => ({ shape: p.shape, rotatable: p.rotatable })),\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tfor (const p of tetrisPieces) errorCells.push(p.pos);\n\t\t\t}\n\t\t}\n\t\treturn errorCells;\n\t}\n\n\t/**\n\t * \u30B0\u30ED\u30FC\u30D0\u30EB\u306A\u5236\u7D04\uFF08\u516D\u89D2\u5F62\uFF09\u306E\u5272\u308A\u5F53\u3066\u3092\u30D0\u30C3\u30AF\u30C8\u30E9\u30C3\u30AD\u30F3\u30B0\u3067\u63A2\u7D22\u3059\u308B\n\t */\n\tprivate findGlobalAssignment(regionResults: { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean }[][], totalMissedHexagons: number, totalMissedNodeHexagons: number): { invalidatedCells: Point[]; invalidatedHexIndices: number[]; invalidatedNodeHexIndices: number[] } | null {\n\t\tconst numRegions = regionResults.length;\n\t\tconst currentHexErasures = new Array(totalMissedHexagons).fill(0);\n\t\tconst currentNodeHexErasures = new Array(totalMissedNodeHexagons).fill(0);\n\t\tconst allInvalidatedCells: Point[] = [];\n\t\tconst allInvalidatedHexIndices: number[] = [];\n\t\tconst allInvalidatedNodeHexIndices: number[] = [];\n\n\t\tconst backtrack = (regionIdx: number): boolean => {\n\t\t\tif (regionIdx === numRegions) return currentHexErasures.every((count) => count === 1) && currentNodeHexErasures.every((count) => count === 1);\n\t\t\tfor (const option of regionResults[regionIdx]) {\n\t\t\t\tlet possible = true;\n\t\t\t\tfor (const hexIdx of option.invalidatedHexagons)\n\t\t\t\t\tif (currentHexErasures[hexIdx] > 0) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (possible) {\n\t\t\t\t\tfor (const hexIdx of option.invalidatedNodeHexagons)\n\t\t\t\t\t\tif (currentNodeHexErasures[hexIdx] > 0) {\n\t\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (possible) {\n\t\t\t\t\tfor (const hexIdx of option.invalidatedHexagons) {\n\t\t\t\t\t\tcurrentHexErasures[hexIdx]++;\n\t\t\t\t\t\tallInvalidatedHexIndices.push(hexIdx);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const hexIdx of option.invalidatedNodeHexagons) {\n\t\t\t\t\t\tcurrentNodeHexErasures[hexIdx]++;\n\t\t\t\t\t\tallInvalidatedNodeHexIndices.push(hexIdx);\n\t\t\t\t\t}\n\t\t\t\t\tallInvalidatedCells.push(...option.invalidatedCells);\n\t\t\t\t\tif (backtrack(regionIdx + 1)) return true;\n\n\t\t\t\t\tfor (const hexIdx of option.invalidatedHexagons) {\n\t\t\t\t\t\tcurrentHexErasures[hexIdx]--;\n\t\t\t\t\t\tallInvalidatedHexIndices.pop();\n\t\t\t\t\t}\n\t\t\t\t\tfor (const hexIdx of option.invalidatedNodeHexagons) {\n\t\t\t\t\t\tcurrentNodeHexErasures[hexIdx]--;\n\t\t\t\t\t\tallInvalidatedNodeHexIndices.pop();\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < option.invalidatedCells.length; i++) allInvalidatedCells.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tif (backtrack(0))\n\t\t\treturn {\n\t\t\t\tinvalidatedCells: allInvalidatedCells,\n\t\t\t\tinvalidatedHexIndices: allInvalidatedHexIndices,\n\t\t\t\tinvalidatedNodeHexIndices: allInvalidatedNodeHexIndices,\n\t\t\t};\n\t\treturn null;\n\t}\n\n\t/**\n\t * \u30C6\u30C8\u30EA\u30B9\u5236\u7D04\u306E\u691C\u8A3C\uFF08\u6307\u5B9A\u3055\u308C\u305F\u9818\u57DF\u3092\u30D4\u30FC\u30B9\u3067\u57CB\u3081\u5C3D\u304F\u305B\u308B\u304B\uFF09\n\t */\n\tprivate checkTetrisConstraint(region: Point[], pieces: { shape: number[][]; rotatable: boolean }[]): boolean {\n\t\tconst totalTetrisArea = pieces.reduce((sum, p) => sum + this.getShapeArea(p.shape), 0);\n\t\tif (totalTetrisArea !== region.length) return false;\n\n\t\tconst minX = Math.min(...region.map((p) => p.x));\n\t\tconst minY = Math.min(...region.map((p) => p.y));\n\t\tconst maxX = Math.max(...region.map((p) => p.x));\n\t\tconst maxY = Math.max(...region.map((p) => p.y));\n\t\tconst width = maxX - minX + 1;\n\t\tconst height = maxY - minY + 1;\n\n\t\tconst regionGrid = Array.from({ length: height }, () => Array(width).fill(false));\n\t\tfor (const p of region) regionGrid[p.y - minY][p.x - minX] = true;\n\n\t\treturn this.canTile(regionGrid, pieces);\n\t}\n\n\tprivate getShapeArea(shape: number[][]): number {\n\t\tlet area = 0;\n\t\tfor (const row of shape) for (const cell of row) if (cell) area++;\n\t\treturn area;\n\t}\n\n\t/**\n\t * \u518D\u5E30\u7684\u306B\u30BF\u30A4\u30EA\u30F3\u30B0\u3092\u8A66\u307F\u308B\n\t */\n\tprivate canTile(regionGrid: boolean[][], pieces: { shape: number[][]; rotatable: boolean }[]): boolean {\n\t\tlet r0 = -1;\n\t\tlet c0 = -1;\n\t\tfor (let r = 0; r < regionGrid.length; r++) {\n\t\t\tfor (let c = 0; c < regionGrid[0].length; c++) {\n\t\t\t\tif (regionGrid[r][c]) {\n\t\t\t\t\tr0 = r;\n\t\t\t\t\tc0 = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r0 !== -1) break;\n\t\t}\n\t\tif (r0 === -1) return pieces.length === 0;\n\t\tif (pieces.length === 0) return false;\n\n\t\tfor (let i = 0; i < pieces.length; i++) {\n\t\t\tconst piece = pieces[i];\n\t\t\tconst nextPieces = [...pieces.slice(0, i), ...pieces.slice(i + 1)];\n\t\t\tconst rotations = piece.rotatable ? this.getAllRotations(piece.shape) : [piece.shape];\n\n\t\t\tfor (const shape of rotations) {\n\t\t\t\tconst blocks: { r: number; c: number }[] = [];\n\t\t\t\tfor (let pr = 0; pr < shape.length; pr++) {\n\t\t\t\t\tfor (let pc = 0; pc < shape[0].length; pc++) {\n\t\t\t\t\t\tif (shape[pr][pc]) blocks.push({ r: pr, c: pc });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const anchor of blocks) {\n\t\t\t\t\tconst dr = r0 - anchor.r;\n\t\t\t\t\tconst dc = c0 - anchor.c;\n\t\t\t\t\tif (this.canPlace(regionGrid, shape, dr, dc)) {\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, false);\n\t\t\t\t\t\tif (this.canTile(regionGrid, nextPieces)) return true;\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate canPlace(regionGrid: boolean[][], shape: number[][], r: number, c: number): boolean {\n\t\tfor (let i = 0; i < shape.length; i++) {\n\t\t\tfor (let j = 0; j < shape[0].length; j++) {\n\t\t\t\tif (shape[i][j]) {\n\t\t\t\t\tconst nr = r + i;\n\t\t\t\t\tconst nc = c + j;\n\t\t\t\t\tif (nr < 0 || nr >= regionGrid.length || nc < 0 || nc >= regionGrid[0].length || !regionGrid[nr][nc]) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate placePiece(regionGrid: boolean[][], shape: number[][], r: number, c: number, value: boolean) {\n\t\tfor (let i = 0; i < shape.length; i++) for (let j = 0; j < shape[0].length; j++) if (shape[i][j]) regionGrid[r + i][c + j] = value;\n\t}\n\n\tprivate getAllRotations(shape: number[][]): number[][][] {\n\t\tconst results: number[][][] = [];\n\t\tconst keys = new Set<string>();\n\t\tlet curr = shape;\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tconst key = JSON.stringify(curr);\n\t\t\tif (!keys.has(key)) {\n\t\t\t\tresults.push(curr);\n\t\t\t\tkeys.add(key);\n\t\t\t}\n\t\t\tcurr = this.rotate90(curr);\n\t\t}\n\t\treturn results;\n\t}\n\n\tprivate rotate90(shape: number[][]): number[][] {\n\t\tconst rows = shape.length;\n\t\tconst cols = shape[0].length;\n\t\tconst newShape = Array.from({ length: cols }, () => Array(rows).fill(0));\n\t\tfor (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) newShape[c][rows - 1 - r] = shape[r][c];\n\t\treturn newShape;\n\t}\n\n\t/**\n\t * \u56DE\u7B54\u30D1\u30B9\u306B\u3088\u3063\u3066\u5206\u5272\u3055\u308C\u305F\u5404\u533A\u753B\u306E\u30BB\u30EB\u30EA\u30B9\u30C8\u3092\u53D6\u5F97\u3059\u308B\n\t */\n\tprivate calculateRegions(grid: Grid, path: Point[], symPath: Point[] = [], externalCellsPrecalculated?: Set<string>): Point[][] {\n\t\tconst regions: Point[][] = [];\n\t\tconst visitedCells = new Set<string>();\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) pathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\tfor (let i = 0; i < symPath.length - 1; i++) pathEdges.add(this.getEdgeKey(symPath[i], symPath[i + 1]));\n\n\t\tconst externalCells = externalCellsPrecalculated || this.getExternalCells(grid);\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (visitedCells.has(`${c},${r}`) || (externalCells && externalCells.has(`${c},${r}`))) continue;\n\t\t\t\tconst region: Point[] = [];\n\t\t\t\tconst queue: Point[] = [{ x: c, y: r }];\n\t\t\t\tvisitedCells.add(`${c},${r}`);\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst curr = queue.shift()!;\n\t\t\t\t\tregion.push(curr);\n\t\t\t\t\tconst neighbors = [\n\t\t\t\t\t\t{ nx: curr.x, ny: curr.y - 1, p1: { x: curr.x, y: curr.y }, p2: { x: curr.x + 1, y: curr.y } },\n\t\t\t\t\t\t{ nx: curr.x, ny: curr.y + 1, p1: { x: curr.x, y: curr.y + 1 }, p2: { x: curr.x + 1, y: curr.y + 1 } },\n\t\t\t\t\t\t{ nx: curr.x - 1, ny: curr.y, p1: { x: curr.x, y: curr.y }, p2: { x: curr.x, y: curr.y + 1 } },\n\t\t\t\t\t\t{ nx: curr.x + 1, ny: curr.y, p1: { x: curr.x + 1, y: curr.y }, p2: { x: curr.x + 1, y: curr.y + 1 } },\n\t\t\t\t\t];\n\t\t\t\t\tfor (const n of neighbors) {\n\t\t\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\t\t\tconst neighborKey = `${n.nx},${n.ny}`;\n\t\t\t\t\t\t\tif (!visitedCells.has(neighborKey) && !externalCells.has(neighborKey)) {\n\t\t\t\t\t\t\t\tconst edgeKey = this.getEdgeKey(n.p1, n.p2);\n\t\t\t\t\t\t\t\tif (!pathEdges.has(edgeKey) && !this.isAbsentEdge(grid, n.p1, n.p2)) {\n\t\t\t\t\t\t\t\t\tvisitedCells.add(neighborKey);\n\t\t\t\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregions.push(region);\n\t\t\t}\n\t\t}\n\t\treturn regions;\n\t}\n\n\t/**\n\t * \u30A8\u30C3\u30B8\uFF08Absent\uFF09\u306B\u3088\u3063\u3066\u5916\u90E8\u306B\u7E4B\u304C\u3063\u3066\u3044\u308B\u30BB\u30EB\u3092\u7279\u5B9A\u3059\u308B\n\t */\n\tprivate getExternalCells(grid: Grid): Set<string> {\n\t\tconst external = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [];\n\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\tif (grid.hEdges[0][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},0`)) {\n\t\t\t\t\texternal.add(`${c},0`);\n\t\t\t\t\tqueue.push({ x: c, y: 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.hEdges[grid.rows][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},${grid.rows - 1}`)) {\n\t\t\t\t\texternal.add(`${c},${grid.rows - 1}`);\n\t\t\t\t\tqueue.push({ x: c, y: grid.rows - 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tif (grid.vEdges[r][0].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`0,${r}`)) {\n\t\t\t\t\texternal.add(`0,${r}`);\n\t\t\t\t\tqueue.push({ x: 0, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.vEdges[r][grid.cols].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${grid.cols - 1},${r}`)) {\n\t\t\t\t\texternal.add(`${grid.cols - 1},${r}`);\n\t\t\t\t\tqueue.push({ x: grid.cols - 1, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.hEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.hEdges[curr.y + 1][curr.x] },\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x + 1] },\n\t\t\t];\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\tif (!external.has(`${n.nx},${n.ny}`) && n.edge.type === EdgeType.Absent) {\n\t\t\t\t\t\texternal.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn external;\n\t}\n\n\tprivate getSymmetricalPoint(grid: Grid, p: Point): Point {\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\treturn { x: grid.cols - p.x, y: p.y };\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\treturn { x: p.x, y: grid.rows - p.y };\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\treturn { x: grid.cols - p.x, y: grid.rows - p.y };\n\t\t}\n\t\treturn { ...p };\n\t}\n\n\tprivate getSymmetricalPointIndex(grid: Grid, idx: number): number {\n\t\tconst nodeCols = grid.cols + 1;\n\t\tconst r = Math.floor(idx / nodeCols);\n\t\tconst c = idx % nodeCols;\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\tlet sr = r,\n\t\t\tsc = c;\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\tsc = grid.cols - c;\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\tsr = grid.rows - r;\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\tsc = grid.cols - c;\n\t\t\tsr = grid.rows - r;\n\t\t}\n\t\treturn sr * nodeCols + sc;\n\t}\n\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u306E\u96E3\u6613\u5EA6\u30B9\u30B3\u30A2(0.0-1.0)\u3092\u7B97\u51FA\u3059\u308B\n\t */\n\tpublic calculateDifficulty(grid: Grid): number {\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst nodeCols = cols + 1;\n\t\tconst nodeCount = (rows + 1) * nodeCols;\n\t\tconst adj = Array.from({ length: nodeCount }, () => [] as { next: number; isHexagon: boolean; isBroken: boolean }[]);\n\t\tconst startNodes: number[] = [];\n\t\tconst endNodes: number[] = [];\n\t\tconst hexagonEdges = new Set<string>();\n\t\tconst hexagonNodes = new Set<number>();\n\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tconst u = r * nodeCols + c;\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Start) startNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.End) endNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Hexagon) hexagonNodes.add(u);\n\n\t\t\t\tif (c < cols) {\n\t\t\t\t\tconst v = u + 1;\n\t\t\t\t\tconst type = grid.hEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r }));\n\t\t\t\t}\n\t\t\t\tif (r < rows) {\n\t\t\t\t\tconst v = u + nodeCols;\n\t\t\t\t\tconst type = grid.vEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 }));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst stats = { totalNodesVisited: 0, branchingPoints: 0, solutions: 0, maxDepth: 0, backtracks: 0 };\n\t\tconst totalHexagons = hexagonEdges.size + hexagonNodes.size;\n\t\tconst fingerprints = new Set<string>();\n\n\t\t// \u76E4\u9762\u306E\u5927\u304D\u3055\u306B\u5408\u308F\u305B\u3066\u63A2\u7D22\u30EA\u30DF\u30C3\u30C8\u3092\u8ABF\u6574\n\t\tconst searchLimit = Math.max(1000, rows * cols * 200);\n\t\tconst externalCells = this.getExternalCells(grid);\n\n\t\t// \u30BB\u30EB\u30DE\u30FC\u30AF\uFF08\u56DB\u89D2\u3001\u661F\u3001\u30C6\u30C8\u30EA\u30B9\u3001\u6D88\u3057\u30B4\u30E0\uFF09\u304C\u3042\u308B\u304B\u4E8B\u524D\u306B\u30C1\u30A7\u30C3\u30AF\n\t\tlet hasCellMarks = false;\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tif (grid.cells[r][c].type !== CellType.None) {\n\t\t\t\t\thasCellMarks = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasCellMarks) break;\n\t\t}\n\n\t\tfor (const startIdx of startNodes) {\n\t\t\tconst startIsHex = hexagonNodes.has(startIdx) ? 1 : 0;\n\t\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\t\tlet visitedMask = 1n << BigInt(startIdx);\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snStart = this.getSymmetricalPointIndex(grid, startIdx);\n\t\t\t\tif (snStart === startIdx) continue; // \u30B9\u30BF\u30FC\u30C8\u4F4D\u7F6E\u304C\u5BFE\u79F0\u70B9\uFF08\u8EF8\u4E0A\uFF09\u306A\u3089\u4E0D\u9069\uFF08\u901A\u5E38\u907F\u3051\u308B\uFF09\n\t\t\t\tvisitedMask |= 1n << BigInt(snStart);\n\t\t\t}\n\n\t\t\tthis.exploreSearchSpace(grid, startIdx, visitedMask, [startIdx], startIsHex, totalHexagons, adj, endNodes, fingerprints, stats, searchLimit, externalCells, hasCellMarks);\n\t\t}\n\n\t\tif (stats.solutions === 0) return 0;\n\n\t\tlet constraintCount = hexagonEdges.size + hexagonNodes.size;\n\t\tconst constraintTypes = new Set<number>();\n\t\tif (hexagonEdges.size > 0) constraintTypes.add(999);\n\n\t\tlet tetrisCount = 0;\n\t\tlet rotatedTetrisCount = 0;\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tconst cell = grid.cells[r][c];\n\t\t\t\tif (cell.type !== CellType.None) {\n\t\t\t\t\tconstraintCount++;\n\t\t\t\t\tconstraintTypes.add(cell.type);\n\t\t\t\t\tif (cell.type === CellType.Tetris) tetrisCount++;\n\t\t\t\t\telse if (cell.type === CellType.TetrisRotated) {\n\t\t\t\t\t\ttetrisCount++;\n\t\t\t\t\t\trotatedTetrisCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst branchingFactor = stats.branchingPoints / (stats.totalNodesVisited || 1);\n\t\tconst searchComplexity = Math.log10(stats.totalNodesVisited + 1);\n\t\t// \u89E3\u306E\u6570\u304C\u591A\u3044\u307B\u3069\u96E3\u6613\u5EA6\u3092\u4E0B\u3052\u308B\u3002\u30B9\u30B1\u30FC\u30EB\u3092\u8ABF\u6574\n\t\tlet difficulty = (branchingFactor * 10 + searchComplexity * 1.5) / (Math.log2(stats.solutions + 1) * 0.5 + 1);\n\n\t\t// \u30A8\u30C3\u30B8\u306E\u516D\u89D2\u5F62\u304C\u591A\u3044\u307B\u3069\u7C21\u5358\u306B\u306A\u308B\uFF08\u30AC\u30A4\u30C9\u306B\u306A\u308B\u305F\u3081\uFF09\n\t\tdifficulty -= hexagonEdges.size * 0.05;\n\t\t// \u30CE\u30FC\u30C9\u306E\u516D\u89D2\u5F62\u306F\u96E3\u6613\u5EA6\u3092\u4E0A\u3052\u308B\uFF08\u901A\u904E\u304C\u5F37\u5236\u3055\u308C\u308B\u305F\u3081\uFF09\n\t\tdifficulty += hexagonNodes.size * 0.12;\n\n\t\tif (tetrisCount > 0) {\n\t\t\tdifficulty += rotatedTetrisCount * 0.5;\n\t\t\tdifficulty += (tetrisCount - rotatedTetrisCount) * 0.2;\n\t\t}\n\n\t\tconst cellCount = rows * cols;\n\t\tconst density = constraintCount / cellCount;\n\t\t// \u5BC6\u5EA6\u304C\u4F4E\u3059\u304E\u308B\u3068\u6025\u6FC0\u306B\u96E3\u6613\u5EA6\u304C\u4E0B\u304C\u308B\u3088\u3046\u306B\u8ABF\u6574\u3002\u3088\u308A\u53B3\u3057\u304F\u3002\n\t\tconst densityFactor = density < 0.25 ? Math.pow(density / 0.25, 4) : 1.0;\n\t\tconst typeFactor = constraintTypes.size <= 1 ? 0.5 : 1.0;\n\n\t\tdifficulty *= densityFactor * typeFactor;\n\t\t// \u76E4\u9762\u30B5\u30A4\u30BA\u306B\u3088\u308B\u88DC\u6B63\u3092\u7DE9\u3084\u304B\u306B\n\t\tconst sizeFactor = Math.log2(cellCount) / 5;\n\t\tdifficulty *= sizeFactor;\n\n\t\treturn Math.max(0.01, Math.min(1.0, difficulty / 4));\n\t}\n\n\t/**\n\t * \u63A2\u7D22\u7A7A\u9593\u3092\u8D70\u67FB\u3057\u3066\u7D71\u8A08\u60C5\u5831\u3092\u53CE\u96C6\u3059\u308B\n\t */\n\tprivate exploreSearchSpace(grid: Grid, currIdx: number, visitedMask: bigint, path: number[], hexagonsOnPath: number, totalHexagons: number, adj: { next: number; isHexagon: boolean; isBroken: boolean }[][], endNodes: number[], fingerprints: Set<string>, stats: { totalNodesVisited: number; branchingPoints: number; solutions: number; maxDepth: number; backtracks: number }, limit: number, externalCells?: Set<string>, hasCellMarks: boolean = true): void {\n\t\tstats.totalNodesVisited++;\n\t\tstats.maxDepth = Math.max(stats.maxDepth, path.length);\n\t\tif (stats.totalNodesVisited > limit) return;\n\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\n\t\tif (endNodes.includes(currIdx)) {\n\t\t\tif (hexagonsOnPath === totalHexagons) {\n\t\t\t\tconst points = path.map((idx) => ({ x: idx % (grid.cols + 1), y: Math.floor(idx / (grid.cols + 1)) }));\n\t\t\t\tconst solutionPath = { points };\n\t\t\t\t// symmetry\u30E2\u30FC\u30C9\u306E\u969B\u3001\u3082\u3046\u4E00\u65B9\u3082EndNode\u306B\u3044\u308B\u5FC5\u8981\u304C\u3042\u308B\n\t\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\t\tconst snEnd = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\t\tconst nodeCols = grid.cols + 1;\n\t\t\t\t\tif (grid.nodes[Math.floor(snEnd / nodeCols)][snEnd % nodeCols].type !== NodeType.End) return;\n\t\t\t\t}\n\n\t\t\t\t// \u30BB\u30EB\u30DE\u30FC\u30AF\u304C\u306A\u3044\u5834\u5408\u306F\u3001\u3053\u306E\u6642\u70B9\u3067\u6709\u52B9\u306A\u89E3\u3068\u3057\u3066\u78BA\u5B9A\u3067\u304D\u308B\uFF08DFS\u306B\u3088\u308A\u30D1\u30B9\u306E\u6B63\u5F53\u6027\u3068\u5168\u516D\u89D2\u5F62\u901A\u904E\u306F\u4FDD\u8A3C\u6E08\u307F\uFF09\n\t\t\t\tif (!hasCellMarks) {\n\t\t\t\t\tconst fp = this.getFingerprint(grid, points, undefined, externalCells);\n\t\t\t\t\tif (!fingerprints.has(fp)) {\n\t\t\t\t\t\tfingerprints.add(fp);\n\t\t\t\t\t\tstats.solutions++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// \u30BB\u30EB\u30DE\u30FC\u30AF\u304C\u3042\u308B\u5834\u5408\u306F\u8A73\u7D30\u306A\u691C\u8A3C\u3092\u884C\u3046\n\t\t\t\t\tconst result = this.validate(grid, solutionPath, externalCells);\n\t\t\t\t\tif (result.isValid) {\n\t\t\t\t\t\tconst fp = this.getFingerprint(grid, points, result.regions, externalCells);\n\t\t\t\t\t\tif (!fingerprints.has(fp)) {\n\t\t\t\t\t\t\tfingerprints.add(fp);\n\t\t\t\t\t\t\tstats.solutions++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.canReachEndOptimized(currIdx, visitedMask, adj, endNodes)) {\n\t\t\tstats.backtracks++;\n\t\t\treturn;\n\t\t}\n\n\t\tconst validMoves = [];\n\t\tfor (const edge of adj[currIdx]) {\n\t\t\tif (edge.isBroken) continue;\n\t\t\tif (visitedMask & (1n << BigInt(edge.next))) continue;\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snCurr = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\n\t\t\t\t// \u5BFE\u79F0\u70B9\u3068\u306E\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\n\t\t\t\tif (edge.next === snNext) continue; // \u30CE\u30FC\u30C9\u885D\u7A81\n\t\t\t\tif (currIdx === snNext && edge.next === snCurr) continue; // \u30A8\u30C3\u30B8\u885D\u7A81\uFF08\u53CD\u5BFE\u5411\u304D\uFF09\n\t\t\t}\n\n\t\t\t// \u516D\u89D2\u5F62\u306E\u679D\u5208\u308A\uFF08\u73FE\u5728\u306E\u30CE\u30FC\u30C9\u304B\u3089\u5FC5\u9808\u30A8\u30C3\u30B8\u304C\u51FA\u3066\u3044\u308B\u304C\u3001\u305D\u308C\u3092\u9078\u3070\u306A\u3044\u5834\u5408\u306F\u7121\u52B9\uFF09\n\t\t\tlet possible = true;\n\t\t\tfor (const otherEdge of adj[currIdx]) {\n\t\t\t\tif (otherEdge.isHexagon) {\n\t\t\t\t\tconst isAlreadyOnPath = path.length >= 2 && otherEdge.next === path[path.length - 2];\n\t\t\t\t\tconst isNextMove = otherEdge.next === edge.next;\n\t\t\t\t\tif (!isAlreadyOnPath && !isNextMove) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (possible) validMoves.push(edge);\n\t\t}\n\n\t\tif (validMoves.length > 1) stats.branchingPoints++;\n\n\t\t// \u5927\u304D\u306A\u76E4\u9762\u3067\u306F\u63A2\u7D22\u304C\u30EA\u30DF\u30C3\u30C8\u306B\u9054\u3057\u3084\u3059\u3044\u305F\u3081\u3001\u63A2\u7D22\u9806\u5E8F\u3092\u30E9\u30F3\u30C0\u30E0\u5316\u3057\u3066\n\t\t// \u5C11\u306A\u304F\u3068\u3082\u3044\u304F\u3064\u304B\u306E\u89E3\u3092\u898B\u3064\u3051\u3084\u3059\u304F\u3059\u308B\n\t\tif (grid.rows * grid.cols > 30) {\n\t\t\tfor (let i = validMoves.length - 1; i > 0; i--) {\n\t\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t\t[validMoves[i], validMoves[j]] = [validMoves[j], validMoves[i]];\n\t\t\t}\n\t\t}\n\n\t\tconst nodeCols = grid.cols + 1;\n\t\tfor (const move of validMoves) {\n\t\t\tconst nodeIsHex = grid.nodes[Math.floor(move.next / nodeCols)][move.next % nodeCols].type === NodeType.Hexagon ? 1 : 0;\n\t\t\tpath.push(move.next);\n\n\t\t\tlet nextVisitedMask = visitedMask | (1n << BigInt(move.next));\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, move.next);\n\t\t\t\tnextVisitedMask |= 1n << BigInt(snNext);\n\t\t\t}\n\n\t\t\tthis.exploreSearchSpace(grid, move.next, nextVisitedMask, path, hexagonsOnPath + (move.isHexagon ? 1 : 0) + nodeIsHex, totalHexagons, adj, endNodes, fingerprints, stats, limit, externalCells, hasCellMarks);\n\t\t\tpath.pop();\n\t\t\tif (stats.totalNodesVisited > limit) return;\n\t\t}\n\t}\n\n\t/**\n\t * \u6B63\u89E3\u6570\u3092\u30AB\u30A6\u30F3\u30C8\u3059\u308B\n\t */\n\tpublic countSolutions(grid: Grid, limit: number = 100): number {\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst nodeCols = cols + 1;\n\t\tconst nodeCount = (rows + 1) * nodeCols;\n\t\tconst adj = Array.from({ length: nodeCount }, () => [] as { next: number; isHexagon: boolean; isBroken: boolean }[]);\n\t\tconst startNodes: number[] = [];\n\t\tconst endNodes: number[] = [];\n\t\tconst hexagonEdges = new Set<string>();\n\t\tconst hexagonNodes = new Set<number>();\n\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tconst u = r * nodeCols + c;\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Start) startNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.End) endNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Hexagon) hexagonNodes.add(u);\n\n\t\t\t\tif (c < cols) {\n\t\t\t\t\tconst v = u + 1;\n\t\t\t\t\tconst type = grid.hEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r }));\n\t\t\t\t}\n\t\t\t\tif (r < rows) {\n\t\t\t\t\tconst v = u + nodeCols;\n\t\t\t\t\tconst type = grid.vEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 }));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst fingerprints = new Set<string>();\n\t\tconst totalHexagons = hexagonEdges.size + hexagonNodes.size;\n\t\tconst externalCells = this.getExternalCells(grid);\n\n\t\t// \u30BB\u30EB\u30DE\u30FC\u30AF\uFF08\u56DB\u89D2\u3001\u661F\u3001\u30C6\u30C8\u30EA\u30B9\u3001\u6D88\u3057\u30B4\u30E0\uFF09\u304C\u3042\u308B\u304B\u4E8B\u524D\u306B\u30C1\u30A7\u30C3\u30AF\n\t\tlet hasCellMarks = false;\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tif (grid.cells[r][c].type !== CellType.None) {\n\t\t\t\t\thasCellMarks = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasCellMarks) break;\n\t\t}\n\n\t\tfor (const startIdx of startNodes) {\n\t\t\tconst startIsHex = hexagonNodes.has(startIdx) ? 1 : 0;\n\t\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\t\tlet visitedMask = 1n << BigInt(startIdx);\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snStart = this.getSymmetricalPointIndex(grid, startIdx);\n\t\t\t\tif (snStart === startIdx) continue;\n\t\t\t\tvisitedMask |= 1n << BigInt(snStart);\n\t\t\t}\n\t\t\tthis.findPathsOptimized(grid, startIdx, visitedMask, [startIdx], startIsHex, totalHexagons, adj, endNodes, fingerprints, limit, externalCells, hasCellMarks);\n\t\t}\n\t\treturn fingerprints.size;\n\t}\n\n\tprivate findPathsOptimized(grid: Grid, currIdx: number, visitedMask: bigint, path: number[], hexagonsOnPath: number, totalHexagons: number, adj: { next: number; isHexagon: boolean; isBroken: boolean }[][], endNodes: number[], fingerprints: Set<string>, limit: number, externalCells?: Set<string>, hasCellMarks: boolean = true): void {\n\t\tif (fingerprints.size >= limit) return;\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\n\t\tif (endNodes.includes(currIdx)) {\n\t\t\tif (hexagonsOnPath === totalHexagons) {\n\t\t\t\tconst points = path.map((idx) => ({ x: idx % (grid.cols + 1), y: Math.floor(idx / (grid.cols + 1)) }));\n\t\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\t\tconst snEnd = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\t\tconst nodeCols = grid.cols + 1;\n\t\t\t\t\tif (grid.nodes[Math.floor(snEnd / nodeCols)][snEnd % nodeCols].type !== NodeType.End) return;\n\t\t\t\t}\n\n\t\t\t\tif (!hasCellMarks) {\n\t\t\t\t\tfingerprints.add(this.getFingerprint(grid, points, undefined, externalCells));\n\t\t\t\t} else {\n\t\t\t\t\tconst solutionPath = { points };\n\t\t\t\t\tconst result = this.validate(grid, solutionPath, externalCells);\n\t\t\t\t\tif (result.isValid) {\n\t\t\t\t\t\tfingerprints.add(this.getFingerprint(grid, points, result.regions, externalCells));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (!this.canReachEndOptimized(currIdx, visitedMask, adj, endNodes)) return;\n\t\tfor (const edge of adj[currIdx]) {\n\t\t\tif (edge.isBroken) continue;\n\t\t\tif (visitedMask & (1n << BigInt(edge.next))) continue;\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snCurr = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\t\t\t\tif (edge.next === snNext) continue;\n\t\t\t\tif (currIdx === snNext && edge.next === snCurr) continue;\n\t\t\t}\n\n\t\t\tlet possible = true;\n\t\t\tfor (const otherEdge of adj[currIdx]) {\n\t\t\t\tif (otherEdge.isHexagon) {\n\t\t\t\t\tconst isAlreadyOnPath = path.length >= 2 && otherEdge.next === path[path.length - 2];\n\t\t\t\t\tconst isNextMove = otherEdge.next === edge.next;\n\t\t\t\t\tif (!isAlreadyOnPath && !isNextMove) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!possible) continue;\n\n\t\t\tconst nodeCols = grid.cols + 1;\n\t\t\tconst nodeIsHex = grid.nodes[Math.floor(edge.next / nodeCols)][edge.next % nodeCols].type === NodeType.Hexagon ? 1 : 0;\n\t\t\tpath.push(edge.next);\n\n\t\t\tlet nextVisitedMask = visitedMask | (1n << BigInt(edge.next));\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\t\t\t\tnextVisitedMask |= 1n << BigInt(snNext);\n\t\t\t}\n\n\t\t\tthis.findPathsOptimized(grid, edge.next, nextVisitedMask, path, hexagonsOnPath + (edge.isHexagon ? 1 : 0) + nodeIsHex, totalHexagons, adj, endNodes, fingerprints, limit, externalCells, hasCellMarks);\n\t\t\tpath.pop();\n\t\t\tif (fingerprints.size >= limit) return;\n\t\t}\n\t}\n\n\t/**\n\t * \u7D42\u7AEF\u307E\u3067\u5230\u9054\u53EF\u80FD\u304B\u30D3\u30C3\u30C8\u30DE\u30B9\u30AFBFS\u3067\u9AD8\u901F\u306B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate canReachEndOptimized(curr: number, visitedMask: bigint, adj: { next: number; isBroken: boolean }[][], endNodes: number[]): boolean {\n\t\tlet queue = [curr];\n\t\tlet localVisited = visitedMask;\n\t\tlet head = 0;\n\t\twhile (head < queue.length) {\n\t\t\tconst u = queue[head++];\n\t\t\tif (endNodes.includes(u)) return true;\n\t\t\tfor (const edge of adj[u])\n\t\t\t\tif (!edge.isBroken && !(localVisited & (1n << BigInt(edge.next)))) {\n\t\t\t\t\tlocalVisited |= 1n << BigInt(edge.next);\n\t\t\t\t\tqueue.push(edge.next);\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u30D1\u30B9\u306E\u8AD6\u7406\u7684\u306A\u6307\u7D0B\u3092\u53D6\u5F97\u3059\u308B\uFF08\u533A\u753B\u5206\u3051\u306B\u57FA\u3065\u304D\u3001\u540C\u4E00\u89E3\u3092\u6392\u9664\u3059\u308B\u305F\u3081\uFF09\n\t */\n\tprivate getFingerprint(grid: Grid, path: Point[], precalculatedRegions?: Point[][], externalCells?: Set<string>): string {\n\t\tconst regions = precalculatedRegions || this.calculateRegions(grid, path, [], externalCells);\n\t\tconst regionFingerprints = regions\n\t\t\t.map((region) => {\n\t\t\t\tconst marks = region\n\t\t\t\t\t.map((p) => grid.cells[p.y][p.x])\n\t\t\t\t\t.filter((c) => c.type !== CellType.None)\n\t\t\t\t\t.map((c) => `${c.type}:${c.color}`)\n\t\t\t\t\t.sort();\n\t\t\t\treturn marks.join(\",\");\n\t\t\t})\n\t\t\t.sort();\n\t\treturn regionFingerprints.filter((f) => f.length > 0).join(\"|\") || \"empty\";\n\t}\n}\n", "import { Grid } from \"./grid\";\nimport { CellType, Color, type EdgeConstraint, EdgeType, type GenerationOptions, NodeType, type Point, SymmetryType } from \"./types\";\nimport { PuzzleValidator } from \"./validator\";\n\n/**\n * \u30D1\u30BA\u30EB\u3092\u81EA\u52D5\u751F\u6210\u3059\u308B\u30AF\u30E9\u30B9\n */\nexport class PuzzleGenerator {\n\t/**\n\t * \u30D1\u30BA\u30EB\u3092\u751F\u6210\u3059\u308B\n\t * @param rows \u884C\u6570\n\t * @param cols \u5217\u6570\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\n\t * @returns \u751F\u6210\u3055\u308C\u305F\u30B0\u30EA\u30C3\u30C9\n\t */\n\tpublic generate(rows: number, cols: number, options: GenerationOptions = {}): Grid {\n\t\tconst targetDifficulty = options.difficulty ?? 0.5;\n\t\tconst validator = new PuzzleValidator();\n\t\tlet bestGrid: Grid | null = null;\n\t\tlet bestScore = -1;\n\n\t\t// \u8A66\u884C\u56DE\u6570\u306E\u8A2D\u5B9A\n\t\tconst maxAttempts = rows * cols > 30 ? 100 : 80;\n\t\tconst markAttemptsPerPath = 5;\n\n\t\tconst symmetry = options.symmetry || SymmetryType.None;\n\t\tlet startPoint: Point = { x: 0, y: rows };\n\t\tlet endPoint: Point = { x: cols, y: 0 };\n\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\t// \u5DE6\u53F3\u5BFE\u79F0\uFF1A\u30B9\u30BF\u30FC\u30C8\u3068\u540C\u3058\u5074\uFF08\u5DE6\u5074\uFF09\u306B\u30B4\u30FC\u30EB\u3092\u7F6E\u304F\u3053\u3068\u3067\u3001\u8EF8\u3092\u8DE8\u3050\u5FC5\u8981\u3092\u306A\u304F\u3059\n\t\t\tendPoint = { x: 0, y: 0 };\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\t// \u4E0A\u4E0B\u5BFE\u79F0\uFF1A\u30B9\u30BF\u30FC\u30C8\u3068\u540C\u3058\u5074\uFF08\u4E0B\u5074\uFF09\u306B\u30B4\u30FC\u30EB\u3092\u7F6E\u304F\n\t\t\tendPoint = { x: cols, y: rows };\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\t// \u70B9\u5BFE\u79F0\uFF1A\u70B9\u5BFE\u79F0\u306A\u30B9\u30BF\u30FC\u30C8\u3068\u30B4\u30FC\u30EB\u304C\u91CD\u306A\u3089\u306A\u3044\u3088\u3046\u306B\u914D\u7F6E\n\t\t\tendPoint = { x: cols, y: rows };\n\t\t}\n\n\t\tlet currentPath: Point[] | null = null;\n\t\tlet precalculatedRegions: Point[][] | null = null;\n\t\tlet precalculatedBoundaryEdges: { type: \"h\" | \"v\"; r: number; c: number }[][] | null = null;\n\n\t\tfor (let attempt = 0; attempt < maxAttempts; attempt++) {\n\t\t\t// \u4E00\u5B9A\u56DE\u6570\u3054\u3068\u306B\u65B0\u3057\u3044\u30D1\u30B9\u3092\u751F\u6210\u3059\u308B\n\t\t\tif (attempt % markAttemptsPerPath === 0) {\n\t\t\t\tcurrentPath = this.generateRandomPath(new Grid(rows, cols), startPoint, endPoint, options.pathLength, symmetry);\n\n\t\t\t\t// \u30D1\u30B9\u304C\u6C7A\u307E\u3063\u305F\u6642\u70B9\u3067\u3001\u533A\u753B\u3068\u5883\u754C\u30A8\u30C3\u30B8\u3092\u8A08\u7B97\u3057\u3066\u304A\u304F\uFF08\u30DE\u30FC\u30AF\u751F\u6210\u3067\u6D41\u7528\uFF09\n\t\t\t\tconst tempGrid = new Grid(rows, cols);\n\t\t\t\tconst symPath = symmetry !== SymmetryType.None ? currentPath.map((p) => this.getSymmetricalPoint(tempGrid, p, symmetry)) : [];\n\t\t\t\tprecalculatedRegions = this.calculateRegions(tempGrid, currentPath, symPath);\n\t\t\t\tprecalculatedBoundaryEdges = precalculatedRegions.map((region) => this.getRegionBoundaryEdges(tempGrid, region, currentPath!, symPath));\n\t\t\t}\n\n\t\t\tconst grid = this.generateFromPath(rows, cols, currentPath!, options, precalculatedRegions!, precalculatedBoundaryEdges!);\n\n\t\t\t// \u5FC5\u9808\u5236\u7D04\u304C\u542B\u307E\u308C\u3066\u3044\u308B\u304B\u78BA\u8A8D\n\t\t\tif (!this.checkAllRequestedConstraintsPresent(grid, options)) continue;\n\n\t\t\t// \u96E3\u6613\u5EA6\u306E\u7B97\u51FA\n\t\t\tconst difficulty = validator.calculateDifficulty(grid);\n\t\t\tif (difficulty === 0) continue;\n\n\t\t\tconst diffFromTarget = Math.abs(difficulty - targetDifficulty);\n\t\t\tif (bestGrid === null || diffFromTarget < Math.abs(bestScore - targetDifficulty)) {\n\t\t\t\tbestScore = difficulty;\n\t\t\t\tbestGrid = grid;\n\t\t\t}\n\n\t\t\t// \u30BF\u30FC\u30B2\u30C3\u30C8\u306B\u8FD1\u3044\u5834\u5408\u306F\u65E9\u671F\u7D42\u4E86\n\t\t\tif (targetDifficulty > 0.8 && difficulty > 0.8) break;\n\t\t\tif (diffFromTarget < 0.01) break; // \u3088\u308A\u53B3\u3057\u304F\u65E9\u671F\u7D42\u4E86\u5224\u5B9A\n\t\t}\n\n\t\t// \u898B\u3064\u304B\u3089\u306A\u304B\u3063\u305F\u5834\u5408\u306F\u6700\u5F8C\u306B\u751F\u6210\u3057\u305F\u3082\u306E\u3092\u8FD4\u3059\uFF08\u901A\u5E38\u306F\u3042\u308A\u3048\u306A\u3044\uFF09\n\t\tif (!bestGrid) {\n\t\t\tconst path = this.generateRandomPath(new Grid(rows, cols), startPoint, endPoint, options.pathLength, symmetry);\n\t\t\treturn this.generateFromPath(rows, cols, path, options);\n\t\t}\n\t\treturn bestGrid;\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u30D1\u30BA\u30EB\u3092\u69CB\u7BC9\u3059\u308B\n\t */\n\tprivate generateFromPath(rows: number, cols: number, solutionPath: Point[], options: GenerationOptions, precalculatedRegions?: Point[][], precalculatedBoundaryEdges?: { type: \"h\" | \"v\"; r: number; c: number }[][]): Grid {\n\t\tconst grid = new Grid(rows, cols);\n\t\tconst symmetry = options.symmetry || SymmetryType.None;\n\t\tgrid.symmetry = symmetry;\n\n\t\tlet startPoint: Point = { x: 0, y: rows };\n\t\tlet endPoint: Point = { x: cols, y: 0 };\n\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\tendPoint = { x: 0, y: 0 };\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\tendPoint = { x: cols, y: rows };\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\tendPoint = { x: cols, y: rows };\n\t\t}\n\n\t\tgrid.nodes[startPoint.y][startPoint.x].type = NodeType.Start;\n\t\tgrid.nodes[endPoint.y][endPoint.x].type = NodeType.End;\n\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tconst symStart = this.getSymmetricalPoint(grid, startPoint, symmetry);\n\t\t\tconst symEnd = this.getSymmetricalPoint(grid, endPoint, symmetry);\n\t\t\tgrid.nodes[symStart.y][symStart.x].type = NodeType.Start;\n\t\t\tgrid.nodes[symEnd.y][symEnd.x].type = NodeType.End;\n\t\t}\n\n\t\t// \u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u5236\u7D04\uFF08\u8A18\u53F7\uFF09\u3092\u914D\u7F6E\n\t\tconst symPath = symmetry !== SymmetryType.None ? solutionPath.map((p) => this.getSymmetricalPoint(grid, p, symmetry)) : [];\n\t\tthis.applyConstraintsBasedOnPath(grid, solutionPath, options, symPath, precalculatedRegions, precalculatedBoundaryEdges);\n\n\t\t// \u65AD\u7DDA\u30A8\u30C3\u30B8\u306E\u9069\u7528\n\t\tif (options.useBrokenEdges) {\n\t\t\tthis.applyBrokenEdges(grid, solutionPath, options);\n\t\t}\n\n\t\t// \u4E0D\u8981\u306A\u30A8\u30C3\u30B8\u306E\u524A\u9664\uFF08Absent\u5316\uFF09\u3068\u30AF\u30EA\u30FC\u30CB\u30F3\u30B0\n\t\tthis.cleanGrid(grid);\n\t\treturn grid;\n\t}\n\n\t/**\n\t * \u30E9\u30F3\u30C0\u30E0\u306A\u6B63\u89E3\u30D1\u30B9\u3092\u751F\u6210\u3059\u308B\n\t * @param targetLengthFactor 0.0 (\u6700\u77ED) - 1.0 (\u6700\u9577)\n\t */\n\tprivate generateRandomPath(grid: Grid, start: Point, end: Point, targetLengthFactor?: number, symmetry: SymmetryType = SymmetryType.None): Point[] {\n\t\tif (targetLengthFactor === undefined) {\n\t\t\treturn this.generateSingleRandomPath(grid, start, end, undefined, symmetry);\n\t\t}\n\n\t\t// \u6307\u5B9A\u3055\u308C\u305F\u9577\u3055\u306B\u8FD1\u3044\u30D1\u30B9\u3092\u63A2\u3059\n\t\tconst minLen = grid.rows + grid.cols;\n\t\tconst maxLen = (grid.rows + 1) * (grid.cols + 1) - 1;\n\t\tconst targetLen = minLen + targetLengthFactor * (maxLen - minLen);\n\n\t\tlet bestPath: Point[] = [];\n\t\tlet bestDiff = Infinity;\n\n\t\tconst attempts = grid.rows * grid.cols > 30 ? 30 : 50;\n\t\tfor (let i = 0; i < attempts; i++) {\n\t\t\t// \u6700\u521D\u306E\u65B9\u306E\u8A66\u884C\u306F\u30D0\u30A4\u30A2\u30B9\u3092\u5F37\u3081\u306B\u304B\u3051\u308B\n\t\t\tconst currentPath = this.generateSingleRandomPath(grid, start, end, targetLengthFactor, symmetry);\n\t\t\tif (currentPath.length === 0) continue;\n\n\t\t\tconst currentLen = currentPath.length - 1;\n\t\t\tconst diff = Math.abs(currentLen - targetLen);\n\n\t\t\tif (diff < bestDiff) {\n\t\t\t\tbestDiff = diff;\n\t\t\t\tbestPath = currentPath;\n\t\t\t}\n\n\t\t\t// \u5341\u5206\u306B\u8FD1\u3044\u30D1\u30B9\u304C\u898B\u3064\u304B\u3063\u305F\u3089\u7D42\u4E86\n\t\t\tif (bestDiff <= 2) break;\n\t\t}\n\n\t\treturn bestPath;\n\t}\n\n\t/**\n\t * 1\u672C\u306E\u30E9\u30F3\u30C0\u30E0\u30D1\u30B9\u3092\u751F\u6210\u3059\u308B\n\t */\n\tprivate generateSingleRandomPath(grid: Grid, start: Point, end: Point, biasFactor?: number, symmetry: SymmetryType = SymmetryType.None): Point[] {\n\t\tconst visited = new Set<string>();\n\t\tconst path: Point[] = [];\n\t\tlet nodesVisited = 0;\n\t\tconst limit = grid.rows * grid.cols * 20;\n\n\t\tconst findPath = (current: Point): boolean => {\n\t\t\tnodesVisited++;\n\t\t\tif (nodesVisited > limit) return false;\n\n\t\t\tvisited.add(`${current.x},${current.y}`);\n\t\t\tconst snCurrent = this.getSymmetricalPoint(grid, current, symmetry);\n\t\t\tvisited.add(`${snCurrent.x},${snCurrent.y}`);\n\n\t\t\tpath.push(current);\n\t\t\tif (current.x === end.x && current.y === end.y) return true;\n\n\t\t\tlet neighbors = this.getValidNeighbors(grid, current, visited);\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tneighbors = neighbors.filter((n) => {\n\t\t\t\t\tconst sn = this.getSymmetricalPoint(grid, n, symmetry);\n\t\t\t\t\tif (sn.x < 0 || sn.x > grid.cols || sn.y < 0 || sn.y > grid.rows) return false;\n\t\t\t\t\tif (visited.has(`${sn.x},${sn.y}`)) return false;\n\t\t\t\t\t// \u30CE\u30FC\u30C9\u885D\u7A81\uFF08\u73FE\u5728\u306E\u79FB\u52D5\u5148\u304C\u81EA\u5206\u81EA\u8EAB\u306E\u5BFE\u79F0\u70B9\u3067\u3042\u308B\u5834\u5408\u3082NG\uFF09\n\t\t\t\t\tif (n.x === sn.x && n.y === sn.y) return false;\n\t\t\t\t\t// \u30A8\u30C3\u30B8\u885D\u7A81\n\t\t\t\t\tconst edgeKey = this.getEdgeKey(current, n);\n\t\t\t\t\tconst symEdgeKey = this.getEdgeKey(snCurrent, sn);\n\t\t\t\t\tif (edgeKey === symEdgeKey) return false;\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (biasFactor !== undefined) {\n\t\t\t\tneighbors.sort((a, b) => {\n\t\t\t\t\tconst da = Math.abs(a.x - end.x) + Math.abs(a.y - end.y);\n\t\t\t\t\tconst db = Math.abs(b.x - end.x) + Math.abs(b.y - end.y);\n\t\t\t\t\tconst score = (da - db) * (1 - biasFactor * 2);\n\t\t\t\t\treturn score + (Math.random() - 0.5) * 1.5;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.shuffleArray(neighbors);\n\t\t\t}\n\n\t\t\tfor (const next of neighbors) {\n\t\t\t\tif (findPath(next)) return true;\n\t\t\t}\n\n\t\t\tpath.pop();\n\t\t\tvisited.delete(`${current.x},${current.y}`);\n\t\t\tvisited.delete(`${snCurrent.x},${snCurrent.y}`);\n\t\t\treturn false;\n\t\t};\n\t\tfindPath(start);\n\t\treturn path;\n\t}\n\n\tprivate getValidNeighbors(grid: Grid, p: Point, visited: Set<string>): Point[] {\n\t\tconst candidates: Point[] = [];\n\t\tconst directions = [\n\t\t\t{ x: 0, y: -1 },\n\t\t\t{ x: 1, y: 0 },\n\t\t\t{ x: 0, y: 1 },\n\t\t\t{ x: -1, y: 0 },\n\t\t];\n\t\tfor (const d of directions) {\n\t\t\tconst nx = p.x + d.x;\n\t\t\tconst ny = p.y + d.y;\n\t\t\tif (nx >= 0 && nx <= grid.cols && ny >= 0 && ny <= grid.rows) {\n\t\t\t\tif (!visited.has(`${nx},${ny}`)) candidates.push({ x: nx, y: ny });\n\t\t\t}\n\t\t}\n\t\treturn candidates;\n\t}\n\n\t/**\n\t * \u89E3\u30D1\u30B9\u304C\u901A\u3063\u3066\u3044\u306A\u3044\u5834\u6240\u306B\u30E9\u30F3\u30C0\u30E0\u306B\u65AD\u7DDA\uFF08Broken/Absent\uFF09\u3092\u914D\u7F6E\u3059\u308B\n\t */\n\tprivate applyBrokenEdges(grid: Grid, path: Point[], options: GenerationOptions) {\n\t\tconst complexity = options.complexity ?? 0.5;\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) pathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\n\t\tconst unusedEdges: { type: \"h\" | \"v\"; r: number; c: number; p1: Point; p2: Point }[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tconst p1 = { x: c, y: r };\n\t\t\t\tconst p2 = { x: c + 1, y: r };\n\t\t\t\tif (!pathEdges.has(this.getEdgeKey(p1, p2))) unusedEdges.push({ type: \"h\", r, c, p1, p2 });\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tconst p1 = { x: c, y: r };\n\t\t\t\tconst p2 = { x: c, y: r + 1 };\n\t\t\t\tif (!pathEdges.has(this.getEdgeKey(p1, p2))) unusedEdges.push({ type: \"v\", r, c, p1, p2 });\n\t\t\t}\n\t\t}\n\n\t\tthis.shuffleArray(unusedEdges);\n\t\t// \u76E4\u9762\u30B5\u30A4\u30BA\u306B\u5FDC\u3058\u3066\u65AD\u7DDA\u6570\u3092\u30B9\u30B1\u30FC\u30EB\u3055\u305B\u308B\n\t\tconst targetCount = Math.max(1, Math.floor((complexity * (grid.rows * grid.cols)) / 4));\n\t\tlet placed = 0;\n\t\tfor (const edge of unusedEdges) {\n\t\t\tif (placed >= targetCount) break;\n\t\t\t// \u307E\u305A\u306FBroken\u3068\u3057\u3066\u914D\u7F6E\n\t\t\tif (edge.type === \"h\") grid.hEdges[edge.r][edge.c].type = EdgeType.Broken;\n\t\t\telse grid.vEdges[edge.r][edge.c].type = EdgeType.Broken;\n\t\t\tplaced++;\n\t\t}\n\n\t\t// \u5916\u5468\u307E\u305F\u306FAbsent\u306B\u63A5\u89E6\u3057\u3066\u3044\u308BBroken\u3092Absent\u306B\u7F6E\u304D\u63DB\u3048\u308B\uFF08\u4F1D\u64AD\uFF09\n\t\tlet changed = true;\n\t\twhile (changed) {\n\t\t\tchanged = false;\n\t\t\t// Horizontal edges\n\t\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Broken) {\n\t\t\t\t\t\tif (this.canBecomeAbsent(grid, { type: \"h\", r, c })) {\n\t\t\t\t\t\t\tgrid.hEdges[r][c].type = EdgeType.Absent;\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Vertical edges\n\t\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Broken) {\n\t\t\t\t\t\tif (this.canBecomeAbsent(grid, { type: \"v\", r, c })) {\n\t\t\t\t\t\t\tgrid.vEdges[r][c].type = EdgeType.Absent;\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// \u5468\u56F2\u304C\u5168\u3066\u65AD\u7DDA\u3057\u3066\u3044\u308B\u30CE\u30FC\u30C9\u306E\u5168\u30A8\u30C3\u30B8\u3092Absent\u5316\u3059\u308B\uFF08\u65E2\u5B58\u30ED\u30B8\u30C3\u30AF\u306E\u7DAD\u6301\uFF09\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tconst edgesWithMeta: { e: EdgeConstraint; type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\t\t\tif (c > 0) edgesWithMeta.push({ e: grid.hEdges[r][c - 1], type: \"h\", r, c: c - 1 });\n\t\t\t\tif (c < grid.cols) edgesWithMeta.push({ e: grid.hEdges[r][c], type: \"h\", r, c });\n\t\t\t\tif (r > 0) edgesWithMeta.push({ e: grid.vEdges[r - 1][c], type: \"v\", r: r - 1, c });\n\t\t\t\tif (r < grid.rows) edgesWithMeta.push({ e: grid.vEdges[r][c], type: \"v\", r, c });\n\n\t\t\t\tif (edgesWithMeta.length > 0 && edgesWithMeta.every((m) => m.e.type === EdgeType.Broken || m.e.type === EdgeType.Absent)) {\n\t\t\t\t\tif (edgesWithMeta.every((m) => !this.isAdjacentToMark(grid, m))) {\n\t\t\t\t\t\tfor (const m of edgesWithMeta) m.e.type = EdgeType.Absent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u30A8\u30C3\u30B8\u304CAbsent\u306B\u5909\u63DB\u53EF\u80FD\u304B\u5224\u5B9A\u3059\u308B\n\t */\n\tprivate canBecomeAbsent(grid: Grid, edge: { type: \"h\" | \"v\"; r: number; c: number }): boolean {\n\t\t// \u30DE\u30FC\u30AF\u306B\u96A3\u63A5\u3057\u3066\u3044\u308B\u5834\u5408\u306FAbsent\u7981\u6B62\n\t\tif (this.isAdjacentToMark(grid, edge)) return false;\n\n\t\t// 1. \u5916\u5468\u306B\u3042\u308B\u304B\n\t\tif (edge.type === \"h\") {\n\t\t\tif (edge.r === 0 || edge.r === grid.rows) return true;\n\t\t} else {\n\t\t\tif (edge.c === 0 || edge.c === grid.cols) return true;\n\t\t}\n\n\t\t// 2. \u4ED6\u306EAbsent\u30A8\u30C3\u30B8\u306B\u63A5\u89E6\uFF08\u30CE\u30FC\u30C9\u3092\u5171\u6709\uFF09\u3057\u3066\u3044\u308B\u304B\n\t\tconst nodes =\n\t\t\tedge.type === \"h\"\n\t\t\t\t? [\n\t\t\t\t\t\t{ x: edge.c, y: edge.r },\n\t\t\t\t\t\t{ x: edge.c + 1, y: edge.r },\n\t\t\t\t\t]\n\t\t\t\t: [\n\t\t\t\t\t\t{ x: edge.c, y: edge.r },\n\t\t\t\t\t\t{ x: edge.c, y: edge.r + 1 },\n\t\t\t\t\t];\n\n\t\tfor (const node of nodes) {\n\t\t\tconst adjEdges = [\n\t\t\t\t{ type: \"h\", r: node.y, c: node.x - 1 },\n\t\t\t\t{ type: \"h\", r: node.y, c: node.x },\n\t\t\t\t{ type: \"v\", r: node.y - 1, c: node.x },\n\t\t\t\t{ type: \"v\", r: node.y, c: node.x },\n\t\t\t];\n\t\t\tfor (const adj of adjEdges) {\n\t\t\t\tif (adj.c >= 0 && adj.c <= grid.cols && adj.r >= 0 && adj.r <= grid.rows) {\n\t\t\t\t\tif (adj.type === \"h\" && adj.c < grid.cols) {\n\t\t\t\t\t\tif (grid.hEdges[adj.r][adj.c].type === EdgeType.Absent) return true;\n\t\t\t\t\t} else if (adj.type === \"v\" && adj.r < grid.rows) {\n\t\t\t\t\t\tif (grid.vEdges[adj.r][adj.c].type === EdgeType.Absent) return true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u5230\u9054\u4E0D\u53EF\u80FD\u306A\u30A8\u30EA\u30A2\u3092Absent\u5316\u3057\u3001\u5916\u90E8\u306B\u6F0F\u308C\u305F\u30BB\u30EB\u3092\u30AF\u30EA\u30A2\u3059\u308B\n\t */\n\tprivate cleanGrid(grid: Grid) {\n\t\tconst startNodes: { x: number; y: number }[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) if (grid.nodes[r][c].type === NodeType.Start) startNodes.push({ x: c, y: r });\n\t\t}\n\n\t\tconst reachableNodes = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [...startNodes];\n\t\tfor (const p of startNodes) reachableNodes.add(`${p.x},${p.y}`);\n\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.vEdges[curr.y - 1]?.[curr.x] },\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.vEdges[curr.y]?.[curr.x] },\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.hEdges[curr.y]?.[curr.x - 1] },\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.hEdges[curr.y]?.[curr.x] },\n\t\t\t];\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.edge && n.edge.type !== EdgeType.Absent) {\n\t\t\t\t\tif (!reachableNodes.has(`${n.nx},${n.ny}`)) {\n\t\t\t\t\t\treachableNodes.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) if (!reachableNodes.has(`${c},${r}`) || !reachableNodes.has(`${c + 1},${r}`)) grid.hEdges[r][c].type = EdgeType.Absent;\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) if (!reachableNodes.has(`${c},${r}`) || !reachableNodes.has(`${c},${r + 1}`)) grid.vEdges[r][c].type = EdgeType.Absent;\n\t\t}\n\n\t\tconst external = this.getExternalCells(grid);\n\t\tfor (const cellKey of external) {\n\t\t\tconst [c, r] = cellKey.split(\",\").map(Number);\n\t\t\tgrid.cells[r][c].type = CellType.None;\n\t\t}\n\t}\n\n\tprivate getExternalCells(grid: Grid): Set<string> {\n\t\tconst external = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [];\n\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\tif (grid.hEdges[0][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},0`)) {\n\t\t\t\t\texternal.add(`${c},0`);\n\t\t\t\t\tqueue.push({ x: c, y: 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.hEdges[grid.rows][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},${grid.rows - 1}`)) {\n\t\t\t\t\texternal.add(`${c},${grid.rows - 1}`);\n\t\t\t\t\tqueue.push({ x: c, y: grid.rows - 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tif (grid.vEdges[r][0].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`0,${r}`)) {\n\t\t\t\t\texternal.add(`0,${r}`);\n\t\t\t\t\tqueue.push({ x: 0, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.vEdges[r][grid.cols].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${grid.cols - 1},${r}`)) {\n\t\t\t\t\texternal.add(`${grid.cols - 1},${r}`);\n\t\t\t\t\tqueue.push({ x: grid.cols - 1, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.hEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.hEdges[curr.y + 1][curr.x] },\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x + 1] },\n\t\t\t];\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\tif (!external.has(`${n.nx},${n.ny}`) && n.edge.type === EdgeType.Absent) {\n\t\t\t\t\t\texternal.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn external;\n\t}\n\n\tprivate isAdjacentToMark(grid: Grid, edge: { type: \"h\" | \"v\"; r: number; c: number }): boolean {\n\t\tif (edge.type === \"h\") {\n\t\t\tif (edge.r > 0 && grid.cells[edge.r - 1][edge.c].type !== CellType.None) return true;\n\t\t\tif (edge.r < grid.rows && grid.cells[edge.r][edge.c].type !== CellType.None) return true;\n\t\t} else {\n\t\t\tif (edge.c > 0 && grid.cells[edge.r][edge.c - 1].type !== CellType.None) return true;\n\t\t\tif (edge.c < grid.cols && grid.cells[edge.r][edge.c].type !== CellType.None) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u30DE\u30FC\u30AF\u304C\u5B8C\u5168\u306B\u65AD\u7D76\u3055\u308C\u305F\u30BB\u30EB\u306B\u3044\u306A\u3044\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate hasIsolatedMark(grid: Grid): boolean {\n\t\tfor (let r = 0; r < grid.rows; r++)\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (grid.cells[r][c].type === CellType.None) continue;\n\t\t\t\tconst edges = [grid.hEdges[r][c], grid.hEdges[r + 1][c], grid.vEdges[r][c], grid.vEdges[r][c + 1]];\n\t\t\t\tif (edges.every((e) => e.type === EdgeType.Broken || e.type === EdgeType.Absent)) return true;\n\t\t\t}\n\t\treturn false;\n\t}\n\n\tprivate getSymmetricalPoint(grid: Grid, p: Point, symmetry: SymmetryType): Point {\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\treturn { x: grid.cols - p.x, y: p.y };\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\treturn { x: p.x, y: grid.rows - p.y };\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\treturn { x: grid.cols - p.x, y: grid.rows - p.y };\n\t\t}\n\t\treturn { ...p };\n\t}\n\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t}\n\n\tprivate TETRIS_SHAPES = [\n\t\t[[1]],\n\t\t[[1, 1]],\n\t\t[[1, 1, 1]],\n\t\t[[1, 1, 1, 1]],\n\t\t[[1, 1, 1, 1, 1]],\n\t\t[\n\t\t\t[1, 1],\n\t\t\t[1, 1],\n\t\t],\n\t\t[\n\t\t\t[1, 1],\n\t\t\t[1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[1, 0, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[0, 0, 1],\n\t\t],\n\t\t[\n\t\t\t[0, 1],\n\t\t\t[1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[0, 1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[0, 1, 0],\n\t\t\t[0, 1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 0],\n\t\t\t[0, 1, 1],\n\t\t],\n\t\t[\n\t\t\t[0, 1, 1],\n\t\t\t[1, 1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 0],\n\t\t\t[0, 1, 0],\n\t\t\t[0, 1, 1],\n\t\t],\n\t\t[\n\t\t\t[0, 1, 1],\n\t\t\t[0, 1, 0],\n\t\t\t[1, 1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[1, 0, 1],\n\t\t],\n\t\t[\n\t\t\t[0, 1, 0],\n\t\t\t[1, 0, 1],\n\t\t],\n\t\t[\n\t\t\t[1, 0, 0, 1],\n\t\t\t[1, 0, 0, 1],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[1, 0, 1],\n\t\t\t[1, 1, 1],\n\t\t],\n\t];\n\n\t/**\n\t * \u89E3\u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u5404\u533A\u753B\u306B\u30EB\u30FC\u30EB\u3092\u914D\u7F6E\u3059\u308B\n\t */\n\tprivate applyConstraintsBasedOnPath(grid: Grid, path: Point[], options: GenerationOptions, symPath: Point[] = [], precalculatedRegions?: Point[][], precalculatedBoundaryEdges?: { type: \"h\" | \"v\"; r: number; c: number }[][]) {\n\t\tconst complexity = options.complexity ?? 0.5;\n\t\tconst useHexagons = options.useHexagons ?? true;\n\t\tconst useSquares = options.useSquares ?? true;\n\t\tconst useStars = options.useStars ?? true;\n\t\tconst useTetris = options.useTetris ?? false;\n\t\tconst useEraser = options.useEraser ?? false;\n\n\t\tlet hexagonsPlaced = 0;\n\t\tlet squaresPlaced = 0;\n\t\tlet starsPlaced = 0;\n\t\tlet tetrisPlaced = 0;\n\t\tlet erasersPlaced = 0;\n\t\tlet totalTetrisArea = 0;\n\t\tconst maxTotalTetrisArea = Math.floor(grid.rows * grid.cols * 0.45);\n\n\t\t// \u516D\u89D2\u5F62\u306E\u914D\u7F6E\n\t\tif (useHexagons) {\n\t\t\tconst targetDifficulty = options.difficulty ?? 0.5;\n\t\t\t// \u30A8\u30C3\u30B8\u516D\u89D2\u5F62 (\u7DDA\u4E0A\u30FB\u4E2D\u5FC3)\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst neighbors = this.getValidNeighbors(grid, path[i], new Set());\n\t\t\t\tconst isBranching = neighbors.length > 2;\n\t\t\t\t// \u96E3\u6613\u5EA6\u304C\u4F4E\u3044\u3068\u304D\u306F\u30A8\u30C3\u30B8\u516D\u89D2\u5F62\u3092\u591A\u304F\u3057\u3066\u30AC\u30A4\u30C9\u306B\u3059\u308B\n\t\t\t\tlet prob = complexity * (targetDifficulty < 0.4 ? 0.6 : 0.3);\n\t\t\t\tif (isBranching) prob = targetDifficulty < 0.4 ? prob * 1.0 : prob * 0.5;\n\t\t\t\tif (Math.random() < prob) {\n\t\t\t\t\tthis.setEdgeHexagon(grid, path[i], path[i + 1]);\n\t\t\t\t\thexagonsPlaced++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// \u30CE\u30FC\u30C9\u516D\u89D2\u5F62 (\u7DDA\u4E0A\u30FB\u4EA4\u70B9)\n\t\t\tfor (let i = 0; i < path.length; i++) {\n\t\t\t\tconst node = path[i];\n\t\t\t\tif (grid.nodes[node.y][node.x].type !== NodeType.Normal) continue;\n\t\t\t\t// Edge\u306EHexagon\u3068\u96A3\u63A5\u3057\u3066\u3044\u308B\u5834\u5408\u306F\u30B9\u30AD\u30C3\u30D7\n\t\t\t\tif (this.hasIncidentHexagonEdge(grid, node)) continue;\n\n\t\t\t\t// \u96E3\u6613\u5EA6\u304C\u9AD8\u3044\u3068\u304D\u306B\u30CE\u30FC\u30C9\u516D\u89D2\u5F62\u3092\u914D\u7F6E\n\t\t\t\tlet prob = complexity * (targetDifficulty > 0.6 ? 0.15 : 0.05);\n\t\t\t\tif (Math.random() < prob) {\n\t\t\t\t\tgrid.nodes[node.y][node.x].type = NodeType.Hexagon;\n\t\t\t\t\thexagonsPlaced++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hexagonsPlaced === 0 && path.length >= 2) {\n\t\t\t\tconst idx = Math.floor(Math.random() * (path.length - 1));\n\t\t\t\tthis.setEdgeHexagon(grid, path[idx], path[idx + 1]);\n\t\t\t}\n\t\t}\n\n\t\t// \u533A\u753B\u30EB\u30FC\u30EB\u306E\u914D\u7F6E\n\t\tif (useSquares || useStars || useTetris || useEraser) {\n\t\t\tconst regions = precalculatedRegions || this.calculateRegions(grid, path, symPath);\n\t\t\tconst availableColors = options.availableColors ?? [Color.Black, Color.White, Color.Red, Color.Blue];\n\t\t\tconst defaultColors = (options.defaultColors ?? {}) as any;\n\t\t\tconst getDefColor = (type: CellType, fallback: Color): Color => {\n\t\t\t\tif (defaultColors[type] !== undefined) return defaultColors[type];\n\t\t\t\tconst name = CellType[type];\n\t\t\t\tif (name && defaultColors[name] !== undefined) return defaultColors[name];\n\t\t\t\treturn fallback;\n\t\t\t};\n\t\t\tconst regionIndices = Array.from({ length: regions.length }, (_, i) => i);\n\t\t\tthis.shuffleArray(regionIndices);\n\t\t\tconst squareColorsUsed = new Set<number>();\n\n\t\t\t// \u5FC5\u8981\u306A\u6700\u5C0F\u9650\u306E\u5236\u7D04\u3092\u5206\u6563\u3057\u3066\u914D\u7F6E\u3059\u308B\u305F\u3081\u306E\u30D5\u30E9\u30B0\n\t\t\tconst needs = {\n\t\t\t\tsquare: useSquares,\n\t\t\t\tstar: useStars,\n\t\t\t\ttetris: useTetris,\n\t\t\t\teraser: useEraser,\n\t\t\t};\n\n\t\t\tfor (let rIdx = 0; rIdx < regionIndices.length; rIdx++) {\n\t\t\t\tconst idx = regionIndices[rIdx];\n\t\t\t\tconst region = regions[idx];\n\n\t\t\t\t// \u76E4\u9762\u304C\u5927\u304D\u304F\u533A\u753B\u304C\u591A\u3044\u5834\u5408\u3001\u5F8C\u534A\u306B\u504F\u308B\u306E\u3092\u9632\u3050\u305F\u3081\u78BA\u7387\u3092\u8ABF\u6574\n\t\t\t\tconst remainingRegions = regionIndices.length - rIdx;\n\t\t\t\tconst forceOne = (needs.square && squaresPlaced === 0) || (needs.star && starsPlaced === 0) || (needs.tetris && tetrisPlaced === 0) || (needs.eraser && erasersPlaced === 0);\n\n\t\t\t\t// \u5FC5\u9808\u306A\u3082\u306E\u304C\u307E\u3060\u914D\u7F6E\u3055\u308C\u3066\u3044\u306A\u3044\u5834\u5408\u3001\u6B8B\u308A\u533A\u753B\u6570\u304C\u5C11\u306A\u304F\u306A\u3063\u3066\u304D\u305F\u3089\u78BA\u7387\u3092\u4E0A\u3052\u308B\n\t\t\t\tlet placementProb = 0.2 + complexity * 0.6;\n\t\t\t\tif (forceOne && remainingRegions <= 3) placementProb = 1.0;\n\t\t\t\telse if (forceOne && remainingRegions <= 6) placementProb = 0.7;\n\n\t\t\t\tif (Math.random() > placementProb) continue;\n\n\t\t\t\tconst potentialCells = [...region];\n\t\t\t\tthis.shuffleArray(potentialCells);\n\n\t\t\t\t// \u56DB\u89D2\u5F62\u306E\u914D\u7F6E\n\t\t\t\tlet squareColor = availableColors[Math.floor(Math.random() * availableColors.length)];\n\t\t\t\tif (useSquares && !useStars && remainingRegions <= 2 && squareColorsUsed.size === 1) {\n\t\t\t\t\tconst otherColors = availableColors.filter((c) => !squareColorsUsed.has(c));\n\t\t\t\t\tif (otherColors.length > 0) squareColor = otherColors[Math.floor(Math.random() * otherColors.length)];\n\t\t\t\t}\n\n\t\t\t\tlet shouldPlaceSquare = useSquares && Math.random() < 0.5 + complexity * 0.3;\n\t\t\t\tif (useSquares && squaresPlaced === 0 && remainingRegions <= 2) shouldPlaceSquare = true;\n\t\t\t\tif (useSquares && !useStars && remainingRegions <= 2 && squareColorsUsed.size < 2 && squaresPlaced > 0) shouldPlaceSquare = true;\n\n\t\t\t\tif (shouldPlaceSquare && potentialCells.length > 0) {\n\t\t\t\t\t// \u533A\u57DF\u306E\u5927\u304D\u3055\u306B\u5FDC\u3058\u3066\u914D\u7F6E\u3059\u308B\u6570\u3092\u5897\u3084\u3059\n\t\t\t\t\tconst maxSquares = Math.min(potentialCells.length, Math.max(4, Math.floor(region.length / 4)));\n\t\t\t\t\tconst numSquares = Math.floor(Math.random() * (maxSquares / 2)) + Math.ceil(maxSquares / 2);\n\t\t\t\t\tfor (let i = 0; i < numSquares; i++) {\n\t\t\t\t\t\tif (potentialCells.length === 0) break;\n\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Square;\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = squareColor;\n\t\t\t\t\t\tsquaresPlaced++;\n\t\t\t\t\t\tsquareColorsUsed.add(squareColor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// \u30C6\u30C8\u30EA\u30B9\u306E\u914D\u7F6E\n\t\t\t\tif (useTetris && totalTetrisArea < maxTotalTetrisArea) {\n\t\t\t\t\tlet shouldPlaceTetris = Math.random() < 0.1 + complexity * 0.4;\n\t\t\t\t\tif (tetrisPlaced === 0 && remainingRegions <= 2) shouldPlaceTetris = true;\n\t\t\t\t\tconst maxTetrisPerRegion = tetrisPlaced === 0 && remainingRegions <= 2 ? 6 : 4;\n\t\t\t\t\tif (shouldPlaceTetris && potentialCells.length > 0 && region.length <= maxTetrisPerRegion * 4 && totalTetrisArea + region.length <= maxTotalTetrisArea) {\n\t\t\t\t\t\tconst tiledPieces = this.generateTiling(region, maxTetrisPerRegion, options);\n\t\t\t\t\t\tif (tiledPieces) {\n\t\t\t\t\t\t\tfor (const p of tiledPieces) {\n\t\t\t\t\t\t\t\tif (potentialCells.length === 0) break;\n\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = p.isRotated ? CellType.TetrisRotated : CellType.Tetris;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].shape = p.isRotated ? p.displayShape : p.shape;\n\n\t\t\t\t\t\t\t\tlet tetrisColor = getDefColor(CellType.Tetris, Color.None);\n\t\t\t\t\t\t\t\tif (useStars && Math.random() < 0.5) {\n\t\t\t\t\t\t\t\t\tconst colors = availableColors.filter((c) => c !== Color.Blue && c !== tetrisColor);\n\t\t\t\t\t\t\t\t\tif (colors.length > 0) {\n\t\t\t\t\t\t\t\t\t\ttetrisColor = colors[Math.floor(Math.random() * colors.length)];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = tetrisColor;\n\t\t\t\t\t\t\t\ttetrisPlaced++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttotalTetrisArea += region.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// \u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF08\u30A8\u30E9\u30FC\u524A\u9664\uFF09\u306E\u914D\u7F6E\n\t\t\t\tif (useEraser && erasersPlaced < 1) {\n\t\t\t\t\tconst prob = 0.05 + complexity * 0.2;\n\t\t\t\t\tlet shouldPlaceEraser = Math.random() < prob;\n\t\t\t\t\tif (remainingRegions <= 2) shouldPlaceEraser = true;\n\n\t\t\t\t\tif (shouldPlaceEraser && potentialCells.length >= 1) {\n\t\t\t\t\t\tconst errorTypes: string[] = [];\n\t\t\t\t\t\tif (useStars) errorTypes.push(\"star\");\n\t\t\t\t\t\tif (useSquares) errorTypes.push(\"square\");\n\t\t\t\t\t\tlet boundaryEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\t\t\t\t\tif (useHexagons) {\n\t\t\t\t\t\t\tboundaryEdges = precalculatedBoundaryEdges ? precalculatedBoundaryEdges[idx] : this.getRegionBoundaryEdges(grid, region, path, symPath);\n\t\t\t\t\t\t\tif (boundaryEdges.length > 0) errorTypes.push(\"hexagon\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (useTetris) errorTypes.push(\"tetris\");\n\n\t\t\t\t\t\tlet errorType = errorTypes.length > 0 ? errorTypes[Math.floor(Math.random() * errorTypes.length)] : null;\n\n\t\t\t\t\t\t// eraser\u540C\u58EB\u306E\u6253\u3061\u6D88\u3057\u5408\u3044\u306F\u8D85\u4F4E\u78BA\u7387\u306B\u3059\u308B\n\t\t\t\t\t\tif (potentialCells.length >= 2 && (!errorType || Math.random() < 0.01)) errorType = \"eraser\";\n\n\t\t\t\t\t\tlet errorPlaced = false;\n\n\t\t\t\t\t\tif (errorType === \"hexagon\") {\n\t\t\t\t\t\t\t// Node\u306EHexagon\u3068\u96A3\u63A5\u3057\u306A\u3044Edge\u3092\u9078\u629E\n\t\t\t\t\t\t\tconst validEdges = boundaryEdges.filter((e) => !this.isEdgeAdjacentToHexagonNode(grid, e));\n\t\t\t\t\t\t\tif (validEdges.length > 0) {\n\t\t\t\t\t\t\t\tconst edge = validEdges[Math.floor(Math.random() * validEdges.length)];\n\t\t\t\t\t\t\t\tif (edge.type === \"h\") grid.hEdges[edge.r][edge.c].type = EdgeType.Hexagon;\n\t\t\t\t\t\t\t\telse grid.vEdges[edge.r][edge.c].type = EdgeType.Hexagon;\n\t\t\t\t\t\t\t\thexagonsPlaced++;\n\t\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (errorType === \"square\" && potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Square;\n\t\t\t\t\t\t\tconst existingSquare = region.find((p) => grid.cells[p.y][p.x].type === CellType.Square);\n\t\t\t\t\t\t\tconst existingSquareColor = existingSquare ? grid.cells[existingSquare.y][existingSquare.x].color : undefined;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = availableColors.find((c) => c !== existingSquareColor) || Color.Red;\n\t\t\t\t\t\t\tsquaresPlaced++;\n\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t} else if (errorType === \"star\" && potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Star;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = availableColors[Math.floor(Math.random() * availableColors.length)];\n\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t} else if (errorType === \"tetris\" && potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst tiledPieces = this.generateTiling(region, 4, options);\n\t\t\t\t\t\t\tlet piecesToPlace = [];\n\t\t\t\t\t\t\tif (tiledPieces && tiledPieces.length > 0) {\n\t\t\t\t\t\t\t\tlet currentArea = 0;\n\t\t\t\t\t\t\t\tfor (const p of tiledPieces) {\n\t\t\t\t\t\t\t\t\tconst area = this.getShapeArea(p.shape);\n\t\t\t\t\t\t\t\t\tif (currentArea + area < region.length) {\n\t\t\t\t\t\t\t\t\t\tpiecesToPlace.push(p);\n\t\t\t\t\t\t\t\t\t\tcurrentArea += area;\n\t\t\t\t\t\t\t\t\t} else break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (piecesToPlace.length === 0 && region.length > 1) {\n\t\t\t\t\t\t\t\t// \u9762\u7A4D\u4E0D\u4E00\u81F4\u306E\u30A8\u30E9\u30FC\u3092\u78BA\u5B9F\u306B\u4F5C\u6210\n\t\t\t\t\t\t\t\tpiecesToPlace = [{ shape: [[1]], displayShape: [[1]], isRotated: false }];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (piecesToPlace.length > 0) {\n\t\t\t\t\t\t\t\tfor (const p of piecesToPlace) {\n\t\t\t\t\t\t\t\t\tif (potentialCells.length < 2) break;\n\t\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = p.isRotated ? CellType.TetrisRotated : CellType.Tetris;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].shape = p.isRotated ? p.displayShape : p.shape;\n\n\t\t\t\t\t\t\t\t\tlet tetrisColor = Color.None;\n\t\t\t\t\t\t\t\t\tif (useStars && Math.random() < 0.3) {\n\t\t\t\t\t\t\t\t\t\tconst colors = availableColors.filter((c) => c !== Color.Blue);\n\t\t\t\t\t\t\t\t\t\ttetrisColor = colors[Math.floor(Math.random() * colors.length)];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = tetrisColor;\n\t\t\t\t\t\t\t\t\ttetrisPlaced++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (errorType === \"eraser\" && potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Eraser;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = getDefColor(CellType.Eraser, Color.White);\n\t\t\t\t\t\t\terasersPlaced++;\n\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// \u305D\u308C\u3067\u3082\u30A8\u30E9\u30FC\u304C\u914D\u7F6E\u3067\u304D\u306A\u304B\u3063\u305F\u5834\u5408\u306F\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\u540C\u58EB\u306E\u6253\u3061\u6D88\u3057\u3092\u8A66\u307F\u308B\n\t\t\t\t\t\tif (!errorPlaced && potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Eraser;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = getDefColor(CellType.Eraser, Color.White);\n\t\t\t\t\t\t\terasersPlaced++;\n\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (errorPlaced) {\n\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Eraser;\n\t\t\t\t\t\t\tlet eraserColor = getDefColor(CellType.Eraser, Color.White);\n\t\t\t\t\t\t\tif (useStars && Math.random() < 0.4) {\n\t\t\t\t\t\t\t\tconst colors = availableColors.filter((c) => c !== eraserColor);\n\t\t\t\t\t\t\t\tif (colors.length > 0) {\n\t\t\t\t\t\t\t\t\teraserColor = colors[Math.floor(Math.random() * colors.length)];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = eraserColor;\n\t\t\t\t\t\t\terasersPlaced++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// \u661F\u306E\u914D\u7F6E\n\t\t\t\tif (useStars) {\n\t\t\t\t\t// \u533A\u57DF\u304C\u5341\u5206\u306B\u5927\u304D\u3051\u308C\u3070\u3001\u8907\u6570\u30DA\u30A2\u306E\u914D\u7F6E\u3092\u691C\u8A0E\u3059\u308B\n\t\t\t\t\tconst maxPairs = Math.max(1, Math.floor(region.length / 8));\n\t\t\t\t\tfor (let p = 0; p < maxPairs; p++) {\n\t\t\t\t\t\tfor (const color of availableColors) {\n\t\t\t\t\t\t\tif (potentialCells.length < 1) break;\n\t\t\t\t\t\t\tif (Math.random() > 0.3 + complexity * 0.4) continue;\n\t\t\t\t\t\t\tconst colorCount = region.filter((p) => grid.cells[p.y][p.x].color === color).length;\n\t\t\t\t\t\t\tif (colorCount === 1) {\n\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\n\t\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t\t} else if (colorCount === 0 && potentialCells.length >= 2) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < 2; i++) {\n\t\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\n\t\t\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// \u56DB\u89D2\u5F62\u306E\u8272\u304C1\u8272\u3057\u304B\u4F7F\u308F\u308C\u306A\u304B\u3063\u305F\u5834\u5408\u306E\u88DC\u6B63\n\t\t\tif (useSquares && !useStars && squareColorsUsed.size < 2) {\n\t\t\t\tfor (const region of regions) {\n\t\t\t\t\tif (region.every((p) => grid.cells[p.y][p.x].type === CellType.None)) {\n\t\t\t\t\t\tconst otherColor = availableColors.find((c) => !squareColorsUsed.has(c)) || Color.White;\n\t\t\t\t\t\tconst cell = region[Math.floor(Math.random() * region.length)];\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Square;\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = otherColor;\n\t\t\t\t\t\tsquareColorsUsed.add(otherColor);\n\t\t\t\t\t\tsquaresPlaced++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u533A\u753B\u5206\u3051\u3092\u884C\u3046\n\t */\n\tprivate calculateRegions(grid: Grid, path: Point[], symPath: Point[] = []): Point[][] {\n\t\tconst regions: Point[][] = [];\n\t\tconst visitedCells = new Set<string>();\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) pathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\tfor (let i = 0; i < symPath.length - 1; i++) pathEdges.add(this.getEdgeKey(symPath[i], symPath[i + 1]));\n\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (visitedCells.has(`${c},${r}`)) continue;\n\t\t\t\tconst currentRegion: Point[] = [];\n\t\t\t\tconst queue: Point[] = [{ x: c, y: r }];\n\t\t\t\tvisitedCells.add(`${c},${r}`);\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst cell = queue.shift()!;\n\t\t\t\t\tcurrentRegion.push(cell);\n\t\t\t\t\tconst neighbors = [\n\t\t\t\t\t\t{ dx: 0, dy: -1, p1: { x: cell.x, y: cell.y }, p2: { x: cell.x + 1, y: cell.y } },\n\t\t\t\t\t\t{ dx: 0, dy: 1, p1: { x: cell.x, y: cell.y + 1 }, p2: { x: cell.x + 1, y: cell.y + 1 } },\n\t\t\t\t\t\t{ dx: -1, dy: 0, p1: { x: cell.x, y: cell.y }, p2: { x: cell.x, y: cell.y + 1 } },\n\t\t\t\t\t\t{ dx: 1, dy: 0, p1: { x: cell.x + 1, y: cell.y }, p2: { x: cell.x + 1, y: cell.y + 1 } },\n\t\t\t\t\t];\n\t\t\t\t\tfor (const n of neighbors) {\n\t\t\t\t\t\tconst nx = cell.x + n.dx;\n\t\t\t\t\t\tconst ny = cell.y + n.dy;\n\t\t\t\t\t\tif (nx >= 0 && nx < grid.cols && ny >= 0 && ny < grid.rows) {\n\t\t\t\t\t\t\tif (!visitedCells.has(`${nx},${ny}`) && !pathEdges.has(this.getEdgeKey(n.p1, n.p2)) && !this.isAbsentEdge(grid, n.p1, n.p2)) {\n\t\t\t\t\t\t\t\tvisitedCells.add(`${nx},${ny}`);\n\t\t\t\t\t\t\t\tqueue.push({ x: nx, y: ny });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregions.push(currentRegion);\n\t\t\t}\n\t\t}\n\t\treturn regions;\n\t}\n\n\tprivate isAbsentEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\treturn grid.vEdges[y][p1.x].type === EdgeType.Absent;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\treturn grid.hEdges[p1.y][x].type === EdgeType.Absent;\n\t\t}\n\t}\n\n\t/**\n\t * \u533A\u753B\u306E\u5883\u754C\u30A8\u30C3\u30B8\u306E\u3046\u3061\u3001\u89E3\u30D1\u30B9\u304C\u901A\u3063\u3066\u3044\u306A\u3044\u3082\u306E\u3092\u53D6\u5F97\u3059\u308B\n\t */\n\tprivate getRegionBoundaryEdges(grid: Grid, region: Point[], path: Point[], symPath: Point[] = []): { type: \"h\" | \"v\"; r: number; c: number }[] {\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) pathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\tfor (let i = 0; i < symPath.length - 1; i++) pathEdges.add(this.getEdgeKey(symPath[i], symPath[i + 1]));\n\n\t\tconst boundary: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\tfor (const cell of region) {\n\t\t\tconst edges = [\n\t\t\t\t{ type: \"h\" as const, r: cell.y, c: cell.x },\n\t\t\t\t{ type: \"h\" as const, r: cell.y + 1, c: cell.x },\n\t\t\t\t{ type: \"v\" as const, r: cell.y, c: cell.x },\n\t\t\t\t{ type: \"v\" as const, r: cell.y, c: cell.x + 1 },\n\t\t\t];\n\t\t\tfor (const e of edges) {\n\t\t\t\tconst p1 = e.type === \"h\" ? { x: e.c, y: e.r } : { x: e.c, y: e.r };\n\t\t\t\tconst p2 = e.type === \"h\" ? { x: e.c + 1, y: e.r } : { x: e.c, y: e.r + 1 };\n\t\t\t\tconst key = this.getEdgeKey(p1, p2);\n\t\t\t\tif (!pathEdges.has(key) && !this.isAbsentEdge(grid, p1, p2)) {\n\t\t\t\t\tboundary.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// \u91CD\u8907\u3092\u524A\u9664\n\t\tconst unique = new Map<string, { type: \"h\" | \"v\"; r: number; c: number }>();\n\t\tfor (const e of boundary) unique.set(`${e.type},${e.r},${e.c}`, e);\n\t\treturn Array.from(unique.values());\n\t}\n\n\tprivate setEdgeHexagon(grid: Grid, p1: Point, p2: Point) {\n\t\tif (p1.x === p2.x) grid.vEdges[Math.min(p1.y, p2.y)][p1.x].type = EdgeType.Hexagon;\n\t\telse grid.hEdges[p1.y][Math.min(p1.x, p2.x)].type = EdgeType.Hexagon;\n\t}\n\n\tprivate hasIncidentHexagonEdge(grid: Grid, p: Point): boolean {\n\t\tif (p.x > 0 && grid.hEdges[p.y][p.x - 1].type === EdgeType.Hexagon) return true;\n\t\tif (p.x < grid.cols && grid.hEdges[p.y][p.x].type === EdgeType.Hexagon) return true;\n\t\tif (p.y > 0 && grid.vEdges[p.y - 1][p.x].type === EdgeType.Hexagon) return true;\n\t\tif (p.y < grid.rows && grid.vEdges[p.y][p.x].type === EdgeType.Hexagon) return true;\n\t\treturn false;\n\t}\n\n\tprivate isEdgeAdjacentToHexagonNode(grid: Grid, edge: { type: \"h\" | \"v\"; r: number; c: number }): boolean {\n\t\tif (edge.type === \"h\") {\n\t\t\treturn grid.nodes[edge.r][edge.c].type === NodeType.Hexagon || grid.nodes[edge.r][edge.c + 1].type === NodeType.Hexagon;\n\t\t} else {\n\t\t\treturn grid.nodes[edge.r][edge.c].type === NodeType.Hexagon || grid.nodes[edge.r + 1][edge.c].type === NodeType.Hexagon;\n\t\t}\n\t}\n\n\t/**\n\t * \u8981\u6C42\u3055\u308C\u305F\u5236\u7D04\u304C\u5168\u3066\u542B\u307E\u308C\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate checkAllRequestedConstraintsPresent(grid: Grid, options: GenerationOptions): boolean {\n\t\tconst useHexagons = options.useHexagons ?? true;\n\t\tconst useSquares = options.useSquares ?? true;\n\t\tconst useStars = options.useStars ?? true;\n\t\tconst useTetris = options.useTetris ?? false;\n\t\tconst useEraser = options.useEraser ?? false;\n\t\tconst useBrokenEdges = options.useBrokenEdges ?? false;\n\n\t\tif (useBrokenEdges) {\n\t\t\tlet found = false;\n\t\t\tfor (let r = 0; r <= grid.rows; r++)\n\t\t\t\tfor (let c = 0; c < grid.cols; c++)\n\t\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Broken || grid.hEdges[r][c].type === EdgeType.Absent) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tfor (let r = 0; r < grid.rows; r++)\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++)\n\t\t\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Broken || grid.vEdges[r][c].type === EdgeType.Absent) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (!found) return false;\n\t\t}\n\t\tif (useHexagons) {\n\t\t\tlet found = false;\n\t\t\tfor (let r = 0; r <= grid.rows; r++)\n\t\t\t\tfor (let c = 0; c < grid.cols; c++)\n\t\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tfor (let r = 0; r < grid.rows; r++)\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++)\n\t\t\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tfor (let r = 0; r <= grid.rows; r++)\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++)\n\t\t\t\t\t\tif (grid.nodes[r][c].type === NodeType.Hexagon) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (!found) return false;\n\t\t}\n\t\tif (useSquares || useStars || useTetris || useEraser) {\n\t\t\tlet fSq = false;\n\t\t\tlet fSt = false;\n\t\t\tlet fT = false;\n\t\t\tlet fE = false;\n\t\t\tconst sqC = new Set<number>();\n\t\t\tfor (let r = 0; r < grid.rows; r++)\n\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\t\tconst type = grid.cells[r][c].type;\n\t\t\t\t\tif (type === CellType.Square) {\n\t\t\t\t\t\tfSq = true;\n\t\t\t\t\t\tsqC.add(grid.cells[r][c].color);\n\t\t\t\t\t}\n\t\t\t\t\tif (type === CellType.Star) fSt = true;\n\t\t\t\t\tif (type === CellType.Tetris || type === CellType.TetrisRotated) fT = true;\n\t\t\t\t\tif (type === CellType.Eraser) fE = true;\n\t\t\t\t}\n\t\t\tif (useSquares && !fSq) return false;\n\t\t\tif (useStars && !fSt) return false;\n\t\t\tif (useTetris && !fT) return false;\n\t\t\tif (useEraser && !fE) return false;\n\t\t\tif (useSquares && fSq && !fSt && sqC.size < 2) return false;\n\t\t}\n\t\tif (this.hasIsolatedMark(grid)) return false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u533A\u753B\u3092\u30D4\u30FC\u30B9\u3067\u57CB\u3081\u5C3D\u304F\u3059\u30BF\u30A4\u30EA\u30F3\u30B0\u3092\u751F\u6210\u3059\u308B\n\t */\n\tprivate generateTiling(region: Point[], maxPieces: number, options: GenerationOptions): { shape: number[][]; displayShape: number[][]; isRotated: boolean }[] | null {\n\t\tconst minX = Math.min(...region.map((p) => p.x));\n\t\tconst minY = Math.min(...region.map((p) => p.y));\n\t\tconst maxX = Math.max(...region.map((p) => p.x));\n\t\tconst maxY = Math.max(...region.map((p) => p.y));\n\t\tconst width = maxX - minX + 1;\n\t\tconst height = maxY - minY + 1;\n\t\tconst regionGrid = Array.from({ length: height }, () => Array(width).fill(false));\n\t\tfor (const p of region) regionGrid[p.y - minY][p.x - minX] = true;\n\t\treturn this.tilingDfs(regionGrid, [], maxPieces, options);\n\t}\n\n\t/**\n\t * \u30BF\u30A4\u30EA\u30F3\u30B0\u3092\u6DF1\u3055\u512A\u5148\u63A2\u7D22\u3067\u751F\u6210\u3059\u308B\n\t */\n\tprivate tilingDfs(regionGrid: boolean[][], currentPieces: { shape: number[][]; displayShape: number[][]; isRotated: boolean }[], maxPieces: number, options: GenerationOptions): { shape: number[][]; displayShape: number[][]; isRotated: boolean }[] | null {\n\t\tlet r0 = -1;\n\t\tlet c0 = -1;\n\t\tfor (let r = 0; r < regionGrid.length; r++) {\n\t\t\tfor (let c = 0; c < regionGrid[0].length; c++)\n\t\t\t\tif (regionGrid[r][c]) {\n\t\t\t\t\tr0 = r;\n\t\t\t\t\tc0 = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (r0 !== -1) break;\n\t\t}\n\t\tif (r0 === -1) return currentPieces;\n\t\tif (currentPieces.length >= maxPieces) return null;\n\n\t\tconst difficulty = options.difficulty ?? 0.5;\n\t\tlet shapes = [...this.TETRIS_SHAPES];\n\t\tthis.shuffleArray(shapes);\n\t\tif (difficulty > 0.6) shapes.sort((a, b) => this.getShapeArea(b) - this.getShapeArea(a));\n\n\t\tfor (const baseShape of shapes) {\n\t\t\tconst isInv = this.isRotationallyInvariant(baseShape);\n\t\t\tconst rotations = isInv ? [baseShape] : this.getAllRotations(baseShape);\n\t\t\tthis.shuffleArray(rotations);\n\t\t\tfor (const shape of rotations) {\n\t\t\t\tconst blocks: { r: number; c: number }[] = [];\n\t\t\t\tfor (let pr = 0; pr < shape.length; pr++) for (let pc = 0; pc < shape[0].length; pc++) if (shape[pr][pc]) blocks.push({ r: pr, c: pc });\n\t\t\t\tfor (const anchor of blocks) {\n\t\t\t\t\tconst dr = r0 - anchor.r;\n\t\t\t\t\tconst dc = c0 - anchor.c;\n\t\t\t\t\tif (this.canPlace(regionGrid, shape, dr, dc)) {\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, false);\n\t\t\t\t\t\tconst result = this.tilingDfs(regionGrid, [...currentPieces, { shape, displayShape: baseShape, isRotated: !isInv && Math.random() < 0.3 + difficulty * 0.6 }], maxPieces, options);\n\t\t\t\t\t\tif (result) return result;\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate getShapeArea(shape: number[][]): number {\n\t\tlet area = 0;\n\t\tfor (const row of shape) for (const cell of row) if (cell) area++;\n\t\treturn area;\n\t}\n\tprivate isRotationallyInvariant(shape: number[][]): boolean {\n\t\tconst area = this.getShapeArea(shape);\n\t\treturn area === 1 || (area === 4 && shape.length === 2 && shape[0].length === 2);\n\t}\n\tprivate getAllRotations(shape: number[][]): number[][][] {\n\t\tconst results: number[][][] = [];\n\t\tconst keys = new Set<string>();\n\t\tlet curr = shape;\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tconst key = JSON.stringify(curr);\n\t\t\tif (!keys.has(key)) {\n\t\t\t\tresults.push(curr);\n\t\t\t\tkeys.add(key);\n\t\t\t}\n\t\t\tcurr = this.rotate90(curr);\n\t\t}\n\t\treturn results;\n\t}\n\tprivate rotate90(shape: number[][]): number[][] {\n\t\tconst rows = shape.length;\n\t\tconst cols = shape[0].length;\n\t\tconst newShape = Array.from({ length: cols }, () => Array(rows).fill(0));\n\t\tfor (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) newShape[c][rows - 1 - r] = shape[r][c];\n\t\treturn newShape;\n\t}\n\tprivate canPlace(regionGrid: boolean[][], shape: number[][], r: number, c: number): boolean {\n\t\tfor (let i = 0; i < shape.length; i++)\n\t\t\tfor (let j = 0; j < shape[0].length; j++)\n\t\t\t\tif (shape[i][j]) {\n\t\t\t\t\tconst nr = r + i,\n\t\t\t\t\t\tnc = c + j;\n\t\t\t\t\tif (nr < 0 || nr >= regionGrid.length || nc < 0 || nc >= regionGrid[0].length || !regionGrid[nr][nc]) return false;\n\t\t\t\t}\n\t\treturn true;\n\t}\n\tprivate placePiece(regionGrid: boolean[][], shape: number[][], r: number, c: number, value: boolean) {\n\t\tfor (let i = 0; i < shape.length; i++) for (let j = 0; j < shape[0].length; j++) if (shape[i][j]) regionGrid[r + i][c + j] = value;\n\t}\n\tprivate shuffleArray(array: any[]) {\n\t\tfor (let i = array.length - 1; i > 0; i--) {\n\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t[array[i], array[j]] = [array[j], array[i]];\n\t\t}\n\t}\n}\n", "import type { CellConstraint, GenerationOptions, PuzzleData } from \"./types\";\n\n/* ================= Bit IO ================= */\n\nclass BitWriter {\n\tprivate bytes: number[] = [];\n\tprivate cur = 0;\n\tprivate bit = 0;\n\n\twrite(value: number, bits: number) {\n\t\tfor (let i = 0; i < bits; i++) {\n\t\t\tif (value & (1 << i)) this.cur |= 1 << this.bit;\n\t\t\tthis.bit++;\n\t\t\tif (this.bit === 8) {\n\t\t\t\tthis.bytes.push(this.cur);\n\t\t\t\tthis.cur = 0;\n\t\t\t\tthis.bit = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfinish(): Uint8Array {\n\t\tif (this.bit > 0) this.bytes.push(this.cur);\n\t\treturn new Uint8Array(this.bytes);\n\t}\n}\n\nclass BitReader {\n\tprivate i = 0;\n\tprivate bit = 0;\n\tconstructor(private buf: Uint8Array) {}\n\n\tread(bits: number): number {\n\t\tlet v = 0;\n\t\tfor (let i = 0; i < bits; i++) {\n\t\t\tif (this.buf[this.i] & (1 << this.bit)) v |= 1 << i;\n\t\t\tthis.bit++;\n\t\t\tif (this.bit === 8) {\n\t\t\t\tthis.bit = 0;\n\t\t\t\tthis.i++;\n\t\t\t}\n\t\t}\n\t\treturn v;\n\t}\n}\n\n/* ================= Utils ================= */\n\nfunction collectShapes(cells: CellConstraint[][]): number[][][] {\n\tconst map = new Map<string, number[][]>();\n\tfor (const row of cells) {\n\t\tfor (const c of row) {\n\t\t\tif (c.shape) {\n\t\t\t\tconst key = JSON.stringify(c.shape);\n\t\t\t\tif (!map.has(key)) map.set(key, c.shape);\n\t\t\t}\n\t\t}\n\t}\n\treturn [...map.values()];\n}\n\n/* ================= Serializer ================= */\n\nexport class PuzzleSerializer {\n\tstatic async serialize(puzzle: PuzzleData, options: GenerationOptions): Promise<string> {\n\t\tconst bw = new BitWriter();\n\n\t\tbw.write(puzzle.rows, 6);\n\t\tbw.write(puzzle.cols, 6);\n\t\tbw.write(puzzle.symmetry ?? 0, 2);\n\n\t\t/* ---- shapes ---- */\n\t\tconst shapes = collectShapes(puzzle.cells);\n\t\tbw.write(shapes.length, 5);\n\n\t\tfor (const s of shapes) {\n\t\t\tbw.write(s.length, 4);\n\t\t\tbw.write(s[0].length, 4);\n\t\t\tfor (const r of s) for (const v of r) bw.write(v, 1);\n\t\t}\n\n\t\tconst shapeIndex = new Map<string, number>();\n\t\tshapes.forEach((s, i) => shapeIndex.set(JSON.stringify(s), i));\n\n\t\t/* ---- cells ---- */\n\t\tfor (const row of puzzle.cells) {\n\t\t\tfor (const c of row) {\n\t\t\t\tbw.write(c.type, 3);\n\t\t\t\tbw.write(c.color, 3);\n\t\t\t\tif (c.shape) {\n\t\t\t\t\tbw.write(1, 1);\n\t\t\t\t\tbw.write(shapeIndex.get(JSON.stringify(c.shape))!, 5);\n\t\t\t\t} else {\n\t\t\t\t\tbw.write(0, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* ---- edges & nodes\uFF08\u30B5\u30A4\u30BA\u53B3\u5BC6\uFF09 ---- */\n\t\tfor (let y = 0; y < puzzle.rows; y++) for (let x = 0; x < puzzle.cols + 1; x++) bw.write(puzzle.vEdges[y][x].type, 2);\n\n\t\tfor (let y = 0; y < puzzle.rows + 1; y++) for (let x = 0; x < puzzle.cols; x++) bw.write(puzzle.hEdges[y][x].type, 2);\n\n\t\tfor (let y = 0; y < puzzle.rows + 1; y++) for (let x = 0; x < puzzle.cols + 1; x++) bw.write(puzzle.nodes[y][x].type, 2);\n\n\t\t/* ---- options ---- */\n\t\tbw.write(+!!options.useHexagons, 1);\n\t\tbw.write(+!!options.useSquares, 1);\n\t\tbw.write(+!!options.useStars, 1);\n\t\tbw.write(+!!options.useTetris, 1);\n\t\tbw.write(+!!options.useEraser, 1);\n\t\tbw.write(+!!options.useBrokenEdges, 1);\n\t\tbw.write(options.symmetry ?? 0, 2);\n\n\t\tbw.write(Math.round((options.complexity ?? 0) * 254), 8);\n\t\tbw.write(Math.round((options.difficulty ?? 0) * 254), 8);\n\t\tbw.write(Math.round((options.pathLength ?? 0) * 254), 8);\n\n\t\tconst raw = bw.finish();\n\n\t\tconst gz = new Uint8Array(await new Response(new Blob([raw.buffer as ArrayBuffer]).stream().pipeThrough(new CompressionStream(\"gzip\"))).arrayBuffer());\n\n\t\tlet parity = 0;\n\t\tfor (const b of gz) parity ^= b;\n\n\t\tconst final = new Uint8Array(gz.length + 1);\n\t\tfinal.set(gz);\n\t\tfinal[gz.length] = parity;\n\n\t\treturn btoa(String.fromCharCode(...final))\n\t\t\t.replace(/\\+/g, \"-\")\n\t\t\t.replace(/\\//g, \"_\")\n\t\t\t.replace(/=+$/, \"\");\n\t}\n\n\tstatic async deserialize(str: string): Promise<{ puzzle: PuzzleData; options: GenerationOptions }> {\n\t\tlet s = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\t\twhile (s.length % 4) s += \"=\";\n\n\t\tconst bin = atob(s);\n\t\tconst buf = Uint8Array.from(bin, (c) => c.charCodeAt(0));\n\n\t\tlet parity = 0;\n\t\tfor (let i = 0; i < buf.length - 1; i++) parity ^= buf[i];\n\t\tif (parity !== buf.at(-1)) throw new Error(\"Invalid parity data\");\n\n\t\tconst raw = new Uint8Array(await new Response(new Blob([buf.slice(0, -1).buffer]).stream().pipeThrough(new DecompressionStream(\"gzip\"))).arrayBuffer());\n\n\t\tconst br = new BitReader(raw);\n\n\t\tconst rows = br.read(6);\n\t\tconst cols = br.read(6);\n\t\tconst symmetry = br.read(2);\n\n\t\t/* ---- shapes ---- */\n\t\tconst shapeCount = br.read(5);\n\t\tconst shapes: number[][][] = [];\n\n\t\tfor (let i = 0; i < shapeCount; i++) {\n\t\t\tconst h = br.read(4);\n\t\t\tconst w = br.read(4);\n\t\t\tconst s: number[][] = [];\n\t\t\tfor (let y = 0; y < h; y++) {\n\t\t\t\tconst r: number[] = [];\n\t\t\t\tfor (let x = 0; x < w; x++) r.push(br.read(1));\n\t\t\t\ts.push(r);\n\t\t\t}\n\t\t\tshapes.push(s);\n\t\t}\n\n\t\t/* ---- cells ---- */\n\t\tconst cells: CellConstraint[][] = [];\n\t\tfor (let y = 0; y < rows; y++) {\n\t\t\tconst row: CellConstraint[] = [];\n\t\t\tfor (let x = 0; x < cols; x++) {\n\t\t\t\tconst type = br.read(3);\n\t\t\t\tconst color = br.read(3);\n\t\t\t\tconst hasShape = br.read(1);\n\n\t\t\t\tconst cell: CellConstraint = { type, color };\n\t\t\t\tif (hasShape) cell.shape = shapes[br.read(5)].map((r) => r.slice());\n\n\t\t\t\trow.push(cell);\n\t\t\t}\n\t\t\tcells.push(row);\n\t\t}\n\n\t\t/* ---- edges & nodes ---- */\n\t\tconst vEdges = Array.from({ length: rows }, () => Array.from({ length: cols + 1 }, () => ({ type: br.read(2) })));\n\n\t\tconst hEdges = Array.from({ length: rows + 1 }, () => Array.from({ length: cols }, () => ({ type: br.read(2) })));\n\n\t\tconst nodes = Array.from({ length: rows + 1 }, () => Array.from({ length: cols + 1 }, () => ({ type: br.read(2) })));\n\n\t\tconst readRatio = () => {\n\t\t\tconst v = br.read(8);\n\t\t\treturn Math.round((v / 254) * 1000) / 1000;\n\t\t};\n\n\t\tconst options: GenerationOptions = {};\n\n\t\tconst useHexagons = !!br.read(1);\n\t\tconst useSquares = !!br.read(1);\n\t\tconst useStars = !!br.read(1);\n\t\tconst useTetris = !!br.read(1);\n\t\tconst useEraser = !!br.read(1);\n\t\tconst useBroken = !!br.read(1);\n\t\tconst optSymmetry = br.read(2);\n\n\t\tif (useHexagons) options.useHexagons = true;\n\t\tif (useSquares) options.useSquares = true;\n\t\tif (useStars) options.useStars = true;\n\t\tif (useTetris) options.useTetris = true;\n\t\tif (useEraser) options.useEraser = true;\n\t\tif (useBroken) options.useBrokenEdges = true;\n\t\toptions.symmetry = optSymmetry;\n\n\t\tconst complexity = readRatio();\n\t\tconst difficulty = readRatio();\n\t\tconst pathLength = readRatio();\n\n\t\tif (complexity !== 0) options.complexity = complexity;\n\t\tif (difficulty !== 0) options.difficulty = difficulty;\n\t\tif (pathLength !== 0) options.pathLength = pathLength;\n\n\t\treturn { puzzle: { rows, cols, cells, vEdges, hEdges, nodes, symmetry }, options };\n\t}\n}\n", "import { CellType, Color, EdgeType, NodeType, SymmetryType, type CellConstraint, type Point, type PuzzleData } from \"./types\";\n\n/**\n * UI\u8868\u793A\u8A2D\u5B9A\n */\nexport interface WitnessUIOptions {\n\t/** \u30B0\u30EA\u30C3\u30C9\u5468\u56F2\u306E\u4F59\u767D */\n\tgridPadding?: number;\n\t/** \u30BB\u30EB1\u8FBA\u306E\u30B5\u30A4\u30BA */\n\tcellSize?: number;\n\t/** \u901A\u5E38\u30CE\u30FC\u30C9\u306E\u534A\u5F84 */\n\tnodeRadius?: number;\n\t/** \u958B\u59CB\u30CE\u30FC\u30C9\u306E\u534A\u5F84 */\n\tstartNodeRadius?: number;\n\t/** \u30D1\u30B9\u306E\u592A\u3055 */\n\tpathWidth?: number;\n\t/** \u51FA\u53E3\u306E\u9577\u3055 */\n\texitLength?: number;\n\t/** \u30D1\u30BA\u30EB\u306E\u30B5\u30A4\u30BA\u306B\u5408\u308F\u305B\u3066Canvas\u30B5\u30A4\u30BA\u3092\u81EA\u52D5\u8ABF\u6574\u3059\u308B\u304B */\n\tautoResize?: boolean;\n\t/** \u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u8A2D\u5B9A */\n\tanimations?: {\n\t\t/** \u70B9\u6EC5\u30FB\u524D\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u306E\u6642\u9593(ms) */\n\t\tblinkDuration: number;\n\t\t/** \u7121\u52B9\u5316\u30D5\u30A7\u30FC\u30C9\u306E\u6642\u9593(ms) */\n\t\tfadeDuration: number;\n\t\t/** \u70B9\u6EC5\u306E\u5468\u671F(ms) */\n\t\tblinkPeriod: number;\n\t};\n\t/** \u8272\u8A2D\u5B9A */\n\tcolors?: {\n\t\t/** \u901A\u5E38\u306E\u30D1\u30B9\u306E\u8272 */\n\t\tpath?: string;\n\t\t/** \u30A8\u30E9\u30FC\u6642\u306E\u8272 */\n\t\terror?: string;\n\t\t/** \u6210\u529F\u6642\u306E\u30D5\u30E9\u30C3\u30B7\u30E5/\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u7528 */\n\t\tsuccess?: string;\n\t\t/** \u5BFE\u79F0\u30D1\u30B9\u306E\u8272 */\n\t\tsymmetry?: string;\n\t\t/** \u9014\u4E2D\u3067\u96E2\u3057\u305F\u969B\u306E\u30D5\u30A7\u30FC\u30C9\u8272 */\n\t\tinterrupted?: string;\n\t\t/** \u30B0\u30EA\u30C3\u30C9\u306E\u8272 */\n\t\tgrid?: string;\n\t\t/** \u30CE\u30FC\u30C9\u306E\u8272 */\n\t\tnode?: string;\n\t\t/** \u516D\u89D2\u5F62\uFF08\u901A\u904E\u5FC5\u9808\uFF09\u306E\u8272 */\n\t\thexagon?: string;\n\t\t/** \u5404\u8272\u306E\u30AB\u30E9\u30FC\u30B3\u30FC\u30C9\u30DE\u30C3\u30D7 */\n\t\tcolorMap?: Record<number, string>;\n\t\t/** \u5404\u8272\u306E\u30AB\u30E9\u30FC\u30B3\u30FC\u30C9\u30EA\u30B9\u30C8\uFF08\u30A4\u30F3\u30C7\u30C3\u30AF\u30B9\u304CColor\u5024\u306B\u5BFE\u5FDC\uFF09 */\n\t\tcolorList?: string[];\n\t};\n\t/** \u30D1\u30B9\u304C\u5B8C\u4E86\uFF08\u51FA\u53E3\u306B\u5230\u9054\uFF09\u3057\u305F\u969B\u306E\u30B3\u30FC\u30EB\u30D0\u30C3\u30AF */\n\tonPathComplete?: (path: Point[]) => void;\n}\n\ntype WitnessContext = CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\n\n/**\n * the witness\u30D1\u30BA\u30EB\u306E\u63CF\u753B\u3068\u30E6\u30FC\u30B6\u30FC\u64CD\u4F5C\u3092\u7BA1\u7406\u3059\u308B\u30AF\u30E9\u30B9\n */\nexport class WitnessUI {\n\tprivate canvas: HTMLCanvasElement | OffscreenCanvas;\n\tprivate ctx: WitnessContext;\n\tprivate puzzle: PuzzleData | null = null;\n\tprivate options: Required<WitnessUIOptions>;\n\n\tprivate path: Point[] = [];\n\tprivate isDrawing = false;\n\tprivate currentMousePos: Point = { x: 0, y: 0 };\n\tprivate exitTipPos: Point | null = null;\n\tprivate isInvalidPath = false;\n\n\t// \u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u30FB\u72B6\u614B\u8868\u793A\u7528\n\tprivate invalidatedCells: Point[] = [];\n\tprivate invalidatedEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\tprivate invalidatedNodes: Point[] = [];\n\tprivate errorCells: Point[] = [];\n\tprivate errorEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\tprivate errorNodes: Point[] = [];\n\tprivate eraserAnimationStartTime = 0;\n\tprivate isFading = false;\n\tprivate fadeOpacity = 1.0;\n\tprivate fadeColor = \"#ff4444\";\n\tprivate fadingPath: Point[] = [];\n\tprivate fadingTipPos: Point | null = null;\n\n\tprivate isSuccessFading = false;\n\tprivate successFadeStartTime = 0;\n\tprivate startTime = Date.now();\n\n\t// \u900F\u904E\u63CF\u753B\u7528\u306E\u30AA\u30D5\u30B9\u30AF\u30EA\u30FC\u30F3Canvas\n\tprivate offscreenCanvas: HTMLCanvasElement | OffscreenCanvas | null = null;\n\tprivate offscreenCtx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D | null = null;\n\n\tprivate canvasRect: { left: number; top: number; width: number; height: number } | null = null;\n\n\tconstructor(canvasOrId: HTMLCanvasElement | OffscreenCanvas | string, puzzle?: PuzzleData, options: WitnessUIOptions = {}) {\n\t\tif (typeof canvasOrId === \"string\") {\n\t\t\tif (typeof document === \"undefined\") {\n\t\t\t\tthrow new Error(\"Cannot look up canvas by ID in a non-browser environment.\");\n\t\t\t}\n\t\t\tconst el = document.getElementById(canvasOrId);\n\t\t\tif (!(el instanceof HTMLCanvasElement)) {\n\t\t\t\tthrow new Error(`Element with id \"${canvasOrId}\" is not a canvas.`);\n\t\t\t}\n\t\t\tthis.canvas = el;\n\t\t} else {\n\t\t\tthis.canvas = canvasOrId;\n\t\t}\n\n\t\tconst context = (this.canvas as HTMLCanvasElement).getContext(\"2d\") as WitnessContext | null;\n\t\tif (!context) throw new Error(\"Could not get 2D context.\");\n\t\tthis.ctx = context;\n\t\tthis.ctx.imageSmoothingEnabled = false;\n\n\t\tthis.options = this.mergeOptions(options);\n\n\t\tif (puzzle) {\n\t\t\tthis.setPuzzle(puzzle);\n\t\t}\n\n\t\tthis.initEvents();\n\t\tthis.animate();\n\t}\n\n\tprivate mergeOptions(options: WitnessUIOptions): Required<WitnessUIOptions> {\n\t\tconst animations = {\n\t\t\tblinkDuration: options.animations?.blinkDuration ?? this.options?.animations?.blinkDuration ?? 1000,\n\t\t\tfadeDuration: options.animations?.fadeDuration ?? this.options?.animations?.fadeDuration ?? 1000,\n\t\t\tblinkPeriod: options.animations?.blinkPeriod ?? this.options?.animations?.blinkPeriod ?? 800,\n\t\t};\n\n\t\tconst colors = {\n\t\t\tpath: options.colors?.path ?? this.options?.colors?.path ?? \"#ffcc00\",\n\t\t\terror: options.colors?.error ?? this.options?.colors?.error ?? \"#ff4444\",\n\t\t\tsuccess: options.colors?.success ?? this.options?.colors?.success ?? \"#ffcc00\",\n\t\t\tsymmetry: options.colors?.symmetry ?? this.options?.colors?.symmetry ?? \"rgba(255, 255, 255, 0.5)\",\n\t\t\tinterrupted: options.colors?.interrupted ?? this.options?.colors?.interrupted ?? \"#ffcc00\",\n\t\t\tgrid: options.colors?.grid ?? this.options?.colors?.grid ?? \"#555\",\n\t\t\tnode: options.colors?.node ?? this.options?.colors?.node ?? \"#555\",\n\t\t\thexagon: options.colors?.hexagon ?? this.options?.colors?.hexagon ?? \"#000\",\n\t\t\tcolorMap: options.colors?.colorMap ??\n\t\t\t\tthis.options?.colors?.colorMap ?? {\n\t\t\t\t\t[Color.Black]: \"#000\",\n\t\t\t\t\t[Color.White]: \"#fff\",\n\t\t\t\t\t[Color.Red]: \"#f00\",\n\t\t\t\t\t[Color.Blue]: \"#00f\",\n\t\t\t\t\t[Color.None]: \"#ffcc00\",\n\t\t\t\t},\n\t\t\tcolorList: options.colors?.colorList ?? this.options?.colors?.colorList,\n\t\t};\n\n\t\treturn {\n\t\t\tgridPadding: options.gridPadding ?? this.options?.gridPadding ?? 60,\n\t\t\tcellSize: options.cellSize ?? this.options?.cellSize ?? 80,\n\t\t\tnodeRadius: options.nodeRadius ?? this.options?.nodeRadius ?? 6,\n\t\t\tstartNodeRadius: options.startNodeRadius ?? this.options?.startNodeRadius ?? 22,\n\t\t\tpathWidth: options.pathWidth ?? this.options?.pathWidth ?? 18,\n\t\t\texitLength: options.exitLength ?? this.options?.exitLength ?? 25,\n\t\t\tautoResize: options.autoResize ?? this.options?.autoResize ?? true,\n\t\t\tanimations,\n\t\t\tcolors,\n\t\t\tonPathComplete: options.onPathComplete ?? this.options?.onPathComplete ?? (() => {}),\n\t\t};\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\u3092\u8A2D\u5B9A\u3057\u3001\u518D\u63CF\u753B\u3059\u308B\n\t */\n\tpublic setPuzzle(puzzle: PuzzleData) {\n\t\tthis.puzzle = puzzle;\n\t\tthis.path = [];\n\t\tthis.isDrawing = false;\n\t\tthis.exitTipPos = null;\n\t\tthis.invalidatedCells = [];\n\t\tthis.invalidatedEdges = [];\n\t\tthis.invalidatedNodes = [];\n\t\tthis.errorCells = [];\n\t\tthis.errorEdges = [];\n\t\tthis.errorNodes = [];\n\t\tthis.cancelFade();\n\n\t\tif (this.options.autoResize) {\n\t\t\tthis.resizeCanvas();\n\t\t}\n\t\tthis.draw();\n\t}\n\n\t/**\n\t * \u8868\u793A\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u66F4\u65B0\u3059\u308B\n\t */\n\tpublic setOptions(options: WitnessUIOptions) {\n\t\tthis.options = this.mergeOptions({ ...this.options, ...options });\n\t\tif (this.options.autoResize && this.puzzle) {\n\t\t\tthis.resizeCanvas();\n\t\t}\n\t\tthis.draw();\n\t}\n\n\t/**\n\t * \u691C\u8A3C\u7D50\u679C\u3092\u53CD\u6620\u3055\u305B\u308B\uFF08\u4E0D\u6B63\u89E3\u6642\u306E\u8D64\u70B9\u6EC5\u3084\u3001\u6D88\u3057\u30B4\u30E0\u306B\u3088\u308B\u7121\u52B9\u5316\u306E\u8868\u793A\uFF09\n\t */\n\tpublic setValidationResult(isValid: boolean, invalidatedCells: Point[] = [], invalidatedEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [], errorCells: Point[] = [], errorEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [], invalidatedNodes: Point[] = [], errorNodes: Point[] = []) {\n\t\tthis.invalidatedCells = invalidatedCells;\n\t\tthis.invalidatedEdges = invalidatedEdges;\n\t\tthis.invalidatedNodes = invalidatedNodes;\n\t\tthis.errorCells = errorCells;\n\t\tthis.errorEdges = errorEdges;\n\t\tthis.errorNodes = errorNodes;\n\t\tthis.eraserAnimationStartTime = Date.now();\n\n\t\tif (isValid) {\n\t\t\tthis.isSuccessFading = true;\n\t\t\tthis.successFadeStartTime = Date.now();\n\t\t} else {\n\t\t\tthis.isInvalidPath = true;\n\t\t}\n\t}\n\n\tprivate resizeCanvas() {\n\t\tif (!this.puzzle || !this.canvas) return;\n\t\tthis.canvas.width = this.puzzle.cols * this.options.cellSize + this.options.gridPadding * 2;\n\t\tthis.canvas.height = this.puzzle.rows * this.options.cellSize + this.options.gridPadding * 2;\n\t}\n\n\t/**\n\t * Canvas\u306E\u8868\u793A\u4E0A\u306E\u77E9\u5F62\u60C5\u5831\u3092\u8A2D\u5B9A\u3059\u308B\uFF08Worker\u6642\u306A\u3069\u306B\u5FC5\u8981\uFF09\n\t */\n\tpublic setCanvasRect(rect: { left: number; top: number; width: number; height: number }) {\n\t\tthis.canvasRect = rect;\n\t}\n\n\tprivate initEvents() {\n\t\tif (typeof window === \"undefined\" || !(this.canvas instanceof HTMLCanvasElement)) return;\n\t\tthis.canvas.addEventListener(\"mousedown\", (e) => this.handleStart(e));\n\t\twindow.addEventListener(\"mousemove\", (e) => this.handleMove(e));\n\t\twindow.addEventListener(\"mouseup\", (e) => this.handleEnd(e));\n\n\t\tthis.canvas.addEventListener(\n\t\t\t\"touchstart\",\n\t\t\t(e) => {\n\t\t\t\tif (this.handleStart(e.touches[0])) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ passive: false },\n\t\t);\n\t\twindow.addEventListener(\n\t\t\t\"touchmove\",\n\t\t\t(e) => {\n\t\t\t\tif (this.isDrawing) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t\tthis.handleMove(e.touches[0]);\n\t\t\t},\n\t\t\t{ passive: false },\n\t\t);\n\t\twindow.addEventListener(\n\t\t\t\"touchend\",\n\t\t\t(e) => {\n\t\t\t\tif (this.isDrawing) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t\tthis.handleEnd(e.changedTouches[0]);\n\t\t\t},\n\t\t\t{ passive: false },\n\t\t);\n\t}\n\n\t// --- \u5EA7\u6A19\u5909\u63DB ---\n\n\tprivate getCanvasCoords(gridX: number, gridY: number): Point {\n\t\treturn {\n\t\t\tx: this.options.gridPadding + gridX * this.options.cellSize,\n\t\t\ty: this.options.gridPadding + gridY * this.options.cellSize,\n\t\t};\n\t}\n\n\tprivate getExitDir(x: number, y: number): Point | null {\n\t\tif (!this.puzzle) return null;\n\t\tif (this.puzzle.nodes[y]?.[x]?.type !== NodeType.End) return null;\n\t\tif (x === this.puzzle.cols) return { x: 1, y: 0 };\n\t\tif (x === 0) return { x: -1, y: 0 };\n\t\tif (y === 0) return { x: 0, y: -1 };\n\t\tif (y === this.puzzle.rows) return { x: 0, y: 1 };\n\t\treturn { x: 1, y: 0 };\n\t}\n\n\t// --- \u30A4\u30D9\u30F3\u30C8\u30CF\u30F3\u30C9\u30E9 ---\n\n\tpublic handleStart(e: { clientX: number; clientY: number }): boolean {\n\t\tif (!this.puzzle) return false;\n\n\t\tconst rect = this.canvasRect || (this.canvas instanceof HTMLCanvasElement ? this.canvas.getBoundingClientRect() : { left: 0, top: 0, width: this.canvas.width, height: this.canvas.height });\n\t\tconst mouseX = (e.clientX - rect.left) * (this.canvas.width / rect.width);\n\t\tconst mouseY = (e.clientY - rect.top) * (this.canvas.height / rect.height);\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tif (this.puzzle.nodes[r][c].type === NodeType.Start) {\n\t\t\t\t\tconst nodePos = this.getCanvasCoords(c, r);\n\t\t\t\t\tconst dist = Math.hypot(nodePos.x - mouseX, nodePos.y - mouseY);\n\t\t\t\t\tif (dist < this.options.startNodeRadius) {\n\t\t\t\t\t\t// \u30B9\u30BF\u30FC\u30C8\u5730\u70B9\u304C\u30AF\u30EA\u30C3\u30AF\u3055\u308C\u305F\u5834\u5408\u306E\u307F\u3001\u524D\u56DE\u306E\u72B6\u614B\u3092\u30EA\u30BB\u30C3\u30C8\u3057\u3066\u958B\u59CB\u3059\u308B\n\t\t\t\t\t\tthis.cancelFade();\n\t\t\t\t\t\tthis.isSuccessFading = false;\n\t\t\t\t\t\tthis.isInvalidPath = false;\n\t\t\t\t\t\tthis.invalidatedCells = [];\n\t\t\t\t\t\tthis.invalidatedEdges = [];\n\t\t\t\t\t\tthis.invalidatedNodes = [];\n\t\t\t\t\t\tthis.errorCells = [];\n\t\t\t\t\t\tthis.errorEdges = [];\n\t\t\t\t\t\tthis.errorNodes = [];\n\n\t\t\t\t\t\tthis.isDrawing = true;\n\t\t\t\t\t\tthis.path = [{ x: c, y: r }];\n\t\t\t\t\t\tthis.currentMousePos = nodePos;\n\t\t\t\t\t\tthis.exitTipPos = null;\n\t\t\t\t\t\tthis.draw();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic handleMove(e: { clientX: number; clientY: number }) {\n\t\tif (!this.puzzle || !this.isDrawing) return;\n\n\t\tconst rect = this.canvasRect || (this.canvas instanceof HTMLCanvasElement ? this.canvas.getBoundingClientRect() : { left: 0, top: 0, width: this.canvas.width, height: this.canvas.height });\n\t\tconst mouseX = (e.clientX - rect.left) * (this.canvas.width / rect.width);\n\t\tconst mouseY = (e.clientY - rect.top) * (this.canvas.height / rect.height);\n\n\t\tconst lastPoint = this.path[this.path.length - 1];\n\t\tconst lastPos = this.getCanvasCoords(lastPoint.x, lastPoint.y);\n\n\t\tconst dx = mouseX - lastPos.x;\n\t\tconst dy = mouseY - lastPos.y;\n\n\t\tconst symmetry = this.puzzle.symmetry || SymmetryType.None;\n\n\t\tconst exitDir = this.getExitDir(lastPoint.x, lastPoint.y);\n\t\tconst intendedDir = Math.abs(dx) > Math.abs(dy) ? { x: dx > 0 ? 1 : -1, y: 0 } : { x: 0, y: dy > 0 ? 1 : -1 };\n\n\t\t// \u30B4\u30FC\u30EB\u306E\u51FA\u3063\u5F35\u308A\u65B9\u5411\u3078\u306E\u79FB\u52D5\n\t\tif (exitDir && intendedDir.x === exitDir.x && intendedDir.y === exitDir.y) {\n\t\t\tconst dot = dx * exitDir.x + dy * exitDir.y;\n\t\t\tconst length = Math.max(0, Math.min(dot, this.options.exitLength));\n\t\t\tthis.currentMousePos = {\n\t\t\t\tx: lastPos.x + exitDir.x * length,\n\t\t\t\ty: lastPos.y + exitDir.y * length,\n\t\t\t};\n\t\t\tthis.draw();\n\t\t\treturn;\n\t\t}\n\n\t\tconst tryMoveTo = (target: Point, d: number) => {\n\t\t\tconst edgeType = this.getEdgeType(lastPoint, target);\n\t\t\tif (target.x < 0 || target.x > this.puzzle!.cols || target.y < 0 || target.y > this.puzzle!.rows || edgeType === EdgeType.Absent) {\n\t\t\t\tthis.currentMousePos = lastPos;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet maxMove = edgeType === EdgeType.Broken ? this.options.cellSize * 0.35 : this.options.cellSize;\n\n\t\t\t// \u81EA\u5DF1\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\uFF08\u30E1\u30A4\u30F3\u30D1\u30B9\u306E\u30A8\u30C3\u30B8\uFF09\n\t\t\tconst targetEdgeKey = this.getEdgeKey(lastPoint, target);\n\t\t\tconst isBacktracking = this.path.length >= 2 && target.x === this.path[this.path.length - 2].x && target.y === this.path[this.path.length - 2].y;\n\n\t\t\tif (!isBacktracking) {\n\t\t\t\tfor (let i = 0; i < this.path.length - 1; i++) {\n\t\t\t\t\tif (this.getEdgeKey(this.path[i], this.path[i + 1]) === targetEdgeKey) {\n\t\t\t\t\t\t// \u65E2\u306B\u4F7F\u7528\u4E2D\u306E\u30A8\u30C3\u30B8\u306B\u5411\u304B\u3046\u5834\u5408\u306F\u3001\u5373\u5EA7\u306B\u30D6\u30ED\u30C3\u30AF\uFF08\u623B\u308B\u52D5\u4F5C\u306F\u5225\u9014 handleMove \u3067 snap \u51E6\u7406\u3055\u308C\u308B\uFF09\n\t\t\t\t\t\tmaxMove = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// \u81EA\u5DF1\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\uFF08\u30E1\u30A4\u30F3\u30D1\u30B9\u306E\u30CE\u30FC\u30C9\uFF09\n\t\t\tconst isTargetInPath = this.path.some((p) => p.x === target.x && p.y === target.y);\n\t\t\tif (isTargetInPath && this.path.length >= 2) {\n\t\t\t\tconst secondToLast = this.path[this.path.length - 2];\n\t\t\t\tif (target.x !== secondToLast.x || target.y !== secondToLast.y) {\n\t\t\t\t\tmaxMove = Math.min(maxMove, this.options.cellSize * 0.5 - this.options.pathWidth * 0.5);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst symLast = this.getSymmetricalPoint(lastPoint);\n\t\t\t\tconst symTarget = this.getSymmetricalPoint(target);\n\t\t\t\tconst symEdgeType = this.getEdgeType(symLast, symTarget);\n\t\t\t\tconst symPath = this.getSymmetryPath(this.path);\n\t\t\t\tconst symEdgeKey = this.getEdgeKey(symLast, symTarget);\n\n\t\t\t\tif (symTarget.x < 0 || symTarget.x > this.puzzle!.cols || symTarget.y < 0 || symTarget.y > this.puzzle!.rows || symEdgeType === EdgeType.Absent) {\n\t\t\t\t\tthis.currentMousePos = lastPos;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (symEdgeType === EdgeType.Broken) {\n\t\t\t\t\tmaxMove = Math.min(maxMove, this.options.cellSize * 0.35);\n\t\t\t\t}\n\n\t\t\t\t// \u5BFE\u79F0\u30D1\u30B9\u3068\u306E\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\n\t\t\t\tconst isNodeOccupiedBySym = symPath.some((p) => p.x === target.x && p.y === target.y);\n\t\t\t\tconst isSymNodeOccupiedByMain = this.path.some((p) => p.x === symTarget.x && p.y === symTarget.y);\n\t\t\t\tconst isMeetingAtNode = target.x === symTarget.x && target.y === symTarget.y;\n\t\t\t\tconst isEdgeOccupiedBySym = symPath.some((p, i) => i < symPath.length - 1 && this.getEdgeKey(symPath[i], symPath[i + 1]) === targetEdgeKey);\n\t\t\t\tconst isMirrorEdgeOccupiedByMain = this.path.some((p, i) => i < this.path.length - 1 && this.getEdgeKey(this.path[i], this.path[i + 1]) === symEdgeKey);\n\t\t\t\tconst isSelfMirrorEdge = targetEdgeKey === symEdgeKey;\n\n\t\t\t\tif (isNodeOccupiedBySym || isSymNodeOccupiedByMain || isMeetingAtNode || isEdgeOccupiedBySym || isMirrorEdgeOccupiedByMain || isSelfMirrorEdge) {\n\t\t\t\t\tmaxMove = Math.min(maxMove, this.options.cellSize * 0.5 - this.options.pathWidth * 0.5);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (target.x !== lastPoint.x) {\n\t\t\t\tthis.currentMousePos = {\n\t\t\t\t\tx: lastPos.x + Math.max(-maxMove, Math.min(maxMove, d)),\n\t\t\t\t\ty: lastPos.y,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthis.currentMousePos = {\n\t\t\t\t\tx: lastPos.x,\n\t\t\t\t\ty: lastPos.y + Math.max(-maxMove, Math.min(maxMove, d)),\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\n\t\tif (Math.abs(dx) > Math.abs(dy)) {\n\t\t\tconst dir = dx > 0 ? 1 : -1;\n\t\t\ttryMoveTo({ x: lastPoint.x + dir, y: lastPoint.y }, dx);\n\t\t} else {\n\t\t\tconst dir = dy > 0 ? 1 : -1;\n\t\t\ttryMoveTo({ x: lastPoint.x, y: lastPoint.y + dir }, dy);\n\t\t}\n\n\t\tconst neighbors = [\n\t\t\t{ x: lastPoint.x + 1, y: lastPoint.y },\n\t\t\t{ x: lastPoint.x - 1, y: lastPoint.y },\n\t\t\t{ x: lastPoint.x, y: lastPoint.y + 1 },\n\t\t\t{ x: lastPoint.x, y: lastPoint.y - 1 },\n\t\t];\n\n\t\tconst symPath = this.getSymmetryPath(this.path);\n\n\t\tfor (const n of neighbors) {\n\t\t\tif (n.x >= 0 && n.x <= this.puzzle.cols && n.y >= 0 && n.y <= this.puzzle.rows) {\n\t\t\t\tconst nPos = this.getCanvasCoords(n.x, n.y);\n\t\t\t\tconst dist = Math.hypot(nPos.x - this.currentMousePos.x, nPos.y - this.currentMousePos.y);\n\n\t\t\t\tif (dist < this.options.cellSize * 0.3) {\n\t\t\t\t\tconst idx = this.path.findIndex((p) => p.x === n.x && p.y === n.y);\n\t\t\t\t\tif (idx === -1) {\n\t\t\t\t\t\t// \u885D\u7A81\u30C1\u30A7\u30C3\u30AF\n\t\t\t\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\t\t\t\tconst sn = this.getSymmetricalPoint(n);\n\t\t\t\t\t\t\t// \u30CE\u30FC\u30C9\u81EA\u4F53\u304C\u5BFE\u79F0\u70B9\u306E\u5834\u5408\n\t\t\t\t\t\t\tif (n.x === sn.x && n.y === sn.y) continue;\n\t\t\t\t\t\t\t// \u4ED6\u306E\u7DDA\u3078\u306E\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\n\t\t\t\t\t\t\tif (this.path.some((p) => p.x === sn.x && p.y === sn.y)) continue;\n\t\t\t\t\t\t\tif (symPath.some((p) => p.x === n.x && p.y === n.y)) continue;\n\t\t\t\t\t\t\t// \u30A8\u30C3\u30B8\u306E\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\n\t\t\t\t\t\t\tconst edgeKey = this.getEdgeKey(lastPoint, n);\n\t\t\t\t\t\t\tconst symEdgeKey = this.getEdgeKey(this.getSymmetricalPoint(lastPoint), sn);\n\t\t\t\t\t\t\tif (edgeKey === symEdgeKey) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.path.push(n);\n\t\t\t\t\t} else if (idx === this.path.length - 2) {\n\t\t\t\t\t\tthis.path.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.draw();\n\t}\n\n\tpublic handleEnd(e: { clientX: number; clientY: number }) {\n\t\tif (!this.puzzle || !this.isDrawing) return;\n\t\tthis.isDrawing = false;\n\n\t\tconst lastPoint = this.path[this.path.length - 1];\n\t\tconst lastPos = this.getCanvasCoords(lastPoint.x, lastPoint.y);\n\t\tconst exitDir = this.getExitDir(lastPoint.x, lastPoint.y);\n\n\t\tif (exitDir) {\n\t\t\tconst dx_exit = this.currentMousePos.x - lastPos.x;\n\t\t\tconst dy_exit = this.currentMousePos.y - lastPos.y;\n\t\t\tconst dot = dx_exit * exitDir.x + dy_exit * exitDir.y;\n\n\t\t\tif (dot > 0) {\n\t\t\t\t// \u51FA\u3063\u5F35\u308A\u306E\u7BC4\u56F2\u306B\u5165\u3063\u3066\u3044\u308C\u3070\u3001\u6700\u5F8C\u307E\u3067\u4F38\u3070\u3057\u3066\u30B4\u30FC\u30EB\u3068\u3059\u308B\n\t\t\t\tthis.exitTipPos = {\n\t\t\t\t\tx: lastPos.x + exitDir.x * this.options.exitLength,\n\t\t\t\t\ty: lastPos.y + exitDir.y * this.options.exitLength,\n\t\t\t\t};\n\t\t\t\tthis.options.onPathComplete(this.path);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.exitTipPos = exitDir ? { ...this.currentMousePos } : null;\n\t\tthis.startFade(this.options.colors.interrupted); // \u9014\u4E2D\u3067\u96E2\u3057\u305F\u5834\u5408\u306F\u6307\u5B9A\u3055\u308C\u305F\u30D5\u30A7\u30FC\u30C9\u8272\u3067\u6D88\u3048\u308B\n\t}\n\n\tprivate getEdgeType(p1: Point, p2: Point): EdgeType {\n\t\tif (!this.puzzle) return EdgeType.Absent;\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\tif (y < 0 || y >= this.puzzle.rows) return EdgeType.Absent;\n\t\t\treturn this.puzzle.vEdges[y][p1.x].type;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\tif (x < 0 || x >= this.puzzle.cols) return EdgeType.Absent;\n\t\t\treturn this.puzzle.hEdges[p1.y][x].type;\n\t\t}\n\t}\n\n\tprivate startFade(color = \"#ff4444\") {\n\t\tthis.isFading = true;\n\t\tthis.fadeOpacity = 1.0;\n\t\tthis.fadeColor = color;\n\t\tthis.fadingPath = [...this.path];\n\t\tthis.fadingTipPos = this.exitTipPos ? { ...this.exitTipPos } : null;\n\t\tthis.path = [];\n\t}\n\n\tprivate cancelFade() {\n\t\tthis.isFading = false;\n\t}\n\n\tprivate animate() {\n\t\tif (typeof requestAnimationFrame === \"undefined\") {\n\t\t\tthis.draw();\n\t\t\treturn;\n\t\t}\n\t\tthis.draw();\n\n\t\tif (this.isFading) {\n\t\t\t// \u30D5\u30A7\u30FC\u30C9\u901F\u5EA6\u3092 fadeDuration \u306B\u57FA\u3065\u3044\u3066\u8A08\u7B97\n\t\t\tconst step = 1000 / (this.options.animations.fadeDuration * 60); // 60FPS\u60F3\u5B9A\n\t\t\tthis.fadeOpacity -= step;\n\t\t\tif (this.fadeOpacity <= 0) {\n\t\t\t\tthis.isFading = false;\n\t\t\t\tthis.fadeOpacity = 0;\n\t\t\t}\n\t\t}\n\n\t\trequestAnimationFrame(() => this.animate());\n\t}\n\n\t// --- Drawing Logic ---\n\n\tpublic draw() {\n\t\tif (!this.puzzle || !this.ctx) return;\n\n\t\tconst ctx = this.ctx;\n\t\tconst now = Date.now();\n\t\tctx.globalAlpha = 1.0;\n\t\tctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n\t\tthis.drawGrid(ctx);\n\t\tthis.drawConstraints(ctx);\n\t\tthis.drawNodes(ctx);\n\n\t\tif (this.path.length === 0 && !this.isDrawing) {\n\t\t\tthis.drawRipples(ctx);\n\t\t}\n\n\t\tif (this.isFading) {\n\t\t\tthis.drawPath(ctx, this.fadingPath, false, this.fadeColor, this.fadeOpacity, this.fadingTipPos);\n\t\t\tif (this.puzzle.symmetry !== undefined && this.puzzle.symmetry !== SymmetryType.None) {\n\t\t\t\tconst symFadingPath = this.getSymmetryPath(this.fadingPath);\n\t\t\t\tconst symColor = this.options.colors.symmetry as string;\n\t\t\t\tlet symTipPos: Point | null = null;\n\t\t\t\tif (this.fadingTipPos) {\n\t\t\t\t\tconst gridRelX = (this.fadingTipPos.x - this.options.gridPadding) / this.options.cellSize;\n\t\t\t\t\tconst gridRelY = (this.fadingTipPos.y - this.options.gridPadding) / this.options.cellSize;\n\t\t\t\t\tconst symGridRel = this.getSymmetricalPoint({ x: gridRelX, y: gridRelY });\n\t\t\t\t\tsymTipPos = {\n\t\t\t\t\t\tx: symGridRel.x * this.options.cellSize + this.options.gridPadding,\n\t\t\t\t\t\ty: symGridRel.y * this.options.cellSize + this.options.gridPadding,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// \u9014\u4E2D\u3067\u96E2\u3057\u305F\u5834\u5408\u306F\u30E1\u30A4\u30F3\u3068\u540C\u3058\u8272\u3067\u6D88\u3048\u3066\u3082\u826F\u3044\u304C\u3001\u4E00\u5FDC\u5BFE\u79F0\u5074\u306E\u8272\u3067\u30D5\u30A7\u30FC\u30C9\u3055\u305B\u308B\n\t\t\t\tthis.drawPath(ctx, symFadingPath, false, symColor, this.fadeOpacity, symTipPos);\n\t\t\t}\n\t\t} else if (this.path.length > 0) {\n\t\t\tlet color = this.isInvalidPath ? (this.options.colors.error as string) : (this.options.colors.path as string);\n\n\t\t\t// \u6210\u529F\u6642\u306F\u6210\u529F\u6642\u306E\u8272\u3092\u30C7\u30D5\u30A9\u30EB\u30C8\u3068\u3059\u308B\uFF08\u5BFE\u79F0\u30E2\u30FC\u30C9\u6642\u306F\u5143\u306E\u8272\u3092\u7DAD\u6301\uFF09\n\t\t\tif (this.isSuccessFading && !this.puzzle.symmetry) {\n\t\t\t\tcolor = this.options.colors.success as string;\n\t\t\t}\n\n\t\t\t// Eraser\u7121\u52B9\u5316\u524D\u306E\u70B9\u6EC5\u6642\u306A\u3069\u306E\u8272\u5236\u5FA1\n\t\t\tif (!this.isDrawing && this.exitTipPos && !this.isInvalidPath) {\n\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\t\t\t\tif (elapsed < blinkDuration) {\n\t\t\t\t\tif (this.isSuccessFading) {\n\t\t\t\t\t\tconst hasNegation = this.invalidatedCells.length > 0 || this.invalidatedEdges.length > 0 || this.invalidatedNodes.length > 0;\n\t\t\t\t\t\tif (hasNegation) {\n\t\t\t\t\t\t\t// \u6D88\u3057\u30B4\u30E0\u7121\u52B9\u5316\u304C\u3042\u308B\u6210\u529F\u6642\u306F\u3001\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u4E2D\u306E\u307F\u8D64\u8272\uFF08\u4E00\u77AC\u3067\u5207\u308A\u66FF\u3048\uFF09\n\t\t\t\t\t\t\tcolor = this.options.colors.error as string;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// \u5931\u6557\u6642\uFF08Eraser\u3042\u308A\uFF09\u306F\u70B9\u6EC5\u3055\u305B\u308B\n\t\t\t\t\t\t// \u958B\u59CB\u3068\u7D42\u4E86\u3092\u6ED1\u3089\u304B\u306B\u3059\u308B\n\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\n\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\n\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\n\n\t\t\t\t\t\tconst blinkFactor = (Math.sin((now * Math.PI * 2) / this.options.animations.blinkPeriod!) + 1) / 2;\n\t\t\t\t\t\tcolor = this.lerpColor(this.options.colors.path as string, this.options.colors.error as string, blinkFactor * transitionFactor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.drawPath(ctx, this.path, this.isDrawing, color, 1.0, this.isDrawing ? this.currentMousePos : this.exitTipPos);\n\n\t\t\tif (this.puzzle.symmetry !== undefined && this.puzzle.symmetry !== SymmetryType.None) {\n\t\t\t\tconst symPath = this.getSymmetryPath(this.path);\n\t\t\t\tlet symColor = this.options.colors.symmetry as string;\n\n\t\t\t\t// \u30A8\u30E9\u30FC\u6642\u3084\u6210\u529F\u6642\u306F\u8272\u3092\u4E0A\u66F8\u304D\uFF08\u5BFE\u79F0\u30E2\u30FC\u30C9\u6210\u529F\u6642\u306F\u5143\u306E\u8272\u3092\u7DAD\u6301\uFF09\n\t\t\t\tif (this.isInvalidPath) {\n\t\t\t\t\tsymColor = this.options.colors.error as string;\n\t\t\t\t}\n\n\t\t\t\tif (!this.isDrawing && this.exitTipPos && !this.isInvalidPath) {\n\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\t\t\t\t\tif (elapsed < blinkDuration) {\n\t\t\t\t\t\tif (this.isSuccessFading) {\n\t\t\t\t\t\t\tconst hasNegation = this.invalidatedCells.length > 0 || this.invalidatedEdges.length > 0 || this.invalidatedNodes.length > 0;\n\t\t\t\t\t\t\tif (hasNegation) {\n\t\t\t\t\t\t\t\tsymColor = this.options.colors.error as string;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\n\t\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\n\t\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\n\t\t\t\t\t\t\tconst blinkFactor = (Math.sin((now * Math.PI * 2) / this.options.animations.blinkPeriod!) + 1) / 2;\n\t\t\t\t\t\t\tsymColor = this.lerpColor(this.options.colors.symmetry as string, this.options.colors.error as string, blinkFactor * transitionFactor);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet symTipPos: Point | null = null;\n\t\t\t\tif (this.isDrawing || this.exitTipPos) {\n\t\t\t\t\tconst tip = this.isDrawing ? this.currentMousePos : this.exitTipPos!;\n\t\t\t\t\t// Canvas\u5EA7\u6A19\u304B\u3089\u30B0\u30EA\u30C3\u30C9\u76F8\u5BFE\u5EA7\u6A19\u306B\u5909\u63DB\u3057\u3066\u5BFE\u79F0\u70B9\u3092\u6C42\u3081\u3001\u518D\u5EA6Canvas\u5EA7\u6A19\u306B\u623B\u3059\n\t\t\t\t\tconst gridRelX = (tip.x - this.options.gridPadding) / this.options.cellSize;\n\t\t\t\t\tconst gridRelY = (tip.y - this.options.gridPadding) / this.options.cellSize;\n\t\t\t\t\tconst symGridRel = this.getSymmetricalPoint({ x: gridRelX, y: gridRelY }, true);\n\t\t\t\t\tsymTipPos = {\n\t\t\t\t\t\tx: symGridRel.x * this.options.cellSize + this.options.gridPadding,\n\t\t\t\t\t\ty: symGridRel.y * this.options.cellSize + this.options.gridPadding,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tthis.drawPath(ctx, symPath, this.isDrawing, symColor, 1.0, symTipPos);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate drawRipples(ctx: WitnessContext) {\n\t\tif (!this.puzzle) return;\n\t\tconst time = (Date.now() - this.startTime) / 500;\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tconst node = this.puzzle.nodes[r][c];\n\t\t\t\tif (node.type === NodeType.End) {\n\t\t\t\t\tconst pos = this.getCanvasCoords(c, r);\n\t\t\t\t\tconst dir = this.getExitDir(c, r);\n\t\t\t\t\tif (!dir) continue;\n\t\t\t\t\tconst exitPos = {\n\t\t\t\t\t\tx: pos.x + dir.x * this.options.exitLength,\n\t\t\t\t\t\ty: pos.y + dir.y * this.options.exitLength,\n\t\t\t\t\t};\n\n\t\t\t\t\tconst t = time % 4.0;\n\t\t\t\t\tconst radius = t * 5;\n\t\t\t\t\tconst opacity = Math.max(0, 1 - t / 3.0);\n\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(exitPos.x, exitPos.y, radius, 0, Math.PI * 2);\n\t\t\t\t\tctx.strokeStyle = `rgba(170, 170, 170, ${opacity * 0.4})`;\n\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate drawGrid(ctx: WitnessContext) {\n\t\tif (!this.puzzle || !this.options.colors.grid) return;\n\t\tctx.strokeStyle = this.options.colors.grid;\n\t\tctx.lineWidth = 12;\n\t\tctx.lineCap = \"round\";\n\n\t\tconst drawEdge = (p1: Point, p2: Point, type: EdgeType) => {\n\t\t\tif (type === EdgeType.Absent) return;\n\n\t\t\tif (type === EdgeType.Broken) {\n\t\t\t\tconst gapSize = 0.15;\n\t\t\t\tconst q1 = {\n\t\t\t\t\tx: p1.x + (p2.x - p1.x) * (0.5 - gapSize),\n\t\t\t\t\ty: p1.y + (p2.y - p1.y) * (0.5 - gapSize),\n\t\t\t\t};\n\t\t\t\tconst q2 = {\n\t\t\t\t\tx: p1.x + (p2.x - p1.x) * (0.5 + gapSize),\n\t\t\t\t\ty: p1.y + (p2.y - p1.y) * (0.5 + gapSize),\n\t\t\t\t};\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(p1.x, p1.y);\n\t\t\t\tctx.lineTo(q1.x, q1.y);\n\t\t\t\tctx.stroke();\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(q2.x, q2.y);\n\t\t\t\tctx.lineTo(p2.x, p2.y);\n\t\t\t\tctx.stroke();\n\t\t\t} else {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(p1.x, p1.y);\n\t\t\t\tctx.lineTo(p2.x, p2.y);\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t};\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c < this.puzzle.cols; c++) {\n\t\t\t\tdrawEdge(this.getCanvasCoords(c, r), this.getCanvasCoords(c + 1, r), this.puzzle.hEdges[r][c].type);\n\t\t\t}\n\t\t}\n\n\t\tfor (let r = 0; r < this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tdrawEdge(this.getCanvasCoords(c, r), this.getCanvasCoords(c, r + 1), this.puzzle.vEdges[r][c].type);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate drawConstraints(ctx: WitnessContext) {\n\t\tif (!this.puzzle) return;\n\t\tconst now = Date.now();\n\t\tconst blinkFactor = (Math.sin((now * Math.PI * 2) / this.options.animations.blinkPeriod!) + 1) / 2;\n\n\t\tfor (let r = 0; r < this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c < this.puzzle.cols; c++) {\n\t\t\t\tconst cell = this.puzzle.cells[r][c];\n\t\t\t\tconst pos = this.getCanvasCoords(c + 0.5, r + 0.5);\n\n\t\t\t\tconst isInvalidated = this.invalidatedCells.some((p) => p.x === c && p.y === r);\n\t\t\t\tconst isError = this.errorCells.some((p) => p.x === c && p.y === r);\n\n\t\t\t\tlet opacity = 1.0;\n\t\t\t\tlet overrideColor: string | undefined = undefined;\n\n\t\t\t\tconst originalColor = this.getColorCode(cell.color);\n\t\t\t\tconst errorColor = this.options.colors.error as string;\n\n\t\t\t\tif (isError) {\n\t\t\t\t\toverrideColor = this.lerpColor(originalColor, errorColor, blinkFactor);\n\t\t\t\t}\n\n\t\t\t\tif (isInvalidated) {\n\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\n\t\t\t\t\tif (this.isFading) {\n\t\t\t\t\t\topacity = this.fadeOpacity;\n\t\t\t\t\t} else if (elapsed < blinkDuration) {\n\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\n\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\n\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\n\t\t\t\t\t\toverrideColor = this.lerpColor(originalColor, errorColor, blinkFactor * transitionFactor);\n\t\t\t\t\t} else {\n\t\t\t\t\t\topacity = Math.max(0.3, 1.0 - (elapsed - blinkDuration) / this.options.animations.fadeDuration!);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (opacity < 1.0 || overrideColor) {\n\t\t\t\t\tconst { canvas: tempCanvas, ctx: tempCtx } = this.prepareOffscreen();\n\t\t\t\t\tthis.drawConstraintItem(tempCtx, cell, pos, overrideColor);\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.globalAlpha = opacity;\n\t\t\t\t\tctx.drawImage(tempCanvas, 0, 0);\n\t\t\t\t\tctx.restore();\n\t\t\t\t} else {\n\t\t\t\t\tthis.drawConstraintItem(ctx, cell, pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tctx.lineWidth = 2;\n\t\tconst hexRadius = 8;\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c < this.puzzle.cols; c++) {\n\t\t\t\tif (this.puzzle.hEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst pos = this.getCanvasCoords(c + 0.5, r);\n\t\t\t\t\tctx.save();\n\t\t\t\t\tconst isInvalidated = this.invalidatedEdges.some((e) => e.type === \"h\" && e.r === r && e.c === c);\n\t\t\t\t\tconst isError = this.errorEdges.some((e) => e.type === \"h\" && e.r === r && e.c === c);\n\n\t\t\t\t\tif (isError) {\n\t\t\t\t\t\tconst color = this.lerpColor(this.options.colors.hexagon as string, this.options.colors.error as string, blinkFactor);\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t} else if (isInvalidated) {\n\t\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\t\t\t\t\t\tif (this.isFading) ctx.globalAlpha *= this.fadeOpacity;\n\t\t\t\t\t\telse if (elapsed < blinkDuration) {\n\t\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\n\t\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\n\t\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\n\t\t\t\t\t\t\tconst color = this.lerpColor(this.options.colors.hexagon as string, this.options.colors.error as string, blinkFactor * transitionFactor);\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.globalAlpha *= Math.max(0.3, 1.0 - (elapsed - blinkDuration) / this.options.animations.fadeDuration!);\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius);\n\t\t\t\t\t}\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tif (this.puzzle.vEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst pos = this.getCanvasCoords(c, r + 0.5);\n\t\t\t\t\tctx.save();\n\t\t\t\t\tconst isInvalidated = this.invalidatedEdges.some((e) => e.type === \"v\" && e.r === r && e.c === c);\n\t\t\t\t\tconst isError = this.errorEdges.some((e) => e.type === \"v\" && e.r === r && e.c === c);\n\n\t\t\t\t\tif (isError) {\n\t\t\t\t\t\tconst color = this.lerpColor(this.options.colors.hexagon as string, this.options.colors.error as string, blinkFactor);\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t} else if (isInvalidated) {\n\t\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\t\t\t\t\t\tif (this.isFading) ctx.globalAlpha *= this.fadeOpacity;\n\t\t\t\t\t\telse if (elapsed < blinkDuration) {\n\t\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\n\t\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\n\t\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\n\t\t\t\t\t\t\tconst color = this.lerpColor(this.options.colors.hexagon as string, this.options.colors.error as string, blinkFactor * transitionFactor);\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.globalAlpha *= Math.max(0.3, 1.0 - (elapsed - blinkDuration) / this.options.animations.fadeDuration!);\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius);\n\t\t\t\t\t}\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tif (this.puzzle.nodes[r][c].type === NodeType.Hexagon) {\n\t\t\t\t\tconst pos = this.getCanvasCoords(c, r);\n\t\t\t\t\tctx.save();\n\t\t\t\t\tconst isInvalidated = this.invalidatedNodes.some((p) => p.x === c && p.y === r);\n\t\t\t\t\tconst isError = this.errorNodes.some((p) => p.x === c && p.y === r);\n\n\t\t\t\t\tif (isError) {\n\t\t\t\t\t\tconst color = this.lerpColor(this.options.colors.hexagon as string, this.options.colors.error as string, blinkFactor);\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t} else if (isInvalidated) {\n\t\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\t\t\t\t\t\tif (this.isFading) ctx.globalAlpha *= this.fadeOpacity;\n\t\t\t\t\t\telse if (elapsed < blinkDuration) {\n\t\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\n\t\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\n\t\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\n\t\t\t\t\t\t\tconst color = this.lerpColor(this.options.colors.hexagon as string, this.options.colors.error as string, blinkFactor * transitionFactor);\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.globalAlpha *= Math.max(0.3, 1.0 - (elapsed - blinkDuration) / this.options.animations.fadeDuration!);\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius);\n\t\t\t\t\t}\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u5358\u4E00\u306E\u5236\u7D04\u30A2\u30A4\u30C6\u30E0\u3092\u63CF\u753B\uFF08\u5EA7\u6A19\u306F\u30AD\u30E3\u30F3\u30D0\u30B9\u5168\u4F53\u306B\u5BFE\u3059\u308B\u7D76\u5BFE\u5EA7\u6A19\uFF09\n\t */\n\tprivate drawConstraintItem(ctx: WitnessContext, cell: CellConstraint, pos: Point, overrideColor?: string) {\n\t\tif (cell.type === CellType.Square) {\n\t\t\tconst size = 26;\n\t\t\tconst radius = 8;\n\t\t\tctx.fillStyle = overrideColor || this.getColorCode(cell.color);\n\t\t\tthis.drawRoundedRect(ctx, pos.x - size / 2, pos.y - size / 2, size, size, radius);\n\t\t} else if (cell.type === CellType.Star) {\n\t\t\tthis.drawStar(ctx, pos.x, pos.y, 12, 16, 8, cell.color, overrideColor);\n\t\t} else if (cell.type === CellType.Tetris || cell.type === CellType.TetrisRotated) {\n\t\t\tthis.drawTetris(ctx, pos.x, pos.y, cell.shape || [], cell.type === CellType.TetrisRotated, cell.color, overrideColor);\n\t\t} else if (cell.type === CellType.Eraser) {\n\t\t\tthis.drawEraser(ctx, pos.x, pos.y, 14, 3, cell.color, overrideColor);\n\t\t}\n\t}\n\n\tprivate drawNodes(ctx: WitnessContext) {\n\t\tif (!this.puzzle) return;\n\t\tconst isNodeIsolated = (c: number, r: number) => {\n\t\t\tconst connectedEdges: EdgeType[] = [];\n\t\t\tif (c > 0) connectedEdges.push(this.puzzle!.hEdges[r][c - 1].type);\n\t\t\tif (c < this.puzzle!.cols) connectedEdges.push(this.puzzle!.hEdges[r][c].type);\n\t\t\tif (r > 0) connectedEdges.push(this.puzzle!.vEdges[r - 1][c].type);\n\t\t\tif (r < this.puzzle!.rows) connectedEdges.push(this.puzzle!.vEdges[r][c].type);\n\t\t\treturn connectedEdges.length > 0 && connectedEdges.every((e) => e === EdgeType.Absent);\n\t\t};\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tif (isNodeIsolated(c, r)) continue;\n\n\t\t\t\tconst node = this.puzzle.nodes[r][c];\n\t\t\t\tif (node.type === NodeType.Hexagon) continue;\n\n\t\t\t\tconst pos = this.getCanvasCoords(c, r);\n\n\t\t\t\tif (node.type === NodeType.Start) {\n\t\t\t\t\tif (this.options.colors.node) ctx.fillStyle = this.options.colors.node;\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(pos.x, pos.y, this.options.startNodeRadius, 0, Math.PI * 2);\n\t\t\t\t\tctx.fill();\n\t\t\t\t} else if (node.type === NodeType.End) {\n\t\t\t\t\tconst dir = this.getExitDir(c, r);\n\t\t\t\t\tif (!dir) continue;\n\t\t\t\t\tif (this.options.colors.node) ctx.strokeStyle = this.options.colors.node;\n\t\t\t\t\tctx.lineWidth = 12;\n\t\t\t\t\tctx.lineCap = \"round\";\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(pos.x, pos.y);\n\t\t\t\t\tctx.lineTo(pos.x + dir.x * this.options.exitLength, pos.y + dir.y * this.options.exitLength);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t} else {\n\t\t\t\t\tif (this.options.colors.node) ctx.fillStyle = this.options.colors.node;\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(pos.x, pos.y, this.options.nodeRadius, 0, Math.PI * 2);\n\t\t\t\t\tctx.fill();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate drawPath(ctx: WitnessContext, path: Point[], isDrawing: boolean, color: string | undefined, opacity: number, tipPos: Point | null = null) {\n\t\tif (path.length === 0 || !color) return;\n\n\t\tlet finalOpacity = opacity;\n\t\tlet finalColor = color;\n\t\tif (color.startsWith(\"rgba\")) {\n\t\t\tconst match = color.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\n\t\t\tif (match) {\n\t\t\t\tconst r = match[1];\n\t\t\t\tconst g = match[2];\n\t\t\t\tconst b = match[3];\n\t\t\t\tconst a = match[4] ? parseFloat(match[4]) : 1.0;\n\t\t\t\tfinalColor = `rgb(${r},${g},${b})`;\n\t\t\t\tfinalOpacity *= a;\n\t\t\t}\n\t\t} else if (color === \"transparent\") {\n\t\t\treturn;\n\t\t}\n\n\t\t// \u91CD\u306A\u308A\u90E8\u5206\u306E\u8272\u304C\u6FC3\u304F\u306A\u308B\u306E\u3092\u9632\u3050\u305F\u3081\u3001\u5E38\u306B\u30AA\u30D5\u30B9\u30AF\u30EA\u30FC\u30F3\u3067\u4E0D\u900F\u660E\u306B\u63CF\u753B\u3057\u3066\u304B\u3089\u900F\u904E\u3067\u5408\u6210\u3059\u308B\n\t\tconst { canvas: tempCanvas, ctx: tempCtx } = this.prepareOffscreen();\n\t\tthis.drawPathInternal(tempCtx, path, isDrawing, finalColor, tipPos);\n\t\tctx.save();\n\t\tctx.globalAlpha = finalOpacity;\n\t\tctx.drawImage(tempCanvas, 0, 0);\n\t\tctx.restore();\n\t}\n\n\tprivate drawPathInternal(ctx: WitnessContext, path: Point[], isDrawing: boolean, color: string, tipPos: Point | null = null) {\n\t\tctx.save();\n\t\tctx.strokeStyle = color;\n\t\tctx.fillStyle = color;\n\t\tctx.lineWidth = this.options.pathWidth;\n\t\tctx.lineCap = \"round\";\n\t\tctx.lineJoin = \"round\";\n\n\t\tctx.beginPath();\n\t\tconst startPos = this.getCanvasCoords(path[0].x, path[0].y);\n\t\tctx.moveTo(startPos.x, startPos.y);\n\n\t\tfor (let i = 1; i < path.length; i++) {\n\t\t\tconst pos = this.getCanvasCoords(path[i].x, path[i].y);\n\t\t\tctx.lineTo(pos.x, pos.y);\n\t\t}\n\n\t\tconst actualTipPos = tipPos || this.currentMousePos;\n\t\tif (isDrawing || tipPos) {\n\t\t\tctx.lineTo(actualTipPos.x, actualTipPos.y);\n\t\t}\n\n\t\tctx.stroke();\n\n\t\tctx.beginPath();\n\t\tctx.arc(startPos.x, startPos.y, this.options.startNodeRadius, 0, Math.PI * 2);\n\t\tctx.fill();\n\n\t\tif (isDrawing || tipPos) {\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(actualTipPos.x, actualTipPos.y, this.options.pathWidth / 2, 0, Math.PI * 2);\n\t\t\tctx.fill();\n\t\t}\n\t\tctx.restore();\n\t}\n\n\tprivate drawRoundedRect(ctx: WitnessContext, x: number, y: number, width: number, height: number, radius: number) {\n\t\tctx.beginPath();\n\t\tctx.moveTo(x + radius, y);\n\t\tctx.lineTo(x + width - radius, y);\n\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\tctx.lineTo(x + width, y + height - radius);\n\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\tctx.lineTo(x + radius, y + height);\n\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\tctx.lineTo(x, y + radius);\n\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\tctx.closePath();\n\t\tctx.fill();\n\t}\n\n\tprivate drawHexagon(ctx: WitnessContext, x: number, y: number, radius: number, overrideColor?: string) {\n\t\tif (!this.options.colors.hexagon && !overrideColor) return;\n\t\tctx.fillStyle = (overrideColor || this.options.colors.hexagon) as string;\n\t\tctx.beginPath();\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tconst angle = (Math.PI / 3) * i;\n\t\t\tconst px = x + radius * Math.cos(angle);\n\t\t\tconst py = y + radius * Math.sin(angle);\n\t\t\tif (i === 0) ctx.moveTo(px, py);\n\t\t\telse ctx.lineTo(px, py);\n\t\t}\n\t\tctx.closePath();\n\t\tctx.fill();\n\t}\n\n\tprivate drawEraser(ctx: WitnessContext, x: number, y: number, radius: number, points: number, colorEnum: Color, overrideColor?: string) {\n\t\tctx.strokeStyle = overrideColor || this.getColorCode(colorEnum);\n\t\tctx.lineWidth = radius * 0.5;\n\t\tctx.lineCap = \"butt\";\n\t\tconst rotation = 0.5;\n\t\tctx.beginPath();\n\t\tfor (let i = 0; i < points; i++) {\n\t\t\tconst angle = ((Math.PI * 2) / points) * i + rotation;\n\t\t\tconst px = x + radius * Math.cos(angle);\n\t\t\tconst py = y + radius * Math.sin(angle);\n\n\t\t\tctx.moveTo(x, y);\n\t\t\tctx.lineTo(px, py);\n\t\t}\n\t\tctx.stroke();\n\t}\n\n\tprivate drawStar(ctx: WitnessContext, x: number, y: number, innerRadius: number, outerRadius: number, points: number, colorEnum: Color, overrideColor?: string) {\n\t\tctx.fillStyle = overrideColor || this.getColorCode(colorEnum);\n\t\tctx.beginPath();\n\t\tfor (let i = 0; i < points * 2; i++) {\n\t\t\tconst radius = i % 2 === 0 ? outerRadius : innerRadius;\n\t\t\tconst angle = (Math.PI / points) * i;\n\t\t\tconst px = x + radius * Math.cos(angle);\n\t\t\tconst py = y + radius * Math.sin(angle);\n\t\t\tif (i === 0) ctx.moveTo(px, py);\n\t\t\telse ctx.lineTo(px, py);\n\t\t}\n\t\tctx.closePath();\n\t\tctx.fill();\n\t}\n\n\tprivate drawTetris(ctx: WitnessContext, x: number, y: number, shape: number[][], rotated: boolean, colorEnum: Color, overrideColor?: string) {\n\t\tif (!shape || shape.length === 0) return;\n\t\tconst cellSize = 12;\n\t\tconst gap = 2;\n\t\tconst totalW = shape[0].length * cellSize + (shape[0].length - 1) * gap;\n\t\tconst totalH = shape.length * cellSize + (shape.length - 1) * gap;\n\n\t\tctx.save();\n\t\tctx.translate(x, y);\n\t\tif (rotated) {\n\t\t\tctx.rotate(Math.PI / 8);\n\t\t}\n\t\t// overrideColor\u304C\u3042\u308B\u5834\u5408\u306F\u305D\u308C\u3092\u512A\u5148\u3001\u306A\u3051\u308C\u3070Color.None\u304B\u3064\u30C7\u30D5\u30A9\u30EB\u30C8\u30AB\u30E9\u30FC\u8A2D\u5B9A\u304C\u306A\u3044\u5834\u5408\u306F\u9EC4\u8272(#ffcc00)\n\t\tctx.fillStyle = overrideColor || this.getColorCode(colorEnum, \"#ffcc00\");\n\n\t\tfor (let r = 0; r < shape.length; r++) {\n\t\t\tfor (let c = 0; c < shape[r].length; c++) {\n\t\t\t\tif (shape[r][c]) {\n\t\t\t\t\tconst px = c * (cellSize + gap) - totalW / 2;\n\t\t\t\t\tconst py = r * (cellSize + gap) - totalH / 2;\n\t\t\t\t\tctx.fillRect(px, py, cellSize, cellSize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx.restore();\n\t}\n\n\tprivate getColorCode(colorEnum: Color, defaultFallback = \"#666\"): string {\n\t\tif (this.options.colors.colorList && this.options.colors.colorList[colorEnum] !== undefined) {\n\t\t\treturn this.options.colors.colorList[colorEnum];\n\t\t}\n\t\tif (this.options.colors.colorMap && this.options.colors.colorMap[colorEnum] !== undefined) {\n\t\t\treturn this.options.colors.colorMap[colorEnum];\n\t\t}\n\t\treturn defaultFallback;\n\t}\n\n\tprivate hexToRgb(hex: string): { r: number; g: number; b: number } {\n\t\tlet c = hex.startsWith(\"#\") ? hex.slice(1) : hex;\n\t\tif (c.length === 3) {\n\t\t\tc = c\n\t\t\t\t.split(\"\")\n\t\t\t\t.map((s) => s + s)\n\t\t\t\t.join(\"\");\n\t\t}\n\t\tconst i = parseInt(c, 16);\n\t\treturn {\n\t\t\tr: (i >> 16) & 255,\n\t\t\tg: (i >> 8) & 255,\n\t\t\tb: i & 255,\n\t\t};\n\t}\n\n\tprivate rgbToHex(r: number, g: number, b: number): string {\n\t\treturn \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n\t}\n\n\tprivate lerpColor(c1: string, c2: string, t: number): string {\n\t\ttry {\n\t\t\tconst rgb1 = this.hexToRgb(c1);\n\t\t\tconst rgb2 = this.hexToRgb(c2);\n\t\t\treturn this.rgbToHex(Math.round(rgb1.r + (rgb2.r - rgb1.r) * t), Math.round(rgb1.g + (rgb2.g - rgb1.g) * t), Math.round(rgb1.b + (rgb2.b - rgb1.b) * t));\n\t\t} catch (e) {\n\t\t\treturn c1;\n\t\t}\n\t}\n\n\tprivate getSymmetryPath(path: Point[]): Point[] {\n\t\tif (!this.puzzle || !this.puzzle.symmetry) return [];\n\t\treturn path.map((p) => this.getSymmetricalPoint(p));\n\t}\n\n\tprivate getSymmetricalPoint(p: Point, isFloat = false): Point {\n\t\tif (!this.puzzle || !this.puzzle.symmetry) return { ...p };\n\t\tconst { cols, rows, symmetry } = this.puzzle;\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\treturn { x: cols - p.x, y: p.y };\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\treturn { x: p.x, y: rows - p.y };\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\treturn { x: cols - p.x, y: rows - p.y };\n\t\t}\n\t\treturn { ...p };\n\t}\n\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t}\n\n\tprivate prepareOffscreen(): { canvas: HTMLCanvasElement | OffscreenCanvas; ctx: WitnessContext } {\n\t\tif (!this.offscreenCanvas) {\n\t\t\tif (typeof document !== \"undefined\") {\n\t\t\t\tthis.offscreenCanvas = document.createElement(\"canvas\");\n\t\t\t} else if (typeof OffscreenCanvas !== \"undefined\") {\n\t\t\t\tthis.offscreenCanvas = new OffscreenCanvas(this.canvas.width, this.canvas.height);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Offscreen canvas not supported in this environment.\");\n\t\t\t}\n\t\t\tthis.offscreenCtx = (this.offscreenCanvas as HTMLCanvasElement).getContext(\"2d\") as WitnessContext | null;\n\t\t}\n\t\tif (this.offscreenCanvas.width !== this.canvas.width || this.offscreenCanvas.height !== this.canvas.height) {\n\t\t\tthis.offscreenCanvas.width = this.canvas.width;\n\t\t\tthis.offscreenCanvas.height = this.canvas.height;\n\t\t}\n\t\tif (!this.offscreenCtx) throw new Error(\"Could not get offscreen 2D context.\");\n\t\tthis.offscreenCtx.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);\n\t\treturn { canvas: this.offscreenCanvas, ctx: this.offscreenCtx };\n\t}\n}\n", "import { PuzzleGenerator } from \"./generator\";\nimport { Grid } from \"./grid\";\nimport type { GenerationOptions, PuzzleData, SolutionPath, ValidationResult } from \"./types\";\nimport { PuzzleValidator } from \"./validator\";\n\n// \u30E9\u30A4\u30D6\u30E9\u30EA\u306E\u30D5\u30A1\u30B5\u30FC\u30C9\u30AF\u30E9\u30B9\nexport { PuzzleGenerator } from \"./generator\";\nexport { Grid } from \"./grid\";\nexport { PuzzleSerializer } from \"./serializer\";\nexport { WitnessUI } from \"./ui\";\nexport { PuzzleValidator } from \"./validator\";\n\nexport class WitnessCore {\n\tprivate generator: PuzzleGenerator;\n\tprivate validator: PuzzleValidator;\n\n\tconstructor() {\n\t\tthis.generator = new PuzzleGenerator();\n\t\tthis.validator = new PuzzleValidator();\n\t}\n\n\t/**\n\t * \u65B0\u3057\u3044\u30D1\u30BA\u30EB\u3092\u751F\u6210\u3057\u3066\u30C7\u30FC\u30BF\u3092\u8FD4\u3059\n\t */\n\tpublic createPuzzle(rows: number, cols: number, options: GenerationOptions = {}): PuzzleData {\n\t\tconst grid = this.generator.generate(rows, cols, options);\n\t\treturn grid.export();\n\t}\n\n\t/**\n\t * \u89E3\u7B54\u3092\u691C\u8A3C\u3059\u308B\n\t */\n\tpublic validateSolution(puzzleData: PuzzleData, solution: SolutionPath): ValidationResult {\n\t\tconst grid = Grid.fromData(puzzleData);\n\t\treturn this.validator.validate(grid, solution);\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u306E\u96E3\u6613\u5EA6\u3092\u8A08\u7B97\u3059\u308B\n\t */\n\tpublic calculateDifficulty(puzzleData: PuzzleData): number {\n\t\tconst grid = Grid.fromData(puzzleData);\n\t\treturn this.validator.calculateDifficulty(grid);\n\t}\n}\n\n// \u30D6\u30E9\u30A6\u30B6/Node.js\u74B0\u5883\u4E21\u5BFE\u5FDC\u306E\u305F\u3081\u306E\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\nexport * from \"./types\";\n"],
  "mappings": "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",
  "names": ["Direction", "CellType", "EdgeType", "NodeType", "SymmetryType", "Color", "Grid", "_Grid", "rows", "cols", "Color", "data", "grid", "PuzzleValidator", "grid", "solution", "externalCellsPrecalculated", "path", "symmetry", "symPath", "p", "start", "end", "symStart", "symEnd", "visitedNodes", "visitedEdges", "i", "p1", "p2", "key", "sp1", "sp2", "symKey", "edgeKey", "regions", "missed", "result", "type", "y", "x", "pathEdges", "pathNodes", "missedEdges", "r", "missedNodes", "missedHexagons", "missedNodeHexagons", "regionResults", "allRegionsPossiblyValid", "region", "erasers", "otherMarks", "adjacentMissedHexagons", "j", "adjacentMissedNodeHexagons", "possible", "bestEffort", "a", "b", "costA", "costB", "assignment", "idx", "errorCells", "invalidatedCells", "invalidatedHexIndices", "invalidatedNodeHexIndices", "options", "best", "errorEdges", "errorNodes", "hex", "regionCells", "node", "adjCells", "cell", "results", "numErasers", "itemsToNegate", "initiallyValid", "N", "negatedEraserCombinations", "negatedErasers", "negatedErasersSet", "e", "activeErasers", "K", "itemCombinations", "negatedItems", "negatedCells", "it", "negatedHexIndices", "negatedNodeHexIndices", "isUseful", "subset", "subsetCells", "subsetHexIndices", "subsetNodeHexIndices", "allHexSatisfied", "allNodeHexSatisfied", "naturalErrors", "bestResult", "minErrorCount", "tryNegate", "priorityItems", "toInvalidateCells", "toInvalidateHexagons", "toInvalidateNodeHexagons", "usedErasersCount", "item", "remainingForPairs", "errorCount", "errCell", "items", "n", "backtrack", "current", "erasedCells", "erasedSet", "colorCounts", "colorCells", "starColors", "squareColors", "tetrisPieces", "constraint", "color", "Color", "cells", "totalMissedHexagons", "totalMissedNodeHexagons", "numRegions", "currentHexErasures", "currentNodeHexErasures", "allInvalidatedCells", "allInvalidatedHexIndices", "allInvalidatedNodeHexIndices", "regionIdx", "count", "option", "hexIdx", "pieces", "sum", "minX", "minY", "maxX", "maxY", "width", "height", "regionGrid", "shape", "area", "row", "r0", "c0", "c", "piece", "nextPieces", "rotations", "blocks", "pr", "pc", "anchor", "dr", "dc", "nr", "nc", "value", "keys", "curr", "rows", "cols", "newShape", "visitedCells", "externalCells", "queue", "neighbors", "neighborKey", "external", "nodeCols", "sr", "sc", "nodeCount", "adj", "startNodes", "endNodes", "hexagonEdges", "hexagonNodes", "u", "v", "isHexagon", "isBroken", "stats", "totalHexagons", "fingerprints", "searchLimit", "hasCellMarks", "startIdx", "startIsHex", "visitedMask", "snStart", "constraintCount", "constraintTypes", "tetrisCount", "rotatedTetrisCount", "branchingFactor", "searchComplexity", "difficulty", "cellCount", "density", "densityFactor", "typeFactor", "sizeFactor", "currIdx", "hexagonsOnPath", "limit", "points", "solutionPath", "snEnd", "fp", "validMoves", "edge", "snCurr", "snNext", "otherEdge", "isAlreadyOnPath", "isNextMove", "move", "nodeIsHex", "nextVisitedMask", "localVisited", "head", "precalculatedRegions", "f", "PuzzleGenerator", "rows", "cols", "options", "targetDifficulty", "validator", "PuzzleValidator", "bestGrid", "bestScore", "maxAttempts", "markAttemptsPerPath", "symmetry", "startPoint", "endPoint", "currentPath", "precalculatedRegions", "precalculatedBoundaryEdges", "attempt", "Grid", "tempGrid", "symPath", "p", "region", "grid", "difficulty", "diffFromTarget", "path", "solutionPath", "symStart", "symEnd", "start", "end", "targetLengthFactor", "minLen", "maxLen", "targetLen", "bestPath", "bestDiff", "attempts", "i", "currentLen", "diff", "biasFactor", "visited", "nodesVisited", "limit", "findPath", "current", "snCurrent", "neighbors", "n", "sn", "edgeKey", "symEdgeKey", "a", "b", "da", "db", "next", "candidates", "directions", "d", "nx", "ny", "complexity", "pathEdges", "unusedEdges", "r", "c", "p1", "p2", "targetCount", "placed", "edge", "changed", "edgesWithMeta", "m", "nodes", "node", "adjEdges", "adj", "startNodes", "reachableNodes", "queue", "curr", "external", "cellKey", "e", "useHexagons", "useSquares", "useStars", "useTetris", "useEraser", "hexagonsPlaced", "squaresPlaced", "starsPlaced", "tetrisPlaced", "erasersPlaced", "totalTetrisArea", "maxTotalTetrisArea", "isBranching", "prob", "idx", "regions", "availableColors", "Color", "defaultColors", "getDefColor", "type", "fallback", "name", "CellType", "regionIndices", "_", "squareColorsUsed", "needs", "rIdx", "remainingRegions", "forceOne", "placementProb", "potentialCells", "squareColor", "otherColors", "shouldPlaceSquare", "maxSquares", "numSquares", "cell", "shouldPlaceTetris", "maxTetrisPerRegion", "tiledPieces", "tetrisColor", "colors", "shouldPlaceEraser", "errorTypes", "boundaryEdges", "errorType", "errorPlaced", "validEdges", "errCell", "existingSquare", "existingSquareColor", "piecesToPlace", "currentArea", "area", "eraserColor", "maxPairs", "color", "colorCount", "otherColor", "visitedCells", "currentRegion", "y", "x", "boundary", "edges", "key", "unique", "found", "fSq", "fSt", "fT", "fE", "sqC", "maxPieces", "minX", "minY", "maxX", "maxY", "width", "height", "regionGrid", "currentPieces", "r0", "c0", "shapes", "baseShape", "isInv", "rotations", "shape", "blocks", "pr", "pc", "anchor", "dr", "dc", "result", "row", "results", "keys", "newShape", "j", "nr", "nc", "value", "array", "BitWriter", "value", "bits", "i", "BitReader", "buf", "v", "collectShapes", "cells", "map", "row", "c", "key", "PuzzleSerializer", "puzzle", "options", "bw", "shapes", "s", "r", "shapeIndex", "y", "x", "raw", "gz", "parity", "b", "final", "str", "bin", "br", "rows", "cols", "symmetry", "shapeCount", "h", "w", "type", "color", "hasShape", "cell", "vEdges", "hEdges", "nodes", "readRatio", "useHexagons", "useSquares", "useStars", "useTetris", "useEraser", "useBroken", "optSymmetry", "complexity", "difficulty", "pathLength", "WitnessUI", "canvasOrId", "puzzle", "options", "el", "context", "animations", "colors", "Color", "isValid", "invalidatedCells", "invalidatedEdges", "errorCells", "errorEdges", "invalidatedNodes", "errorNodes", "rect", "gridX", "gridY", "x", "y", "mouseX", "mouseY", "c", "nodePos", "lastPoint", "lastPos", "dx", "dy", "symmetry", "exitDir", "intendedDir", "dot", "length", "tryMoveTo", "target", "d", "edgeType", "maxMove", "targetEdgeKey", "i", "p", "secondToLast", "symLast", "symTarget", "symEdgeType", "symPath", "symEdgeKey", "isNodeOccupiedBySym", "isSymNodeOccupiedByMain", "isMeetingAtNode", "isEdgeOccupiedBySym", "isMirrorEdgeOccupiedByMain", "dir", "neighbors", "n", "nPos", "idx", "sn", "edgeKey", "dx_exit", "dy_exit", "p1", "p2", "color", "step", "ctx", "now", "symFadingPath", "symColor", "symTipPos", "gridRelX", "gridRelY", "symGridRel", "elapsed", "blinkDuration", "transitionIn", "transitionOut", "transitionFactor", "blinkFactor", "tip", "time", "r", "pos", "exitPos", "t", "radius", "opacity", "drawEdge", "type", "q1", "q2", "cell", "isInvalidated", "isError", "overrideColor", "originalColor", "errorColor", "tempCanvas", "tempCtx", "hexRadius", "e", "isNodeIsolated", "connectedEdges", "node", "path", "isDrawing", "tipPos", "finalOpacity", "finalColor", "match", "g", "b", "a", "startPos", "actualTipPos", "width", "height", "angle", "px", "py", "points", "colorEnum", "rotation", "innerRadius", "outerRadius", "shape", "rotated", "cellSize", "gap", "totalW", "totalH", "defaultFallback", "hex", "c1", "c2", "rgb1", "rgb2", "isFloat", "cols", "rows", "WitnessCore", "PuzzleGenerator", "PuzzleValidator", "rows", "cols", "options", "puzzleData", "solution", "grid", "Grid"]
}
