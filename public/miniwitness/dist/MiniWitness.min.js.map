{
  "version": 3,
  "sources": ["../src/types.ts", "../src/grid.ts", "../src/validator.ts", "../src/generator.ts", "../src/ui.ts", "../src/index.ts"],
  "sourcesContent": ["export enum Direction {\n\tUp = 0,\n\tRight = 1,\n\tDown = 2,\n\tLeft = 3,\n}\n\nexport enum CellType {\n\tNone = 0,\n\tSquare = 1, // \u8272\u5206\u3051\u304C\u5FC5\u8981\u306A\u30D6\u30ED\u30C3\u30AF\n\tStar = 2, // \u540C\u3058\u8272\u306E\u30DA\u30A2\u4F5C\u6210 (\u661F)\n\tTetris = 3, // \u30C6\u30C8\u30EA\u30B9\n\tTetrisRotated = 4, // \u30C6\u30C8\u30EA\u30B9\uFF08\u56DE\u8EE2\u53EF\u80FD\uFF09\n\tEraser = 5, // \u30C6\u30C8\u30E9\u30DD\u30C3\u30C9 (\u30A8\u30E9\u30FC\u524A\u9664)\n}\n\nexport enum EdgeType {\n\tNormal = 0,\n\tBroken = 1, // \u7DDA\u306E\u771F\u3093\u4E2D\u3067\u65AD\u7DDA (\u901A\u884C\u4E0D\u53EF)\n\tAbsent = 2, // \u305D\u3082\u305D\u3082\u5206\u5C90\u3082\u306A\u3057 (\u901A\u884C\u4E0D\u53EF)\n\tHexagon = 3, // \u901A\u904E\u5FC5\u9808\n}\n\nexport enum NodeType {\n\tNormal = 0,\n\tStart = 1,\n\tEnd = 2,\n}\n\n/**\n * \u4F7F\u7528\u53EF\u80FD\u8272\n */\nexport enum Color {\n\tNone = 0,\n\tBlack = 1,\n\tWhite = 2,\n\tRed = 3,\n\tBlue = 4,\n\t// \u62E1\u5F35\u53EF\u80FD\n}\n\nexport interface Point {\n\tx: number;\n\ty: number;\n}\n\nexport interface CellConstraint {\n\ttype: CellType;\n\tcolor: Color;\n\tshape?: number[][]; // [row][col] 0 or 1\n}\n\nexport interface EdgeConstraint {\n\ttype: EdgeType;\n}\n\nexport interface NodeConstraint {\n\ttype: NodeType;\n}\n\n/**\n * \u30D1\u30BA\u30EB\u306E\u9759\u7684\u306A\u5B9A\u7FA9\u30C7\u30FC\u30BF\n */\nexport interface PuzzleData {\n\trows: number;\n\tcols: number;\n\tcells: CellConstraint[][]; // [row][col]\n\tvEdges: EdgeConstraint[][]; // Vertical edges [row][col] (row: 0..rows-1, col: 0..cols)\n\thEdges: EdgeConstraint[][]; // Horizontal edges [row][col] (row: 0..rows, col: 0..cols-1)\n\tnodes: NodeConstraint[][]; // [row][col]\n}\n\n/**\n * \u30E6\u30FC\u30B6\u30FC\u306E\u5165\u529B\uFF08\u56DE\u7B54\u30D1\u30B9\uFF09\n */\nexport interface SolutionPath {\n\tpoints: Point[]; // \u901A\u904E\u3057\u305F\u30CE\u30FC\u30C9\u306E\u5EA7\u6A19\u914D\u5217\n}\n\nexport interface ValidationResult {\n\tisValid: boolean;\n\terrorReason?: string;\n\tinvalidatedCells?: Point[];\n\tinvalidatedEdges?: { type: \"h\" | \"v\"; r: number; c: number }[];\n}\n\n/**\n * \u30D1\u30BA\u30EB\u751F\u6210\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\n */\nexport interface GenerationOptions {\n\tuseHexagons?: boolean;\n\tuseSquares?: boolean;\n\tuseStars?: boolean;\n\tuseTetris?: boolean;\n\tuseEraser?: boolean;\n\tuseBrokenEdges?: boolean;\n\tcomplexity?: number; // 0.0 - 1.0 (\u5236\u7D04\u306E\u5BC6\u5EA6)\n\tdifficulty?: number; // 0.0 (Easy) - 1.0 (Hard) (\u89E3\u30D1\u30BF\u30FC\u30F3\u306E\u6570\u306B\u57FA\u3065\u304F)\n}\n", "import { type CellConstraint, CellType, Color, type EdgeConstraint, EdgeType, type NodeConstraint, NodeType, type PuzzleData } from \"./types\";\n\nexport class Grid {\n\tpublic readonly rows: number;\n\tpublic readonly cols: number;\n\n\t// \u30C7\u30FC\u30BF\u30DE\u30C8\u30EA\u30AF\u30B9\n\tpublic cells: CellConstraint[][] = [];\n\tpublic hEdges: EdgeConstraint[][] = []; // \u6A2A\u68D2\n\tpublic vEdges: EdgeConstraint[][] = []; // \u7E26\u68D2\n\tpublic nodes: NodeConstraint[][] = [];\n\n\tconstructor(rows: number, cols: number) {\n\t\tthis.rows = rows;\n\t\tthis.cols = cols;\n\t\tthis.initializeGrid();\n\t}\n\n\tprivate initializeGrid() {\n\t\t// Cells: rows * cols\n\t\tthis.cells = Array.from({ length: this.rows }, () => Array.from({ length: this.cols }, () => ({ type: CellType.None, color: Color.None })));\n\n\t\t// H-Edges: (rows + 1) * cols\n\t\tthis.hEdges = Array.from({ length: this.rows + 1 }, () => Array.from({ length: this.cols }, () => ({ type: EdgeType.Normal })));\n\n\t\t// V-Edges: rows * (cols + 1)\n\t\tthis.vEdges = Array.from({ length: this.rows }, () => Array.from({ length: this.cols + 1 }, () => ({ type: EdgeType.Normal })));\n\n\t\t// Nodes: (rows + 1) * (cols + 1)\n\t\tthis.nodes = Array.from({ length: this.rows + 1 }, () => Array.from({ length: this.cols + 1 }, () => ({ type: NodeType.Normal })));\n\t}\n\n\tpublic export(): PuzzleData {\n\t\t// \u30C7\u30FC\u30BF\u306E\u30C7\u30A3\u30FC\u30D7\u30B3\u30D4\u30FC\u3092\u8FD4\u3059\n\t\treturn JSON.parse(\n\t\t\tJSON.stringify({\n\t\t\t\trows: this.rows,\n\t\t\t\tcols: this.cols,\n\t\t\t\tcells: this.cells,\n\t\t\t\tvEdges: this.vEdges,\n\t\t\t\thEdges: this.hEdges,\n\t\t\t\tnodes: this.nodes,\n\t\t\t}),\n\t\t);\n\t}\n\n\tpublic static fromData(data: PuzzleData): Grid {\n\t\tconst grid = new Grid(data.rows, data.cols);\n\t\tgrid.cells = data.cells;\n\t\tgrid.vEdges = data.vEdges;\n\t\tgrid.hEdges = data.hEdges;\n\t\tgrid.nodes = data.nodes;\n\t\treturn grid;\n\t}\n}\n", "import { Grid } from \"./grid\";\nimport { CellType, Color, EdgeType, NodeType, type Point, type SolutionPath, type ValidationResult } from \"./types\";\n\n/**\n * \u30D1\u30BA\u30EB\u306E\u56DE\u7B54\u3092\u691C\u8A3C\u3059\u308B\u30AF\u30E9\u30B9\n */\nexport class PuzzleValidator {\n\t/**\n\t * \u4E0E\u3048\u3089\u308C\u305F\u30B0\u30EA\u30C3\u30C9\u3068\u56DE\u7B54\u30D1\u30B9\u304C\u6B63\u5F53\u304B\u3069\u3046\u304B\u3092\u691C\u8A3C\u3059\u308B\n\t * @param grid \u30D1\u30BA\u30EB\u306E\u30B0\u30EA\u30C3\u30C9\u30C7\u30FC\u30BF\n\t * @param solution \u56DE\u7B54\u30D1\u30B9\n\t * @returns \u691C\u8A3C\u7D50\u679C\uFF08\u6B63\u8AA4\u3001\u30A8\u30E9\u30FC\u7406\u7531\u3001\u7121\u52B9\u5316\u3055\u308C\u305F\u8A18\u53F7\u306A\u3069\uFF09\n\t */\n\tpublic validate(grid: Grid, solution: SolutionPath): ValidationResult {\n\t\tconst path = solution.points;\n\t\tif (path.length < 2) return { isValid: false, errorReason: \"Path too short\" };\n\t\tconst start = path[0];\n\t\tconst end = path[path.length - 1];\n\n\t\t// \u958B\u59CB\u30CE\u30FC\u30C9\u3068\u7D42\u4E86\u30CE\u30FC\u30C9\u306E\u30C1\u30A7\u30C3\u30AF\n\t\tif (grid.nodes[start.y][start.x].type !== NodeType.Start) return { isValid: false, errorReason: \"Must start at Start Node\" };\n\t\tif (grid.nodes[end.y][end.x].type !== NodeType.End) return { isValid: false, errorReason: \"Must end at End Node\" };\n\n\t\t// \u30D1\u30B9\u306E\u9023\u7D9A\u6027\u3068\u81EA\u5DF1\u4EA4\u5DEE\u3001\u65AD\u7DDA\u30C1\u30A7\u30C3\u30AF\n\t\tconst visitedNodes = new Set<string>();\n\t\tvisitedNodes.add(`${start.x},${start.y}`);\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst p1 = path[i];\n\t\t\tconst p2 = path[i + 1];\n\t\t\tconst dist = Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n\t\t\tif (dist !== 1) return { isValid: false, errorReason: \"Invalid jump in path\" };\n\t\t\tconst key = `${p2.x},${p2.y}`;\n\t\t\tif (visitedNodes.has(key)) return { isValid: false, errorReason: \"Self-intersecting path\" };\n\t\t\tvisitedNodes.add(key);\n\t\t\tif (this.isBrokenEdge(grid, p1, p2)) return { isValid: false, errorReason: \"Passed through broken edge\" };\n\t\t}\n\n\t\t// \u533A\u753B\u306E\u8A08\u7B97\n\t\tconst regions = this.calculateRegions(grid, path);\n\t\t// \u901A\u904E\u3057\u306A\u304B\u3063\u305F\u516D\u89D2\u5F62\u306E\u53D6\u5F97\n\t\tconst missedHexagons = this.getMissedHexagons(grid, path);\n\t\t// \u30A8\u30E9\u30FC\u524A\u9664\uFF08\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF09\u3092\u8003\u616E\u3057\u305F\u5236\u7D04\u691C\u8A3C\n\t\treturn this.validateWithErasers(grid, regions, missedHexagons);\n\t}\n\n\t/**\n\t * \u4E8C\u70B9\u9593\u304C\u65AD\u7DDA\uFF08Broken or Absent\uFF09\u3057\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate isBrokenEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tlet type: EdgeType;\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\ttype = grid.vEdges[y][p1.x].type;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\ttype = grid.hEdges[p1.y][x].type;\n\t\t}\n\t\treturn type === EdgeType.Broken || type === EdgeType.Absent;\n\t}\n\n\t/**\n\t * \u4E8C\u70B9\u9593\u304C Absent\uFF08\u5B58\u5728\u3057\u306A\u3044\uFF09\u30A8\u30C3\u30B8\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate isAbsentEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\treturn grid.vEdges[y][p1.x].type === EdgeType.Absent;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\treturn grid.hEdges[p1.y][x].type === EdgeType.Absent;\n\t\t}\n\t}\n\n\t/**\n\t * \u56DE\u7B54\u30D1\u30B9\u304C\u901A\u904E\u3057\u306A\u304B\u3063\u305F\u516D\u89D2\u5F62\u30A8\u30C3\u30B8\u3092\u30EA\u30B9\u30C8\u30A2\u30C3\u30D7\u3059\u308B\n\t */\n\tprivate getMissedHexagons(grid: Grid, path: Point[]): { type: \"h\" | \"v\"; r: number; c: number }[] {\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t}\n\t\tconst missed: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst key = this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r });\n\t\t\t\t\tif (!pathEdges.has(key)) missed.push({ type: \"h\", r, c });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst key = this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 });\n\t\t\t\t\tif (!pathEdges.has(key)) missed.push({ type: \"v\", r, c });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn missed;\n\t}\n\n\t/**\n\t * \u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF08\u30A8\u30E9\u30FC\u524A\u9664\uFF09\u3092\u8003\u616E\u3057\u3066\u30D1\u30BA\u30EB\u306E\u5404\u5236\u7D04\u3092\u691C\u8A3C\u3059\u308B\n\t */\n\tprivate validateWithErasers(grid: Grid, regions: Point[][], missedHexagons: { type: \"h\" | \"v\"; r: number; c: number }[]): ValidationResult {\n\t\tconst regionResults: { invalidatedCells: Point[]; invalidatedHexagons: number[]; isValid: boolean }[][] = [];\n\n\t\tfor (let i = 0; i < regions.length; i++) {\n\t\t\tconst region = regions[i];\n\t\t\tconst erasers = region.filter((p) => grid.cells[p.y][p.x].type === CellType.Eraser);\n\t\t\tconst otherMarks = region.filter((p) => grid.cells[p.y][p.x].type !== CellType.None && grid.cells[p.y][p.x].type !== CellType.Eraser);\n\t\t\tconst adjacentMissedHexagons: number[] = [];\n\t\t\tfor (let j = 0; j < missedHexagons.length; j++) {\n\t\t\t\tif (this.isHexagonAdjacentToRegion(grid, missedHexagons[j], region)) adjacentMissedHexagons.push(j);\n\t\t\t}\n\n\t\t\t// \u5404\u533A\u753B\u3067\u30A8\u30E9\u30FC\u524A\u9664\u306E\u5168\u7D44\u307F\u5408\u308F\u305B\u3092\u8A66\u884C\n\t\t\tconst possible = this.getPossibleErasures(grid, region, erasers, otherMarks, adjacentMissedHexagons);\n\t\t\tif (possible.length === 0) return { isValid: false, errorReason: `Constraints failed in region ${i}` };\n\t\t\t// \u6700\u5C0F\u306E\u524A\u9664\u6570\u3092\u6301\u3064\u89E3\u6C7A\u7B56\u3092\u512A\u5148\u3059\u308B\n\t\t\tpossible.sort((a, b) => {\n\t\t\t\tconst costA = a.invalidatedCells.length + a.invalidatedHexagons.length;\n\t\t\t\tconst costB = b.invalidatedCells.length + b.invalidatedHexagons.length;\n\t\t\t\treturn costA - costB;\n\t\t\t});\n\t\t\tregionResults.push(possible);\n\t\t}\n\n\t\t// \u8907\u6570\u306E\u533A\u753B\u306B\u307E\u305F\u304C\u308B\u516D\u89D2\u5F62\u306E\u30A8\u30E9\u30FC\u524A\u9664\u5272\u308A\u5F53\u3066\u3092\u6C7A\u5B9A\n\t\tconst assignment = this.findGlobalAssignment(regionResults, missedHexagons.length);\n\t\tif (!assignment) return { isValid: false, errorReason: \"Could not satisfy all constraints with available erasers\" };\n\t\treturn {\n\t\t\tisValid: true,\n\t\t\tinvalidatedCells: assignment.invalidatedCells,\n\t\t\tinvalidatedEdges: assignment.invalidatedHexIndices.map((idx) => missedHexagons[idx]),\n\t\t};\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30A8\u30C3\u30B8\u304C\u7279\u5B9A\u306E\u533A\u753B\u306B\u96A3\u63A5\u3057\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate isHexagonAdjacentToRegion(grid: Grid, hex: { type: \"h\" | \"v\"; r: number; c: number }, region: Point[]): boolean {\n\t\tconst regionCells = new Set(region.map((p) => `${p.x},${p.y}`));\n\t\tif (hex.type === \"h\") {\n\t\t\tif (hex.r > 0 && regionCells.has(`${hex.c},${hex.r - 1}`)) return true;\n\t\t\tif (hex.r < grid.rows && regionCells.has(`${hex.c},${hex.r}`)) return true;\n\t\t} else {\n\t\t\tif (hex.c > 0 && regionCells.has(`${hex.c - 1},${hex.r}`)) return true;\n\t\t\tif (hex.c < grid.cols && regionCells.has(`${hex.c},${hex.r}`)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u533A\u753B\u5185\u306E\u30A8\u30E9\u30FC\u524A\u9664\u53EF\u80FD\u306A\u5168\u30D1\u30BF\u30FC\u30F3\u3092\u53D6\u5F97\u3059\u308B\n\t */\n\tprivate getPossibleErasures(grid: Grid, region: Point[], erasers: Point[], otherMarks: Point[], adjacentMissedHexagons: number[]): { invalidatedCells: Point[]; invalidatedHexagons: number[]; isValid: boolean }[] {\n\t\tconst results: { invalidatedCells: Point[]; invalidatedHexagons: number[]; isValid: boolean }[] = [];\n\t\tconst numErasers = erasers.length;\n\t\tif (numErasers === 0) {\n\t\t\tif (this.checkRegionValid(grid, region, [], [])) {\n\t\t\t\tresults.push({ invalidatedCells: [], invalidatedHexagons: [], isValid: true });\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\n\t\tconst itemsToNegate = [...otherMarks.map((p) => ({ type: \"cell\" as const, pos: p })), ...adjacentMissedHexagons.map((idx) => ({ type: \"hex\" as const, index: idx }))];\n\n\t\t// \u521D\u671F\u72B6\u614B\u3067\u30A8\u30E9\u30FC\u304C\u3042\u308B\u304B\u78BA\u8A8D\uFF08\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\u81EA\u8EAB\u306E\u30DA\u30A2\u4E0D\u6210\u7ACB\u306F\u9664\u5916\u3057\u3066\u5224\u5B9A\uFF09\n\t\tconst initiallyValid = this.checkRegionValid(grid, region, [], []) && adjacentMissedHexagons.length === 0;\n\n\t\t// E: \u5168\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\u6570, N: \u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\u81EA\u8EAB\u304C\u524A\u9664\u3055\u308C\u308B\u6570, K: itemsToNegate \u304B\u3089\u524A\u9664\u3059\u308B\u6570\n\t\t// \u5404 activeEraser (E-N\u500B) \u306F\u30011\u3064\u306E\u5BFE\u8C61\uFF08N\u500B\u306E\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9 or K\u500B\u306E\u9805\u76EE\uFF09\u3092\u524A\u9664\u3067\u304D\u308B\u3002\n\t\t// \u4F59\u3063\u305F activeEraser \u306F\u3001Star\u306E\u30DA\u30A2\u306A\u3069\u306E\u8A18\u53F7\u3068\u3057\u3066\u6A5F\u80FD\u3057\u3001\u305D\u308C\u304C\u5FC5\u9808\u3067\u306A\u3051\u308C\u3070\u306A\u3089\u306A\u3044\u3002\n\t\tfor (let N = 0; N <= numErasers; N++) {\n\t\t\tconst negatedEraserCombinations = this.getNCombinations(erasers, N);\n\t\t\tfor (const negatedErasers of negatedEraserCombinations) {\n\t\t\t\tconst negatedErasersSet = new Set(negatedErasers.map((e) => `${e.x},${e.y}`));\n\t\t\t\tconst activeErasers = erasers.filter((e) => !negatedErasersSet.has(`${e.x},${e.y}`));\n\n\t\t\t\tfor (let K = 0; K <= itemsToNegate.length; K++) {\n\t\t\t\t\tif (activeErasers.length !== N + K) continue; // \u3059\u3079\u3066\u306E\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\u306F\u524A\u9664\uFF08N or K\uFF09\u306B\u4F7F\u7528\u3055\u308C\u306A\u3051\u308C\u3070\u306A\u3089\u306A\u3044\n\n\t\t\t\t\tconst itemCombinations = this.getNCombinations(itemsToNegate, K);\n\t\t\t\t\tfor (const negatedItems of itemCombinations) {\n\t\t\t\t\t\tconst negatedCells = negatedItems.filter((it) => it.type === \"cell\").map((it) => it.pos as Point);\n\t\t\t\t\t\tconst negatedHexIndices = negatedItems.filter((it) => it.type === \"hex\").map((it) => it.index as number);\n\n\t\t\t\t\t\tconst isValid = this.checkRegionValid(grid, region, [...negatedCells, ...negatedErasers], activeErasers);\n\t\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\t\tlet isUseful = true;\n\t\t\t\t\t\t\tif (initiallyValid) {\n\t\t\t\t\t\t\t\t// \u521D\u671F\u72B6\u614B\u3067\u6709\u52B9\u306A\u3089\u3001\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\u540C\u58EB\u3067\u5B8C\u5168\u306B\u6D88\u3057\u5408\u3046\u3057\u304B\u306A\u3044\uFF08K=0\u3001\u304B\u3064N\u306B\u3088\u3063\u3066\u3059\u3079\u3066\u6D88\u3048\u308B\uFF09\n\t\t\t\t\t\t\t\tif (K > 0) isUseful = false;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// \u5197\u9577\u306A\u524A\u9664\uFF08natural \u306A\u30A8\u30E9\u30FC\u306B\u5BFE\u3059\u308B\u3082\u306E\uFF09\u306E\u30C1\u30A7\u30C3\u30AF\n\t\t\t\t\t\t\t\tfor (let i = 0; i < negatedItems.length; i++) {\n\t\t\t\t\t\t\t\t\tconst subset = [...negatedItems.slice(0, i), ...negatedItems.slice(i + 1)];\n\t\t\t\t\t\t\t\t\tconst subsetCells = subset.filter((it) => it.type === \"cell\").map((it) => it.pos as Point);\n\t\t\t\t\t\t\t\t\tconst subsetHexIndices = new Set(subset.filter((it) => it.type === \"hex\").map((it) => it.index as number));\n\t\t\t\t\t\t\t\t\tconst allHexSatisfied = adjacentMissedHexagons.every((idx) => subsetHexIndices.has(idx));\n\n\t\t\t\t\t\t\t\t\tif (this.checkRegionValid(grid, region, subsetCells, activeErasers) && allHexSatisfied) {\n\t\t\t\t\t\t\t\t\t\tisUseful = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (isUseful) {\n\t\t\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\t\t\tinvalidatedCells: [...negatedCells, ...negatedErasers],\n\t\t\t\t\t\t\t\t\tinvalidatedHexagons: negatedHexIndices,\n\t\t\t\t\t\t\t\t\tisValid: true,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * \u914D\u5217\u304B\u3089N\u500B\u9078\u3076\u7D44\u307F\u5408\u308F\u305B\u3092\u53D6\u5F97\u3059\u308B\n\t */\n\tprivate getNCombinations<T>(items: T[], n: number): T[][] {\n\t\tconst results: T[][] = [];\n\t\tconst backtrack = (start: number, current: T[]) => {\n\t\t\tif (current.length === n) {\n\t\t\t\tresults.push([...current]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (let i = start; i < items.length; i++) {\n\t\t\t\tcurrent.push(items[i]);\n\t\t\t\tbacktrack(i + 1, current);\n\t\t\t\tcurrent.pop();\n\t\t\t}\n\t\t};\n\t\tbacktrack(0, []);\n\t\treturn results;\n\t}\n\n\t/**\n\t * \u7279\u5B9A\u306E\u524A\u9664\u30FB\u7121\u52B9\u5316\u3092\u9069\u7528\u3057\u305F\u72B6\u614B\u3067\u3001\u533A\u753B\u5185\u306E\u5236\u7D04\u304C\u6E80\u305F\u3055\u308C\u3066\u3044\u308B\u304B\u691C\u8A3C\u3059\u308B\n\t */\n\tprivate checkRegionValid(grid: Grid, region: Point[], erasedCells: Point[], erasersAsMarks: Point[]): boolean {\n\t\tconst erasedSet = new Set(erasedCells.map((p) => `${p.x},${p.y}`));\n\t\tconst erasersAsMarksSet = new Set(erasersAsMarks.map((p) => `${p.x},${p.y}`));\n\t\tconst colorCounts = new Map<number, number>();\n\t\tconst starColors = new Set<number>();\n\t\tconst squareColors = new Set<number>();\n\t\tconst tetrisPieces: { shape: number[][]; rotatable: boolean }[] = [];\n\n\t\tfor (const cell of region) {\n\t\t\tif (erasedSet.has(`${cell.x},${cell.y}`)) continue;\n\t\t\tconst constraint = grid.cells[cell.y][cell.x];\n\t\t\tif (constraint.type === CellType.None) continue;\n\n\t\t\tconst isEraserAsMark = constraint.type === CellType.Eraser && erasersAsMarksSet.has(`${cell.x},${cell.y}`);\n\t\t\tconst isOtherMark = constraint.type !== CellType.Eraser;\n\t\t\tif (!isEraserAsMark && !isOtherMark) continue;\n\n\t\t\tconst color = constraint.color;\n\t\t\tif (color !== Color.None) colorCounts.set(color, (colorCounts.get(color) || 0) + 1);\n\n\t\t\tif (constraint.type === CellType.Square) squareColors.add(color);\n\t\t\telse if (constraint.type === CellType.Star) starColors.add(color);\n\t\t\telse if (constraint.type === CellType.Tetris || constraint.type === CellType.TetrisRotated) {\n\t\t\t\tif (constraint.shape) tetrisPieces.push({ shape: constraint.shape, rotatable: constraint.type === CellType.TetrisRotated });\n\t\t\t}\n\t\t}\n\n\t\t// \u56DB\u89D2\u5F62\u306E\u30EB\u30FC\u30EB\uFF1A\u540C\u533A\u753B\u5185\u306F\u540C\u3058\u8272\n\t\tif (squareColors.size > 1) return false;\n\n\t\t// \u661F\u306E\u30EB\u30FC\u30EB\uFF1A\u540C\u8272\u306E\u8A18\u53F7\u304C\u3061\u3087\u3046\u30692\u3064\n\t\tfor (const color of starColors) if (colorCounts.get(color) !== 2) return false;\n\n\t\t// \u30C6\u30C8\u30EA\u30B9\u306E\u30EB\u30FC\u30EB\uFF1A\u30BF\u30A4\u30EA\u30F3\u30B0\u53EF\u80FD\n\t\tif (tetrisPieces.length > 0) {\n\t\t\tif (!this.checkTetrisConstraint(region, tetrisPieces)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * \u30B0\u30ED\u30FC\u30D0\u30EB\u306A\u5236\u7D04\uFF08\u516D\u89D2\u5F62\uFF09\u306E\u5272\u308A\u5F53\u3066\u3092\u30D0\u30C3\u30AF\u30C8\u30E9\u30C3\u30AD\u30F3\u30B0\u3067\u63A2\u7D22\u3059\u308B\n\t */\n\tprivate findGlobalAssignment(regionResults: { invalidatedCells: Point[]; invalidatedHexagons: number[]; isValid: boolean }[][], totalMissedHexagons: number): { invalidatedCells: Point[]; invalidatedHexIndices: number[] } | null {\n\t\tconst numRegions = regionResults.length;\n\t\tconst currentHexErasures = new Array(totalMissedHexagons).fill(0);\n\t\tconst allInvalidatedCells: Point[] = [];\n\t\tconst allInvalidatedHexIndices: number[] = [];\n\n\t\tconst backtrack = (regionIdx: number): boolean => {\n\t\t\tif (regionIdx === numRegions) return currentHexErasures.every((count) => count === 1);\n\t\t\tfor (const option of regionResults[regionIdx]) {\n\t\t\t\tlet possible = true;\n\t\t\t\tfor (const hexIdx of option.invalidatedHexagons)\n\t\t\t\t\tif (currentHexErasures[hexIdx] > 0) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (possible) {\n\t\t\t\t\tfor (const hexIdx of option.invalidatedHexagons) {\n\t\t\t\t\t\tcurrentHexErasures[hexIdx]++;\n\t\t\t\t\t\tallInvalidatedHexIndices.push(hexIdx);\n\t\t\t\t\t}\n\t\t\t\t\tallInvalidatedCells.push(...option.invalidatedCells);\n\t\t\t\t\tif (backtrack(regionIdx + 1)) return true;\n\t\t\t\t\tfor (const hexIdx of option.invalidatedHexagons) {\n\t\t\t\t\t\tcurrentHexErasures[hexIdx]--;\n\t\t\t\t\t\tallInvalidatedHexIndices.pop();\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < option.invalidatedCells.length; i++) allInvalidatedCells.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tif (backtrack(0)) return { invalidatedCells: allInvalidatedCells, invalidatedHexIndices: allInvalidatedHexIndices };\n\t\treturn null;\n\t}\n\n\t/**\n\t * \u30C6\u30C8\u30EA\u30B9\u5236\u7D04\u306E\u691C\u8A3C\uFF08\u6307\u5B9A\u3055\u308C\u305F\u9818\u57DF\u3092\u30D4\u30FC\u30B9\u3067\u57CB\u3081\u5C3D\u304F\u305B\u308B\u304B\uFF09\n\t */\n\tprivate checkTetrisConstraint(region: Point[], pieces: { shape: number[][]; rotatable: boolean }[]): boolean {\n\t\tconst totalTetrisArea = pieces.reduce((sum, p) => sum + this.getShapeArea(p.shape), 0);\n\t\tif (totalTetrisArea !== region.length) return false;\n\n\t\tconst minX = Math.min(...region.map((p) => p.x));\n\t\tconst minY = Math.min(...region.map((p) => p.y));\n\t\tconst maxX = Math.max(...region.map((p) => p.x));\n\t\tconst maxY = Math.max(...region.map((p) => p.y));\n\t\tconst width = maxX - minX + 1;\n\t\tconst height = maxY - minY + 1;\n\n\t\tconst regionGrid = Array.from({ length: height }, () => Array(width).fill(false));\n\t\tfor (const p of region) regionGrid[p.y - minY][p.x - minX] = true;\n\n\t\treturn this.canTile(regionGrid, pieces);\n\t}\n\n\tprivate getShapeArea(shape: number[][]): number {\n\t\tlet area = 0;\n\t\tfor (const row of shape) for (const cell of row) if (cell) area++;\n\t\treturn area;\n\t}\n\n\t/**\n\t * \u518D\u5E30\u7684\u306B\u30BF\u30A4\u30EA\u30F3\u30B0\u3092\u8A66\u307F\u308B\n\t */\n\tprivate canTile(regionGrid: boolean[][], pieces: { shape: number[][]; rotatable: boolean }[]): boolean {\n\t\tlet r0 = -1;\n\t\tlet c0 = -1;\n\t\tfor (let r = 0; r < regionGrid.length; r++) {\n\t\t\tfor (let c = 0; c < regionGrid[0].length; c++) {\n\t\t\t\tif (regionGrid[r][c]) {\n\t\t\t\t\tr0 = r;\n\t\t\t\t\tc0 = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r0 !== -1) break;\n\t\t}\n\t\tif (r0 === -1) return pieces.length === 0;\n\t\tif (pieces.length === 0) return false;\n\n\t\tfor (let i = 0; i < pieces.length; i++) {\n\t\t\tconst piece = pieces[i];\n\t\t\tconst nextPieces = [...pieces.slice(0, i), ...pieces.slice(i + 1)];\n\t\t\tconst rotations = piece.rotatable ? this.getAllRotations(piece.shape) : [piece.shape];\n\n\t\t\tfor (const shape of rotations) {\n\t\t\t\tconst blocks: { r: number; c: number }[] = [];\n\t\t\t\tfor (let pr = 0; pr < shape.length; pr++) {\n\t\t\t\t\tfor (let pc = 0; pc < shape[0].length; pc++) {\n\t\t\t\t\t\tif (shape[pr][pc]) blocks.push({ r: pr, c: pc });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const anchor of blocks) {\n\t\t\t\t\tconst dr = r0 - anchor.r;\n\t\t\t\t\tconst dc = c0 - anchor.c;\n\t\t\t\t\tif (this.canPlace(regionGrid, shape, dr, dc)) {\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, false);\n\t\t\t\t\t\tif (this.canTile(regionGrid, nextPieces)) return true;\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate canPlace(regionGrid: boolean[][], shape: number[][], r: number, c: number): boolean {\n\t\tfor (let i = 0; i < shape.length; i++) {\n\t\t\tfor (let j = 0; j < shape[0].length; j++) {\n\t\t\t\tif (shape[i][j]) {\n\t\t\t\t\tconst nr = r + i;\n\t\t\t\t\tconst nc = c + j;\n\t\t\t\t\tif (nr < 0 || nr >= regionGrid.length || nc < 0 || nc >= regionGrid[0].length || !regionGrid[nr][nc]) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate placePiece(regionGrid: boolean[][], shape: number[][], r: number, c: number, value: boolean) {\n\t\tfor (let i = 0; i < shape.length; i++) for (let j = 0; j < shape[0].length; j++) if (shape[i][j]) regionGrid[r + i][c + j] = value;\n\t}\n\n\tprivate getAllRotations(shape: number[][]): number[][][] {\n\t\tconst results: number[][][] = [];\n\t\tconst keys = new Set<string>();\n\t\tlet curr = shape;\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tconst key = JSON.stringify(curr);\n\t\t\tif (!keys.has(key)) {\n\t\t\t\tresults.push(curr);\n\t\t\t\tkeys.add(key);\n\t\t\t}\n\t\t\tcurr = this.rotate90(curr);\n\t\t}\n\t\treturn results;\n\t}\n\n\tprivate rotate90(shape: number[][]): number[][] {\n\t\tconst rows = shape.length;\n\t\tconst cols = shape[0].length;\n\t\tconst newShape = Array.from({ length: cols }, () => Array(rows).fill(0));\n\t\tfor (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) newShape[c][rows - 1 - r] = shape[r][c];\n\t\treturn newShape;\n\t}\n\n\t/**\n\t * \u56DE\u7B54\u30D1\u30B9\u306B\u3088\u3063\u3066\u5206\u5272\u3055\u308C\u305F\u5404\u533A\u753B\u306E\u30BB\u30EB\u30EA\u30B9\u30C8\u3092\u53D6\u5F97\u3059\u308B\n\t */\n\tprivate calculateRegions(grid: Grid, path: Point[]): Point[][] {\n\t\tconst regions: Point[][] = [];\n\t\tconst visitedCells = new Set<string>();\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) pathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\n\t\tconst externalCells = this.getExternalCells(grid);\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (visitedCells.has(`${c},${r}`) || externalCells.has(`${c},${r}`)) continue;\n\t\t\t\tconst region: Point[] = [];\n\t\t\t\tconst queue: Point[] = [{ x: c, y: r }];\n\t\t\t\tvisitedCells.add(`${c},${r}`);\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst curr = queue.shift()!;\n\t\t\t\t\tregion.push(curr);\n\t\t\t\t\tconst neighbors = [\n\t\t\t\t\t\t{ nx: curr.x, ny: curr.y - 1, p1: { x: curr.x, y: curr.y }, p2: { x: curr.x + 1, y: curr.y } },\n\t\t\t\t\t\t{ nx: curr.x, ny: curr.y + 1, p1: { x: curr.x, y: curr.y + 1 }, p2: { x: curr.x + 1, y: curr.y + 1 } },\n\t\t\t\t\t\t{ nx: curr.x - 1, ny: curr.y, p1: { x: curr.x, y: curr.y }, p2: { x: curr.x, y: curr.y + 1 } },\n\t\t\t\t\t\t{ nx: curr.x + 1, ny: curr.y, p1: { x: curr.x + 1, y: curr.y }, p2: { x: curr.x + 1, y: curr.y + 1 } },\n\t\t\t\t\t];\n\t\t\t\t\tfor (const n of neighbors) {\n\t\t\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\t\t\tconst neighborKey = `${n.nx},${n.ny}`;\n\t\t\t\t\t\t\tif (!visitedCells.has(neighborKey) && !externalCells.has(neighborKey)) {\n\t\t\t\t\t\t\t\tconst edgeKey = this.getEdgeKey(n.p1, n.p2);\n\t\t\t\t\t\t\t\tif (!pathEdges.has(edgeKey) && !this.isAbsentEdge(grid, n.p1, n.p2)) {\n\t\t\t\t\t\t\t\t\tvisitedCells.add(neighborKey);\n\t\t\t\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregions.push(region);\n\t\t\t}\n\t\t}\n\t\treturn regions;\n\t}\n\n\t/**\n\t * \u30A8\u30C3\u30B8\uFF08Absent\uFF09\u306B\u3088\u3063\u3066\u5916\u90E8\u306B\u7E4B\u304C\u3063\u3066\u3044\u308B\u30BB\u30EB\u3092\u7279\u5B9A\u3059\u308B\n\t */\n\tprivate getExternalCells(grid: Grid): Set<string> {\n\t\tconst external = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [];\n\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\tif (grid.hEdges[0][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},0`)) {\n\t\t\t\t\texternal.add(`${c},0`);\n\t\t\t\t\tqueue.push({ x: c, y: 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.hEdges[grid.rows][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},${grid.rows - 1}`)) {\n\t\t\t\t\texternal.add(`${c},${grid.rows - 1}`);\n\t\t\t\t\tqueue.push({ x: c, y: grid.rows - 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tif (grid.vEdges[r][0].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`0,${r}`)) {\n\t\t\t\t\texternal.add(`0,${r}`);\n\t\t\t\t\tqueue.push({ x: 0, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.vEdges[r][grid.cols].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${grid.cols - 1},${r}`)) {\n\t\t\t\t\texternal.add(`${grid.cols - 1},${r}`);\n\t\t\t\t\tqueue.push({ x: grid.cols - 1, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.hEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.hEdges[curr.y + 1][curr.x] },\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x + 1] },\n\t\t\t];\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\tif (!external.has(`${n.nx},${n.ny}`) && n.edge.type === EdgeType.Absent) {\n\t\t\t\t\t\texternal.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn external;\n\t}\n\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u306E\u96E3\u6613\u5EA6\u30B9\u30B3\u30A2(0.0-1.0)\u3092\u7B97\u51FA\u3059\u308B\n\t */\n\tpublic calculateDifficulty(grid: Grid): number {\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst nodeCols = cols + 1;\n\t\tconst nodeCount = (rows + 1) * nodeCols;\n\t\tconst adj = Array.from({ length: nodeCount }, () => [] as { next: number; isHexagon: boolean; isBroken: boolean }[]);\n\t\tconst startNodes: number[] = [];\n\t\tconst endNodes: number[] = [];\n\t\tconst hexagonEdges = new Set<string>();\n\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tconst u = r * nodeCols + c;\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Start) startNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.End) endNodes.push(u);\n\t\t\t\tif (c < cols) {\n\t\t\t\t\tconst v = u + 1;\n\t\t\t\t\tconst type = grid.hEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r }));\n\t\t\t\t}\n\t\t\t\tif (r < rows) {\n\t\t\t\t\tconst v = u + nodeCols;\n\t\t\t\t\tconst type = grid.vEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 }));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst stats = { totalNodesVisited: 0, branchingPoints: 0, solutions: 0, maxDepth: 0, backtracks: 0 };\n\t\tconst totalHexagons = hexagonEdges.size;\n\t\tconst fingerprints = new Set<string>();\n\n\t\t// \u76E4\u9762\u306E\u5927\u304D\u3055\u306B\u5408\u308F\u305B\u3066\u63A2\u7D22\u30EA\u30DF\u30C3\u30C8\u3092\u8ABF\u6574\n\t\tconst searchLimit = Math.max(1000, rows * cols * 200);\n\n\t\tfor (const startIdx of startNodes) {\n\t\t\tthis.exploreSearchSpace(grid, startIdx, 1n << BigInt(startIdx), [startIdx], 0, totalHexagons, adj, endNodes, fingerprints, stats, searchLimit);\n\t\t}\n\n\t\tif (stats.solutions === 0) return 0;\n\n\t\tlet constraintCount = hexagonEdges.size;\n\t\tconst constraintTypes = new Set<number>();\n\t\tif (hexagonEdges.size > 0) constraintTypes.add(999);\n\n\t\tlet tetrisCount = 0;\n\t\tlet rotatedTetrisCount = 0;\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tconst cell = grid.cells[r][c];\n\t\t\t\tif (cell.type !== CellType.None) {\n\t\t\t\t\tconstraintCount++;\n\t\t\t\t\tconstraintTypes.add(cell.type);\n\t\t\t\t\tif (cell.type === CellType.Tetris) tetrisCount++;\n\t\t\t\t\telse if (cell.type === CellType.TetrisRotated) {\n\t\t\t\t\t\ttetrisCount++;\n\t\t\t\t\t\trotatedTetrisCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst branchingFactor = stats.branchingPoints / (stats.totalNodesVisited || 1);\n\t\tconst searchComplexity = Math.log10(stats.totalNodesVisited + 1);\n\t\t// \u89E3\u306E\u6570\u304C\u591A\u3044\u307B\u3069\u96E3\u6613\u5EA6\u3092\u4E0B\u3052\u308B\u3002\u30B9\u30B1\u30FC\u30EB\u3092\u8ABF\u6574\n\t\tlet difficulty = (branchingFactor * 10 + searchComplexity * 1.5) / (Math.log2(stats.solutions + 1) * 0.5 + 1);\n\n\t\tif (tetrisCount > 0) {\n\t\t\tdifficulty += rotatedTetrisCount * 0.5;\n\t\t\tdifficulty += (tetrisCount - rotatedTetrisCount) * 0.2;\n\t\t}\n\n\t\tconst cellCount = rows * cols;\n\t\tconst density = constraintCount / cellCount;\n\t\t// \u5BC6\u5EA6\u304C\u4F4E\u3059\u304E\u308B\u3068\u6025\u6FC0\u306B\u96E3\u6613\u5EA6\u304C\u4E0B\u304C\u308B\u3088\u3046\u306B\u8ABF\u6574\u3002\u3088\u308A\u53B3\u3057\u304F\u3002\n\t\tconst densityFactor = density < 0.25 ? Math.pow(density / 0.25, 4) : 1.0;\n\t\tconst typeFactor = constraintTypes.size <= 1 ? 0.5 : 1.0;\n\n\t\tdifficulty *= densityFactor * typeFactor;\n\t\t// \u76E4\u9762\u30B5\u30A4\u30BA\u306B\u3088\u308B\u88DC\u6B63\u3092\u7DE9\u3084\u304B\u306B\n\t\tconst sizeFactor = Math.log2(cellCount) / 5;\n\t\tdifficulty *= sizeFactor;\n\n\t\treturn Math.max(0.01, Math.min(1.0, difficulty / 4));\n\t}\n\n\t/**\n\t * \u63A2\u7D22\u7A7A\u9593\u3092\u8D70\u67FB\u3057\u3066\u7D71\u8A08\u60C5\u5831\u3092\u53CE\u96C6\u3059\u308B\n\t */\n\tprivate exploreSearchSpace(grid: Grid, currIdx: number, visitedMask: bigint, path: number[], hexagonsOnPath: number, totalHexagons: number, adj: { next: number; isHexagon: boolean; isBroken: boolean }[][], endNodes: number[], fingerprints: Set<string>, stats: { totalNodesVisited: number; branchingPoints: number; solutions: number; maxDepth: number; backtracks: number }, limit: number): void {\n\t\tstats.totalNodesVisited++;\n\t\tstats.maxDepth = Math.max(stats.maxDepth, path.length);\n\t\tif (stats.totalNodesVisited > limit) return;\n\n\t\tif (endNodes.includes(currIdx)) {\n\t\t\tif (hexagonsOnPath === totalHexagons) {\n\t\t\t\tconst solutionPath = { points: path.map((idx) => ({ x: idx % (grid.cols + 1), y: Math.floor(idx / (grid.cols + 1)) })) };\n\t\t\t\tif (this.validate(grid, solutionPath).isValid) {\n\t\t\t\t\tconst fp = this.getFingerprint(grid, solutionPath.points);\n\t\t\t\t\tif (!fingerprints.has(fp)) {\n\t\t\t\t\t\tfingerprints.add(fp);\n\t\t\t\t\t\tstats.solutions++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.canReachEndOptimized(currIdx, visitedMask, adj, endNodes)) {\n\t\t\tstats.backtracks++;\n\t\t\treturn;\n\t\t}\n\n\t\tconst validMoves = [];\n\t\tfor (const edge of adj[currIdx]) {\n\t\t\tif (edge.isBroken) continue;\n\t\t\tif (visitedMask & (1n << BigInt(edge.next))) continue;\n\n\t\t\t// \u516D\u89D2\u5F62\u306E\u679D\u5208\u308A\uFF08\u73FE\u5728\u306E\u30CE\u30FC\u30C9\u304B\u3089\u5FC5\u9808\u30A8\u30C3\u30B8\u304C\u51FA\u3066\u3044\u308B\u304C\u3001\u305D\u308C\u3092\u9078\u3070\u306A\u3044\u5834\u5408\u306F\u7121\u52B9\uFF09\n\t\t\tlet possible = true;\n\t\t\tfor (const otherEdge of adj[currIdx]) {\n\t\t\t\tif (otherEdge.isHexagon) {\n\t\t\t\t\tconst isAlreadyOnPath = path.length >= 2 && otherEdge.next === path[path.length - 2];\n\t\t\t\t\tconst isNextMove = otherEdge.next === edge.next;\n\t\t\t\t\tif (!isAlreadyOnPath && !isNextMove) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (possible) validMoves.push(edge);\n\t\t}\n\n\t\tif (validMoves.length > 1) stats.branchingPoints++;\n\n\t\t// \u5927\u304D\u306A\u76E4\u9762\u3067\u306F\u63A2\u7D22\u304C\u30EA\u30DF\u30C3\u30C8\u306B\u9054\u3057\u3084\u3059\u3044\u305F\u3081\u3001\u63A2\u7D22\u9806\u5E8F\u3092\u30E9\u30F3\u30C0\u30E0\u5316\u3057\u3066\n\t\t// \u5C11\u306A\u304F\u3068\u3082\u3044\u304F\u3064\u304B\u306E\u89E3\u3092\u898B\u3064\u3051\u3084\u3059\u304F\u3059\u308B\n\t\tif (grid.rows * grid.cols > 30) {\n\t\t\tfor (let i = validMoves.length - 1; i > 0; i--) {\n\t\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t\t[validMoves[i], validMoves[j]] = [validMoves[j], validMoves[i]];\n\t\t\t}\n\t\t}\n\n\t\tfor (const move of validMoves) {\n\t\t\tpath.push(move.next);\n\t\t\tthis.exploreSearchSpace(grid, move.next, visitedMask | (1n << BigInt(move.next)), path, hexagonsOnPath + (move.isHexagon ? 1 : 0), totalHexagons, adj, endNodes, fingerprints, stats, limit);\n\t\t\tpath.pop();\n\t\t\tif (stats.totalNodesVisited > limit) return;\n\t\t}\n\t}\n\n\t/**\n\t * \u6B63\u89E3\u6570\u3092\u30AB\u30A6\u30F3\u30C8\u3059\u308B\n\t */\n\tpublic countSolutions(grid: Grid, limit: number = 100): number {\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst nodeCols = cols + 1;\n\t\tconst nodeCount = (rows + 1) * nodeCols;\n\t\tconst adj = Array.from({ length: nodeCount }, () => [] as { next: number; isHexagon: boolean; isBroken: boolean }[]);\n\t\tconst startNodes: number[] = [];\n\t\tconst endNodes: number[] = [];\n\t\tconst hexagonEdges = new Set<string>();\n\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tconst u = r * nodeCols + c;\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Start) startNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.End) endNodes.push(u);\n\t\t\t\tif (c < cols) {\n\t\t\t\t\tconst v = u + 1;\n\t\t\t\t\tconst type = grid.hEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r }));\n\t\t\t\t}\n\t\t\t\tif (r < rows) {\n\t\t\t\t\tconst v = u + nodeCols;\n\t\t\t\t\tconst type = grid.vEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 }));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst fingerprints = new Set<string>();\n\t\tconst totalHexagons = hexagonEdges.size;\n\t\tfor (const startIdx of startNodes) {\n\t\t\tthis.findPathsOptimized(grid, startIdx, 1n << BigInt(startIdx), [startIdx], 0, totalHexagons, adj, endNodes, fingerprints, limit);\n\t\t}\n\t\treturn fingerprints.size;\n\t}\n\n\tprivate findPathsOptimized(grid: Grid, currIdx: number, visitedMask: bigint, path: number[], hexagonsOnPath: number, totalHexagons: number, adj: { next: number; isHexagon: boolean; isBroken: boolean }[][], endNodes: number[], fingerprints: Set<string>, limit: number): void {\n\t\tif (fingerprints.size >= limit) return;\n\t\tif (endNodes.includes(currIdx)) {\n\t\t\tif (hexagonsOnPath === totalHexagons) {\n\t\t\t\tconst solutionPath = { points: path.map((idx) => ({ x: idx % (grid.cols + 1), y: Math.floor(idx / (grid.cols + 1)) })) };\n\t\t\t\tif (this.validate(grid, solutionPath).isValid) fingerprints.add(this.getFingerprint(grid, solutionPath.points));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (!this.canReachEndOptimized(currIdx, visitedMask, adj, endNodes)) return;\n\t\tfor (const edge of adj[currIdx]) {\n\t\t\tif (edge.isBroken) continue;\n\t\t\tif (visitedMask & (1n << BigInt(edge.next))) continue;\n\n\t\t\tlet possible = true;\n\t\t\tfor (const otherEdge of adj[currIdx]) {\n\t\t\t\tif (otherEdge.isHexagon) {\n\t\t\t\t\tconst isAlreadyOnPath = path.length >= 2 && otherEdge.next === path[path.length - 2];\n\t\t\t\t\tconst isNextMove = otherEdge.next === edge.next;\n\t\t\t\t\tif (!isAlreadyOnPath && !isNextMove) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!possible) continue;\n\n\t\t\tpath.push(edge.next);\n\t\t\tthis.findPathsOptimized(grid, edge.next, visitedMask | (1n << BigInt(edge.next)), path, hexagonsOnPath + (edge.isHexagon ? 1 : 0), totalHexagons, adj, endNodes, fingerprints, limit);\n\t\t\tpath.pop();\n\t\t\tif (fingerprints.size >= limit) return;\n\t\t}\n\t}\n\n\t/**\n\t * \u7D42\u7AEF\u307E\u3067\u5230\u9054\u53EF\u80FD\u304B\u30D3\u30C3\u30C8\u30DE\u30B9\u30AFBFS\u3067\u9AD8\u901F\u306B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate canReachEndOptimized(curr: number, visitedMask: bigint, adj: { next: number; isBroken: boolean }[][], endNodes: number[]): boolean {\n\t\tlet queue = [curr];\n\t\tlet localVisited = visitedMask;\n\t\tlet head = 0;\n\t\twhile (head < queue.length) {\n\t\t\tconst u = queue[head++];\n\t\t\tif (endNodes.includes(u)) return true;\n\t\t\tfor (const edge of adj[u])\n\t\t\t\tif (!edge.isBroken && !(localVisited & (1n << BigInt(edge.next)))) {\n\t\t\t\t\tlocalVisited |= 1n << BigInt(edge.next);\n\t\t\t\t\tqueue.push(edge.next);\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u30D1\u30B9\u306E\u8AD6\u7406\u7684\u306A\u6307\u7D0B\u3092\u53D6\u5F97\u3059\u308B\uFF08\u533A\u753B\u5206\u3051\u306B\u57FA\u3065\u304D\u3001\u540C\u4E00\u89E3\u3092\u6392\u9664\u3059\u308B\u305F\u3081\uFF09\n\t */\n\tprivate getFingerprint(grid: Grid, path: Point[]): string {\n\t\tconst regions = this.calculateRegions(grid, path);\n\t\tconst regionFingerprints = regions\n\t\t\t.map((region) => {\n\t\t\t\tconst marks = region\n\t\t\t\t\t.map((p) => grid.cells[p.y][p.x])\n\t\t\t\t\t.filter((c) => c.type !== CellType.None)\n\t\t\t\t\t.map((c) => `${c.type}:${c.color}`)\n\t\t\t\t\t.sort();\n\t\t\t\treturn marks.join(\",\");\n\t\t\t})\n\t\t\t.sort();\n\t\treturn regionFingerprints.filter((f) => f.length > 0).join(\"|\") || \"empty\";\n\t}\n}\n", "import { Grid } from \"./grid\";\nimport { CellType, Color, type EdgeConstraint, EdgeType, type GenerationOptions, NodeType, type Point } from \"./types\";\nimport { PuzzleValidator } from \"./validator\";\n\n/**\n * \u30D1\u30BA\u30EB\u3092\u81EA\u52D5\u751F\u6210\u3059\u308B\u30AF\u30E9\u30B9\n */\nexport class PuzzleGenerator {\n\t/**\n\t * \u30D1\u30BA\u30EB\u3092\u751F\u6210\u3059\u308B\n\t * @param rows \u884C\u6570\n\t * @param cols \u5217\u6570\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\n\t * @returns \u751F\u6210\u3055\u308C\u305F\u30B0\u30EA\u30C3\u30C9\n\t */\n\tpublic generate(rows: number, cols: number, options: GenerationOptions = {}): Grid {\n\t\tconst targetDifficulty = options.difficulty ?? 0.5;\n\t\tconst validator = new PuzzleValidator();\n\t\tlet bestGrid: Grid | null = null;\n\t\tlet bestScore = -1;\n\n\t\t// \u8A66\u884C\u56DE\u6570\u306E\u8A2D\u5B9A\n\t\tconst maxAttempts = rows * cols > 30 ? 50 : 80;\n\n\t\tfor (let attempt = 0; attempt < maxAttempts; attempt++) {\n\t\t\tconst grid = this.generateOnce(rows, cols, options);\n\n\t\t\t// \u5FC5\u9808\u5236\u7D04\u304C\u542B\u307E\u308C\u3066\u3044\u308B\u304B\u78BA\u8A8D\n\t\t\tif (!this.checkAllRequestedConstraintsPresent(grid, options)) continue;\n\n\t\t\t// \u96E3\u6613\u5EA6\u306E\u7B97\u51FA\n\t\t\tconst difficulty = validator.calculateDifficulty(grid);\n\t\t\tif (difficulty === 0) continue;\n\n\t\t\tconst diffFromTarget = Math.abs(difficulty - targetDifficulty);\n\t\t\tif (bestGrid === null || diffFromTarget < Math.abs(bestScore - targetDifficulty)) {\n\t\t\t\tbestScore = difficulty;\n\t\t\t\tbestGrid = grid;\n\t\t\t}\n\n\t\t\t// \u30BF\u30FC\u30B2\u30C3\u30C8\u306B\u8FD1\u3044\u5834\u5408\u306F\u65E9\u671F\u7D42\u4E86\n\t\t\tif (targetDifficulty > 0.8 && difficulty > 0.8) break;\n\t\t\tif (diffFromTarget < 0.05) break;\n\t\t}\n\n\t\t// \u898B\u3064\u304B\u3089\u306A\u304B\u3063\u305F\u5834\u5408\u306F\u6700\u5F8C\u306B\u751F\u6210\u3057\u305F\u3082\u306E\u3092\u8FD4\u3059\uFF08\u901A\u5E38\u306F\u3042\u308A\u3048\u306A\u3044\uFF09\n\t\tif (!bestGrid) {\n\t\t\treturn this.generateOnce(rows, cols, options);\n\t\t}\n\t\treturn bestGrid;\n\t}\n\n\t/**\n\t * 1\u56DE\u306E\u8A66\u884C\u3067\u30D1\u30BA\u30EB\u3092\u69CB\u7BC9\u3059\u308B\n\t */\n\tprivate generateOnce(rows: number, cols: number, options: GenerationOptions): Grid {\n\t\tconst grid = new Grid(rows, cols);\n\t\tconst startPoint: Point = { x: 0, y: rows };\n\t\tconst endPoint: Point = { x: cols, y: 0 };\n\n\t\tgrid.nodes[startPoint.y][startPoint.x].type = NodeType.Start;\n\t\tgrid.nodes[endPoint.y][endPoint.x].type = NodeType.End;\n\n\t\t// \u6B63\u89E3\u30D1\u30B9\u306E\u751F\u6210\n\t\tconst solutionPath = this.generateRandomPath(grid, startPoint, endPoint);\n\t\t// \u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u5236\u7D04\uFF08\u8A18\u53F7\uFF09\u3092\u914D\u7F6E\n\t\tthis.applyConstraintsBasedOnPath(grid, solutionPath, options);\n\n\t\t// \u65AD\u7DDA\u30A8\u30C3\u30B8\u306E\u9069\u7528\n\t\tif (options.useBrokenEdges) {\n\t\t\tthis.applyBrokenEdges(grid, solutionPath, options);\n\t\t}\n\n\t\t// \u4E0D\u8981\u306A\u30A8\u30C3\u30B8\u306E\u524A\u9664\uFF08Absent\u5316\uFF09\u3068\u30AF\u30EA\u30FC\u30CB\u30F3\u30B0\n\t\tthis.cleanGrid(grid);\n\t\treturn grid;\n\t}\n\n\t/**\n\t * \u30E9\u30F3\u30C0\u30E0\u306A\u6B63\u89E3\u30D1\u30B9\u3092\u751F\u6210\u3059\u308B\n\t */\n\tprivate generateRandomPath(grid: Grid, start: Point, end: Point): Point[] {\n\t\tconst visited = new Set<string>();\n\t\tconst path: Point[] = [];\n\t\tconst findPath = (current: Point): boolean => {\n\t\t\tvisited.add(`${current.x},${current.y}`);\n\t\t\tpath.push(current);\n\t\t\tif (current.x === end.x && current.y === end.y) return true;\n\n\t\t\tconst neighbors = this.getValidNeighbors(grid, current, visited);\n\t\t\tthis.shuffleArray(neighbors);\n\t\t\tfor (const next of neighbors) if (findPath(next)) return true;\n\n\t\t\tpath.pop();\n\t\t\treturn false;\n\t\t};\n\t\tfindPath(start);\n\t\treturn path;\n\t}\n\n\tprivate getValidNeighbors(grid: Grid, p: Point, visited: Set<string>): Point[] {\n\t\tconst candidates: Point[] = [];\n\t\tconst directions = [\n\t\t\t{ x: 0, y: -1 },\n\t\t\t{ x: 1, y: 0 },\n\t\t\t{ x: 0, y: 1 },\n\t\t\t{ x: -1, y: 0 },\n\t\t];\n\t\tfor (const d of directions) {\n\t\t\tconst nx = p.x + d.x;\n\t\t\tconst ny = p.y + d.y;\n\t\t\tif (nx >= 0 && nx <= grid.cols && ny >= 0 && ny <= grid.rows) {\n\t\t\t\tif (!visited.has(`${nx},${ny}`)) candidates.push({ x: nx, y: ny });\n\t\t\t}\n\t\t}\n\t\treturn candidates;\n\t}\n\n\t/**\n\t * \u89E3\u30D1\u30B9\u304C\u901A\u3063\u3066\u3044\u306A\u3044\u5834\u6240\u306B\u30E9\u30F3\u30C0\u30E0\u306B\u65AD\u7DDA\uFF08Broken/Absent\uFF09\u3092\u914D\u7F6E\u3059\u308B\n\t */\n\tprivate applyBrokenEdges(grid: Grid, path: Point[], options: GenerationOptions) {\n\t\tconst complexity = options.complexity ?? 0.5;\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) pathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\n\t\tconst unusedEdges: { type: \"h\" | \"v\"; r: number; c: number; p1: Point; p2: Point }[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tconst p1 = { x: c, y: r };\n\t\t\t\tconst p2 = { x: c + 1, y: r };\n\t\t\t\tif (!pathEdges.has(this.getEdgeKey(p1, p2))) unusedEdges.push({ type: \"h\", r, c, p1, p2 });\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tconst p1 = { x: c, y: r };\n\t\t\t\tconst p2 = { x: c, y: r + 1 };\n\t\t\t\tif (!pathEdges.has(this.getEdgeKey(p1, p2))) unusedEdges.push({ type: \"v\", r, c, p1, p2 });\n\t\t\t}\n\t\t}\n\n\t\tthis.shuffleArray(unusedEdges);\n\t\t// \u76E4\u9762\u30B5\u30A4\u30BA\u306B\u5FDC\u3058\u3066\u65AD\u7DDA\u6570\u3092\u30B9\u30B1\u30FC\u30EB\u3055\u305B\u308B\n\t\tconst targetCount = Math.max(1, Math.floor((complexity * (grid.rows * grid.cols)) / 4));\n\t\tlet placed = 0;\n\t\tfor (const edge of unusedEdges) {\n\t\t\tif (placed >= targetCount) break;\n\t\t\tlet type = Math.random() < 0.8 ? EdgeType.Broken : EdgeType.Absent;\n\t\t\tif (type === EdgeType.Absent && this.isAdjacentToMark(grid, edge)) type = EdgeType.Broken;\n\n\t\t\tif (edge.type === \"h\") grid.hEdges[edge.r][edge.c].type = type;\n\t\t\telse grid.vEdges[edge.r][edge.c].type = type;\n\t\t\tplaced++;\n\t\t}\n\n\t\t// \u5468\u56F2\u304C\u5168\u3066\u65AD\u7DDA\u3057\u3066\u3044\u308B\u30CE\u30FC\u30C9\u306E\u5168\u30A8\u30C3\u30B8\u3092Absent\u5316\u3059\u308B\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tconst edgesWithMeta: { e: EdgeConstraint; type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\t\t\tif (c > 0) edgesWithMeta.push({ e: grid.hEdges[r][c - 1], type: \"h\", r, c: c - 1 });\n\t\t\t\tif (c < grid.cols) edgesWithMeta.push({ e: grid.hEdges[r][c], type: \"h\", r, c });\n\t\t\t\tif (r > 0) edgesWithMeta.push({ e: grid.vEdges[r - 1][c], type: \"v\", r: r - 1, c });\n\t\t\t\tif (r < grid.rows) edgesWithMeta.push({ e: grid.vEdges[r][c], type: \"v\", r, c });\n\n\t\t\t\tif (edgesWithMeta.every((m) => m.e.type === EdgeType.Broken || m.e.type === EdgeType.Absent)) {\n\t\t\t\t\tif (edgesWithMeta.every((m) => !this.isAdjacentToMark(grid, m))) {\n\t\t\t\t\t\tfor (const m of edgesWithMeta) m.e.type = EdgeType.Absent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u5230\u9054\u4E0D\u53EF\u80FD\u306A\u30A8\u30EA\u30A2\u3092Absent\u5316\u3057\u3001\u5916\u90E8\u306B\u6F0F\u308C\u305F\u30BB\u30EB\u3092\u30AF\u30EA\u30A2\u3059\u308B\n\t */\n\tprivate cleanGrid(grid: Grid) {\n\t\tconst startNodes: { x: number; y: number }[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) if (grid.nodes[r][c].type === NodeType.Start) startNodes.push({ x: c, y: r });\n\t\t}\n\n\t\tconst reachableNodes = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [...startNodes];\n\t\tfor (const p of startNodes) reachableNodes.add(`${p.x},${p.y}`);\n\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.vEdges[curr.y - 1]?.[curr.x] },\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.vEdges[curr.y]?.[curr.x] },\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.hEdges[curr.y]?.[curr.x - 1] },\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.hEdges[curr.y]?.[curr.x] },\n\t\t\t];\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.edge && n.edge.type !== EdgeType.Absent) {\n\t\t\t\t\tif (!reachableNodes.has(`${n.nx},${n.ny}`)) {\n\t\t\t\t\t\treachableNodes.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) if (!reachableNodes.has(`${c},${r}`) || !reachableNodes.has(`${c + 1},${r}`)) grid.hEdges[r][c].type = EdgeType.Absent;\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) if (!reachableNodes.has(`${c},${r}`) || !reachableNodes.has(`${c},${r + 1}`)) grid.vEdges[r][c].type = EdgeType.Absent;\n\t\t}\n\n\t\tconst external = this.getExternalCells(grid);\n\t\tfor (const cellKey of external) {\n\t\t\tconst [c, r] = cellKey.split(\",\").map(Number);\n\t\t\tgrid.cells[r][c].type = CellType.None;\n\t\t}\n\t}\n\n\tprivate getExternalCells(grid: Grid): Set<string> {\n\t\tconst external = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [];\n\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\tif (grid.hEdges[0][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},0`)) {\n\t\t\t\t\texternal.add(`${c},0`);\n\t\t\t\t\tqueue.push({ x: c, y: 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.hEdges[grid.rows][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},${grid.rows - 1}`)) {\n\t\t\t\t\texternal.add(`${c},${grid.rows - 1}`);\n\t\t\t\t\tqueue.push({ x: c, y: grid.rows - 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tif (grid.vEdges[r][0].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`0,${r}`)) {\n\t\t\t\t\texternal.add(`0,${r}`);\n\t\t\t\t\tqueue.push({ x: 0, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.vEdges[r][grid.cols].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${grid.cols - 1},${r}`)) {\n\t\t\t\t\texternal.add(`${grid.cols - 1},${r}`);\n\t\t\t\t\tqueue.push({ x: grid.cols - 1, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.hEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.hEdges[curr.y + 1][curr.x] },\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x + 1] },\n\t\t\t];\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\tif (!external.has(`${n.nx},${n.ny}`) && n.edge.type === EdgeType.Absent) {\n\t\t\t\t\t\texternal.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn external;\n\t}\n\n\tprivate isAdjacentToMark(grid: Grid, edge: { type: \"h\" | \"v\"; r: number; c: number }): boolean {\n\t\tif (edge.type === \"h\") {\n\t\t\tif (edge.r > 0 && grid.cells[edge.r - 1][edge.c].type !== CellType.None) return true;\n\t\t\tif (edge.r < grid.rows && grid.cells[edge.r][edge.c].type !== CellType.None) return true;\n\t\t} else {\n\t\t\tif (edge.c > 0 && grid.cells[edge.r][edge.c - 1].type !== CellType.None) return true;\n\t\t\tif (edge.c < grid.cols && grid.cells[edge.r][edge.c].type !== CellType.None) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u30DE\u30FC\u30AF\u304C\u5B8C\u5168\u306B\u65AD\u7D76\u3055\u308C\u305F\u30BB\u30EB\u306B\u3044\u306A\u3044\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate hasIsolatedMark(grid: Grid): boolean {\n\t\tfor (let r = 0; r < grid.rows; r++)\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (grid.cells[r][c].type === CellType.None) continue;\n\t\t\t\tconst edges = [grid.hEdges[r][c], grid.hEdges[r + 1][c], grid.vEdges[r][c], grid.vEdges[r][c + 1]];\n\t\t\t\tif (edges.every((e) => e.type === EdgeType.Broken || e.type === EdgeType.Absent)) return true;\n\t\t\t}\n\t\treturn false;\n\t}\n\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t}\n\n\tprivate TETRIS_SHAPES = [\n\t\t[[1]],\n\t\t[[1, 1]],\n\t\t[[1, 1, 1]],\n\t\t[[1, 1, 1, 1]],\n\t\t[[1, 1, 1, 1, 1]],\n\t\t[\n\t\t\t[1, 1],\n\t\t\t[1, 1],\n\t\t],\n\t\t[\n\t\t\t[1, 1],\n\t\t\t[1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[1, 0, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[0, 0, 1],\n\t\t],\n\t\t[\n\t\t\t[0, 1],\n\t\t\t[1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[0, 1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[0, 1, 0],\n\t\t\t[0, 1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 0],\n\t\t\t[0, 1, 1],\n\t\t],\n\t\t[\n\t\t\t[0, 1, 1],\n\t\t\t[1, 1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 0],\n\t\t\t[0, 1, 0],\n\t\t\t[0, 1, 1],\n\t\t],\n\t\t[\n\t\t\t[0, 1, 1],\n\t\t\t[0, 1, 0],\n\t\t\t[1, 1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[1, 0, 1],\n\t\t],\n\t\t[\n\t\t\t[0, 1, 0],\n\t\t\t[1, 0, 1],\n\t\t],\n\t\t[\n\t\t\t[1, 0, 0, 1],\n\t\t\t[1, 0, 0, 1],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[1, 0, 1],\n\t\t\t[1, 1, 1],\n\t\t],\n\t];\n\n\t/**\n\t * \u89E3\u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u5404\u533A\u753B\u306B\u30EB\u30FC\u30EB\u3092\u914D\u7F6E\u3059\u308B\n\t */\n\tprivate applyConstraintsBasedOnPath(grid: Grid, path: Point[], options: GenerationOptions) {\n\t\tconst complexity = options.complexity ?? 0.5;\n\t\tconst useHexagons = options.useHexagons ?? true;\n\t\tconst useSquares = options.useSquares ?? true;\n\t\tconst useStars = options.useStars ?? true;\n\t\tconst useTetris = options.useTetris ?? false;\n\t\tconst useEraser = options.useEraser ?? false;\n\n\t\tlet hexagonsPlaced = 0;\n\t\tlet squaresPlaced = 0;\n\t\tlet starsPlaced = 0;\n\t\tlet tetrisPlaced = 0;\n\t\tlet erasersPlaced = 0;\n\t\tlet totalTetrisArea = 0;\n\t\tconst maxTotalTetrisArea = Math.floor(grid.rows * grid.cols * 0.45);\n\n\t\t// \u516D\u89D2\u5F62\u306E\u914D\u7F6E\n\t\tif (useHexagons) {\n\t\t\tconst targetDifficulty = options.difficulty ?? 0.5;\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst neighbors = this.getValidNeighbors(grid, path[i], new Set());\n\t\t\t\tconst isBranching = neighbors.length > 2;\n\t\t\t\tlet prob = complexity * 0.4;\n\t\t\t\tif (isBranching) prob = targetDifficulty < 0.4 ? prob * 1.0 : prob * 0.5;\n\t\t\t\tif (Math.random() < prob) {\n\t\t\t\t\tthis.setEdgeHexagon(grid, path[i], path[i + 1]);\n\t\t\t\t\thexagonsPlaced++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hexagonsPlaced === 0 && path.length >= 2) {\n\t\t\t\tconst idx = Math.floor(Math.random() * (path.length - 1));\n\t\t\t\tthis.setEdgeHexagon(grid, path[idx], path[idx + 1]);\n\t\t\t}\n\t\t}\n\n\t\t// \u533A\u753B\u30EB\u30FC\u30EB\u306E\u914D\u7F6E\n\t\tif (useSquares || useStars || useTetris || useEraser) {\n\t\t\tconst regions = this.calculateRegions(grid, path);\n\t\t\tconst availableColors = [Color.Black, Color.White, Color.Red, Color.Blue];\n\t\t\tconst regionIndices = Array.from({ length: regions.length }, (_, i) => i);\n\t\t\tthis.shuffleArray(regionIndices);\n\t\t\tconst squareColorsUsed = new Set<number>();\n\n\t\t\t// \u5FC5\u8981\u306A\u6700\u5C0F\u9650\u306E\u5236\u7D04\u3092\u5206\u6563\u3057\u3066\u914D\u7F6E\u3059\u308B\u305F\u3081\u306E\u30D5\u30E9\u30B0\n\t\t\tconst needs = {\n\t\t\t\tsquare: useSquares,\n\t\t\t\tstar: useStars,\n\t\t\t\ttetris: useTetris,\n\t\t\t\teraser: useEraser,\n\t\t\t};\n\n\t\t\tfor (let rIdx = 0; rIdx < regionIndices.length; rIdx++) {\n\t\t\t\tconst idx = regionIndices[rIdx];\n\t\t\t\tconst region = regions[idx];\n\n\t\t\t\t// \u76E4\u9762\u304C\u5927\u304D\u304F\u533A\u753B\u304C\u591A\u3044\u5834\u5408\u3001\u5F8C\u534A\u306B\u504F\u308B\u306E\u3092\u9632\u3050\u305F\u3081\u78BA\u7387\u3092\u8ABF\u6574\n\t\t\t\tconst remainingRegions = regionIndices.length - rIdx;\n\t\t\t\tconst forceOne = (needs.square && squaresPlaced === 0) || (needs.star && starsPlaced === 0) || (needs.tetris && tetrisPlaced === 0) || (needs.eraser && erasersPlaced === 0);\n\n\t\t\t\t// \u5FC5\u9808\u306A\u3082\u306E\u304C\u307E\u3060\u914D\u7F6E\u3055\u308C\u3066\u3044\u306A\u3044\u5834\u5408\u3001\u6B8B\u308A\u533A\u753B\u6570\u304C\u5C11\u306A\u304F\u306A\u3063\u3066\u304D\u305F\u3089\u78BA\u7387\u3092\u4E0A\u3052\u308B\n\t\t\t\tlet placementProb = 0.2 + complexity * 0.6;\n\t\t\t\tif (forceOne && remainingRegions <= 3) placementProb = 1.0;\n\t\t\t\telse if (forceOne && remainingRegions <= 6) placementProb = 0.7;\n\n\t\t\t\tif (Math.random() > placementProb) continue;\n\n\t\t\t\tconst potentialCells = [...region];\n\t\t\t\tthis.shuffleArray(potentialCells);\n\n\t\t\t\t// \u56DB\u89D2\u5F62\u306E\u914D\u7F6E\n\t\t\t\tlet squareColor = availableColors[Math.floor(Math.random() * availableColors.length)];\n\t\t\t\tif (useSquares && !useStars && remainingRegions <= 2 && squareColorsUsed.size === 1) {\n\t\t\t\t\tconst otherColors = availableColors.filter((c) => !squareColorsUsed.has(c));\n\t\t\t\t\tif (otherColors.length > 0) squareColor = otherColors[Math.floor(Math.random() * otherColors.length)];\n\t\t\t\t}\n\n\t\t\t\tlet shouldPlaceSquare = useSquares && Math.random() < 0.5 + complexity * 0.3;\n\t\t\t\tif (useSquares && squaresPlaced === 0 && remainingRegions <= 2) shouldPlaceSquare = true;\n\t\t\t\tif (useSquares && !useStars && remainingRegions <= 2 && squareColorsUsed.size < 2 && squaresPlaced > 0) shouldPlaceSquare = true;\n\n\t\t\t\tif (shouldPlaceSquare && potentialCells.length > 0) {\n\t\t\t\t\t// \u533A\u57DF\u306E\u5927\u304D\u3055\u306B\u5FDC\u3058\u3066\u914D\u7F6E\u3059\u308B\u6570\u3092\u5897\u3084\u3059\n\t\t\t\t\tconst maxSquares = Math.min(potentialCells.length, Math.max(4, Math.floor(region.length / 4)));\n\t\t\t\t\tconst numSquares = Math.floor(Math.random() * (maxSquares / 2)) + Math.ceil(maxSquares / 2);\n\t\t\t\t\tfor (let i = 0; i < numSquares; i++) {\n\t\t\t\t\t\tif (potentialCells.length === 0) break;\n\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Square;\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = squareColor;\n\t\t\t\t\t\tsquaresPlaced++;\n\t\t\t\t\t\tsquareColorsUsed.add(squareColor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// \u30C6\u30C8\u30EA\u30B9\u306E\u914D\u7F6E\n\t\t\t\tif (useTetris && totalTetrisArea < maxTotalTetrisArea) {\n\t\t\t\t\tlet shouldPlaceTetris = Math.random() < 0.1 + complexity * 0.4;\n\t\t\t\t\tif (tetrisPlaced === 0 && remainingRegions <= 2) shouldPlaceTetris = true;\n\t\t\t\t\tconst maxTetrisPerRegion = tetrisPlaced === 0 && remainingRegions <= 2 ? 6 : 4;\n\t\t\t\t\tif (shouldPlaceTetris && potentialCells.length > 0 && region.length <= maxTetrisPerRegion * 4 && totalTetrisArea + region.length <= maxTotalTetrisArea) {\n\t\t\t\t\t\tconst tiledPieces = this.generateTiling(region, maxTetrisPerRegion, options);\n\t\t\t\t\t\tif (tiledPieces) {\n\t\t\t\t\t\t\tfor (const p of tiledPieces) {\n\t\t\t\t\t\t\t\tif (potentialCells.length === 0) break;\n\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = p.isRotated ? CellType.TetrisRotated : CellType.Tetris;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].shape = p.isRotated ? p.displayShape : p.shape;\n\n\t\t\t\t\t\t\t\tlet tetrisColor = Color.None;\n\t\t\t\t\t\t\t\tif (useStars && Math.random() < 0.5) {\n\t\t\t\t\t\t\t\t\tconst colors = availableColors.filter((c) => c !== Color.Blue);\n\t\t\t\t\t\t\t\t\ttetrisColor = colors[Math.floor(Math.random() * colors.length)];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = tetrisColor;\n\t\t\t\t\t\t\t\ttetrisPlaced++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttotalTetrisArea += region.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// \u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF08\u30A8\u30E9\u30FC\u524A\u9664\uFF09\u306E\u914D\u7F6E\n\t\t\t\tif (useEraser && erasersPlaced < 1) {\n\t\t\t\t\tconst prob = 0.05 + complexity * 0.2;\n\t\t\t\t\tlet shouldPlaceEraser = Math.random() < prob;\n\t\t\t\t\tif (remainingRegions <= 2) shouldPlaceEraser = true;\n\n\t\t\t\t\tif (shouldPlaceEraser && potentialCells.length >= 1) {\n\t\t\t\t\t\tconst errorTypes: string[] = [];\n\t\t\t\t\t\tif (useStars) errorTypes.push(\"star\");\n\t\t\t\t\t\tif (useSquares) errorTypes.push(\"square\");\n\t\t\t\t\t\tlet boundaryEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\t\t\t\t\tif (useHexagons) {\n\t\t\t\t\t\t\tboundaryEdges = this.getRegionBoundaryEdges(grid, region, path);\n\t\t\t\t\t\t\tif (boundaryEdges.length > 0) errorTypes.push(\"hexagon\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (useTetris) errorTypes.push(\"tetris\");\n\n\t\t\t\t\t\tlet errorType = errorTypes.length > 0 ? errorTypes[Math.floor(Math.random() * errorTypes.length)] : null;\n\n\t\t\t\t\t\t// eraser\u540C\u58EB\u306E\u6253\u3061\u6D88\u3057\u5408\u3044\u306F\u8D85\u4F4E\u78BA\u7387\u306B\u3059\u308B\n\t\t\t\t\t\tif (potentialCells.length >= 2 && (!errorType || Math.random() < 0.01)) errorType = \"eraser\";\n\n\t\t\t\t\t\tlet errorPlaced = false;\n\n\t\t\t\t\t\tif (errorType === \"hexagon\") {\n\t\t\t\t\t\t\tconst edge = boundaryEdges[Math.floor(Math.random() * boundaryEdges.length)];\n\t\t\t\t\t\t\tif (edge.type === \"h\") grid.hEdges[edge.r][edge.c].type = EdgeType.Hexagon;\n\t\t\t\t\t\t\telse grid.vEdges[edge.r][edge.c].type = EdgeType.Hexagon;\n\t\t\t\t\t\t\thexagonsPlaced++;\n\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t} else if (errorType === \"square\" && potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Square;\n\t\t\t\t\t\t\tconst existingSquare = region.find((p) => grid.cells[p.y][p.x].type === CellType.Square);\n\t\t\t\t\t\t\tconst existingSquareColor = existingSquare ? grid.cells[existingSquare.y][existingSquare.x].color : undefined;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = availableColors.find((c) => c !== existingSquareColor) || Color.Red;\n\t\t\t\t\t\t\tsquaresPlaced++;\n\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t} else if (errorType === \"star\" && potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Star;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = availableColors[Math.floor(Math.random() * availableColors.length)];\n\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t} else if (errorType === \"tetris\" && potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst tiledPieces = this.generateTiling(region, 4, options);\n\t\t\t\t\t\t\tlet piecesToPlace = [];\n\t\t\t\t\t\t\tif (tiledPieces && tiledPieces.length > 0) {\n\t\t\t\t\t\t\t\tlet currentArea = 0;\n\t\t\t\t\t\t\t\tfor (const p of tiledPieces) {\n\t\t\t\t\t\t\t\t\tconst area = this.getShapeArea(p.shape);\n\t\t\t\t\t\t\t\t\tif (currentArea + area < region.length) {\n\t\t\t\t\t\t\t\t\t\tpiecesToPlace.push(p);\n\t\t\t\t\t\t\t\t\t\tcurrentArea += area;\n\t\t\t\t\t\t\t\t\t} else break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (piecesToPlace.length === 0 && region.length > 1) {\n\t\t\t\t\t\t\t\t// \u9762\u7A4D\u4E0D\u4E00\u81F4\u306E\u30A8\u30E9\u30FC\u3092\u78BA\u5B9F\u306B\u4F5C\u6210\n\t\t\t\t\t\t\t\tpiecesToPlace = [{ shape: [[1]], displayShape: [[1]], isRotated: false }];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (piecesToPlace.length > 0) {\n\t\t\t\t\t\t\t\tfor (const p of piecesToPlace) {\n\t\t\t\t\t\t\t\t\tif (potentialCells.length < 2) break;\n\t\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = p.isRotated ? CellType.TetrisRotated : CellType.Tetris;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].shape = p.isRotated ? p.displayShape : p.shape;\n\n\t\t\t\t\t\t\t\t\tlet tetrisColor = Color.None;\n\t\t\t\t\t\t\t\t\tif (useStars && Math.random() < 0.3) {\n\t\t\t\t\t\t\t\t\t\tconst colors = availableColors.filter((c) => c !== Color.Blue);\n\t\t\t\t\t\t\t\t\t\ttetrisColor = colors[Math.floor(Math.random() * colors.length)];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = tetrisColor;\n\t\t\t\t\t\t\t\t\ttetrisPlaced++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (errorType === \"eraser\" && potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Eraser;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = Color.None;\n\t\t\t\t\t\t\terasersPlaced++;\n\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// \u305D\u308C\u3067\u3082\u30A8\u30E9\u30FC\u304C\u914D\u7F6E\u3067\u304D\u306A\u304B\u3063\u305F\u5834\u5408\u306F\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\u540C\u58EB\u306E\u6253\u3061\u6D88\u3057\u3092\u8A66\u307F\u308B\n\t\t\t\t\t\tif (!errorPlaced && potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Eraser;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = Color.None;\n\t\t\t\t\t\t\terasersPlaced++;\n\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (errorPlaced) {\n\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Eraser;\n\t\t\t\t\t\t\tlet eraserColor = Color.None;\n\t\t\t\t\t\t\tif (useStars && Math.random() < 0.4) eraserColor = availableColors[Math.floor(Math.random() * availableColors.length)];\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = eraserColor;\n\t\t\t\t\t\t\terasersPlaced++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// \u661F\u306E\u914D\u7F6E\n\t\t\t\tif (useStars) {\n\t\t\t\t\t// \u533A\u57DF\u304C\u5341\u5206\u306B\u5927\u304D\u3051\u308C\u3070\u3001\u8907\u6570\u30DA\u30A2\u306E\u914D\u7F6E\u3092\u691C\u8A0E\u3059\u308B\n\t\t\t\t\tconst maxPairs = Math.max(1, Math.floor(region.length / 8));\n\t\t\t\t\tfor (let p = 0; p < maxPairs; p++) {\n\t\t\t\t\t\tfor (const color of availableColors) {\n\t\t\t\t\t\t\tif (potentialCells.length < 1) break;\n\t\t\t\t\t\t\tif (Math.random() > 0.3 + complexity * 0.4) continue;\n\t\t\t\t\t\t\tconst colorCount = region.filter((p) => grid.cells[p.y][p.x].color === color).length;\n\t\t\t\t\t\t\tif (colorCount === 1) {\n\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\n\t\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t\t} else if (colorCount === 0 && potentialCells.length >= 2) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < 2; i++) {\n\t\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\n\t\t\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// \u56DB\u89D2\u5F62\u306E\u8272\u304C1\u8272\u3057\u304B\u4F7F\u308F\u308C\u306A\u304B\u3063\u305F\u5834\u5408\u306E\u88DC\u6B63\n\t\t\tif (useSquares && !useStars && squareColorsUsed.size < 2) {\n\t\t\t\tfor (const region of regions) {\n\t\t\t\t\tif (region.every((p) => grid.cells[p.y][p.x].type === CellType.None)) {\n\t\t\t\t\t\tconst otherColor = availableColors.find((c) => !squareColorsUsed.has(c)) || Color.White;\n\t\t\t\t\t\tconst cell = region[Math.floor(Math.random() * region.length)];\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Square;\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = otherColor;\n\t\t\t\t\t\tsquareColorsUsed.add(otherColor);\n\t\t\t\t\t\tsquaresPlaced++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u533A\u753B\u5206\u3051\u3092\u884C\u3046\n\t */\n\tprivate calculateRegions(grid: Grid, path: Point[]): Point[][] {\n\t\tconst regions: Point[][] = [];\n\t\tconst visitedCells = new Set<string>();\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) pathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (visitedCells.has(`${c},${r}`)) continue;\n\t\t\t\tconst currentRegion: Point[] = [];\n\t\t\t\tconst queue: Point[] = [{ x: c, y: r }];\n\t\t\t\tvisitedCells.add(`${c},${r}`);\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst cell = queue.shift()!;\n\t\t\t\t\tcurrentRegion.push(cell);\n\t\t\t\t\tconst neighbors = [\n\t\t\t\t\t\t{ dx: 0, dy: -1, p1: { x: cell.x, y: cell.y }, p2: { x: cell.x + 1, y: cell.y } },\n\t\t\t\t\t\t{ dx: 0, dy: 1, p1: { x: cell.x, y: cell.y + 1 }, p2: { x: cell.x + 1, y: cell.y + 1 } },\n\t\t\t\t\t\t{ dx: -1, dy: 0, p1: { x: cell.x, y: cell.y }, p2: { x: cell.x, y: cell.y + 1 } },\n\t\t\t\t\t\t{ dx: 1, dy: 0, p1: { x: cell.x + 1, y: cell.y }, p2: { x: cell.x + 1, y: cell.y + 1 } },\n\t\t\t\t\t];\n\t\t\t\t\tfor (const n of neighbors) {\n\t\t\t\t\t\tconst nx = cell.x + n.dx;\n\t\t\t\t\t\tconst ny = cell.y + n.dy;\n\t\t\t\t\t\tif (nx >= 0 && nx < grid.cols && ny >= 0 && ny < grid.rows) {\n\t\t\t\t\t\t\tif (!visitedCells.has(`${nx},${ny}`) && !pathEdges.has(this.getEdgeKey(n.p1, n.p2)) && !this.isAbsentEdge(grid, n.p1, n.p2)) {\n\t\t\t\t\t\t\t\tvisitedCells.add(`${nx},${ny}`);\n\t\t\t\t\t\t\t\tqueue.push({ x: nx, y: ny });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregions.push(currentRegion);\n\t\t\t}\n\t\t}\n\t\treturn regions;\n\t}\n\n\tprivate isAbsentEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\treturn grid.vEdges[y][p1.x].type === EdgeType.Absent;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\treturn grid.hEdges[p1.y][x].type === EdgeType.Absent;\n\t\t}\n\t}\n\n\t/**\n\t * \u533A\u753B\u306E\u5883\u754C\u30A8\u30C3\u30B8\u306E\u3046\u3061\u3001\u89E3\u30D1\u30B9\u304C\u901A\u3063\u3066\u3044\u306A\u3044\u3082\u306E\u3092\u53D6\u5F97\u3059\u308B\n\t */\n\tprivate getRegionBoundaryEdges(grid: Grid, region: Point[], path: Point[]): { type: \"h\" | \"v\"; r: number; c: number }[] {\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) pathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\n\t\tconst boundary: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\tfor (const cell of region) {\n\t\t\tconst edges = [\n\t\t\t\t{ type: \"h\" as const, r: cell.y, c: cell.x },\n\t\t\t\t{ type: \"h\" as const, r: cell.y + 1, c: cell.x },\n\t\t\t\t{ type: \"v\" as const, r: cell.y, c: cell.x },\n\t\t\t\t{ type: \"v\" as const, r: cell.y, c: cell.x + 1 },\n\t\t\t];\n\t\t\tfor (const e of edges) {\n\t\t\t\tconst p1 = e.type === \"h\" ? { x: e.c, y: e.r } : { x: e.c, y: e.r };\n\t\t\t\tconst p2 = e.type === \"h\" ? { x: e.c + 1, y: e.r } : { x: e.c, y: e.r + 1 };\n\t\t\t\tconst key = this.getEdgeKey(p1, p2);\n\t\t\t\tif (!pathEdges.has(key) && !this.isAbsentEdge(grid, p1, p2)) {\n\t\t\t\t\tboundary.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// \u91CD\u8907\u3092\u524A\u9664\n\t\tconst unique = new Map<string, { type: \"h\" | \"v\"; r: number; c: number }>();\n\t\tfor (const e of boundary) unique.set(`${e.type},${e.r},${e.c}`, e);\n\t\treturn Array.from(unique.values());\n\t}\n\n\tprivate setEdgeHexagon(grid: Grid, p1: Point, p2: Point) {\n\t\tif (p1.x === p2.x) grid.vEdges[Math.min(p1.y, p2.y)][p1.x].type = EdgeType.Hexagon;\n\t\telse grid.hEdges[p1.y][Math.min(p1.x, p2.x)].type = EdgeType.Hexagon;\n\t}\n\n\t/**\n\t * \u8981\u6C42\u3055\u308C\u305F\u5236\u7D04\u304C\u5168\u3066\u542B\u307E\u308C\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate checkAllRequestedConstraintsPresent(grid: Grid, options: GenerationOptions): boolean {\n\t\tconst useHexagons = options.useHexagons ?? true;\n\t\tconst useSquares = options.useSquares ?? true;\n\t\tconst useStars = options.useStars ?? true;\n\t\tconst useTetris = options.useTetris ?? false;\n\t\tconst useEraser = options.useEraser ?? false;\n\t\tconst useBrokenEdges = options.useBrokenEdges ?? false;\n\n\t\tif (useBrokenEdges) {\n\t\t\tlet found = false;\n\t\t\tfor (let r = 0; r <= grid.rows; r++)\n\t\t\t\tfor (let c = 0; c < grid.cols; c++)\n\t\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Broken || grid.hEdges[r][c].type === EdgeType.Absent) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tfor (let r = 0; r < grid.rows; r++)\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++)\n\t\t\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Broken || grid.vEdges[r][c].type === EdgeType.Absent) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (!found) return false;\n\t\t}\n\t\tif (useHexagons) {\n\t\t\tlet found = false;\n\t\t\tfor (let r = 0; r <= grid.rows; r++)\n\t\t\t\tfor (let c = 0; c < grid.cols; c++)\n\t\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tfor (let r = 0; r < grid.rows; r++)\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++)\n\t\t\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (!found) return false;\n\t\t}\n\t\tif (useSquares || useStars || useTetris || useEraser) {\n\t\t\tlet fSq = false;\n\t\t\tlet fSt = false;\n\t\t\tlet fT = false;\n\t\t\tlet fE = false;\n\t\t\tconst sqC = new Set<number>();\n\t\t\tfor (let r = 0; r < grid.rows; r++)\n\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\t\tconst type = grid.cells[r][c].type;\n\t\t\t\t\tif (type === CellType.Square) {\n\t\t\t\t\t\tfSq = true;\n\t\t\t\t\t\tsqC.add(grid.cells[r][c].color);\n\t\t\t\t\t}\n\t\t\t\t\tif (type === CellType.Star) fSt = true;\n\t\t\t\t\tif (type === CellType.Tetris || type === CellType.TetrisRotated) fT = true;\n\t\t\t\t\tif (type === CellType.Eraser) fE = true;\n\t\t\t\t}\n\t\t\tif (useSquares && !fSq) return false;\n\t\t\tif (useStars && !fSt) return false;\n\t\t\tif (useTetris && !fT) return false;\n\t\t\tif (useEraser && !fE) return false;\n\t\t\tif (useSquares && fSq && !fSt && sqC.size < 2) return false;\n\t\t}\n\t\tif (this.hasIsolatedMark(grid)) return false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u533A\u753B\u3092\u30D4\u30FC\u30B9\u3067\u57CB\u3081\u5C3D\u304F\u3059\u30BF\u30A4\u30EA\u30F3\u30B0\u3092\u751F\u6210\u3059\u308B\n\t */\n\tprivate generateTiling(region: Point[], maxPieces: number, options: GenerationOptions): { shape: number[][]; displayShape: number[][]; isRotated: boolean }[] | null {\n\t\tconst minX = Math.min(...region.map((p) => p.x));\n\t\tconst minY = Math.min(...region.map((p) => p.y));\n\t\tconst maxX = Math.max(...region.map((p) => p.x));\n\t\tconst maxY = Math.max(...region.map((p) => p.y));\n\t\tconst width = maxX - minX + 1;\n\t\tconst height = maxY - minY + 1;\n\t\tconst regionGrid = Array.from({ length: height }, () => Array(width).fill(false));\n\t\tfor (const p of region) regionGrid[p.y - minY][p.x - minX] = true;\n\t\treturn this.tilingDfs(regionGrid, [], maxPieces, options);\n\t}\n\n\t/**\n\t * \u30BF\u30A4\u30EA\u30F3\u30B0\u3092\u6DF1\u3055\u512A\u5148\u63A2\u7D22\u3067\u751F\u6210\u3059\u308B\n\t */\n\tprivate tilingDfs(regionGrid: boolean[][], currentPieces: { shape: number[][]; displayShape: number[][]; isRotated: boolean }[], maxPieces: number, options: GenerationOptions): { shape: number[][]; displayShape: number[][]; isRotated: boolean }[] | null {\n\t\tlet r0 = -1;\n\t\tlet c0 = -1;\n\t\tfor (let r = 0; r < regionGrid.length; r++) {\n\t\t\tfor (let c = 0; c < regionGrid[0].length; c++)\n\t\t\t\tif (regionGrid[r][c]) {\n\t\t\t\t\tr0 = r;\n\t\t\t\t\tc0 = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (r0 !== -1) break;\n\t\t}\n\t\tif (r0 === -1) return currentPieces;\n\t\tif (currentPieces.length >= maxPieces) return null;\n\n\t\tconst difficulty = options.difficulty ?? 0.5;\n\t\tlet shapes = [...this.TETRIS_SHAPES];\n\t\tthis.shuffleArray(shapes);\n\t\tif (difficulty > 0.6) shapes.sort((a, b) => this.getShapeArea(b) - this.getShapeArea(a));\n\n\t\tfor (const baseShape of shapes) {\n\t\t\tconst isInv = this.isRotationallyInvariant(baseShape);\n\t\t\tconst rotations = isInv ? [baseShape] : this.getAllRotations(baseShape);\n\t\t\tthis.shuffleArray(rotations);\n\t\t\tfor (const shape of rotations) {\n\t\t\t\tconst blocks: { r: number; c: number }[] = [];\n\t\t\t\tfor (let pr = 0; pr < shape.length; pr++) for (let pc = 0; pc < shape[0].length; pc++) if (shape[pr][pc]) blocks.push({ r: pr, c: pc });\n\t\t\t\tfor (const anchor of blocks) {\n\t\t\t\t\tconst dr = r0 - anchor.r;\n\t\t\t\t\tconst dc = c0 - anchor.c;\n\t\t\t\t\tif (this.canPlace(regionGrid, shape, dr, dc)) {\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, false);\n\t\t\t\t\t\tconst result = this.tilingDfs(regionGrid, [...currentPieces, { shape, displayShape: baseShape, isRotated: !isInv && Math.random() < 0.3 + difficulty * 0.6 }], maxPieces, options);\n\t\t\t\t\t\tif (result) return result;\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate getShapeArea(shape: number[][]): number {\n\t\tlet area = 0;\n\t\tfor (const row of shape) for (const cell of row) if (cell) area++;\n\t\treturn area;\n\t}\n\tprivate isRotationallyInvariant(shape: number[][]): boolean {\n\t\tconst area = this.getShapeArea(shape);\n\t\treturn area === 1 || (area === 4 && shape.length === 2 && shape[0].length === 2);\n\t}\n\tprivate getAllRotations(shape: number[][]): number[][][] {\n\t\tconst results: number[][][] = [];\n\t\tconst keys = new Set<string>();\n\t\tlet curr = shape;\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tconst key = JSON.stringify(curr);\n\t\t\tif (!keys.has(key)) {\n\t\t\t\tresults.push(curr);\n\t\t\t\tkeys.add(key);\n\t\t\t}\n\t\t\tcurr = this.rotate90(curr);\n\t\t}\n\t\treturn results;\n\t}\n\tprivate rotate90(shape: number[][]): number[][] {\n\t\tconst rows = shape.length;\n\t\tconst cols = shape[0].length;\n\t\tconst newShape = Array.from({ length: cols }, () => Array(rows).fill(0));\n\t\tfor (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) newShape[c][rows - 1 - r] = shape[r][c];\n\t\treturn newShape;\n\t}\n\tprivate canPlace(regionGrid: boolean[][], shape: number[][], r: number, c: number): boolean {\n\t\tfor (let i = 0; i < shape.length; i++)\n\t\t\tfor (let j = 0; j < shape[0].length; j++)\n\t\t\t\tif (shape[i][j]) {\n\t\t\t\t\tconst nr = r + i,\n\t\t\t\t\t\tnc = c + j;\n\t\t\t\t\tif (nr < 0 || nr >= regionGrid.length || nc < 0 || nc >= regionGrid[0].length || !regionGrid[nr][nc]) return false;\n\t\t\t\t}\n\t\treturn true;\n\t}\n\tprivate placePiece(regionGrid: boolean[][], shape: number[][], r: number, c: number, value: boolean) {\n\t\tfor (let i = 0; i < shape.length; i++) for (let j = 0; j < shape[0].length; j++) if (shape[i][j]) regionGrid[r + i][c + j] = value;\n\t}\n\tprivate shuffleArray(array: any[]) {\n\t\tfor (let i = array.length - 1; i > 0; i--) {\n\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t[array[i], array[j]] = [array[j], array[i]];\n\t\t}\n\t}\n}\n", "import { CellType, Color, EdgeType, NodeType, type Point, type PuzzleData } from \"./types\";\n\n/**\n * UI\u8868\u793A\u8A2D\u5B9A\n */\nexport interface WitnessUIOptions {\n\t/** \u30B0\u30EA\u30C3\u30C9\u5468\u56F2\u306E\u4F59\u767D */\n\tgridPadding?: number;\n\t/** \u30BB\u30EB1\u8FBA\u306E\u30B5\u30A4\u30BA */\n\tcellSize?: number;\n\t/** \u901A\u5E38\u30CE\u30FC\u30C9\u306E\u534A\u5F84 */\n\tnodeRadius?: number;\n\t/** \u958B\u59CB\u30CE\u30FC\u30C9\u306E\u534A\u5F84 */\n\tstartNodeRadius?: number;\n\t/** \u30D1\u30B9\u306E\u592A\u3055 */\n\tpathWidth?: number;\n\t/** \u51FA\u53E3\u306E\u9577\u3055 */\n\texitLength?: number;\n\t/** \u30D1\u30BA\u30EB\u306E\u30B5\u30A4\u30BA\u306B\u5408\u308F\u305B\u3066Canvas\u30B5\u30A4\u30BA\u3092\u81EA\u52D5\u8ABF\u6574\u3059\u308B\u304B */\n\tautoResize?: boolean;\n\t/** \u8272\u8A2D\u5B9A */\n\tcolors?: {\n\t\t/** \u901A\u5E38\u306E\u30D1\u30B9\u306E\u8272 */\n\t\tpath?: string;\n\t\t/** \u30B0\u30EA\u30C3\u30C9\u306E\u8272 */\n\t\tgrid?: string;\n\t\t/** \u30CE\u30FC\u30C9\u306E\u8272 */\n\t\tnode?: string;\n\t\t/** \u516D\u89D2\u5F62\uFF08\u901A\u904E\u5FC5\u9808\uFF09\u306E\u8272 */\n\t\thexagon?: string;\n\t\t/** \u5404\u8272\u306E\u30AB\u30E9\u30FC\u30B3\u30FC\u30C9\u30DE\u30C3\u30D7 */\n\t\tcolorMap?: Record<number, string>;\n\t};\n\t/** \u30D1\u30B9\u304C\u5B8C\u4E86\uFF08\u51FA\u53E3\u306B\u5230\u9054\uFF09\u3057\u305F\u969B\u306E\u30B3\u30FC\u30EB\u30D0\u30C3\u30AF */\n\tonPathComplete?: (path: Point[]) => void;\n}\n\n/**\n * the witness\u30D1\u30BA\u30EB\u306E\u63CF\u753B\u3068\u30E6\u30FC\u30B6\u30FC\u64CD\u4F5C\u3092\u7BA1\u7406\u3059\u308B\u30AF\u30E9\u30B9\n */\nexport class WitnessUI {\n\tprivate canvas: HTMLCanvasElement;\n\tprivate ctx: CanvasRenderingContext2D;\n\tprivate puzzle: PuzzleData | null = null;\n\tprivate options: Required<WitnessUIOptions>;\n\n\tprivate path: Point[] = [];\n\tprivate isDrawing = false;\n\tprivate currentMousePos: Point = { x: 0, y: 0 };\n\tprivate exitTipPos: Point | null = null;\n\n\t// \u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u30FB\u72B6\u614B\u8868\u793A\u7528\n\tprivate invalidatedCells: Point[] = [];\n\tprivate invalidatedEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\tprivate isFading = false;\n\tprivate fadeOpacity = 1.0;\n\tprivate fadeColor = \"#ff4444\";\n\tprivate fadingPath: Point[] = [];\n\tprivate fadingTipPos: Point | null = null;\n\n\tprivate isSuccessFading = false;\n\tprivate successFadeStartTime = 0;\n\tprivate startTime = Date.now();\n\n\t// \u900F\u904E\u63CF\u753B\u7528\u306E\u30AA\u30D5\u30B9\u30AF\u30EA\u30FC\u30F3Canvas\n\tprivate offscreenCanvas: HTMLCanvasElement | null = null;\n\tprivate offscreenCtx: CanvasRenderingContext2D | null = null;\n\n\tconstructor(canvasOrId: HTMLCanvasElement | string, puzzle?: PuzzleData, options: WitnessUIOptions = {}) {\n\t\tif (typeof window === \"undefined\") {\n\t\t\t// Node.js\u74B0\u5883\u306A\u3069\u3067\u306E\u5B9F\u884C\n\t\t\tthis.canvas = {} as HTMLCanvasElement;\n\t\t\tthis.ctx = {} as CanvasRenderingContext2D;\n\t\t\tthis.options = this.mergeOptions(options);\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof canvasOrId === \"string\") {\n\t\t\tconst el = document.getElementById(canvasOrId);\n\t\t\tif (!(el instanceof HTMLCanvasElement)) {\n\t\t\t\tthrow new Error(`Element with id \"${canvasOrId}\" is not a canvas.`);\n\t\t\t}\n\t\t\tthis.canvas = el;\n\t\t} else {\n\t\t\tthis.canvas = canvasOrId;\n\t\t}\n\n\t\tconst context = this.canvas.getContext(\"2d\");\n\t\tif (!context) throw new Error(\"Could not get 2D context.\");\n\t\tthis.ctx = context;\n\t\tthis.ctx.imageSmoothingEnabled = false;\n\n\t\tthis.options = this.mergeOptions(options);\n\n\t\tif (puzzle) {\n\t\t\tthis.setPuzzle(puzzle);\n\t\t}\n\n\t\tthis.initEvents();\n\t\tthis.animate();\n\t}\n\n\tprivate mergeOptions(options: WitnessUIOptions): Required<WitnessUIOptions> {\n\t\treturn {\n\t\t\tgridPadding: options.gridPadding ?? 60,\n\t\t\tcellSize: options.cellSize ?? 80,\n\t\t\tnodeRadius: options.nodeRadius ?? 6,\n\t\t\tstartNodeRadius: options.startNodeRadius ?? 24,\n\t\t\tpathWidth: options.pathWidth ?? 18,\n\t\t\texitLength: options.exitLength ?? 25,\n\t\t\tautoResize: options.autoResize ?? true,\n\t\t\tcolors: {\n\t\t\t\tpath: options.colors?.path ?? \"#ffcc00\",\n\t\t\t\tgrid: options.colors?.grid ?? \"#444\",\n\t\t\t\tnode: options.colors?.node ?? \"#444\",\n\t\t\t\thexagon: options.colors?.hexagon ?? \"#ffcc00\",\n\t\t\t\tcolorMap: options.colors?.colorMap ?? {\n\t\t\t\t\t[Color.Black]: \"#000\",\n\t\t\t\t\t[Color.White]: \"#fff\",\n\t\t\t\t\t[Color.Red]: \"#f00\",\n\t\t\t\t\t[Color.Blue]: \"#00f\",\n\t\t\t\t\t[Color.None]: \"#666\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tonPathComplete: options.onPathComplete ?? (() => {}),\n\t\t};\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\u3092\u8A2D\u5B9A\u3057\u3001\u518D\u63CF\u753B\u3059\u308B\n\t */\n\tpublic setPuzzle(puzzle: PuzzleData) {\n\t\tthis.puzzle = puzzle;\n\t\tthis.path = [];\n\t\tthis.isDrawing = false;\n\t\tthis.exitTipPos = null;\n\t\tthis.invalidatedCells = [];\n\t\tthis.invalidatedEdges = [];\n\t\tthis.cancelFade();\n\n\t\tif (this.options.autoResize) {\n\t\t\tthis.resizeCanvas();\n\t\t}\n\t\tthis.draw();\n\t}\n\n\t/**\n\t * \u8868\u793A\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u66F4\u65B0\u3059\u308B\n\t */\n\tpublic setOptions(options: WitnessUIOptions) {\n\t\tthis.options = this.mergeOptions({ ...this.options, ...options });\n\t\tif (this.options.autoResize && this.puzzle) {\n\t\t\tthis.resizeCanvas();\n\t\t}\n\t\tthis.draw();\n\t}\n\n\t/**\n\t * \u691C\u8A3C\u7D50\u679C\u3092\u53CD\u6620\u3055\u305B\u308B\uFF08\u4E0D\u6B63\u89E3\u6642\u306E\u8D64\u70B9\u6EC5\u3084\u3001\u6D88\u3057\u30B4\u30E0\u306B\u3088\u308B\u7121\u52B9\u5316\u306E\u8868\u793A\uFF09\n\t */\n\tpublic setValidationResult(isValid: boolean, invalidatedCells: Point[] = [], invalidatedEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = []) {\n\t\tthis.invalidatedCells = invalidatedCells;\n\t\tthis.invalidatedEdges = invalidatedEdges;\n\n\t\tif (isValid) {\n\t\t\tthis.isSuccessFading = true;\n\t\t\tthis.successFadeStartTime = Date.now();\n\t\t} else {\n\t\t\tthis.startFade(\"#ff4444\");\n\t\t}\n\t}\n\n\tprivate resizeCanvas() {\n\t\tif (!this.puzzle || !this.canvas) return;\n\t\tthis.canvas.width = this.puzzle.cols * this.options.cellSize + this.options.gridPadding * 2;\n\t\tthis.canvas.height = this.puzzle.rows * this.options.cellSize + this.options.gridPadding * 2;\n\t}\n\n\tprivate initEvents() {\n\t\tif (typeof window === \"undefined\") return;\n\t\tthis.canvas.addEventListener(\"mousedown\", (e) => this.handleStart(e));\n\t\twindow.addEventListener(\"mousemove\", (e) => this.handleMove(e));\n\t\twindow.addEventListener(\"mouseup\", (e) => this.handleEnd(e));\n\n\t\tthis.canvas.addEventListener(\n\t\t\t\"touchstart\",\n\t\t\t(e) => {\n\t\t\t\te.preventDefault();\n\t\t\t\tthis.handleStart(e.touches[0]);\n\t\t\t},\n\t\t\t{ passive: false },\n\t\t);\n\t\twindow.addEventListener(\n\t\t\t\"touchmove\",\n\t\t\t(e) => {\n\t\t\t\tthis.handleMove(e.touches[0]);\n\t\t\t},\n\t\t\t{ passive: false },\n\t\t);\n\t\twindow.addEventListener(\n\t\t\t\"touchend\",\n\t\t\t(e) => {\n\t\t\t\tthis.handleEnd(e.changedTouches[0]);\n\t\t\t},\n\t\t\t{ passive: false },\n\t\t);\n\t}\n\n\t// --- \u5EA7\u6A19\u5909\u63DB ---\n\n\tprivate getCanvasCoords(gridX: number, gridY: number): Point {\n\t\treturn {\n\t\t\tx: this.options.gridPadding + gridX * this.options.cellSize,\n\t\t\ty: this.options.gridPadding + gridY * this.options.cellSize,\n\t\t};\n\t}\n\n\tprivate getExitDir(x: number, y: number): Point | null {\n\t\tif (!this.puzzle) return null;\n\t\tif (this.puzzle.nodes[y][x].type !== NodeType.End) return null;\n\t\tif (x === this.puzzle.cols) return { x: 1, y: 0 };\n\t\tif (x === 0) return { x: -1, y: 0 };\n\t\tif (y === 0) return { x: 0, y: -1 };\n\t\tif (y === this.puzzle.rows) return { x: 0, y: 1 };\n\t\treturn { x: 1, y: 0 };\n\t}\n\n\t// --- \u30A4\u30D9\u30F3\u30C8\u30CF\u30F3\u30C9\u30E9 ---\n\n\tprivate handleStart(e: { clientX: number; clientY: number }) {\n\t\tif (!this.puzzle) return;\n\t\tthis.cancelFade();\n\t\tthis.isSuccessFading = false;\n\t\tthis.invalidatedCells = [];\n\t\tthis.invalidatedEdges = [];\n\n\t\tconst rect = this.canvas.getBoundingClientRect();\n\t\tconst mouseX = e.clientX - rect.left;\n\t\tconst mouseY = e.clientY - rect.top;\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tif (this.puzzle.nodes[r][c].type === NodeType.Start) {\n\t\t\t\t\tconst nodePos = this.getCanvasCoords(c, r);\n\t\t\t\t\tconst dist = Math.hypot(nodePos.x - mouseX, nodePos.y - mouseY);\n\t\t\t\t\tif (dist < this.options.startNodeRadius) {\n\t\t\t\t\t\tthis.isDrawing = true;\n\t\t\t\t\t\tthis.path = [{ x: c, y: r }];\n\t\t\t\t\t\tthis.currentMousePos = nodePos;\n\t\t\t\t\t\tthis.exitTipPos = null;\n\t\t\t\t\t\tthis.draw();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate handleMove(e: { clientX: number; clientY: number }) {\n\t\tif (!this.puzzle || !this.isDrawing) return;\n\n\t\tconst rect = this.canvas.getBoundingClientRect();\n\t\tconst mouseX = e.clientX - rect.left;\n\t\tconst mouseY = e.clientY - rect.top;\n\n\t\tconst lastPoint = this.path[this.path.length - 1];\n\t\tconst lastPos = this.getCanvasCoords(lastPoint.x, lastPoint.y);\n\n\t\tconst dx = mouseX - lastPos.x;\n\t\tconst dy = mouseY - lastPos.y;\n\n\t\tconst exitDir = this.getExitDir(lastPoint.x, lastPoint.y);\n\t\tif (exitDir) {\n\t\t\tconst dot = dx * exitDir.x + dy * exitDir.y;\n\t\t\tif (dot > 0) {\n\t\t\t\tconst length = Math.min(dot, this.options.exitLength);\n\t\t\t\tthis.currentMousePos = {\n\t\t\t\t\tx: lastPos.x + exitDir.x * length,\n\t\t\t\t\ty: lastPos.y + exitDir.y * length,\n\t\t\t\t};\n\t\t\t\tthis.draw();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (Math.abs(dx) > Math.abs(dy)) {\n\t\t\tconst dir = dx > 0 ? 1 : -1;\n\t\t\tconst target = { x: lastPoint.x + dir, y: lastPoint.y };\n\t\t\tconst edgeType = this.getEdgeType(lastPoint, target);\n\n\t\t\tif (target.x >= 0 && target.x <= this.puzzle.cols && edgeType !== EdgeType.Absent) {\n\t\t\t\tconst maxMove = edgeType === EdgeType.Broken ? this.options.cellSize * 0.35 : this.options.cellSize;\n\t\t\t\tthis.currentMousePos = {\n\t\t\t\t\tx: lastPos.x + Math.max(-maxMove, Math.min(maxMove, dx)),\n\t\t\t\t\ty: lastPos.y,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthis.currentMousePos = lastPos;\n\t\t\t}\n\t\t} else {\n\t\t\tconst dir = dy > 0 ? 1 : -1;\n\t\t\tconst target = { x: lastPoint.x, y: lastPoint.y + dir };\n\t\t\tconst edgeType = this.getEdgeType(lastPoint, target);\n\n\t\t\tif (target.y >= 0 && target.y <= this.puzzle.rows && edgeType !== EdgeType.Absent) {\n\t\t\t\tconst maxMove = edgeType === EdgeType.Broken ? this.options.cellSize * 0.35 : this.options.cellSize;\n\t\t\t\tthis.currentMousePos = {\n\t\t\t\t\tx: lastPos.x,\n\t\t\t\t\ty: lastPos.y + Math.max(-maxMove, Math.min(maxMove, dy)),\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthis.currentMousePos = lastPos;\n\t\t\t}\n\t\t}\n\n\t\tconst neighbors = [\n\t\t\t{ x: lastPoint.x + 1, y: lastPoint.y },\n\t\t\t{ x: lastPoint.x - 1, y: lastPoint.y },\n\t\t\t{ x: lastPoint.x, y: lastPoint.y + 1 },\n\t\t\t{ x: lastPoint.x, y: lastPoint.y - 1 },\n\t\t];\n\n\t\tfor (const n of neighbors) {\n\t\t\tif (n.x >= 0 && n.x <= this.puzzle.cols && n.y >= 0 && n.y <= this.puzzle.rows) {\n\t\t\t\tconst nPos = this.getCanvasCoords(n.x, n.y);\n\t\t\t\tconst dist = Math.hypot(nPos.x - this.currentMousePos.x, nPos.y - this.currentMousePos.y);\n\n\t\t\t\tif (dist < this.options.cellSize * 0.3) {\n\t\t\t\t\tconst idx = this.path.findIndex((p) => p.x === n.x && p.y === n.y);\n\t\t\t\t\tif (idx === -1) {\n\t\t\t\t\t\tthis.path.push(n);\n\t\t\t\t\t} else if (idx === this.path.length - 2) {\n\t\t\t\t\t\tthis.path.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.draw();\n\t}\n\n\tprivate handleEnd(e: { clientX: number; clientY: number }) {\n\t\tif (!this.puzzle || !this.isDrawing) return;\n\t\tthis.isDrawing = false;\n\n\t\tconst lastPoint = this.path[this.path.length - 1];\n\t\tconst lastPos = this.getCanvasCoords(lastPoint.x, lastPoint.y);\n\t\tconst exitDir = this.getExitDir(lastPoint.x, lastPoint.y);\n\n\t\tif (exitDir) {\n\t\t\tconst distToExit = Math.hypot(this.currentMousePos.x - lastPos.x, this.currentMousePos.y - lastPos.y);\n\t\t\tif (distToExit > this.options.exitLength * 0.1) {\n\t\t\t\tthis.exitTipPos = { ...this.currentMousePos };\n\t\t\t\tthis.options.onPathComplete(this.path);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.exitTipPos = exitDir ? { ...this.currentMousePos } : null;\n\t\tthis.startFade(\"#ffcc00\"); // \u9014\u4E2D\u3067\u96E2\u3057\u305F\u5834\u5408\u306F\u9EC4\u8272\u3067\u6D88\u3048\u308B\n\t}\n\n\tprivate getEdgeType(p1: Point, p2: Point): EdgeType {\n\t\tif (!this.puzzle) return EdgeType.Absent;\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\tif (y < 0 || y >= this.puzzle.rows) return EdgeType.Absent;\n\t\t\treturn this.puzzle.vEdges[y][p1.x].type;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\tif (x < 0 || x >= this.puzzle.cols) return EdgeType.Absent;\n\t\t\treturn this.puzzle.hEdges[p1.y][x].type;\n\t\t}\n\t}\n\n\tprivate startFade(color = \"#ff4444\") {\n\t\tthis.isFading = true;\n\t\tthis.fadeOpacity = 1.0;\n\t\tthis.fadeColor = color;\n\t\tthis.fadingPath = [...this.path];\n\t\tthis.fadingTipPos = this.exitTipPos ? { ...this.exitTipPos } : null;\n\t\tthis.path = [];\n\t}\n\n\tprivate cancelFade() {\n\t\tthis.isFading = false;\n\t}\n\n\tprivate animate() {\n\t\tif (typeof window === \"undefined\") return;\n\t\tthis.draw();\n\n\t\tif (this.isFading) {\n\t\t\tthis.fadeOpacity -= 0.015;\n\t\t\tif (this.fadeOpacity <= 0) {\n\t\t\t\tthis.isFading = false;\n\t\t\t\tthis.fadeOpacity = 0;\n\t\t\t}\n\t\t}\n\n\t\trequestAnimationFrame(() => this.animate());\n\t}\n\n\t// --- Drawing Logic ---\n\n\tpublic draw() {\n\t\tif (!this.puzzle || !this.ctx) return;\n\n\t\tconst ctx = this.ctx;\n\t\tctx.globalAlpha = 1.0;\n\t\tctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n\t\tthis.drawGrid(ctx);\n\t\tthis.drawConstraints(ctx);\n\t\tthis.drawNodes(ctx);\n\n\t\tif (this.path.length === 0 && !this.isDrawing) {\n\t\t\tthis.drawRipples(ctx);\n\t\t}\n\n\t\tif (this.isFading) {\n\t\t\tthis.drawPath(ctx, this.fadingPath, false, this.fadeColor, this.fadeOpacity, this.fadingTipPos);\n\t\t} else if (this.path.length > 0) {\n\t\t\tthis.drawPath(ctx, this.path, this.isDrawing, this.options.colors.path, 1.0, this.isDrawing ? this.currentMousePos : this.exitTipPos);\n\t\t}\n\t}\n\n\tprivate drawRipples(ctx: CanvasRenderingContext2D) {\n\t\tif (!this.puzzle) return;\n\t\tconst time = (Date.now() - this.startTime) / 500;\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tconst node = this.puzzle.nodes[r][c];\n\t\t\t\tif (node.type === NodeType.End) {\n\t\t\t\t\tconst pos = this.getCanvasCoords(c, r);\n\t\t\t\t\tconst dir = this.getExitDir(c, r);\n\t\t\t\t\tif (!dir) continue;\n\t\t\t\t\tconst exitPos = {\n\t\t\t\t\t\tx: pos.x + dir.x * this.options.exitLength,\n\t\t\t\t\t\ty: pos.y + dir.y * this.options.exitLength,\n\t\t\t\t\t};\n\n\t\t\t\t\tconst t = time % 4.0;\n\t\t\t\t\tconst radius = t * 5;\n\t\t\t\t\tconst opacity = Math.max(0, 1 - t / 3.0);\n\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(exitPos.x, exitPos.y, radius, 0, Math.PI * 2);\n\t\t\t\t\tctx.strokeStyle = `rgba(170, 170, 170, ${opacity * 0.4})`;\n\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate drawGrid(ctx: CanvasRenderingContext2D) {\n\t\tif (!this.puzzle || !this.options.colors.grid) return;\n\t\tctx.strokeStyle = this.options.colors.grid;\n\t\tctx.lineWidth = 12;\n\t\tctx.lineCap = \"round\";\n\n\t\tconst drawEdge = (p1: Point, p2: Point, type: EdgeType) => {\n\t\t\tif (type === EdgeType.Absent) return;\n\n\t\t\tif (type === EdgeType.Broken) {\n\t\t\t\tconst gapSize = 0.15;\n\t\t\t\tconst q1 = {\n\t\t\t\t\tx: p1.x + (p2.x - p1.x) * (0.5 - gapSize),\n\t\t\t\t\ty: p1.y + (p2.y - p1.y) * (0.5 - gapSize),\n\t\t\t\t};\n\t\t\t\tconst q2 = {\n\t\t\t\t\tx: p1.x + (p2.x - p1.x) * (0.5 + gapSize),\n\t\t\t\t\ty: p1.y + (p2.y - p1.y) * (0.5 + gapSize),\n\t\t\t\t};\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(p1.x, p1.y);\n\t\t\t\tctx.lineTo(q1.x, q1.y);\n\t\t\t\tctx.stroke();\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(q2.x, q2.y);\n\t\t\t\tctx.lineTo(p2.x, p2.y);\n\t\t\t\tctx.stroke();\n\t\t\t} else {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(p1.x, p1.y);\n\t\t\t\tctx.lineTo(p2.x, p2.y);\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t};\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c < this.puzzle.cols; c++) {\n\t\t\t\tdrawEdge(this.getCanvasCoords(c, r), this.getCanvasCoords(c + 1, r), this.puzzle.hEdges[r][c].type);\n\t\t\t}\n\t\t}\n\n\t\tfor (let r = 0; r < this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tdrawEdge(this.getCanvasCoords(c, r), this.getCanvasCoords(c, r + 1), this.puzzle.vEdges[r][c].type);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate drawConstraints(ctx: CanvasRenderingContext2D) {\n\t\tif (!this.puzzle) return;\n\t\tconst now = Date.now();\n\t\tfor (let r = 0; r < this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c < this.puzzle.cols; c++) {\n\t\t\t\tconst cell = this.puzzle.cells[r][c];\n\t\t\t\tconst pos = this.getCanvasCoords(c + 0.5, r + 0.5);\n\n\t\t\t\tconst isInvalidated = this.invalidatedCells.some((p) => p.x === c && p.y === r);\n\t\t\t\tlet opacity = 1.0;\n\t\t\t\tif (isInvalidated) {\n\t\t\t\t\tif (this.isFading) {\n\t\t\t\t\t\topacity = this.fadeOpacity;\n\t\t\t\t\t} else if (this.isSuccessFading) {\n\t\t\t\t\t\tconst elapsed = now - this.successFadeStartTime;\n\t\t\t\t\t\topacity = Math.max(0.3, 1.0 - elapsed / 1000);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (opacity < 1.0) {\n\t\t\t\t\tconst { canvas: tempCanvas, ctx: tempCtx } = this.prepareOffscreen();\n\t\t\t\t\tthis.drawConstraintItem(tempCtx, cell, pos);\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.globalAlpha = opacity;\n\t\t\t\t\tctx.drawImage(tempCanvas, 0, 0);\n\t\t\t\t\tctx.restore();\n\t\t\t\t} else {\n\t\t\t\t\tthis.drawConstraintItem(ctx, cell, pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tctx.lineWidth = 2;\n\t\tconst hexRadius = 8;\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c < this.puzzle.cols; c++) {\n\t\t\t\tif (this.puzzle.hEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst pos = this.getCanvasCoords(c + 0.5, r);\n\t\t\t\t\tctx.save();\n\t\t\t\t\tconst isInvalidated = this.invalidatedEdges.some((e) => e.type === \"h\" && e.r === r && e.c === c);\n\t\t\t\t\tif (isInvalidated) {\n\t\t\t\t\t\tif (this.isFading) ctx.globalAlpha *= this.fadeOpacity;\n\t\t\t\t\t\telse if (this.isSuccessFading) {\n\t\t\t\t\t\t\tconst elapsed = now - this.successFadeStartTime;\n\t\t\t\t\t\t\tctx.globalAlpha *= Math.max(0.3, 1.0 - elapsed / 1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius);\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tif (this.puzzle.vEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst pos = this.getCanvasCoords(c, r + 0.5);\n\t\t\t\t\tctx.save();\n\t\t\t\t\tconst isInvalidated = this.invalidatedEdges.some((e) => e.type === \"v\" && e.r === r && e.c === c);\n\t\t\t\t\tif (isInvalidated) {\n\t\t\t\t\t\tif (this.isFading) ctx.globalAlpha *= this.fadeOpacity;\n\t\t\t\t\t\telse if (this.isSuccessFading) {\n\t\t\t\t\t\t\tconst elapsed = now - this.successFadeStartTime;\n\t\t\t\t\t\t\tctx.globalAlpha *= Math.max(0.3, 1.0 - elapsed / 1000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius);\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u5358\u4E00\u306E\u5236\u7D04\u30A2\u30A4\u30C6\u30E0\u3092\u63CF\u753B\uFF08\u5EA7\u6A19\u306F\u30AD\u30E3\u30F3\u30D0\u30B9\u5168\u4F53\u306B\u5BFE\u3059\u308B\u7D76\u5BFE\u5EA7\u6A19\uFF09\n\t */\n\tprivate drawConstraintItem(ctx: CanvasRenderingContext2D, cell: any, pos: Point) {\n\t\tif (cell.type === CellType.Square) {\n\t\t\tconst size = 26;\n\t\t\tconst radius = 8;\n\t\t\tctx.fillStyle = this.getColorCode(cell.color);\n\t\t\tthis.drawRoundedRect(ctx, pos.x - size / 2, pos.y - size / 2, size, size, radius);\n\t\t} else if (cell.type === CellType.Star) {\n\t\t\tthis.drawStar(ctx, pos.x, pos.y, 12, 16, 8, cell.color);\n\t\t} else if (cell.type === CellType.Tetris || cell.type === CellType.TetrisRotated) {\n\t\t\tthis.drawTetris(ctx, pos.x, pos.y, cell.shape || [], cell.type === CellType.TetrisRotated, cell.color);\n\t\t} else if (cell.type === CellType.Eraser) {\n\t\t\tthis.drawEraser(ctx, pos.x, pos.y, 14, 3, cell.color);\n\t\t}\n\t}\n\n\tprivate drawNodes(ctx: CanvasRenderingContext2D) {\n\t\tif (!this.puzzle) return;\n\t\tconst isNodeIsolated = (c: number, r: number) => {\n\t\t\tconst connectedEdges: EdgeType[] = [];\n\t\t\tif (c > 0) connectedEdges.push(this.puzzle!.hEdges[r][c - 1].type);\n\t\t\tif (c < this.puzzle!.cols) connectedEdges.push(this.puzzle!.hEdges[r][c].type);\n\t\t\tif (r > 0) connectedEdges.push(this.puzzle!.vEdges[r - 1][c].type);\n\t\t\tif (r < this.puzzle!.rows) connectedEdges.push(this.puzzle!.vEdges[r][c].type);\n\t\t\treturn connectedEdges.length > 0 && connectedEdges.every((e) => e === EdgeType.Absent);\n\t\t};\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tif (isNodeIsolated(c, r)) continue;\n\n\t\t\t\tconst node = this.puzzle.nodes[r][c];\n\t\t\t\tconst pos = this.getCanvasCoords(c, r);\n\n\t\t\t\tif (node.type === NodeType.Start) {\n\t\t\t\t\tif (this.options.colors.node) ctx.fillStyle = this.options.colors.node;\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(pos.x, pos.y, this.options.startNodeRadius, 0, Math.PI * 2);\n\t\t\t\t\tctx.fill();\n\t\t\t\t} else if (node.type === NodeType.End) {\n\t\t\t\t\tconst dir = this.getExitDir(c, r);\n\t\t\t\t\tif (!dir) continue;\n\t\t\t\t\tif (this.options.colors.node) ctx.strokeStyle = this.options.colors.node;\n\t\t\t\t\tctx.lineWidth = 12;\n\t\t\t\t\tctx.lineCap = \"round\";\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(pos.x, pos.y);\n\t\t\t\t\tctx.lineTo(pos.x + dir.x * this.options.exitLength, pos.y + dir.y * this.options.exitLength);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t} else {\n\t\t\t\t\tif (this.options.colors.node) ctx.fillStyle = this.options.colors.node;\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(pos.x, pos.y, this.options.nodeRadius, 0, Math.PI * 2);\n\t\t\t\t\tctx.fill();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate drawPath(ctx: CanvasRenderingContext2D, path: Point[], isDrawing: boolean, color: string | undefined, opacity: number, tipPos: Point | null = null) {\n\t\tif (path.length === 0 || !color) return;\n\n\t\tif (opacity < 1.0) {\n\t\t\tconst { canvas: tempCanvas, ctx: tempCtx } = this.prepareOffscreen();\n\t\t\tthis.drawPathInternal(tempCtx, path, isDrawing, color, tipPos);\n\t\t\tctx.save();\n\t\t\tctx.globalAlpha = opacity;\n\t\t\tctx.drawImage(tempCanvas, 0, 0);\n\t\t\tctx.restore();\n\t\t} else {\n\t\t\tthis.drawPathInternal(ctx, path, isDrawing, color, tipPos);\n\t\t}\n\t}\n\n\tprivate drawPathInternal(ctx: CanvasRenderingContext2D, path: Point[], isDrawing: boolean, color: string, tipPos: Point | null = null) {\n\t\tctx.save();\n\t\tctx.strokeStyle = color;\n\t\tctx.fillStyle = color;\n\t\tctx.lineWidth = this.options.pathWidth;\n\t\tctx.lineCap = \"round\";\n\t\tctx.lineJoin = \"round\";\n\n\t\tctx.beginPath();\n\t\tconst startPos = this.getCanvasCoords(path[0].x, path[0].y);\n\t\tctx.moveTo(startPos.x, startPos.y);\n\n\t\tfor (let i = 1; i < path.length; i++) {\n\t\t\tconst pos = this.getCanvasCoords(path[i].x, path[i].y);\n\t\t\tctx.lineTo(pos.x, pos.y);\n\t\t}\n\n\t\tif (isDrawing || tipPos) {\n\t\t\tconst pos = tipPos || this.currentMousePos;\n\t\t\tctx.lineTo(pos.x, pos.y);\n\t\t}\n\n\t\tctx.stroke();\n\n\t\tctx.beginPath();\n\t\tctx.arc(startPos.x, startPos.y, this.options.startNodeRadius, 0, Math.PI * 2);\n\t\tctx.fill();\n\n\t\tif (isDrawing) {\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(this.currentMousePos.x, this.currentMousePos.y, this.options.pathWidth / 2, 0, Math.PI * 2);\n\t\t\tctx.fill();\n\t\t}\n\t\tctx.restore();\n\t}\n\n\tprivate drawRoundedRect(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: number) {\n\t\tctx.beginPath();\n\t\tctx.moveTo(x + radius, y);\n\t\tctx.lineTo(x + width - radius, y);\n\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\tctx.lineTo(x + width, y + height - radius);\n\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\tctx.lineTo(x + radius, y + height);\n\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\tctx.lineTo(x, y + radius);\n\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\tctx.closePath();\n\t\tctx.fill();\n\t}\n\n\tprivate drawHexagon(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number) {\n\t\tif (!this.options.colors.hexagon) return;\n\t\tctx.fillStyle = this.options.colors.hexagon;\n\t\tctx.beginPath();\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tconst angle = (Math.PI / 3) * i;\n\t\t\tconst px = x + radius * Math.cos(angle);\n\t\t\tconst py = y + radius * Math.sin(angle);\n\t\t\tif (i === 0) ctx.moveTo(px, py);\n\t\t\telse ctx.lineTo(px, py);\n\t\t}\n\t\tctx.closePath();\n\t\tctx.fill();\n\t}\n\n\tprivate drawEraser(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, points: number, colorEnum: Color) {\n\t\tctx.strokeStyle = this.getColorCode(colorEnum);\n\t\tctx.lineWidth = radius * 0.5;\n\t\tctx.lineCap = \"butt\";\n\t\tconst rotation = 0.5;\n\t\tctx.beginPath();\n\t\tfor (let i = 0; i < points; i++) {\n\t\t\tconst angle = ((Math.PI * 2) / points) * i + rotation;\n\t\t\tconst px = x + radius * Math.cos(angle);\n\t\t\tconst py = y + radius * Math.sin(angle);\n\n\t\t\tctx.moveTo(x, y);\n\t\t\tctx.lineTo(px, py);\n\t\t}\n\t\tctx.stroke();\n\t}\n\n\tprivate drawStar(ctx: CanvasRenderingContext2D, x: number, y: number, innerRadius: number, outerRadius: number, points: number, colorEnum: Color) {\n\t\tctx.fillStyle = this.getColorCode(colorEnum);\n\t\tctx.beginPath();\n\t\tfor (let i = 0; i < points * 2; i++) {\n\t\t\tconst radius = i % 2 === 0 ? outerRadius : innerRadius;\n\t\t\tconst angle = (Math.PI / points) * i;\n\t\t\tconst px = x + radius * Math.cos(angle);\n\t\t\tconst py = y + radius * Math.sin(angle);\n\t\t\tif (i === 0) ctx.moveTo(px, py);\n\t\t\telse ctx.lineTo(px, py);\n\t\t}\n\t\tctx.closePath();\n\t\tctx.fill();\n\t}\n\n\tprivate drawTetris(ctx: CanvasRenderingContext2D, x: number, y: number, shape: number[][], rotated: boolean, colorEnum: Color) {\n\t\tif (!shape || shape.length === 0) return;\n\t\tconst cellSize = 12;\n\t\tconst gap = 2;\n\t\tconst totalW = shape[0].length * cellSize + (shape[0].length - 1) * gap;\n\t\tconst totalH = shape.length * cellSize + (shape.length - 1) * gap;\n\n\t\tctx.save();\n\t\tctx.translate(x, y);\n\t\tif (rotated) {\n\t\t\tctx.rotate(Math.PI / 8);\n\t\t}\n\t\tctx.fillStyle = colorEnum === Color.None ? \"#ffcc00\" : this.getColorCode(colorEnum);\n\n\t\tfor (let r = 0; r < shape.length; r++) {\n\t\t\tfor (let c = 0; c < shape[r].length; c++) {\n\t\t\t\tif (shape[r][c]) {\n\t\t\t\t\tconst px = c * (cellSize + gap) - totalW / 2;\n\t\t\t\t\tconst py = r * (cellSize + gap) - totalH / 2;\n\t\t\t\t\tctx.fillRect(px, py, cellSize, cellSize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx.restore();\n\t}\n\n\tprivate getColorCode(colorEnum: Color): string {\n\t\treturn (this.options.colors.colorMap && this.options.colors.colorMap[colorEnum]) || \"#666\";\n\t}\n\n\tprivate prepareOffscreen() {\n\t\tif (typeof document === \"undefined\") {\n\t\t\treturn { canvas: {} as HTMLCanvasElement, ctx: {} as CanvasRenderingContext2D };\n\t\t}\n\t\tif (!this.offscreenCanvas) {\n\t\t\tthis.offscreenCanvas = document.createElement(\"canvas\");\n\t\t\tthis.offscreenCtx = this.offscreenCanvas.getContext(\"2d\");\n\t\t}\n\t\tif (this.offscreenCanvas.width !== this.canvas.width || this.offscreenCanvas.height !== this.canvas.height) {\n\t\t\tthis.offscreenCanvas.width = this.canvas.width;\n\t\t\tthis.offscreenCanvas.height = this.canvas.height;\n\t\t}\n\t\tthis.offscreenCtx!.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);\n\t\treturn { canvas: this.offscreenCanvas, ctx: this.offscreenCtx! };\n\t}\n}\n", "import { PuzzleGenerator } from \"./generator\";\nimport { Grid } from \"./grid\";\nimport type { GenerationOptions, PuzzleData, SolutionPath, ValidationResult } from \"./types\";\nimport { PuzzleValidator } from \"./validator\";\n\n// \u30E9\u30A4\u30D6\u30E9\u30EA\u306E\u30D5\u30A1\u30B5\u30FC\u30C9\u30AF\u30E9\u30B9\nexport { PuzzleGenerator } from \"./generator\";\nexport { Grid } from \"./grid\";\nexport { WitnessUI } from \"./ui\";\nexport { PuzzleValidator } from \"./validator\";\n\nexport class WitnessCore {\n\tprivate generator: PuzzleGenerator;\n\tprivate validator: PuzzleValidator;\n\n\tconstructor() {\n\t\tthis.generator = new PuzzleGenerator();\n\t\tthis.validator = new PuzzleValidator();\n\t}\n\n\t/**\n\t * \u65B0\u3057\u3044\u30D1\u30BA\u30EB\u3092\u751F\u6210\u3057\u3066\u30C7\u30FC\u30BF\u3092\u8FD4\u3059\n\t */\n\tpublic createPuzzle(rows: number, cols: number, options: GenerationOptions = {}): PuzzleData {\n\t\tconst grid = this.generator.generate(rows, cols, options);\n\t\treturn grid.export();\n\t}\n\n\t/**\n\t * \u89E3\u7B54\u3092\u691C\u8A3C\u3059\u308B\n\t */\n\tpublic validateSolution(puzzleData: PuzzleData, solution: SolutionPath): ValidationResult {\n\t\tconst grid = Grid.fromData(puzzleData);\n\t\treturn this.validator.validate(grid, solution);\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u306E\u96E3\u6613\u5EA6\u3092\u8A08\u7B97\u3059\u308B\n\t */\n\tpublic calculateDifficulty(puzzleData: PuzzleData): number {\n\t\tconst grid = Grid.fromData(puzzleData);\n\t\treturn this.validator.calculateDifficulty(grid);\n\t}\n}\n\n// \u30D6\u30E9\u30A6\u30B6/Node.js\u74B0\u5883\u4E21\u5BFE\u5FDC\u306E\u305F\u3081\u306E\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\nexport * from \"./types\";\n"],
  "mappings": "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",
  "names": ["Direction", "CellType", "EdgeType", "NodeType", "Color", "Grid", "_Grid", "rows", "cols", "data", "grid", "PuzzleValidator", "grid", "solution", "path", "start", "end", "visitedNodes", "i", "p1", "p2", "key", "regions", "missedHexagons", "type", "y", "x", "pathEdges", "missed", "r", "c", "regionResults", "region", "erasers", "p", "otherMarks", "adjacentMissedHexagons", "j", "possible", "a", "b", "costA", "costB", "assignment", "idx", "hex", "regionCells", "results", "numErasers", "itemsToNegate", "initiallyValid", "N", "negatedEraserCombinations", "negatedErasers", "negatedErasersSet", "e", "activeErasers", "K", "itemCombinations", "negatedItems", "negatedCells", "it", "negatedHexIndices", "isUseful", "subset", "subsetCells", "subsetHexIndices", "allHexSatisfied", "items", "n", "backtrack", "current", "erasedCells", "erasersAsMarks", "erasedSet", "erasersAsMarksSet", "colorCounts", "starColors", "squareColors", "tetrisPieces", "cell", "constraint", "isEraserAsMark", "isOtherMark", "color", "totalMissedHexagons", "numRegions", "currentHexErasures", "allInvalidatedCells", "allInvalidatedHexIndices", "regionIdx", "count", "option", "hexIdx", "pieces", "sum", "minX", "minY", "maxX", "maxY", "width", "height", "regionGrid", "shape", "area", "row", "r0", "c0", "piece", "nextPieces", "rotations", "blocks", "pr", "pc", "anchor", "dr", "dc", "nr", "nc", "value", "keys", "curr", "rows", "cols", "newShape", "visitedCells", "externalCells", "queue", "neighbors", "neighborKey", "edgeKey", "external", "nodeCols", "nodeCount", "adj", "startNodes", "endNodes", "hexagonEdges", "u", "v", "isHexagon", "isBroken", "stats", "totalHexagons", "fingerprints", "searchLimit", "startIdx", "constraintCount", "constraintTypes", "tetrisCount", "rotatedTetrisCount", "branchingFactor", "searchComplexity", "difficulty", "cellCount", "density", "densityFactor", "typeFactor", "sizeFactor", "currIdx", "visitedMask", "hexagonsOnPath", "limit", "solutionPath", "fp", "validMoves", "edge", "otherEdge", "isAlreadyOnPath", "isNextMove", "move", "localVisited", "head", "f", "PuzzleGenerator", "rows", "cols", "options", "targetDifficulty", "validator", "PuzzleValidator", "bestGrid", "bestScore", "maxAttempts", "attempt", "grid", "difficulty", "diffFromTarget", "Grid", "startPoint", "endPoint", "solutionPath", "start", "end", "visited", "path", "findPath", "current", "neighbors", "next", "p", "candidates", "directions", "d", "nx", "ny", "complexity", "pathEdges", "i", "unusedEdges", "r", "c", "p1", "p2", "targetCount", "placed", "edge", "type", "edgesWithMeta", "m", "startNodes", "reachableNodes", "queue", "curr", "n", "external", "cellKey", "e", "useHexagons", "useSquares", "useStars", "useTetris", "useEraser", "hexagonsPlaced", "squaresPlaced", "starsPlaced", "tetrisPlaced", "erasersPlaced", "totalTetrisArea", "maxTotalTetrisArea", "isBranching", "prob", "idx", "regions", "availableColors", "regionIndices", "_", "squareColorsUsed", "needs", "rIdx", "region", "remainingRegions", "forceOne", "placementProb", "potentialCells", "squareColor", "otherColors", "shouldPlaceSquare", "maxSquares", "numSquares", "cell", "shouldPlaceTetris", "maxTetrisPerRegion", "tiledPieces", "tetrisColor", "colors", "shouldPlaceEraser", "errorTypes", "boundaryEdges", "errorType", "errorPlaced", "errCell", "existingSquare", "existingSquareColor", "piecesToPlace", "currentArea", "area", "eraserColor", "maxPairs", "color", "colorCount", "otherColor", "visitedCells", "currentRegion", "y", "x", "boundary", "edges", "key", "unique", "found", "fSq", "fSt", "fT", "fE", "sqC", "maxPieces", "minX", "minY", "maxX", "maxY", "width", "height", "regionGrid", "currentPieces", "r0", "c0", "shapes", "a", "b", "baseShape", "isInv", "rotations", "shape", "blocks", "pr", "pc", "anchor", "dr", "dc", "result", "row", "results", "keys", "newShape", "j", "nr", "nc", "value", "array", "WitnessUI", "canvasOrId", "puzzle", "options", "el", "context", "isValid", "invalidatedCells", "invalidatedEdges", "gridX", "gridY", "x", "y", "rect", "mouseX", "mouseY", "r", "c", "nodePos", "lastPoint", "lastPos", "dx", "dy", "exitDir", "dot", "length", "dir", "target", "edgeType", "maxMove", "neighbors", "n", "nPos", "idx", "p1", "p2", "color", "ctx", "time", "pos", "exitPos", "t", "radius", "opacity", "drawEdge", "type", "q1", "q2", "now", "cell", "isInvalidated", "p", "elapsed", "tempCanvas", "tempCtx", "hexRadius", "e", "isNodeIsolated", "connectedEdges", "node", "path", "isDrawing", "tipPos", "startPos", "i", "width", "height", "angle", "px", "py", "points", "colorEnum", "rotation", "innerRadius", "outerRadius", "shape", "rotated", "cellSize", "gap", "totalW", "totalH", "WitnessCore", "PuzzleGenerator", "PuzzleValidator", "rows", "cols", "options", "puzzleData", "solution", "grid", "Grid"]
}
