/*!
 * MiniWitness 1.4.8
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var Re=(n=>(n[n.Up=0]="Up",n[n.Right=1]="Right",n[n.Down=2]="Down",n[n.Left=3]="Left",n))(Re||{}),ae=(f=>(f[f.None=0]="None",f[f.Square=1]="Square",f[f.Star=2]="Star",f[f.Tetris=3]="Tetris",f[f.TetrisRotated=4]="TetrisRotated",f[f.TetrisNegative=5]="TetrisNegative",f[f.TetrisNegativeRotated=6]="TetrisNegativeRotated",f[f.Eraser=7]="Eraser",f[f.Triangle=8]="Triangle",f))(ae||{}),ce=(i=>(i[i.Normal=0]="Normal",i[i.Broken=1]="Broken",i[i.Absent=2]="Absent",i[i.Hexagon=3]="Hexagon",i[i.HexagonMain=4]="HexagonMain",i[i.HexagonSymmetry=5]="HexagonSymmetry",i))(ce||{}),fe=(i=>(i[i.Normal=0]="Normal",i[i.Start=1]="Start",i[i.End=2]="End",i[i.Hexagon=3]="Hexagon",i[i.HexagonMain=4]="HexagonMain",i[i.HexagonSymmetry=5]="HexagonSymmetry",i))(fe||{}),ye=(n=>(n[n.None=0]="None",n[n.Horizontal=1]="Horizontal",n[n.Vertical=2]="Vertical",n[n.Rotational=3]="Rotational",n))(ye||{}),j={None:0,Black:1,White:2,Red:3,Blue:4},Ne=(s=>(s[s.Mulberry32=0]="Mulberry32",s[s.XorShift128Plus=1]="XorShift128Plus",s[s.MathRandom=2]="MathRandom",s))(Ne||{});var ie=class B{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];symmetry=0;seed;constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:j.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes,symmetry:this.symmetry,seed:this.seed}))}static fromData(e){let t=new B(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t.symmetry=e.symmetry||0,t.seed=e.seed,t}};var ge=class{state;constructor(e){this.state=e>>>0}next(){let e=(this.state+=1831565813)|0;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}},be=class{s0;s1;constructor(e,t){this.s0=e>>>0,this.s1=t>>>0,this.s0===0&&this.s1===0&&(this.s1=1)}next(){let e=this.s0,t=this.s1;return this.s0=t,e^=e<<23,this.s1=e^t^e>>>17^t>>>26,(this.s1+t>>>0)/4294967296}},ve=class{next(){return Math.random()}};function me(B,e){switch(B){case 0:return new ge(Number(e&0xffffffffn));case 1:return new be(Number(e&0xffffffffn),Number(e>>32n&0xffffffffn));case 2:return new ve;default:return new ge(Number(e&0xffffffffn))}}var le=class{tetrisCache=new Map;reachabilityCache=new Map;rng=null;setRng(e){this.rng=e}validate(e,t,s){let n=t.points;if(n.length<2)return{isValid:!1,errorReason:"Path too short"};let o=e.symmetry||0,i=[];if(o!==0)for(let c of n)i.push(this.getSymmetricalPoint(e,c));let r=n[0],h=n[n.length-1];if(e.nodes[r.y][r.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[h.y][h.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};if(o!==0){let c=i[0],x=i[i.length-1];if(e.nodes[c.y][c.x].type!==1)return{isValid:!1,errorReason:"Symmetrical path must start at Start Node"};if(e.nodes[x.y][x.x].type!==2)return{isValid:!1,errorReason:"Symmetrical path must end at End Node"}}let f=new Set,d=new Set;if(f.add(`${r.x},${r.y}`),o!==0){let c=i[0];if(f.has(`${c.x},${c.y}`))return{isValid:!1,errorReason:"Paths collide at start"};f.add(`${c.x},${c.y}`)}for(let c=0;c<n.length-1;c++){let x=n[c],P=n[c+1];if(Math.abs(x.x-P.x)+Math.abs(x.y-P.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let y=`${P.x},${P.y}`;if(f.has(y))return{isValid:!1,errorReason:"Self-intersecting path or path collision"};if(f.add(y),this.isBrokenEdge(e,x,P))return{isValid:!1,errorReason:"Passed through broken edge"};if(d.add(this.getEdgeKey(x,P)),o!==0){let m=i[c],g=i[c+1],S=`${g.x},${g.y}`;if(f.has(S))return{isValid:!1,errorReason:"Path collision"};if(f.add(S),this.isBrokenEdge(e,m,g))return{isValid:!1,errorReason:"Symmetrical path passed through broken edge"};let C=this.getEdgeKey(m,g);if(d.has(C))return{isValid:!1,errorReason:"Paths cross the same edge"};d.add(C)}}let u=this.calculateRegions(e,n,i,s),l=this.getMissedHexagons(e,n,i),p=new Set;for(let c=0;c<n.length-1;c++)p.add(this.getEdgeKey(n[c],n[c+1]));if(o!==0)for(let c=0;c<i.length-1;c++)p.add(this.getEdgeKey(i[c],i[c+1]));let a=this.validateWithErasers(e,u,l.edges,l.nodes,p);return a.regions=u,a}validateFast(e,t,s,n){let o=this.calculateRegions(e,t,s,n),i=this.getMissedHexagons(e,t,s),r=new Set;for(let f=0;f<t.length-1;f++)r.add(this.getEdgeKey(t[f],t[f+1]));if((e.symmetry||0)!==0)for(let f=0;f<s.length-1;f++)r.add(this.getEdgeKey(s[f],s[f+1]));return this.validateWithErasers(e,o,i.edges,i.nodes,r)}isBrokenEdge(e,t,s){let n;if(t.x===s.x){let o=Math.min(t.y,s.y);n=e.vEdges[o][t.x].type}else{let o=Math.min(t.x,s.x);n=e.hEdges[t.y][o].type}return n===1||n===2}isAbsentEdge(e,t,s){if(t.x===s.x){let n=Math.min(t.y,s.y);return e.vEdges[n][t.x].type===2}else{let n=Math.min(t.x,s.x);return e.hEdges[t.y][n].type===2}}getMissedHexagons(e,t,s=[]){let n=new Set,o=new Set;for(let d=0;d<t.length;d++)o.add(`${t[d].x},${t[d].y}`),d<t.length-1&&n.add(this.getEdgeKey(t[d],t[d+1]));let i=new Set,r=new Set;for(let d=0;d<s.length;d++)r.add(`${s[d].x},${s[d].y}`),d<s.length-1&&i.add(this.getEdgeKey(s[d],s[d+1]));let h=[];for(let d=0;d<=e.rows;d++)for(let u=0;u<e.cols;u++){let l=e.hEdges[d][u].type;if(l===3||l===4||l===5){let p=this.getEdgeKey({x:u,y:d},{x:u+1,y:d}),a=!1;l===3?a=n.has(p)||i.has(p):l===4?a=n.has(p):l===5&&(a=i.has(p)),a||h.push({type:"h",r:d,c:u})}}for(let d=0;d<e.rows;d++)for(let u=0;u<=e.cols;u++){let l=e.vEdges[d][u].type;if(l===3||l===4||l===5){let p=this.getEdgeKey({x:u,y:d},{x:u,y:d+1}),a=!1;l===3?a=n.has(p)||i.has(p):l===4?a=n.has(p):l===5&&(a=i.has(p)),a||h.push({type:"v",r:d,c:u})}}let f=[];for(let d=0;d<=e.rows;d++)for(let u=0;u<=e.cols;u++){let l=e.nodes[d][u].type;if(l===3||l===4||l===5){let p=`${u},${d}`,a=!1;l===3?a=o.has(p)||r.has(p):l===4?a=o.has(p):l===5&&(a=r.has(p)),a||f.push({x:u,y:d})}}return{edges:h,nodes:f}}validateWithErasers(e,t,s,n,o){let i=[],r=!0;for(let a=0;a<t.length;a++){let c=t[a],x=c.filter(g=>e.cells[g.y][g.x].type===7),P=c.filter(g=>e.cells[g.y][g.x].type!==0&&e.cells[g.y][g.x].type!==7),b=[];for(let g=0;g<s.length;g++)this.isHexagonAdjacentToRegion(e,s[g],c)&&b.push(g);let y=[];for(let g=0;g<n.length;g++)this.isNodeHexagonAdjacentToRegion(e,n[g],c)&&y.push(g);let m=this.getPossibleErasures(e,c,x,P,b,y,o);if(m.length===0){r=!1;let g=this.getBestEffortErasures(e,c,x,P,b,y,o);i.push([g])}else m.sort((g,S)=>{let C=g.invalidatedCells.length+g.invalidatedHexagons.length+g.invalidatedNodeHexagons.length,v=S.invalidatedCells.length+S.invalidatedHexagons.length+S.invalidatedNodeHexagons.length;if(C!==v)return C-v;let w=g.invalidatedHexagons.length+g.invalidatedNodeHexagons.length,k=S.invalidatedHexagons.length+S.invalidatedNodeHexagons.length;return w!==k?k-w:g.invalidatedCells.length-S.invalidatedCells.length}),i.push(m)}if(r){let a=this.findGlobalAssignment(i,s.length,n.length);if(a)return{isValid:!0,invalidatedCells:a.invalidatedCells,invalidatedEdges:a.invalidatedHexIndices.map(c=>s[c]),invalidatedNodes:a.invalidatedNodeHexIndices.map(c=>n[c])}}let h=[],f=[],d=new Set,u=new Set;for(let a of i){let c=a[0];h.push(...c.errorCells),f.push(...c.invalidatedCells);for(let x of c.invalidatedHexagons)d.add(x);for(let x of c.invalidatedNodeHexagons)u.add(x)}let l=[];for(let a=0;a<s.length;a++)d.has(a)||l.push(s[a]);let p=[];for(let a=0;a<n.length;a++)u.has(a)||p.push(n[a]);return{isValid:!1,errorReason:"Constraints failed",errorCells:h,errorEdges:l,errorNodes:p,invalidatedCells:f,invalidatedEdges:Array.from(d).map(a=>s[a]),invalidatedNodes:Array.from(u).map(a=>n[a])}}isHexagonAdjacentToRegion(e,t,s){let n=new Set(s.map(o=>`${o.x},${o.y}`));if(t.type==="h"){if(t.r>0&&n.has(`${t.c},${t.r-1}`)||t.r<e.rows&&n.has(`${t.c},${t.r}`))return!0}else if(t.c>0&&n.has(`${t.c-1},${t.r}`)||t.c<e.cols&&n.has(`${t.c},${t.r}`))return!0;return!1}isNodeHexagonAdjacentToRegion(e,t,s){let n=new Set(s.map(i=>`${i.x},${i.y}`)),o=[{x:t.x-1,y:t.y-1},{x:t.x,y:t.y-1},{x:t.x-1,y:t.y},{x:t.x,y:t.y}];for(let i of o)if(i.x>=0&&i.x<e.cols&&i.y>=0&&i.y<e.rows&&n.has(`${i.x},${i.y}`))return!0;return!1}getPossibleErasures(e,t,s,n,o,i,r){let h=[],f=s.length;if(f===0)return this.getRegionErrors(e,t,[],r).length===0&&o.length===0&&i.length===0&&h.push({invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!0,errorCells:[]}),h;let d=[...n.map(l=>({type:"cell",pos:l})),...o.map(l=>({type:"hex",index:l})),...i.map(l=>({type:"nodeHex",index:l}))],u=this.getRegionErrors(e,t,[],r).length===0&&o.length===0&&i.length===0;for(let l=0;l<=f;l++){let p=this.getNCombinations(s,l);for(let a of p){let c=new Set(a.map(P=>`${P.x},${P.y}`)),x=s.filter(P=>!c.has(`${P.x},${P.y}`));for(let P=0;P<=d.length;P++){if(x.length!==l+P)continue;let b=this.getNCombinations(d,P);for(let y of b){let m=y.filter(w=>w.type==="cell").map(w=>w.pos),g=y.filter(w=>w.type==="hex").map(w=>w.index),S=y.filter(w=>w.type==="nodeHex").map(w=>w.index);if(this.getRegionErrors(e,t,[...m,...a],r).length===0){let w=!0;if(u)P>0&&(w=!1);else for(let k=0;k<y.length;k++){let E=[...y.slice(0,k),...y.slice(k+1)],T=E.filter(W=>W.type==="cell").map(W=>W.pos),z=new Set(E.filter(W=>W.type==="hex").map(W=>W.index)),I=new Set(E.filter(W=>W.type==="nodeHex").map(W=>W.index)),V=o.every(W=>z.has(W)),$=i.every(W=>I.has(W));if(this.getRegionErrors(e,t,T,r).length===0&&V&&$){w=!1;break}}w&&h.push({invalidatedCells:[...m,...a],invalidatedHexagons:g,invalidatedNodeHexagons:S,isValid:!0,errorCells:[]})}}}}}return h}getBestEffortErasures(e,t,s,n,o,i,r){let h=this.getRegionErrors(e,t,[],r);if(h.length===0&&o.length===0&&i.length===0)return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:[...s]};if(s.length>0){let u=[...n.map(c=>({type:"cell",pos:c})),...o.map(c=>({type:"hex",index:c})),...i.map(c=>({type:"nodeHex",index:c}))],l=null,p=1/0,a=c=>{let x=[],P=[],b=[],y=0;for(let E of c)y<s.length&&(E.type==="cell"?x.push(E.pos):E.type==="hex"?P.push(E.index):b.push(E.index),y++);let m=s.length-y,g=Math.floor(m/2),S=s.slice(y,y+g);y+=g*2;let C=this.getRegionErrors(e,t,[...x,...S],r);for(let E=y;E<s.length;E++)C.push(s[E]);let v=Math.max(0,o.length-P.length),w=Math.max(0,i.length-b.length),k=C.length+v+w;k<p&&(p=k,l={invalidatedCells:[...x,...S],invalidatedHexagons:P,invalidatedNodeHexagons:b,isValid:!1,errorCells:C})};a([...h.map(c=>({type:"cell",pos:c})),...o.map(c=>({type:"hex",index:c})),...i.map(c=>({type:"nodeHex",index:c}))]),a(u);for(let c of h)a([{type:"cell",pos:c}]);if(l)return l}let d=[...h,...s];return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:d}}getNCombinations(e,t){let s=[],n=(o,i)=>{if(i.length===t){s.push([...i]);return}for(let r=o;r<e.length;r++)i.push(e[r]),n(r+1,i),i.pop()};return n(0,[]),s}checkRegionValid(e,t,s,n){return this.getRegionErrors(e,t,s,n).length===0}getRegionErrors(e,t,s,n){let o=new Set(s.map(a=>`${a.x},${a.y}`)),i=new Map,r=new Map,h=new Set,f=new Set,d=[],u=[],l=[];for(let a of t){if(o.has(`${a.x},${a.y}`))continue;let c=e.cells[a.y][a.x];if(c.type===0)continue;let x=c.color;x!==j.None&&(i.set(x,(i.get(x)||0)+1),r.has(x)||r.set(x,[]),r.get(x).push(a)),c.type===1?f.add(x):c.type===2?h.add(x):c.type===3||c.type===4?c.shape&&d.push({shape:c.shape,rotatable:c.type===4,pos:a}):c.type===5||c.type===6?c.shape&&u.push({shape:c.shape,rotatable:c.type===6,pos:a}):c.type===8&&l.push({count:c.count||0,pos:a})}let p=[];if(f.size>1)for(let a of t)o.has(`${a.x},${a.y}`)||e.cells[a.y][a.x].type===1&&p.push(a);for(let a of h)if(i.get(a)!==2){let c=r.get(a)||[];for(let x of c)e.cells[x.y][x.x].type===2&&p.push(x)}for(let a of l){let c=0,x=[this.getEdgeKey({x:a.pos.x,y:a.pos.y},{x:a.pos.x+1,y:a.pos.y}),this.getEdgeKey({x:a.pos.x,y:a.pos.y+1},{x:a.pos.x+1,y:a.pos.y+1}),this.getEdgeKey({x:a.pos.x,y:a.pos.y},{x:a.pos.x,y:a.pos.y+1}),this.getEdgeKey({x:a.pos.x+1,y:a.pos.y},{x:a.pos.x+1,y:a.pos.y+1})];for(let P of x)n.has(P)&&c++;c!==a.count&&p.push(a.pos)}if((d.length>0||u.length>0)&&!this.checkTetrisConstraint(e,t,d.map(a=>({shape:a.shape,rotatable:a.rotatable})),u.map(a=>({shape:a.shape,rotatable:a.rotatable})))){for(let a of d)p.push(a.pos);for(let a of u)p.push(a.pos)}return p}findGlobalAssignment(e,t,s){let n=e.length,o=new Array(t).fill(0),i=new Array(s).fill(0),r=[],h=[],f=[],d=u=>{if(u===n)return o.every(l=>l===1)&&i.every(l=>l===1);for(let l of e[u]){let p=!0;for(let a of l.invalidatedHexagons)if(o[a]>0){p=!1;break}if(p){for(let a of l.invalidatedNodeHexagons)if(i[a]>0){p=!1;break}}if(p){for(let a of l.invalidatedHexagons)o[a]++,h.push(a);for(let a of l.invalidatedNodeHexagons)i[a]++,f.push(a);if(r.push(...l.invalidatedCells),d(u+1))return!0;for(let a of l.invalidatedHexagons)o[a]--,h.pop();for(let a of l.invalidatedNodeHexagons)i[a]--,f.pop();for(let a=0;a<l.invalidatedCells.length;a++)r.pop()}}return!1};return d(0)?{invalidatedCells:r,invalidatedHexIndices:h,invalidatedNodeHexIndices:f}:null}checkTetrisConstraint(e,t,s,n=[]){let o=s.reduce((v,w)=>v+this.getShapeArea(w.shape),0),i=n.reduce((v,w)=>v+this.getShapeArea(w.shape),0),r=o-i;if(r<0||r!==0&&r!==t.length)return!1;let h=e.rows,f=e.cols;this.tetrisCache.size>1e4&&this.tetrisCache.clear();let d=new Uint8Array(h*f);for(let v of t)d[v.y*f+v.x]=1;let u=(v,w)=>`${this.getShapeKey(v.shape)}-${v.rotatable}-${w}`,l=[...s.map(v=>u(v,1)),...n.map(v=>u(v,-1))].sort().join("|"),p=`${h}x${f}:${d.join("")}:${l}`;if(this.tetrisCache.has(p))return this.tetrisCache.get(p);let a=new Int8Array(h*f);if(r>0)for(let v=0;v<d.length;v++)a[v]=d[v];let c=new Int8Array(h*f),x=[],P=[...s.map(v=>({...v,sign:1})),...n.map(v=>({...v,sign:-1}))];for(let v of P){let w=v.rotatable?this.getAllRotations(v.shape):[v.shape],k=this.getShapeKey(w[0]),E=x.find(T=>T.sign===v.sign&&(v.rotatable?T.rotations.length>1:T.rotations.length===1)&&this.getShapeKey(T.rotations[0].shape)===k);E?E.count++:x.push({rotations:w.map(T=>({shape:T,h:T.length,w:T[0].length})),sign:v.sign,area:this.getShapeArea(v.shape),count:1})}x.sort((v,w)=>w.sign-v.sign||w.area-v.area);let b=r>0?t.length:0,y=0,m=o,g=i,S=(v,w,k)=>{if(b>m||y>g)return!1;if(v===x.length)return b===0&&y===0;let E=x[v],T=w+1,z=T===E.count;E.sign===1?m-=E.area:g-=E.area;for(let I of E.rotations){let V=I.h,$=I.w,W=w===0?0:k;for(let D=W;D<=h*f-(V>0?(V-1)*f+$:0);D++){let K=Math.floor(D/f),G=D%f;if(K>h-V||G>f-$)continue;let R=!0,M=[];for(let H=0;H<V;H++){for(let Z=0;Z<$;Z++)if(I.shape[H][Z]){let F=(K+H)*f+(G+Z);E.sign===1?c[F]<a[F]?b--:y++:c[F]<=a[F]?b++:y--,c[F]+=E.sign,M.push(F),c[F]<0&&(R=!1),E.sign===1&&c[F]>1+i&&(R=!1)}if(!R)break}if(R){if(z){if(S(v+1,0,0)){for(let H of M)c[H]-=E.sign,E.sign===1?c[H]<a[H]?b++:y--:c[H]<=a[H]?b--:y++;return E.sign===1?m+=E.area:g+=E.area,!0}}else if(S(v,T,D)){for(let H of M)c[H]-=E.sign,E.sign===1?c[H]<a[H]?b++:y--:c[H]<=a[H]?b--:y++;return E.sign===1?m+=E.area:g+=E.area,!0}}for(let H of M)c[H]-=E.sign,E.sign===1?c[H]<a[H]?b++:y--:c[H]<=a[H]?b--:y++}}return E.sign===1?m+=E.area:g+=E.area,!1},C=S(0,0,0);return this.tetrisCache.set(p,C),C}getShapeArea(e){let t=0;for(let s of e)for(let n of s)n&&t++;return t}getShapeKey(e){return JSON.stringify(e)}getAllRotations(e){let t=[],s=new Set,n=e;for(let o=0;o<4;o++){let i=this.getShapeKey(n);s.has(i)||(t.push(n),s.add(i)),n=this.rotate90(n)}return t}rotate90(e){let t=e.length,s=e[0].length,n=Array.from({length:s},()=>Array(t).fill(0));for(let o=0;o<t;o++)for(let i=0;i<s;i++)n[i][t-1-o]=e[o][i];return n}calculateRegions(e,t,s=[],n){let o=[],i=e.rows,r=e.cols,h=new Uint8Array(i*r),f=new Uint8Array((i+1)*r),d=new Uint8Array(i*(r+1)),u=(p,a)=>{p.x===a.x?d[Math.min(p.y,a.y)*(r+1)+p.x]=1:f[p.y*r+Math.min(p.x,a.x)]=1};for(let p=0;p<t.length-1;p++)u(t[p],t[p+1]);for(let p=0;p<s.length-1;p++)u(s[p],s[p+1]);for(let p=0;p<=i;p++)for(let a=0;a<r;a++)e.hEdges[p][a].type===2&&(f[p*r+a]=1);for(let p=0;p<i;p++)for(let a=0;a<=r;a++)e.vEdges[p][a].type===2&&(d[p*(r+1)+a]=1);let l=n||this.getExternalCells(e);for(let p=0;p<i;p++)for(let a=0;a<r;a++){let c=p*r+a;if(h[c]||l&&l.has(`${a},${p}`))continue;let x=[],P=[c];h[c]=1;let b=0;for(;b<P.length;){let y=P[b++],m=y%r,g=Math.floor(y/r);if(x.push({x:m,y:g}),g>0&&!f[g*r+m]){let S=(g-1)*r+m;!h[S]&&(!l||!l.has(`${m},${g-1}`))&&(h[S]=1,P.push(S))}if(g<i-1&&!f[(g+1)*r+m]){let S=(g+1)*r+m;!h[S]&&(!l||!l.has(`${m},${g+1}`))&&(h[S]=1,P.push(S))}if(m>0&&!d[g*(r+1)+m]){let S=g*r+(m-1);!h[S]&&(!l||!l.has(`${m-1},${g}`))&&(h[S]=1,P.push(S))}if(m<r-1&&!d[g*(r+1)+(m+1)]){let S=g*r+(m+1);!h[S]&&(!l||!l.has(`${m+1},${g}`))&&(h[S]=1,P.push(S))}}o.push(x)}return o}getExternalCells(e){let t=new Set,s=[];for(let n=0;n<e.cols;n++)e.hEdges[0][n].type===2&&(t.has(`${n},0`)||(t.add(`${n},0`),s.push({x:n,y:0}))),e.hEdges[e.rows][n].type===2&&(t.has(`${n},${e.rows-1}`)||(t.add(`${n},${e.rows-1}`),s.push({x:n,y:e.rows-1})));for(let n=0;n<e.rows;n++)e.vEdges[n][0].type===2&&(t.has(`0,${n}`)||(t.add(`0,${n}`),s.push({x:0,y:n}))),e.vEdges[n][e.cols].type===2&&(t.has(`${e.cols-1},${n}`)||(t.add(`${e.cols-1},${n}`),s.push({x:e.cols-1,y:n})));for(;s.length>0;){let n=s.shift(),o=[{nx:n.x,ny:n.y-1,edge:e.hEdges[n.y][n.x]},{nx:n.x,ny:n.y+1,edge:e.hEdges[n.y+1][n.x]},{nx:n.x-1,ny:n.y,edge:e.vEdges[n.y][n.x]},{nx:n.x+1,ny:n.y,edge:e.vEdges[n.y][n.x+1]}];for(let i of o)i.nx>=0&&i.nx<e.cols&&i.ny>=0&&i.ny<e.rows&&!t.has(`${i.nx},${i.ny}`)&&i.edge.type===2&&(t.add(`${i.nx},${i.ny}`),s.push({x:i.nx,y:i.ny}))}return t}getSymmetricalPoint(e,t){let s=e.symmetry||0;return s===1?{x:e.cols-t.x,y:t.y}:s===2?{x:t.x,y:e.rows-t.y}:s===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getSymmetricalPointIndex(e,t){let s=e.cols+1,n=Math.floor(t/s),o=t%s,i=e.symmetry||0,r=n,h=o;return i===1?h=e.cols-o:i===2?r=e.rows-n:i===3&&(h=e.cols-o,r=e.rows-n),r*s+h}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}calculateDifficulty(e,t){let s=e.rows,n=e.cols,o=n+1,i=(s+1)*o,r=Array.from({length:i},()=>[]),h=[],f=[],d=Array(i).fill(!1),u=new Map,l=0,p=new Set,a=new Set;for(let R=0;R<=s;R++)for(let M=0;M<=n;M++){let H=R*o+M;if(e.nodes[R][M].type===1&&h.push(H),e.nodes[R][M].type===2&&(f.push(H),d[H]=!0),(e.nodes[R][M].type===3||e.nodes[R][M].type===4||e.nodes[R][M].type===5)&&(u.set(`n${M},${R}`,l++),a.add(H)),M<n){let Z=H+1,F=e.hEdges[R][M].type,q=F===3||F===4||F===5,Y=F===1||F===2;r[H].push({next:Z,hexType:F,isBroken:Y}),r[Z].push({next:H,hexType:F,isBroken:Y}),q&&(u.set(`eh${M},${R}`,l++),p.add(this.getEdgeKey({x:M,y:R},{x:M+1,y:R})))}if(R<s){let Z=H+o,F=e.vEdges[R][M].type,q=F===3||F===4||F===5,Y=F===1||F===2;r[H].push({next:Z,hexType:F,isBroken:Y}),r[Z].push({next:H,hexType:F,isBroken:Y}),q&&(u.set(`ev${M},${R}`,l++),p.add(this.getEdgeKey({x:M,y:R},{x:M,y:R+1})))}}let c={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},x=l,P=new Set,b=Math.max(1e3,s*n*200),y=this.getExternalCells(e),m=!1;for(let R=0;R<s;R++){for(let M=0;M<n;M++)if(e.cells[R][M].type!==0){m=!0;break}if(m)break}this.tetrisCache.clear(),this.reachabilityCache.clear();let g=t?t.map(R=>R.y*o+R.x):h;for(let R of g){let M=e.cols+1,H=Math.floor(R/M),Z=R%M,F=0n,q=e.nodes[H][Z].type;(q===3||q===4)&&(F|=1n<<BigInt(u.get(`n${Z},${H}`)));let Y=e.symmetry||0;if(Y!==0){let L=this.getSymmetricalPointIndex(e,R),O=Math.floor(L/M),J=L%M,N=e.nodes[O][J].type;(N===3||N===5)&&(F|=1n<<BigInt(u.get(`n${J},${O}`)))}let Q=1n<<BigInt(R);if(Y!==0){let L=this.getSymmetricalPointIndex(e,R);if(L===R)continue;Q|=1n<<BigInt(L)}this.exploreSearchSpace(e,R,Q,[R],F,x,r,f,d,P,c,b,y,m,u)}if(c.solutions===0)return 0;let S=p.size+a.size,C=new Set;p.size>0&&C.add(999);let v=0,w=0,k=0;for(let R=0;R<s;R++)for(let M=0;M<n;M++){let H=e.cells[R][M];H.type!==0&&(S++,C.add(H.type),H.type===3?v++:H.type===4?(v++,w++):H.type===8&&k++)}let E=c.branchingPoints/(c.totalNodesVisited||1),T=Math.log10(c.totalNodesVisited+1),z=(E*10+T*1.5)/(Math.log2(c.solutions+1)*.5+1);z-=p.size*.05,z+=a.size*.12,v>0&&(z+=(v-w)*.5,z+=w*.2);let I=0,V=0;for(let R=0;R<s;R++)for(let M=0;M<n;M++){let H=e.cells[R][M];H.type===5?I++:H.type===6&&(I++,V++)}I>0&&(z+=(I-V)*.6,z+=V*.3),k>0&&(z+=k*.25);let $=s*n,W=S/$,D=W<.25?Math.pow(W/.25,4):1,K=C.size<=1?.5:1;z*=D*K;let G=Math.log2($)/5;return z*=G,Math.max(.01,Math.min(1,z/4))}exploreSearchSpace(e,t,s,n,o,i,r,h,f,d,u,l,p,a=!0,c){if(u.totalNodesVisited++,u.maxDepth=Math.max(u.maxDepth,n.length),u.totalNodesVisited>l)return;let x=e.symmetry||0;if(f[t]){let y=0,m=o;for(;m>0n;)m&1n&&y++,m>>=1n;if(y===i){let g=n.map(v=>({x:v%(e.cols+1),y:Math.floor(v/(e.cols+1))})),S={points:g};if(x!==0){let v=this.getSymmetricalPointIndex(e,t),w=e.cols+1;if(e.nodes[Math.floor(v/w)][v%w].type!==2)return}let C=x!==0?g.map(v=>this.getSymmetricalPoint(e,v)):[];if(a){let v=this.validateFast(e,g,C,p);if(v.isValid){let w=this.getFingerprint(e,g,C,v.regions,p);d.has(w)||(d.add(w),u.solutions++)}}else{let v=this.getFingerprint(e,g,C,void 0,p);d.has(v)||(d.add(v),u.solutions++)}}return}if(!this.canReachEndOptimized(t,s,r,f)){u.backtracks++;return}let P=[];for(let y of r[t]){if(y.isBroken||s&1n<<BigInt(y.next))continue;if(x!==0){let g=this.getSymmetricalPointIndex(e,t),S=this.getSymmetricalPointIndex(e,y.next);if(y.next===S||t===S&&y.next===g)continue}let m=!0;for(let g of r[t])if(g.hexType===3||g.hexType===4){let C=n.length>=2&&g.next===n[n.length-2],v=g.next===y.next;if(!C&&!v){m=!1;break}}if(m){if(x!==0){let g=this.getSymmetricalPointIndex(e,t),S=this.getSymmetricalPointIndex(e,y.next);for(let C of r[g])if(C.hexType===3||C.hexType===5){let w=n.length>=2?this.getSymmetricalPointIndex(e,n[n.length-2]):-1,k=C.next===w,E=C.next===S;if(!k&&!E){m=!1;break}}}m&&P.push(y)}}if(P.length>1&&u.branchingPoints++,e.rows*e.cols>30)for(let y=P.length-1;y>0;y--){let m=this.rng?this.rng.next():Math.random(),g=Math.floor(m*(y+1));[P[y],P[g]]=[P[g],P[y]]}let b=e.cols+1;for(let y of P){let m=o,g=Math.floor(y.next/b),S=y.next%b,C=e.nodes[g][S].type;(C===3||C===4)&&(m|=1n<<BigInt(c.get(`n${S},${g}`)));let v=n[n.length-1],w=Math.floor(v/b),k=v%b;if(w===g){let T=Math.min(k,S);(y.hexType===3||y.hexType===4)&&(m|=1n<<BigInt(c.get(`eh${T},${g}`)))}else{let T=Math.min(w,g);(y.hexType===3||y.hexType===4)&&(m|=1n<<BigInt(c.get(`ev${S},${T}`)))}if(x!==0){let T=this.getSymmetricalPointIndex(e,y.next),z=Math.floor(T/b),I=T%b,V=e.nodes[z][I].type;(V===3||V===5)&&(m|=1n<<BigInt(c.get(`n${I},${z}`)));let $=this.getSymmetricalPointIndex(e,v),W=Math.floor($/b),D=$%b;if(W===z){let K=Math.min(D,I),G=e.hEdges[z][K].type;(G===3||G===5)&&(m|=1n<<BigInt(c.get(`eh${K},${z}`)))}else{let K=Math.min(W,z),G=e.vEdges[K][I].type;(G===3||G===5)&&(m|=1n<<BigInt(c.get(`ev${I},${K}`)))}}n.push(y.next);let E=s|1n<<BigInt(y.next);if(x!==0){let T=this.getSymmetricalPointIndex(e,y.next);E|=1n<<BigInt(T)}if(this.exploreSearchSpace(e,y.next,E,n,m,i,r,h,f,d,u,l,p,a,c),n.pop(),u.totalNodesVisited>l)return}}countSolutions(e,t=100,s){let n=e.rows,o=e.cols,i=o+1,r=(n+1)*i,h=Array.from({length:r},()=>[]),f=[],d=[],u=Array(r).fill(!1),l=new Map,p=0;for(let y=0;y<=n;y++)for(let m=0;m<=o;m++){let g=y*i+m;if(e.nodes[y][m].type===1&&f.push(g),e.nodes[y][m].type===2&&(d.push(g),u[g]=!0),(e.nodes[y][m].type===3||e.nodes[y][m].type===4||e.nodes[y][m].type===5)&&l.set(`n${m},${y}`,p++),m<o){let S=g+1,C=e.hEdges[y][m].type,v=C===3||C===4||C===5,w=C===1||C===2;h[g].push({next:S,hexType:C,isBroken:w}),h[S].push({next:g,hexType:C,isBroken:w}),v&&l.set(`eh${m},${y}`,p++)}if(y<n){let S=g+i,C=e.vEdges[y][m].type,v=C===3||C===4||C===5,w=C===1||C===2;h[g].push({next:S,hexType:C,isBroken:w}),h[S].push({next:g,hexType:C,isBroken:w}),v&&l.set(`ev${m},${y}`,p++)}}let a=new Set,c=p,x=this.getExternalCells(e),P=!1;for(let y=0;y<n;y++){for(let m=0;m<o;m++)if(e.cells[y][m].type!==0){P=!0;break}if(P)break}this.tetrisCache.clear(),this.reachabilityCache.clear();let b=s?s.map(y=>y.y*i+y.x):f;for(let y of b){let m=e.cols+1,g=Math.floor(y/m),S=y%m,C=0n,v=e.nodes[g][S].type;(v===3||v===4)&&(C|=1n<<BigInt(l.get(`n${S},${g}`)));let w=e.symmetry||0;if(w!==0){let E=this.getSymmetricalPointIndex(e,y),T=Math.floor(E/m),z=E%m,I=e.nodes[T][z].type;(I===3||I===5)&&(C|=1n<<BigInt(l.get(`n${z},${T}`)))}let k=1n<<BigInt(y);if(w!==0){let E=this.getSymmetricalPointIndex(e,y);if(E===y)continue;k|=1n<<BigInt(E)}this.findPathsOptimized(e,y,k,[y],C,c,h,d,u,a,t,x,P,l)}return a.size}findPathsOptimized(e,t,s,n,o,i,r,h,f,d,u,l,p=!0,a){if(d.size>=u)return;let c=e.symmetry||0;if(f[t]){let x=0,P=o;for(;P>0n;)P&1n&&x++,P>>=1n;if(x===i){let b=n.map(m=>({x:m%(e.cols+1),y:Math.floor(m/(e.cols+1))}));if(c!==0){let m=this.getSymmetricalPointIndex(e,t),g=e.cols+1;if(e.nodes[Math.floor(m/g)][m%g].type!==2)return}let y=c!==0?b.map(m=>this.getSymmetricalPoint(e,m)):[];if(!p)d.add(this.getFingerprint(e,b,y,void 0,l));else{let m=this.validateFast(e,b,y,l);m.isValid&&d.add(this.getFingerprint(e,b,y,m.regions,l))}}return}if(this.canReachEndOptimized(t,s,r,f))for(let x of r[t]){if(x.isBroken||s&1n<<BigInt(x.next))continue;if(c!==0){let k=this.getSymmetricalPointIndex(e,t),E=this.getSymmetricalPointIndex(e,x.next);if(x.next===E||t===E&&x.next===k)continue}let P=!0;for(let k of r[t])if(k.hexType===3||k.hexType===4){let T=n.length>=2&&k.next===n[n.length-2],z=k.next===x.next;if(!T&&!z){P=!1;break}}if(!P)continue;if(c!==0){let k=this.getSymmetricalPointIndex(e,t),E=this.getSymmetricalPointIndex(e,x.next);for(let T of r[k])if(T.hexType===3||T.hexType===5){let I=n.length>=2?this.getSymmetricalPointIndex(e,n[n.length-2]):-1,V=T.next===I,$=T.next===E;if(!V&&!$){P=!1;break}}}if(!P)continue;let b=e.cols+1,y=o,m=Math.floor(x.next/b),g=x.next%b,S=e.nodes[m][g].type;(S===3||S===4)&&(y|=1n<<BigInt(a.get(`n${g},${m}`)));let C=Math.floor(t/b),v=t%b;if(C===m){let k=Math.min(v,g);(x.hexType===3||x.hexType===4)&&(y|=1n<<BigInt(a.get(`eh${k},${m}`)))}else{let k=Math.min(C,m);(x.hexType===3||x.hexType===4)&&(y|=1n<<BigInt(a.get(`ev${g},${k}`)))}if(c!==0){let k=this.getSymmetricalPointIndex(e,x.next),E=Math.floor(k/b),T=k%b,z=e.nodes[E][T].type;(z===3||z===5)&&(y|=1n<<BigInt(a.get(`n${T},${E}`)));let I=this.getSymmetricalPointIndex(e,t),V=Math.floor(I/b),$=I%b;if(V===E){let W=Math.min($,T),D=e.hEdges[E][W].type;(D===3||D===5)&&(y|=1n<<BigInt(a.get(`eh${W},${E}`)))}else{let W=Math.min(V,E),D=e.vEdges[W][T].type;(D===3||D===5)&&(y|=1n<<BigInt(a.get(`ev${T},${W}`)))}}n.push(x.next);let w=s|1n<<BigInt(x.next);if(c!==0){let k=this.getSymmetricalPointIndex(e,x.next);w|=1n<<BigInt(k)}if(this.findPathsOptimized(e,x.next,w,n,y,i,r,h,f,d,u,l,p,a),n.pop(),d.size>=u)return}}canReachEndOptimized(e,t,s,n){let o=`${e}:${t.toString()}`,i=this.reachabilityCache.get(o);if(i!==void 0)return i;let r=[e],h=t,f=0;for(;f<r.length;){let d=r[f++];if(n[d])return this.reachabilityCache.set(o,!0),!0;for(let u of s[d])!u.isBroken&&!(h&1n<<BigInt(u.next))&&(h|=1n<<BigInt(u.next),r.push(u.next))}return this.reachabilityCache.set(o,!1),!1}getFingerprint(e,t,s,n,o){let r=(n||this.calculateRegions(e,t,s,o)).map(f=>{let d="",u=[];for(let l of f){let p=e.cells[l.y][l.x];p.type!==0&&u.push(p.type<<8|p.color)}u.sort((l,p)=>l-p);for(let l of u)d+=l.toString(36)+",";return d}).sort(),h="";for(let f of r)f.length>0&&(h+=f+"|");return h||"empty"}};var ue=class{isWorker;TETRIS_SHAPES_WITH_ROTATIONS=[];rng=null;constructor(){this.isWorker=typeof self<"u"&&"postMessage"in self&&!("document"in self);for(let e of this.TETRIS_SHAPES)this.TETRIS_SHAPES_WITH_ROTATIONS.push(this.getAllRotations(e))}stringToSeed(e){try{if(/^[0-9a-fA-F]+$/.test(e))return BigInt("0x"+e)}catch{}let t=0n;for(let s=0;s<e.length;s++)t=(t<<5n)-t+BigInt(e.charCodeAt(s));return t}generate(e,t,s={}){let n=s.rngType??0,o=s.seed;o||(o=Math.floor(Math.random()*4294967295).toString(16));let i=o,r=this.stringToSeed(o),h=s.difficulty??.5,f=new le,d=null,u=-1,l=e*t<=16,p=this.isWorker?e*t>30?120:l?250:150:e*t>30?80:l?200:100,a=this.isWorker?8:l?12:6,c=s.symmetry||0,x=s.starts?[...s.starts]:[{x:0,y:e}];if(c!==0){let g=[];for(let S of x){let C=this.getSymmetricalPoint({rows:e,cols:t},S,c);x.some(v=>v.x===C.x&&v.y===C.y)||g.push(C)}x.push(...g)}let P=s.ends?[...s.ends]:[];if(P.length===0&&(c===1?P=[{x:0,y:0}]:c===2?P=[{x:t,y:e}]:c===3?P=[{x:t,y:e}]:P=[{x:t,y:0}]),c!==0){let g=[];for(let S of P){let C=this.getSymmetricalPoint({rows:e,cols:t},S,c);P.some(v=>v.x===C.x&&v.y===C.y)||g.push(C)}P.push(...g)}let b=null,y=null,m=null;for(let g=0;g<p;g++){let S=(r^0x5deece66dn)+0xbn;if(this.rng=me(n,r^0x5deece66dn),f.setRng(this.rng),g%a===0){b=this.generateRandomPath(new ie(e,t),x,P,s.pathLength,c);let I=new ie(e,t),V=c!==0?b.map($=>this.getSymmetricalPoint(I,$,c)):[];y=this.calculateRegions(I,b,V),m=y.map($=>this.getRegionBoundaryEdges(I,$,b,V))}let C=this.generateFromPath(e,t,b,s,x,P,y,m);if(!f.validate(C,{points:b}).isValid){r=S;continue}let w=b[0],k=[w];if(c!==0){let I=this.getSymmetricalPoint(C,w,c);(I.x!==w.x||I.y!==w.y)&&k.push(I)}let E=x.filter(I=>!k.some(V=>V.x===I.x&&V.y===I.y));if(E.length>0&&f.countSolutions(C,10,E)>2){r=S;continue}if(!this.checkAllRequestedConstraintsPresent(C,s)){r=S;continue}let T=f.calculateDifficulty(C);if(T===0){r=S;continue}let z=Math.abs(T-h);if((d===null||z<Math.abs(u-h))&&(u=T,d=C,d.seed=i),h>.8&&T>.8){d.seed=i;break}if(z<.01){d.seed=i;break}r=S}if(!d){for(let C=0;C<50;C++){this.rng=me(n,r),f.setRng(this.rng);let v=this.generateRandomPath(new ie(e,t),x,P,s.pathLength,c),w=this.generateFromPath(e,t,v,s,x,P);if(f.validate(w,{points:v}).isValid)return w.seed=i,w;r=(r^0x5deece66dn)+0xbn}this.rng=me(n,r),f.setRng(this.rng);let g=this.generateRandomPath(new ie(e,t),x,P,s.pathLength,c),S=this.generateFromPath(e,t,g,s,x,P);return S.seed=i,S}return d}generateFromPath(e,t,s,n,o,i,r,h){let f=new ie(e,t),d=n.symmetry||0;f.symmetry=d;for(let l of o)f.nodes[l.y][l.x].type=1;for(let l of i)f.nodes[l.y][l.x].type=2;let u=d!==0?s.map(l=>this.getSymmetricalPoint(f,l,d)):[];return this.applyConstraintsBasedOnPath(f,s,n,u,r,h),n.useBrokenEdges&&this.applyBrokenEdges(f,s,n),this.cleanGrid(f),f}generateRandomPath(e,t,s,n,o=0){if(n===void 0)return this.generateSingleRandomPath(e,t,s,void 0,o);let i=e.rows+e.cols,r=(e.rows+1)*(e.cols+1)-1,h=i+n*(r-i),f=[],d=1/0,u=e.rows*e.cols>30?30:50;for(let l=0;l<u;l++){let p=this.generateSingleRandomPath(e,t,s,n,o);if(p.length===0)continue;let a=p.length-1,c=Math.abs(a-h);if(c<d&&(d=c,f=p),d<=2)break}return f}generateSingleRandomPath(e,t,s,n,o=0){let i=(e.rows+1)*(e.cols+1),r=new Array(i).fill(!1),h=[],f=0,d=e.rows*e.cols*200,u=t[Math.floor(this.rng.next()*t.length)],l=new Array(i).fill(!1);for(let a of s)l[this.toPointIndex(e,a.x,a.y)]=!0;let p=a=>{if(f++,f>d)return!1;let c=this.toPointIndex(e,a.x,a.y);r[c]=!0;let x=this.getSymmetricalPoint(e,a,o),P=this.toPointIndex(e,x.x,x.y);if(r[P]=!0,h.push(a),l[c])if(o!==0){if(l[P])return!0}else return!0;let b=this.getValidNeighbors(e,a,r);o!==0&&(b=b.filter(y=>{let m=this.getSymmetricalPoint(e,y,o);if(m.x<0||m.x>e.cols||m.y<0||m.y>e.rows||r[this.toPointIndex(e,m.x,m.y)]||y.x===m.x&&y.y===m.y)return!1;let g=this.getEdgeKey(a,y),S=this.getEdgeKey(x,m);return g!==S})),n!==void 0?b.sort((y,m)=>{let g=w=>Math.min(...s.map(k=>Math.abs(w.x-k.x)+Math.abs(w.y-k.y))),S=g(y),C=g(m);return(S-C)*(1-n*2)+(this.rng.next()-.5)*1.5}):this.shuffleArray(b);for(let y of b)if(p(y))return!0;return h.pop(),r[c]=!1,r[P]=!1,!1};return p(u),h}toPointIndex(e,t,s){return s*(e.cols+1)+t}getValidNeighbors(e,t,s){let n=[],o=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let i of o){let r=t.x+i.x,h=t.y+i.y;r>=0&&r<=e.cols&&h>=0&&h<=e.rows&&(!s||!s[this.toPointIndex(e,r,h)])&&n.push({x:r,y:h})}return n}applyBrokenEdges(e,t,s){let n=s.complexity??.5,o=s.symmetry??0,i=new Set;for(let u=0;u<t.length-1;u++)if(i.add(this.getEdgeKey(t[u],t[u+1])),o!==0){let l=this.getSymmetricalPoint(e,t[u],o),p=this.getSymmetricalPoint(e,t[u+1],o);i.add(this.getEdgeKey(l,p))}let r=[];for(let u=0;u<=e.rows;u++)for(let l=0;l<e.cols;l++){let p={x:l,y:u},a={x:l+1,y:u};i.has(this.getEdgeKey(p,a))||r.push({type:"h",r:u,c:l,p1:p,p2:a})}for(let u=0;u<e.rows;u++)for(let l=0;l<=e.cols;l++){let p={x:l,y:u},a={x:l,y:u+1};i.has(this.getEdgeKey(p,a))||r.push({type:"v",r:u,c:l,p1:p,p2:a})}this.shuffleArray(r);let h=Math.max(1,Math.floor(n*(e.rows*e.cols)/4)),f=0;for(let u of r){if(f>=h)break;u.type==="h"?e.hEdges[u.r][u.c].type=1:e.vEdges[u.r][u.c].type=1,f++}let d=!0;for(;d;){d=!1;for(let u=0;u<=e.rows;u++)for(let l=0;l<e.cols;l++)e.hEdges[u][l].type===1&&this.canBecomeAbsent(e,{type:"h",r:u,c:l})&&(e.hEdges[u][l].type=2,d=!0);for(let u=0;u<e.rows;u++)for(let l=0;l<=e.cols;l++)e.vEdges[u][l].type===1&&this.canBecomeAbsent(e,{type:"v",r:u,c:l})&&(e.vEdges[u][l].type=2,d=!0)}for(let u=0;u<=e.rows;u++)for(let l=0;l<=e.cols;l++){let p=[];if(l>0&&p.push({e:e.hEdges[u][l-1],type:"h",r:u,c:l-1}),l<e.cols&&p.push({e:e.hEdges[u][l],type:"h",r:u,c:l}),u>0&&p.push({e:e.vEdges[u-1][l],type:"v",r:u-1,c:l}),u<e.rows&&p.push({e:e.vEdges[u][l],type:"v",r:u,c:l}),p.length>0&&p.every(a=>a.e.type===1||a.e.type===2)&&p.every(a=>!this.isAdjacentToMark(e,a)))for(let a of p)a.e.type=2}}canBecomeAbsent(e,t){if(this.isAdjacentToMark(e,t))return!1;if(t.type==="h"){if(t.r===0||t.r===e.rows)return!0}else if(t.c===0||t.c===e.cols)return!0;let s=t.type==="h"?[{x:t.c,y:t.r},{x:t.c+1,y:t.r}]:[{x:t.c,y:t.r},{x:t.c,y:t.r+1}];for(let n of s){let o=[{type:"h",r:n.y,c:n.x-1},{type:"h",r:n.y,c:n.x},{type:"v",r:n.y-1,c:n.x},{type:"v",r:n.y,c:n.x}];for(let i of o)if(i.c>=0&&i.c<=e.cols&&i.r>=0&&i.r<=e.rows){if(i.type==="h"&&i.c<e.cols){if(e.hEdges[i.r][i.c].type===2)return!0}else if(i.type==="v"&&i.r<e.rows&&e.vEdges[i.r][i.c].type===2)return!0}}return!1}cleanGrid(e){let t=[];for(let i=0;i<=e.rows;i++)for(let r=0;r<=e.cols;r++)e.nodes[i][r].type===1&&t.push({x:r,y:i});let s=new Set,n=[...t];for(let i of t)s.add(`${i.x},${i.y}`);for(;n.length>0;){let i=n.shift(),r=[{nx:i.x,ny:i.y-1,edge:e.vEdges[i.y-1]?.[i.x]},{nx:i.x,ny:i.y+1,edge:e.vEdges[i.y]?.[i.x]},{nx:i.x-1,ny:i.y,edge:e.hEdges[i.y]?.[i.x-1]},{nx:i.x+1,ny:i.y,edge:e.hEdges[i.y]?.[i.x]}];for(let h of r)h.edge&&h.edge.type!==2&&(s.has(`${h.nx},${h.ny}`)||(s.add(`${h.nx},${h.ny}`),n.push({x:h.nx,y:h.ny})))}for(let i=0;i<=e.rows;i++)for(let r=0;r<e.cols;r++)(!s.has(`${r},${i}`)||!s.has(`${r+1},${i}`))&&(e.hEdges[i][r].type=2);for(let i=0;i<e.rows;i++)for(let r=0;r<=e.cols;r++)(!s.has(`${r},${i}`)||!s.has(`${r},${i+1}`))&&(e.vEdges[i][r].type=2);let o=this.getExternalCells(e);for(let i of o){let[r,h]=i.split(",").map(Number);e.cells[h][r].type=0}}getExternalCells(e){let t=new Set,s=[];for(let n=0;n<e.cols;n++)e.hEdges[0][n].type===2&&(t.has(`${n},0`)||(t.add(`${n},0`),s.push({x:n,y:0}))),e.hEdges[e.rows][n].type===2&&(t.has(`${n},${e.rows-1}`)||(t.add(`${n},${e.rows-1}`),s.push({x:n,y:e.rows-1})));for(let n=0;n<e.rows;n++)e.vEdges[n][0].type===2&&(t.has(`0,${n}`)||(t.add(`0,${n}`),s.push({x:0,y:n}))),e.vEdges[n][e.cols].type===2&&(t.has(`${e.cols-1},${n}`)||(t.add(`${e.cols-1},${n}`),s.push({x:e.cols-1,y:n})));for(;s.length>0;){let n=s.shift(),o=[{nx:n.x,ny:n.y-1,edge:e.hEdges[n.y][n.x]},{nx:n.x,ny:n.y+1,edge:e.hEdges[n.y+1][n.x]},{nx:n.x-1,ny:n.y,edge:e.vEdges[n.y][n.x]},{nx:n.x+1,ny:n.y,edge:e.vEdges[n.y][n.x+1]}];for(let i of o)i.nx>=0&&i.nx<e.cols&&i.ny>=0&&i.ny<e.rows&&!t.has(`${i.nx},${i.ny}`)&&i.edge.type===2&&(t.add(`${i.nx},${i.ny}`),s.push({x:i.nx,y:i.ny}))}return t}isAdjacentToMark(e,t){if(t.type==="h"){if(t.r>0&&e.cells[t.r-1][t.c].type!==0||t.r<e.rows&&e.cells[t.r][t.c].type!==0)return!0}else if(t.c>0&&e.cells[t.r][t.c-1].type!==0||t.c<e.cols&&e.cells[t.r][t.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let t=0;t<e.rows;t++)for(let s=0;s<e.cols;s++){if(e.cells[t][s].type===0)continue;if([e.hEdges[t][s],e.hEdges[t+1][s],e.vEdges[t][s],e.vEdges[t][s+1]].every(o=>o.type===1||o.type===2))return!0}return!1}getSymmetricalPoint(e,t,s){return s===1?{x:e.cols-t.x,y:t.y}:s===2?{x:t.x,y:e.rows-t.y}:s===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,t,s,n=[],o,i){let r=s.complexity??.5,h=s.useHexagons??!0,f=s.useSquares??!0,d=s.useStars??!0,u=s.useTetris??!1,l=s.useTetrisNegative??!1,p=s.useEraser??!1,a=s.useTriangles??!1,c=0,x=0,P=0,b=0,y=0,m=0,g=Math.floor(e.rows*e.cols*.6);if(h){let S=s.difficulty??.5,C=s.symmetry||0;for(let v=0;v<t.length-1;v++){let k=this.getValidNeighbors(e,t[v]).length>2,E=r*(S<.4?.6:.3);if(k&&(E=S<.4?E*1:E*.5),this.rng.next()<E){let T=3,z=t[v],I=t[v+1];if(C!==0){let V=this.rng.next();V<.3?T=4:V<.6&&(T=5,z=this.getSymmetricalPoint(e,t[v],C),I=this.getSymmetricalPoint(e,t[v+1],C))}this.setEdgeHexagon(e,z,I,T),c++}}for(let v=0;v<t.length;v++){let w=t[v];if(e.nodes[w.y][w.x].type!==0||this.hasIncidentHexagonEdge(e,w))continue;let k=r*(S>.6?.15:.05);if(this.rng.next()<k){let E=3,T=w;if(C!==0){let z=this.rng.next();z<.3?E=4:z<.6&&(E=5,T=this.getSymmetricalPoint(e,w,C))}e.nodes[T.y][T.x].type=E,c++}}if(c===0&&t.length>=2){let v=Math.floor(this.rng.next()*(t.length-1)),w=s.symmetry||0,k=3,E=t[v],T=t[v+1];if(w!==0){let z=this.rng.next();z<.3?k=4:z<.6&&(k=5,E=this.getSymmetricalPoint(e,t[v],w),T=this.getSymmetricalPoint(e,t[v+1],w))}this.setEdgeHexagon(e,E,T,k)}}if(f||d||u||p||a){let S=o||this.calculateRegions(e,t,n),C=s.availableColors??[j.Black,j.White,j.Red,j.Blue],v=s.defaultColors??{},w=($,W)=>{if(v[$]!==void 0)return v[$];let D=ae[$];return D&&v[D]!==void 0?v[D]:$===4?w(3,W):$===6?w(5,W):W},k=Array.from({length:S.length},($,W)=>W);this.shuffleArray(k);let E=new Set,T={square:f,star:d,tetris:u,tetrisNegative:l,eraser:p,triangle:a},z=0,I=0,V=new Set;for(let $=0;$<t.length-1;$++)V.add(this.getEdgeKey(t[$],t[$+1]));for(let $=0;$<n.length-1;$++)V.add(this.getEdgeKey(n[$],n[$+1]));for(let $=0;$<k.length;$++){let W=k[$],D=S[W],K=k.length-$,G=T.square&&x===0||T.star&&P===0||T.tetris&&b===0||T.tetrisNegative&&z===0||T.eraser&&y===0||T.triangle&&I===0,R=.2+r*.6;if(G&&K<=3?R=1:G&&K<=6&&(R=.7),this.rng.next()>R)continue;let M=[...D];this.shuffleArray(M);let H=new Set,Z=C[Math.floor(this.rng.next()*C.length)];if(f&&E.size<2){let q=C.filter(Y=>!E.has(Y));q.length>0&&(Z=q[Math.floor(this.rng.next()*q.length)])}let F=f&&this.rng.next()<.5+r*.3;if(f&&x===0&&K<=2&&(F=!0),f&&!d&&K<=2&&E.size<2&&x>0&&(F=!0),F&&M.length>0){let q=Math.min(M.length,Math.max(4,Math.floor(D.length/4))),Y=Math.floor(this.rng.next()*(q/2))+Math.ceil(q/2);for(let Q=0;Q<Y&&M.length!==0;Q++){let L=M.pop();e.cells[L.y][L.x].type=1,e.cells[L.y][L.x].color=Z,x++,E.add(Z),H.add(Z)}}if(u||l){let q=this.rng.next()<.1+r*.4;b===0&&K<=3&&(q=!0),l&&z===0&&K<=2&&(q=!0);let Y=b===0&&K<=2?6:4,Q=m+D.length<=g||G&&u&&b===0&&D.length<=30||G&&l&&z===0&&D.length<=30;if(q&&M.length>0&&Q){let L=D.length<=25?this.generateTiling(D,Y,s):null;if(L){let O=[],J=.2+r*.3;if(l&&z===0&&K<=3&&(J=.9),l&&this.rng.next()<J){let A=s.difficulty??.5;if(this.rng.next()<.1&&M.length>=2){let U=!1;if(M.length>=3&&this.rng.next()<.8){let ee=this.rng.next()<.5,ne=1+Math.floor(this.rng.next()*2),se=this.TETRIS_SHAPES.filter(oe=>this.getShapeArea(oe)===ne),te=se[Math.floor(this.rng.next()*se.length)],X=this.findStandardTriple(te);X&&(ee?(L.push({shape:te,displayShape:te,isRotated:!this.isRotationallyInvariant(te)&&this.rng.next()<A*.7,isNegative:!1}),L.push({shape:X.n,displayShape:X.n,isRotated:!this.isRotationallyInvariant(X.n)&&this.rng.next()<A*.7,isNegative:!1}),O.push({shape:X.p,displayShape:X.p,isRotated:!this.isRotationallyInvariant(X.p)&&this.rng.next()<A*.7,isNegative:!0})):(L.push({shape:X.p,displayShape:X.p,isRotated:!this.isRotationallyInvariant(X.p)&&this.rng.next()<A*.7,isNegative:!1}),O.push({shape:te,displayShape:te,isRotated:!this.isRotationallyInvariant(te)&&this.rng.next()<A*.7,isNegative:!0}),O.push({shape:X.n,displayShape:X.n,isRotated:!this.isRotationallyInvariant(X.n)&&this.rng.next()<A*.7,isNegative:!0})),U=!0)}if(!U){let ee=3+Math.floor(this.rng.next()*2),ne=this.TETRIS_SHAPES.filter(se=>this.getShapeArea(se)===ee);if(this.shuffleArray(ne),ne.length>0){let se=ne[0],te=ne[0];L.push({shape:se,displayShape:se,isRotated:!this.isRotationallyInvariant(se)&&this.rng.next()<A*.7,isNegative:!1}),O.push({shape:te,displayShape:te,isRotated:!this.isRotationallyInvariant(te)&&this.rng.next()<A*.7,isNegative:!0})}}}else if(L.length>0){let U=this.rng.next()<.3?2:1;for(let ee=0;ee<U&&!(M.length<1);ee++){let ne=Math.floor(this.rng.next()*L.length),se=L[ne];if(se.isNegative)continue;let te=!1;if(M.length>=2&&this.rng.next()<.2){let X=this.findStandardTriple(se.shape);if(X){let oe=this.findStandardTriple(X.p);oe&&(L[ne]={shape:oe.p,displayShape:oe.p,isRotated:!this.isRotationallyInvariant(oe.p)&&this.rng.next()<A*.7,isNegative:!1},O.push({shape:X.n,displayShape:X.n,isRotated:!this.isRotationallyInvariant(X.n)&&this.rng.next()<A*.7,isNegative:!0}),O.push({shape:oe.n,displayShape:oe.n,isRotated:!this.isRotationallyInvariant(oe.n)&&this.rng.next()<A*.7,isNegative:!0}),te=!0)}}if(!te){let X=this.findStandardTriple(se.shape);X&&(L.some(ze=>!ze.isNegative&&this.isSameShape(ze.shape,X.n))||(L[ne]={shape:X.p,displayShape:X.p,isRotated:!this.isRotationallyInvariant(X.p)&&this.rng.next()<A*.7,isNegative:!1},O.push({shape:X.n,displayShape:X.n,isRotated:!this.isRotationallyInvariant(X.n)&&this.rng.next()<A*.7,isNegative:!0})))}}}}let N=[...L,...O];if(N.length>M.length)continue;for(let A of N){if(M.length===0)break;let _=M.pop();if(A.isNegative)e.cells[_.y][_.x].type=A.isRotated?6:5,e.cells[_.y][_.x].color=w(5,j.None),z++;else{e.cells[_.y][_.x].type=A.isRotated?4:3;let ee=w(3,j.None),ne=ee;if(d&&this.rng.next()<.3){let se=C.filter(te=>te!==ee&&!H.has(te));se.length>0&&(ne=se[Math.floor(this.rng.next()*se.length)],H.add(ne))}e.cells[_.y][_.x].color=ne}e.cells[_.y][_.x].shape=A.isRotated?A.displayShape:A.shape,b++}m+=D.length}}}if(a){let q=this.rng.next()<.2+r*.5;if(I===0&&K<=2&&(q=!0),q&&M.length>0){this.shuffleArray(M);let Y=Math.min(M.length,Math.max(1,Math.floor(D.length/3))),Q=0;for(let L=0;L<M.length&&Q<Y;L++){let O=M[L],J=[this.getEdgeKey({x:O.x,y:O.y},{x:O.x+1,y:O.y}),this.getEdgeKey({x:O.x,y:O.y+1},{x:O.x+1,y:O.y+1}),this.getEdgeKey({x:O.x,y:O.y},{x:O.x,y:O.y+1}),this.getEdgeKey({x:O.x+1,y:O.y},{x:O.x+1,y:O.y+1})],N=0;for(let A of J)V.has(A)&&N++;if(N>=1&&N<=3){e.cells[O.y][O.x].type=8,e.cells[O.y][O.x].count=N;let A=w(8,j.None),_=A;if(d&&this.rng.next()<.3){let U=C.filter(ee=>ee!==A&&!H.has(ee));U.length>0&&(_=U[Math.floor(this.rng.next()*U.length)],H.add(_))}e.cells[O.y][O.x].color=_,M.splice(L,1),L--,I++,Q++}}}}if(p&&y<1){let q=.05+r*.2,Y=this.rng.next()<q;if(K<=2&&(Y=!0),Y&&M.length>=1){let Q=[];d&&Q.push("star"),f&&Q.push("square");let L=[];h&&(L=i?i[W]:this.getRegionBoundaryEdges(e,D,t,n),L.length>0&&Q.push("hexagon")),u&&Q.push("tetris"),l&&Q.push("tetrisNegative"),a&&Q.push("triangle"),this.shuffleArray(Q),M.length>=2&&Q.push("eraser");let O=!1;for(let J of Q){if(O)break;if(J==="hexagon"){let N=L.filter(A=>!this.isEdgeAdjacentToHexagonNode(e,A));if(N.length>0){let A=N[Math.floor(this.rng.next()*N.length)];A.type==="h"?e.hEdges[A.r][A.c].type=3:e.vEdges[A.r][A.c].type=3,c++,O=!0}}else if(J==="square"&&M.length>=2){let N=M.pop();e.cells[N.y][N.x].type=1;let A=D.find(U=>e.cells[U.y][U.x].type===1),_=A?e.cells[A.y][A.x].color:void 0;e.cells[N.y][N.x].color=C.find(U=>U!==_)||j.Red,x++,O=!0}else if(J==="star"&&M.length>=2){let N=M.pop();e.cells[N.y][N.x].type=2,e.cells[N.y][N.x].color=C[Math.floor(this.rng.next()*C.length)],P++,O=!0}else if(J==="tetris"&&M.length>=2){let N=this.generateTiling(D,4,s),A=[];if(N&&N.length>0){let _=0;for(let U of N){let ee=this.getShapeArea(U.shape);if(_+ee<D.length)A.push(U),_+=ee;else break}}if(A.length===0&&D.length>1&&(A=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),A.length>0){for(let _ of A){if(M.length<2)break;let U=M.pop();e.cells[U.y][U.x].type=_.isRotated?4:3,e.cells[U.y][U.x].shape=_.isRotated?_.displayShape:_.shape,e.cells[U.y][U.x].color=w(e.cells[U.y][U.x].type,j.None),b++}O=!0}}else if(J==="tetrisNegative"&&this.canPlaceGeneratedTetrisNegative(e,D,M)){if(!this.hasRegionTetrisSymbol(e,D)){let A=M.pop();e.cells[A.y][A.x].type=3,e.cells[A.y][A.x].shape=[[1]],e.cells[A.y][A.x].color=w(3,j.None),b++}let N=M.pop();e.cells[N.y][N.x].type=5,e.cells[N.y][N.x].shape=[[1]],e.cells[N.y][N.x].color=w(5,j.None),z++}else if(J==="triangle"&&M.length>=2){let N=M.pop();e.cells[N.y][N.x].type=8;let A=[this.getEdgeKey({x:N.x,y:N.y},{x:N.x+1,y:N.y}),this.getEdgeKey({x:N.x,y:N.y+1},{x:N.x+1,y:N.y+1}),this.getEdgeKey({x:N.x,y:N.y},{x:N.x,y:N.y+1}),this.getEdgeKey({x:N.x+1,y:N.y},{x:N.x+1,y:N.y+1})],_=0;for(let ee of A)V.has(ee)&&_++;let U=(_+1)%4;U===0&&(U=1),e.cells[N.y][N.x].count=U,e.cells[N.y][N.x].color=w(8,j.None),I++,O=!0}else if(J==="eraser"&&this.canPlaceGeneratedEraser(e,D,M)){let N=M.pop();e.cells[N.y][N.x].type=7,e.cells[N.y][N.x].color=w(7,j.White),y++,O=!0}}if(O&&this.canPlaceGeneratedEraser(e,D,M)){let J=M.pop();e.cells[J.y][J.x].type=7;let N=w(7,j.White),A=N;if(d&&this.rng.next()<.3){let _=C.filter(U=>U!==N&&!H.has(U));_.length>0&&(A=_[Math.floor(this.rng.next()*_.length)],H.add(A))}e.cells[J.y][J.x].color=A,y++}}}if(d){for(let Y of C){if(M.length<1)break;if(D.filter(L=>e.cells[L.y][L.x].color===Y).length===1&&(Y!==j.White||H.has(Y))){let L=M.pop();e.cells[L.y][L.x].type=2,e.cells[L.y][L.x].color=Y,P++}}let q=Math.max(1,Math.floor(D.length/8));for(let Y=0;Y<q&&!(M.length<2);Y++)for(let Q of C){if(M.length<2)break;if(this.rng.next()>.3+r*.4)continue;if(D.filter(O=>e.cells[O.y][O.x].color===Q).length===0)for(let O=0;O<2;O++){let J=M.pop();e.cells[J.y][J.x].type=2,e.cells[J.y][J.x].color=Q,P++}}}}if(f&&E.size<2){let $=E.values().next().value;if(!($!==void 0&&P>0&&Array.from({length:e.rows*e.cols}).some((D,K)=>{let G=Math.floor(K/e.cols),R=K%e.cols;return e.cells[G][R].type===2&&e.cells[G][R].color===$}))){for(let D of S){if(E.size>=2)break;if(D.some(G=>e.cells[G.y][G.x].type===1))continue;let K=D.filter(G=>e.cells[G.y][G.x].type===0);if(K.length>0){let G=C.find(M=>!E.has(M))||j.White,R=K[Math.floor(this.rng.next()*K.length)];e.cells[R.y][R.x].type=1,e.cells[R.y][R.x].color=G,E.add(G),x++}}if(E.size<2&&d&&$!==void 0)for(let D of S){let K=D.filter(G=>e.cells[G.y][G.x].type===0);if(K.length>0){let G=K[Math.floor(this.rng.next()*K.length)];e.cells[G.y][G.x].type=2,e.cells[G.y][G.x].color=$,P++;break}}}}}}calculateRegions(e,t,s=[]){let n=[],o=e.rows,i=e.cols,r=new Uint8Array(o*i),h=new Uint8Array((o+1)*i),f=new Uint8Array(o*(i+1)),d=(u,l)=>{u.x===l.x?f[Math.min(u.y,l.y)*(i+1)+u.x]=1:h[u.y*i+Math.min(u.x,l.x)]=1};for(let u=0;u<t.length-1;u++)d(t[u],t[u+1]);for(let u=0;u<s.length-1;u++)d(s[u],s[u+1]);for(let u=0;u<=o;u++)for(let l=0;l<i;l++)e.hEdges[u][l].type===2&&(h[u*i+l]=1);for(let u=0;u<o;u++)for(let l=0;l<=i;l++)e.vEdges[u][l].type===2&&(f[u*(i+1)+l]=1);for(let u=0;u<o;u++)for(let l=0;l<i;l++){let p=u*i+l;if(r[p])continue;let a=[],c=[p];r[p]=1;let x=0;for(;x<c.length;){let P=c[x++],b=P%i,y=Math.floor(P/i);if(a.push({x:b,y}),y>0&&!h[y*i+b]){let m=(y-1)*i+b;r[m]||(r[m]=1,c.push(m))}if(y<o-1&&!h[(y+1)*i+b]){let m=(y+1)*i+b;r[m]||(r[m]=1,c.push(m))}if(b>0&&!f[y*(i+1)+b]){let m=y*i+(b-1);r[m]||(r[m]=1,c.push(m))}if(b<i-1&&!f[y*(i+1)+(b+1)]){let m=y*i+(b+1);r[m]||(r[m]=1,c.push(m))}}n.push(a)}return n}isAbsentEdge(e,t,s){if(t.x===s.x){let n=Math.min(t.y,s.y);return e.vEdges[n][t.x].type===2}else{let n=Math.min(t.x,s.x);return e.hEdges[t.y][n].type===2}}getRegionBoundaryEdges(e,t,s,n=[]){let o=new Set;for(let h=0;h<s.length-1;h++)o.add(this.getEdgeKey(s[h],s[h+1]));for(let h=0;h<n.length-1;h++)o.add(this.getEdgeKey(n[h],n[h+1]));let i=[];for(let h of t){let f=[{type:"h",r:h.y,c:h.x},{type:"h",r:h.y+1,c:h.x},{type:"v",r:h.y,c:h.x},{type:"v",r:h.y,c:h.x+1}];for(let d of f){let u=d.type==="h"?{x:d.c,y:d.r}:{x:d.c,y:d.r},l=d.type==="h"?{x:d.c+1,y:d.r}:{x:d.c,y:d.r+1},p=this.getEdgeKey(u,l);!o.has(p)&&!this.isAbsentEdge(e,u,l)&&i.push(d)}}let r=new Map;for(let h of i)r.set(`${h.type},${h.r},${h.c}`,h);return Array.from(r.values())}setEdgeHexagon(e,t,s,n=3){t.x===s.x?e.vEdges[Math.min(t.y,s.y)][t.x].type=n:e.hEdges[t.y][Math.min(t.x,s.x)].type=n}hasIncidentHexagonEdge(e,t){let s=n=>n===3||n===4||n===5;return!!(t.x>0&&s(e.hEdges[t.y][t.x-1].type)||t.x<e.cols&&s(e.hEdges[t.y][t.x].type)||t.y>0&&s(e.vEdges[t.y-1][t.x].type)||t.y<e.rows&&s(e.vEdges[t.y][t.x].type))}isEdgeAdjacentToHexagonNode(e,t){let s=n=>n===3||n===4||n===5;return t.type==="h"?s(e.nodes[t.r][t.c].type)||s(e.nodes[t.r][t.c+1].type):s(e.nodes[t.r][t.c].type)||s(e.nodes[t.r+1][t.c].type)}checkAllRequestedConstraintsPresent(e,t){let s=t.useHexagons??!0,n=t.useSquares??!0,o=t.useStars??!0,i=t.useTetris??!1,r=t.useTetrisNegative??!1,h=t.useEraser??!1,f=t.useTriangles??!1;if(t.useBrokenEdges??!1){let u=!1;for(let l=0;l<=e.rows;l++)for(let p=0;p<e.cols;p++)if(e.hEdges[l][p].type===1||e.hEdges[l][p].type===2){u=!0;break}if(!u){for(let l=0;l<e.rows;l++)for(let p=0;p<=e.cols;p++)if(e.vEdges[l][p].type===1||e.vEdges[l][p].type===2){u=!0;break}}if(!u)return!1}if(s){let u=!1,l=a=>a===3||a===4||a===5,p=a=>a===3||a===4||a===5;for(let a=0;a<=e.rows;a++)for(let c=0;c<e.cols;c++)if(l(e.hEdges[a][c].type)){u=!0;break}if(!u){for(let a=0;a<e.rows;a++)for(let c=0;c<=e.cols;c++)if(l(e.vEdges[a][c].type)){u=!0;break}}if(!u){for(let a=0;a<=e.rows;a++)for(let c=0;c<=e.cols;c++)if(p(e.nodes[a][c].type)){u=!0;break}}if(!u)return!1}if(n||o||i||h){let u=!1,l=!1,p=!1,a=!1,c=!1,x=!1,P=new Set,b=new Set;for(let y=0;y<e.rows;y++)for(let m=0;m<e.cols;m++){let g=e.cells[y][m].type;g===1&&(u=!0,P.add(e.cells[y][m].color)),g===2&&(l=!0,b.add(e.cells[y][m].color)),(g===3||g===4)&&(p=!0),(g===5||g===6)&&(a=!0),g===7&&(c=!0),g===8&&(x=!0)}if(n&&!u||o&&!l||i&&!p||r&&!a||h&&!c||f&&!x)return!1;if(n&&u&&P.size<2){let y=P.values().next().value;if(y===void 0||!b.has(y))return!1}}return!this.hasIsolatedMark(e)}generateTiling(e,t,s){let n=Math.min(...e.map(u=>u.x)),o=Math.min(...e.map(u=>u.y)),i=Math.max(...e.map(u=>u.x)),r=Math.max(...e.map(u=>u.y)),h=i-n+1,f=r-o+1,d=Array.from({length:f},()=>Array(h).fill(!1));for(let u of e)d[u.y-o][u.x-n]=!0;return this.tilingDfs(d,[],t,s)}tilingDfs(e,t,s,n){let o=-1,i=-1;for(let f=0;f<e.length;f++){for(let d=0;d<e[0].length;d++)if(e[f][d]){o=f,i=d;break}if(o!==-1)break}if(o===-1)return t;if(t.length>=s)return null;let r=n.difficulty??.5,h=Array.from({length:this.TETRIS_SHAPES.length},(f,d)=>d);this.shuffleArray(h),r>.6&&h.sort((f,d)=>this.getShapeArea(this.TETRIS_SHAPES[d])-this.getShapeArea(this.TETRIS_SHAPES[f]));for(let f of h){let d=this.TETRIS_SHAPES[f],u=this.TETRIS_SHAPES_WITH_ROTATIONS[f],l=Array.from({length:u.length},(p,a)=>a);this.shuffleArray(l);for(let p of l){let a=u[p],c=[];for(let x=0;x<a.length;x++)for(let P=0;P<a[0].length;P++)a[x][P]&&c.push({r:x,c:P});for(let x of c){let P=o-x.r,b=i-x.c;if(this.canPlace(e,a,P,b)){this.placePiece(e,a,P,b,!1);let y=u.length>1&&this.rng.next()<.3+r*.6,m=this.tilingDfs(e,[...t,{shape:a,displayShape:d,isRotated:y}],s,n);if(m)return m;this.placePiece(e,a,P,b,!0)}}}}return null}getShapeArea(e){let t=0;for(let s of e)for(let n of s)n&&t++;return t}isRotationallyInvariant(e){return this.getAllRotations(e).length===1}getAllRotations(e){let t=[],s=new Set,n=e;for(let o=0;o<4;o++){let i=JSON.stringify(n);s.has(i)||(t.push(n),s.add(i)),n=this.rotate90(n)}return t}rotate90(e){let t=e.length,s=e[0].length,n=Array.from({length:s},()=>Array(t).fill(0));for(let o=0;o<t;o++)for(let i=0;i<s;i++)n[i][t-1-o]=e[o][i];return n}canPlace(e,t,s,n){for(let o=0;o<t.length;o++)for(let i=0;i<t[0].length;i++)if(t[o][i]){let r=s+o,h=n+i;if(r<0||r>=e.length||h<0||h>=e[0].length||!e[r][h])return!1}return!0}placePiece(e,t,s,n,o){for(let i=0;i<t.length;i++)for(let r=0;r<t[0].length;r++)t[i][r]&&(e[s+i][n+r]=o)}isSameShape(e,t){let s=this.getAllRotations(e),n=JSON.stringify(t);return s.some(o=>JSON.stringify(o)===n)}countRegionNonEraserSymbols(e,t){let s=0;for(let n of t){let o=e.cells[n.y][n.x].type;o!==0&&o!==7&&s++}return s}hasRegionTetrisSymbol(e,t){for(let s of t){let n=e.cells[s.y][s.x].type;if(n===3||n===4)return!0}return!1}canPlaceGeneratedTetrisNegative(e,t,s){return s.length<1?!1:this.hasRegionTetrisSymbol(e,t)?!0:s.length>=2}canPlaceGeneratedEraser(e,t,s){return s.length<1?!1:this.countRegionNonEraserSymbols(e,t)>0?!0:s.length>=2}canTilePieceWith(e,t,s){let n=this.getShapeArea(e),o=this.getShapeArea(t),i=this.getShapeArea(s);if(n!==o+i)return!1;let r=this.getAllRotations(t),h=this.getAllRotations(s),f=e.length,d=e[0].length;for(let u of r)for(let l of h){let p=u.length,a=u[0].length,c=l.length,x=l[0].length;for(let P=0;P<=f-p;P++)for(let b=0;b<=d-a;b++)for(let y=0;y<=f-c;y++)for(let m=0;m<=d-x;m++){let g=Array.from({length:f},()=>Array(d).fill(0)),S=!0;for(let C=0;C<p;C++)for(let v=0;v<a;v++)u[C][v]&&(g[P+C][b+v]=1);for(let C=0;C<c;C++){for(let v=0;v<x;v++)if(l[C][v]){if(g[y+C][m+v]){S=!1;break}g[y+C][m+v]=1}if(!S)break}if(S){let C=!0;for(let v=0;v<f;v++){for(let w=0;w<d;w++)if(g[v][w]!==e[v][w]){C=!1;break}if(!C)break}if(C)return!0}}}return!1}findStandardTriple(e){let t=this.getShapeArea(e),s=[...this.TETRIS_SHAPES];this.shuffleArray(s);for(let n of s){let o=this.getShapeArea(n),i=t+o;if(i>5)continue;let r=this.TETRIS_SHAPES.filter(h=>this.getShapeArea(h)===i);for(let h of r)if(this.canTilePieceWith(h,e,n))return{p:h,n}}return null}shuffleArray(e){for(let t=e.length-1;t>0;t--){let s=Math.floor(this.rng.next()*(t+1));[e[t],e[s]]=[e[s],e[t]]}}};var de=class{canvas;ctx=null;worker=null;puzzle=null;options;listeners=new Map;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;isValidPath=!1;invalidatedCells=[];invalidatedEdges=[];invalidatedNodes=[];errorCells=[];errorEdges=[];errorNodes=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;filterCanvas=null;filterCtx=null;canvasRect=null;isDestroyed=!1;animationFrameId=null;timeoutId=null;boundMouseDown=null;boundMouseMove=null;boundMouseUp=null;boundTouchStart=null;boundTouchMove=null;boundTouchEnd=null;boundUpdateRect=null;isTwoClickDrawing=!1;activeStartNode=null;constructor(e,t,s={}){if(typeof e=="string"){if(typeof document>"u")throw new Error("Cannot look up canvas by ID in a non-browser environment.");let n=document.getElementById(e);if(!(n instanceof HTMLCanvasElement))throw new Error(`Element with id "${e}" is not a canvas.`);this.canvas=n}else this.canvas=e;if(this.options=this.mergeOptions(s),this.options.useWorker&&typeof window<"u"&&this.canvas instanceof HTMLCanvasElement&&this.canvas.transferControlToOffscreen){let n=this.options.workerScript??import.meta.url;if(n){this.worker=new Worker(n,{type:"module"});let o=this.canvas.transferControlToOffscreen(),i=this.sanitizeOptions(this.options);this.worker.postMessage({type:"init",payload:{canvas:o,options:i}},[o]),this.worker.addEventListener("message",r=>{let{type:h,payload:f}=r.data;if(h==="drawingStarted")this.isDrawing=f!==!1,this.isDrawing||(this.isTwoClickDrawing=!1,this.setTwoClickPointerUi(!1));else if(h==="drawingEnded")this.isDrawing=!1,this.isTwoClickDrawing=!1,this.setTwoClickPointerUi(!1);else if(h==="pathComplete"){let d=Array.isArray(f?.path)?f.path:f;this.emit("path:complete",{path:d,startNode:this.getStartNodeMetaFromPath(),endNode:this.getEndNodeMetaFromPath()})}else h==="puzzleCreated"?(f?.puzzle&&this.setPuzzle(f.puzzle),this.emit("puzzle:generated",f)):h==="validationResult"?this.emit("goal:validated",{result:f}):h==="uiEvent"&&this.emit(f.type,f.data)})}}if(!this.worker){let n=this.canvas.getContext("2d");if(!n)throw new Error("Could not get 2D context.");this.ctx=n,this.ctx.imageSmoothingEnabled=!1,this.animate()}t&&this.setPuzzle(t),this.initEvents()}mergeOptions(e){let t={blinkDuration:e.animations?.blinkDuration??this.options?.animations?.blinkDuration??1e3,fadeDuration:e.animations?.fadeDuration??this.options?.animations?.fadeDuration??1e3,blinkPeriod:e.animations?.blinkPeriod??this.options?.animations?.blinkPeriod??800},s={path:e.colors?.path??this.options?.colors?.path??"#ffcc00",error:e.colors?.error??this.options?.colors?.error??"#ff4444",success:e.colors?.success??this.options?.colors?.success??"#ffcc00",symmetry:e.colors?.symmetry??this.options?.colors?.symmetry??"rgba(255, 255, 255, 0.5)",interrupted:e.colors?.interrupted??this.options?.colors?.interrupted??"#ffcc00",grid:e.colors?.grid??this.options?.colors?.grid??"#555",node:e.colors?.node??this.options?.colors?.node??"#555",hexagon:e.colors?.hexagon??this.options?.colors?.hexagon??"#000",hexagonMain:e.colors?.hexagonMain??this.options?.colors?.hexagonMain??"#00ffff",hexagonSymmetry:e.colors?.hexagonSymmetry??this.options?.colors?.hexagonSymmetry??"#ffff00",colorMap:e.colors?.colorMap??this.options?.colors?.colorMap??{[j.Black]:"#000",[j.White]:"#fff",[j.Red]:"#f00",[j.Blue]:"#00f",[j.None]:"#ffcc00"},colorList:e.colors?.colorList??this.options?.colors?.colorList};return{inputMode:e.inputMode??this.options?.inputMode??"drag",gridPadding:e.gridPadding??this.options?.gridPadding??60,cellSize:e.cellSize??this.options?.cellSize??80,nodeRadius:e.nodeRadius??this.options?.nodeRadius??6,startNodeRadius:e.startNodeRadius??this.options?.startNodeRadius??22,pathWidth:e.pathWidth??this.options?.pathWidth??18,exitLength:e.exitLength??this.options?.exitLength??25,autoResize:e.autoResize??this.options?.autoResize??!0,blinkMarksOnError:e.blinkMarksOnError??this.options?.blinkMarksOnError??!0,stayPathOnError:e.stayPathOnError??this.options?.stayPathOnError??!0,autoValidate:e.autoValidate??this.options?.autoValidate??!1,useWorker:e.useWorker??this.options?.useWorker??!1,workerScript:e.workerScript??this.options?.workerScript,animations:t,colors:s,filter:{enabled:e.filter?.enabled??this.options?.filter?.enabled??!1,mode:e.filter?.mode??this.options?.filter?.mode??"custom",customColor:e.filter?.customColor??this.options?.filter?.customColor??"#ffffff",rgbColors:e.filter?.rgbColors??this.options?.filter?.rgbColors??["#ff0000","#00ff00","#0000ff"],rgbIndex:e.filter?.rgbIndex??this.options?.filter?.rgbIndex??0,threshold:e.filter?.threshold??this.options?.filter?.threshold??128},pixelRatio:e.pixelRatio??this.options?.pixelRatio??(typeof window<"u"?window.devicePixelRatio:1)}}setPuzzle(e){if(this.worker){this.puzzle=e,this.options.autoResize&&this.resizeCanvas(),this.worker.postMessage({type:"setPuzzle",payload:{puzzle:e}}),this.emit("puzzle:created",{puzzle:e});return}this.puzzle=e,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.isInvalidPath=!1,this.isValidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.activeStartNode=null,this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw(),this.emit("puzzle:created",{puzzle:e})}setPath(e){if(this.worker){this.worker.postMessage({type:"setPath",payload:{path:e}});return}if(this.cancelFade(),this.isInvalidPath=!1,this.isValidPath=!1,this.isSuccessFading=!1,e.length>0){this.path=[...e];let t=this.path[this.path.length-1],s=this.getCanvasCoords(t.x,t.y),n=this.getExitDir(t.x,t.y);n?this.exitTipPos={x:s.x+n.x*this.options.exitLength,y:s.y+n.y*this.options.exitLength}:this.exitTipPos=null,this.currentMousePos=s}else this.path=[],this.exitTipPos=null;this.draw()}setOptions(e){let t=this.options.inputMode;if(this.options=this.mergeOptions({...this.options,...e}),t!==this.options.inputMode&&this.options.inputMode!=="twoClick"&&(this.isTwoClickDrawing=!1,this.setTwoClickPointerUi(!1)),this.worker){this.options.autoResize&&this.puzzle&&this.resizeCanvas();let s=this.sanitizeOptions(e);this.worker.postMessage({type:"setOptions",payload:s});return}this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}addEventListener(e,t){this.listeners.has(e)||this.listeners.set(e,new Set),this.listeners.get(e).add(t)}removeEventListener(e,t){let s=this.listeners.get(e);s&&s.delete(t)}on(e,t){return this.addEventListener(e,t),this}off(e,t){return this.removeEventListener(e,t),this}emit(e,t){let s=this.listeners.get(e);if(s&&s.forEach(n=>n(t)),typeof self<"u"&&self.postMessage&&!this.worker&&typeof OffscreenCanvas<"u"&&this.canvas instanceof OffscreenCanvas&&!["path:complete","puzzle:created","goal:validated"].includes(e))try{let i=e==="render:before"||e==="render:after"?{phase:e}:t;self.postMessage({type:"uiEvent",payload:{type:e,data:i}})}catch{}}setValidationResult(e,t=[],s=[],n=[],o=[],i=[],r=[]){if(this.worker){this.worker.postMessage({type:"setValidationResult",payload:{isValid:e,invalidatedCells:t,invalidatedEdges:s,errorCells:n,errorEdges:o,invalidatedNodes:i,errorNodes:r}});return}this.invalidatedCells=t,this.invalidatedEdges=s,this.invalidatedNodes=i,this.errorCells=n,this.errorEdges=o,this.errorNodes=r,this.eraserAnimationStartTime=Date.now(),e?(this.isValidPath=!0,this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0,this.emit("goal:reached",{path:this.path,isValid:e,startNode:this.getStartNodeMetaFromPath(),endNode:this.getEndNodeMetaFromPath()})}resizeCanvas(){if(!this.puzzle||!this.canvas)return;let e=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,t=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2,s=this.options.pixelRatio;if(typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement)try{this.canvas.width=e*s,this.canvas.height=t*s}catch{}else this.canvas.width=e*s,this.canvas.height=t*s;this.worker&&this.boundUpdateRect&&this.boundUpdateRect()}setCanvasRect(e){let t={left:e.left,top:e.top,width:e.width,height:e.height};this.canvasRect=t,this.worker&&this.worker.postMessage({type:"setCanvasRect",payload:t})}createPuzzle(e,t,s){this.worker&&this.worker.postMessage({type:"createPuzzle",payload:{rows:e,cols:t,genOptions:s}})}setTwoClickPointerUi(e){typeof HTMLCanvasElement>"u"||!(this.canvas instanceof HTMLCanvasElement)||typeof document>"u"||(e?(this.canvas.style.cursor="none",this.canvas.requestPointerLock?.()):(document.pointerLockElement===this.canvas&&document.exitPointerLock?.(),this.canvas.style.cursor=""))}initEvents(){typeof window>"u"||typeof HTMLCanvasElement>"u"||!(this.canvas instanceof HTMLCanvasElement)||(this.boundMouseDown=e=>{(this.options.inputMode==="twoClick"&&this.isDrawing?this.handleEnd(e,"mouse"):this.handleStart(e,"mouse"))&&e.cancelable&&e.preventDefault()},this.boundMouseMove=e=>{this.isDrawing&&e.cancelable&&e.preventDefault(),this.handleMove(e)},this.boundMouseUp=e=>{this.options.inputMode!=="twoClick"&&this.isDrawing&&(e.cancelable&&e.preventDefault(),this.handleEnd(e,"mouse"))},this.boundTouchStart=e=>{this.handleStart(e.touches[0],"touch")&&e.cancelable&&e.preventDefault()},this.boundTouchMove=e=>{this.isDrawing&&(e.cancelable&&e.preventDefault(),this.handleMove(e.touches[0]))},this.boundTouchEnd=e=>{this.options.inputMode!=="twoClick"&&this.isDrawing&&(e.cancelable&&e.preventDefault(),this.handleEnd(e.changedTouches[0],"touch"))},this.canvas.addEventListener("mousedown",this.boundMouseDown),window.addEventListener("mousemove",this.boundMouseMove,{passive:!1}),window.addEventListener("mouseup",this.boundMouseUp,{passive:!1}),this.canvas.addEventListener("touchstart",this.boundTouchStart,{passive:!1}),window.addEventListener("touchmove",this.boundTouchMove,{passive:!1}),window.addEventListener("touchend",this.boundTouchEnd,{passive:!1}),this.worker&&(this.boundUpdateRect=()=>{if(this.canvas instanceof HTMLCanvasElement){let e=this.canvas.getBoundingClientRect();this.setCanvasRect(e)}},window.addEventListener("resize",this.boundUpdateRect),window.addEventListener("scroll",this.boundUpdateRect),this.boundUpdateRect()))}destroy(){this.isDestroyed=!0,this.worker&&(this.worker.terminate(),this.worker=null),this.animationFrameId!==null&&typeof cancelAnimationFrame<"u"&&cancelAnimationFrame(this.animationFrameId),this.timeoutId!==null&&clearTimeout(this.timeoutId),!(typeof window>"u"||typeof HTMLCanvasElement>"u"||!(this.canvas instanceof HTMLCanvasElement))&&(this.boundMouseDown&&this.canvas.removeEventListener("mousedown",this.boundMouseDown),this.boundMouseMove&&window.removeEventListener("mousemove",this.boundMouseMove),this.boundMouseUp&&window.removeEventListener("mouseup",this.boundMouseUp),this.boundTouchStart&&this.canvas.removeEventListener("touchstart",this.boundTouchStart),this.boundTouchMove&&window.removeEventListener("touchmove",this.boundTouchMove),this.boundTouchEnd&&window.removeEventListener("touchend",this.boundTouchEnd),this.boundUpdateRect&&(window.removeEventListener("resize",this.boundUpdateRect),window.removeEventListener("scroll",this.boundUpdateRect)),this.boundMouseDown=null,this.boundMouseMove=null,this.boundMouseUp=null,this.boundTouchStart=null,this.boundTouchMove=null,this.boundTouchEnd=null,this.setTwoClickPointerUi(!1))}getCanvasCoords(e,t){return{x:this.options.gridPadding+e*this.options.cellSize,y:this.options.gridPadding+t*this.options.cellSize}}toCanvasPoint(e,t){let s=this.options.pixelRatio,n=this.canvasRect||(typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width/s,height:this.canvas.height/s});return{x:(e-n.left)*(this.canvas.width/s/n.width),y:(t-n.top)*(this.canvas.height/s/n.height)}}hitTestInput(e,t){if(!this.puzzle)return null;let s=this.toCanvasPoint(e,t),n=(s.x-this.options.gridPadding)/this.options.cellSize,o=(s.y-this.options.gridPadding)/this.options.cellSize,i=Math.round(n),r=Math.round(o),h=Math.abs(n-i),f=Math.abs(o-r),d=.2,u=.2;if(h<=d&&f<=d)return i>=0&&i<=this.puzzle.cols&&r>=0&&r<=this.puzzle.rows?{kind:"node",x:i,y:r}:null;if(f<=u&&n>=0&&n<=this.puzzle.cols&&r>=0&&r<=this.puzzle.rows){let a=Math.floor(n);if(a>=0&&a<this.puzzle.cols)return{kind:"hEdge",r,c:a}}if(h<=u&&o>=0&&o<=this.puzzle.rows&&i>=0&&i<=this.puzzle.cols){let a=Math.floor(o);if(a>=0&&a<this.puzzle.rows)return{kind:"vEdge",r:a,c:i}}let l=Math.floor(n),p=Math.floor(o);return l>=0&&l<this.puzzle.cols&&p>=0&&p<this.puzzle.rows?{kind:"cell",r:p,c:l}:null}getExitDir(e,t){if(!this.puzzle||this.puzzle.nodes[t]?.[e]?.type!==2)return null;let{cols:s,rows:n}=this.puzzle,o=e===0,i=e===s,r=t===0,h=t===n;return!o&&!i&&!r&&!h?null:(o||i)&&(r||h)?s>=n?o?{x:-1,y:0}:{x:1,y:0}:r?{x:0,y:-1}:{x:0,y:1}:o?{x:-1,y:0}:i?{x:1,y:0}:r?{x:0,y:-1}:h?{x:0,y:1}:null}handleStart(e,t="mouse"){if(this.options.inputMode==="twoClick"&&t!=="mouse")return!1;let s=this.isStartNodeHit(e);return this.worker?s?(this.isDrawing=!0,this.isTwoClickDrawing=this.options.inputMode==="twoClick",this.isTwoClickDrawing&&this.setTwoClickPointerUi(!0),this.worker.postMessage({type:"event",payload:{eventType:"mousedown",eventData:{clientX:e.clientX,clientY:e.clientY}}}),!0):(this.isDrawing=!1,!1):s?(this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.isValidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.isDrawing=!0,this.isTwoClickDrawing=this.options.inputMode==="twoClick",this.path=[{x:s.x,y:s.y}],this.currentMousePos=this.getCanvasCoords(s.x,s.y),this.exitTipPos=null,this.isTwoClickDrawing&&this.setTwoClickPointerUi(!0),this.draw(),this.activeStartNode={...s,index:this.getNodeIndexByType(1,s.x,s.y)},this.emit("path:start",{x:s.x,y:s.y,startIndex:this.activeStartNode.index}),!0):!1}isStartNodeHit(e){if(!this.puzzle)return null;let t=this.toCanvasPoint(e.clientX,e.clientY),s=t.x,n=t.y;for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++){if(this.puzzle.nodes[o][i].type!==1)continue;let r=this.getCanvasCoords(i,o);if(Math.hypot(r.x-s,r.y-n)<this.options.startNodeRadius)return{x:i,y:o}}return null}handleMove(e){if(this.worker){this.isDrawing&&this.worker.postMessage({type:"event",payload:{eventType:"mousemove",eventData:{clientX:e.clientX,clientY:e.clientY,movementX:e.movementX,movementY:e.movementY,pointerLocked:typeof document<"u"&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement&&document.pointerLockElement===this.canvas}}});return}if(!this.puzzle||!this.isDrawing)return;let t=this.options.pixelRatio,s=this.canvasRect||(typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width/t,height:this.canvas.height/t}),n=this.toCanvasPoint(e.clientX,e.clientY),o=n.x,i=n.y,r=e.pointerLocked===!0||this.isTwoClickDrawing&&typeof document<"u"&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement&&document.pointerLockElement===this.canvas;if(this.isTwoClickDrawing&&r){let b=this.canvas.width/t/s.width,y=this.canvas.height/t/s.height;o=this.currentMousePos.x+(e.movementX??0)*b,i=this.currentMousePos.y+(e.movementY??0)*y}let h=this.path[this.path.length-1],f=this.getCanvasCoords(h.x,h.y),d=o-f.x,u=i-f.y,l=this.puzzle.symmetry||0,p=this.getExitDir(h.x,h.y),a=Math.abs(d)>Math.abs(u)?{x:d>0?1:-1,y:0}:{x:0,y:u>0?1:-1};if(p&&a.x===p.x&&a.y===p.y){let b=d*p.x+u*p.y,y=Math.max(0,Math.min(b,this.options.exitLength));this.currentMousePos={x:f.x+p.x*y,y:f.y+p.y*y},this.draw();return}let c=(b,y)=>{let m=this.getEdgeType(h,b);if(b.x<0||b.x>this.puzzle.cols||b.y<0||b.y>this.puzzle.rows||m===2){this.currentMousePos=f;return}let g=m===1?this.options.cellSize*.35:this.options.cellSize,S=Math.max(0,this.options.cellSize-this.options.pathWidth-1),C=Math.max(0,S/2),v=(T,z)=>T.x!==z.x||T.y!==z.y?0:Math.max(0,this.options.startNodeRadius-this.options.pathWidth/2),w=this.getEdgeKey(h,b);if(!(this.path.length>=2&&b.x===this.path[this.path.length-2].x&&b.y===this.path[this.path.length-2].y)){for(let T=0;T<this.path.length-1;T++)if(this.getEdgeKey(this.path[T],this.path[T+1])===w){g=0;break}}if(this.path.some(T=>T.x===b.x&&T.y===b.y)&&this.path.length>=2){let T=this.path[this.path.length-2];if(b.x!==T.x||b.y!==T.y){let z=this.path[0],I=v(b,z);g=Math.min(g,Math.max(0,S-I))}}if(l!==0){let T=this.getSymmetricalPoint(h),z=this.getSymmetricalPoint(b),I=this.getEdgeType(T,z),V=this.getSymmetryPath(this.path),$=this.getEdgeKey(T,z),W=this.path[0],D=V[0];if(z.x<0||z.x>this.puzzle.cols||z.y<0||z.y>this.puzzle.rows||I===2){this.currentMousePos=f;return}I===1&&(g=Math.min(g,this.options.cellSize*.35));let K=V.some(F=>F.x===b.x&&F.y===b.y),G=this.path.some(F=>F.x===z.x&&F.y===z.y),R=b.x===z.x&&b.y===z.y,M=V.some((F,q)=>q<V.length-1&&this.getEdgeKey(V[q],V[q+1])===w),H=this.path.some((F,q)=>q<this.path.length-1&&this.getEdgeKey(this.path[q],this.path[q+1])===$),Z=w===$;if(K||M){let F=v(b,D);g=Math.min(g,Math.max(0,S-F))}if(G||H){let F=v(z,W);g=Math.min(g,Math.max(0,S-F))}Z&&(g=Math.min(g,C)),R&&(g=Math.min(g,g-(g-S)/2))}b.x!==h.x?this.currentMousePos={x:f.x+Math.max(-g,Math.min(g,y)),y:f.y}:this.currentMousePos={x:f.x,y:f.y+Math.max(-g,Math.min(g,y))}};if(Math.abs(d)>Math.abs(u)){let b=d>0?1:-1;c({x:h.x+b,y:h.y},d)}else{let b=u>0?1:-1;c({x:h.x,y:h.y+b},u)}let x=[{x:h.x+1,y:h.y},{x:h.x-1,y:h.y},{x:h.x,y:h.y+1},{x:h.x,y:h.y-1}],P=this.getSymmetryPath(this.path);for(let b of x)if(b.x>=0&&b.x<=this.puzzle.cols&&b.y>=0&&b.y<=this.puzzle.rows){let y=this.getCanvasCoords(b.x,b.y);if(Math.hypot(y.x-this.currentMousePos.x,y.y-this.currentMousePos.y)<this.options.cellSize*.3){let g=this.path.findIndex(S=>S.x===b.x&&S.y===b.y);if(g===-1){if(l!==0){let S=this.getSymmetricalPoint(b);if(b.x===S.x&&b.y===S.y||this.path.some(w=>w.x===S.x&&w.y===S.y)||P.some(w=>w.x===b.x&&w.y===b.y))continue;let C=this.getEdgeKey(h,b),v=this.getEdgeKey(this.getSymmetricalPoint(h),S);if(C===v)continue}this.path.push(b),this.emit("path:move",{x:b.x,y:b.y,path:this.path,currentMousePos:this.currentMousePos})}else if(g===this.path.length-2){let S=this.path.pop();S&&this.emit("path:move",{x:S.x,y:S.y,path:this.path,currentMousePos:this.currentMousePos})}}}this.draw()}handleEnd(e,t="mouse"){if(this.options.inputMode==="twoClick"&&t!=="mouse")return!1;if(this.worker)return this.isDrawing&&(this.isDrawing=!1,this.isTwoClickDrawing=!1,this.setTwoClickPointerUi(!1),this.worker.postMessage({type:"event",payload:{eventType:"mouseup",eventData:{clientX:e.clientX,clientY:e.clientY}}})),!0;if(!this.puzzle||!this.isDrawing)return!1;this.isDrawing=!1,this.isTwoClickDrawing=!1,this.setTwoClickPointerUi(!1);let s=this.path[this.path.length-1],n=this.getCanvasCoords(s.x,s.y),o=this.getExitDir(s.x,s.y),i=this.getStartNodeMetaFromPath(),r=this.getEndNodeMetaFromPath();if(o){let h=this.currentMousePos.x-n.x,f=this.currentMousePos.y-n.y;if(h*o.x+f*o.y>0)return this.exitTipPos={x:n.x+o.x*this.options.exitLength,y:n.y+o.y*this.options.exitLength},this.emit("path:complete",{path:this.path,startNode:i,endNode:r}),this.emit("path:end",{path:this.path,isExit:!0,startNode:i,endNode:r}),!0}return this.exitTipPos={...this.currentMousePos},this.emit("path:end",{path:this.path,isExit:!1,startNode:i,endNode:null}),this.startFade(this.options.colors.interrupted),!0}getNodeIndexByType(e,t,s){if(!this.puzzle)return-1;let n=0;for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++)if(this.puzzle.nodes[o][i].type===e){if(i===t&&o===s)return n;n++}return-1}getStartNodeMetaFromPath(){if(this.activeStartNode)return this.activeStartNode;if(!this.path.length)return null;let e=this.path[0];return{x:e.x,y:e.y,index:this.getNodeIndexByType(1,e.x,e.y)}}getEndNodeMetaFromPath(){if(!this.path.length)return null;let e=this.path[this.path.length-1];return!this.puzzle||this.puzzle.nodes[e.y]?.[e.x]?.type!==2?null:{x:e.x,y:e.y,index:this.getNodeIndexByType(2,e.x,e.y)}}getEdgeType(e,t){if(!this.puzzle)return 2;if(e.x===t.x){let s=Math.min(e.y,t.y);return s<0||s>=this.puzzle.rows?2:this.puzzle.vEdges[s][e.x].type}else{let s=Math.min(e.x,t.x);return s<0||s>=this.puzzle.cols?2:this.puzzle.hEdges[e.y][s].type}}startFade(e="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=e,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){if(this.isDestroyed)return;let e=Date.now();if(this.isFading){let t=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=t,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0,this.isInvalidPath&&(this.isInvalidPath=!1,this.emit("goal:validated",{result:{isValid:!1}})))}this.isSuccessFading&&e-this.successFadeStartTime>this.options.animations.blinkDuration+this.options.animations.fadeDuration&&(this.isSuccessFading=!1,this.emit("goal:validated",{result:{isValid:!0}})),this.isInvalidPath&&!this.options.stayPathOnError&&!this.isFading&&this.path.length>0&&this.startFade(this.options.colors.error),this.draw(),typeof requestAnimationFrame<"u"?this.animationFrameId=requestAnimationFrame(()=>this.animate()):(this.timeoutId=setTimeout(()=>this.animate(),1e3/60),this.timeoutId&&this.timeoutId.unref&&this.timeoutId.unref())}lastGoalReachable=!1;draw(){if(!this.puzzle||!this.ctx)return;let e=this.ctx;this.emit("render:before",{ctx:e});let t=Date.now(),s=this.options.pixelRatio;if(e.setTransform(s,0,0,s,0,0),e.globalAlpha=1,e.clearRect(0,0,this.canvas.width/s,this.canvas.height/s),this.drawGrid(e),this.drawConstraints(e),this.drawNodes(e),this.path.length===0&&!this.isDrawing&&this.drawRipples(e),this.isFading){if(this.drawPath(e,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let n=this.getSymmetryPath(this.fadingPath),o=this.options.colors.symmetry;if(this.isInvalidPath){let r=this.colorToRgba(o).a;o=this.setAlpha(this.options.colors.error,r)}let i=this.getSymmetryTipPos(this.fadingTipPos,this.fadingPath);this.drawPath(e,n,!1,o,this.fadeOpacity,i)}}else if(this.path.length>0){let n=this.options.colors.path,o=this.colorToRgba(n).a,i=this.options.colors.error,r=this.isInvalidPath?this.setAlpha(i,o):n;(this.isSuccessFading||this.isValidPath)&&!this.puzzle.symmetry&&(r=this.setAlpha(this.options.colors.success,o));let h=1;if(!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let l=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),p=this.options.animations.blinkDuration;l<p&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(r=this.setAlpha(this.options.colors.error,o),this.options.stayPathOnError||(h=Math.max(0,1-l/this.options.animations.fadeDuration)))}let f=this.isDrawing?this.currentMousePos:this.exitTipPos,d=this.getSymmetryTipPos(f,this.path),u=this.isPathAtExit(this.path,this.isDrawing?this.currentMousePos:this.exitTipPos);if(u!==this.lastGoalReachable&&(this.lastGoalReachable=u,this.emit("goal:reachable",{reachable:u})),u&&!this.isInvalidPath&&!this.isSuccessFading&&!this.isValidPath){let l=this.colorToRgba(r).a,p=(Math.sin(t*Math.PI*2/600)+1)/2;r=this.lerpColor(r,"#ffffff",p*.6),r=this.setAlpha(r,l)}if(this.drawPath(e,this.path,this.isDrawing,r,h,f),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let l=this.getSymmetryPath(this.path),p=this.options.colors.symmetry,a=this.colorToRgba(p).a,c=p,x=h;if(this.isInvalidPath&&(c=this.setAlpha(i,a)),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let P=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),b=this.options.animations.blinkDuration;P<b&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(c=this.setAlpha(this.options.colors.error,a))}if(u&&!this.isInvalidPath&&!this.isSuccessFading&&!this.isValidPath){let P=(Math.sin(t*Math.PI*2/400)+1)/2;c=this.lerpColor(c,"#ffffff",P*.6),c=this.setAlpha(c,a)}this.drawPath(e,l,this.isDrawing,c,x,d)}}if(this.isDrawing&&this.isTwoClickDrawing&&this.path.length>0){let n=this.path[this.path.length-1],o=this.getCanvasCoords(n.x,n.y),i=this.exitTipPos?this.exitTipPos:this.currentMousePos||o;this.drawTwoClickPointer(e,i)}this.applyFilter(e),this.emit("render:after",{ctx:e})}drawTwoClickPointer(e,t){e.save(),e.beginPath(),e.arc(t.x,t.y,this.options.pathWidth*.5,0,Math.PI*2),e.fillStyle="rgba(255, 255, 255, 0.4)",e.fill(),e.restore()}applyFilter(e){if(!this.options.filter.enabled)return;let t=this.getActiveFilterColor();if(t===null||this.isNoopFilterColor(t))return;let s=this.colorToRgba(t),n=Math.max(1,Math.floor(this.canvas.width)),o=Math.max(1,Math.floor(this.canvas.height)),i=this.prepareFilterBuffer(n,o);if(!i)return;let r=i.ctx;try{r.save(),r.setTransform(1,0,0,1,0,0),r.clearRect(0,0,n,o),r.drawImage(this.canvas,0,0,n,o),r.globalCompositeOperation="multiply",r.fillStyle=`rgb(${s.r}, ${s.g}, ${s.b})`,r.fillRect(0,0,n,o),r.globalCompositeOperation="destination-in",r.drawImage(this.canvas,0,0,n,o),r.restore(),e.save(),e.setTransform(1,0,0,1,0,0),e.clearRect(0,0,n,o),e.drawImage(i.canvas,0,0,n,o),e.restore()}catch{}}prepareFilterBuffer(e,t){if(!this.filterCanvas){if(typeof document<"u")this.filterCanvas=document.createElement("canvas");else if(typeof OffscreenCanvas<"u")this.filterCanvas=new OffscreenCanvas(e,t);else return null;this.filterCtx=this.filterCanvas.getContext("2d")}return!this.filterCtx||!this.filterCanvas?null:((this.filterCanvas.width!==e||this.filterCanvas.height!==t)&&(this.filterCanvas.width=e,this.filterCanvas.height=t),{canvas:this.filterCanvas,ctx:this.filterCtx})}getActiveFilterColor(){if(this.options.filter.mode==="rgb"){let s=this.options.filter.rgbColors??["#ff0000","#00ff00","#0000ff"],n=Math.max(0,Math.min(2,this.options.filter.rgbIndex??0));return s[n]??null}let e=this.options.filter.customColor;if(typeof e!="string")return null;let t=e.trim();return t.length>0?t:null}isNoopFilterColor(e){let t=e.toLowerCase().replace(/\s+/g,"");if(t==="#fff"||t==="#ffffff"||t==="rgb(255,255,255)"||t==="rgba(255,255,255,1)")return!0;let s=this.colorToRgba(e);return s.r===255&&s.g===255&&s.b===255}drawRipples(e){if(!this.puzzle)return;let t=(Date.now()-this.startTime)/500;for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++)if(this.puzzle.nodes[s][n].type===2){let i=this.getCanvasCoords(n,s),r=this.getExitDir(n,s);if(!r)continue;let h={x:i.x+r.x*this.options.exitLength,y:i.y+r.y*this.options.exitLength},f=t%4,d=f*5,u=Math.max(0,1-f/3);e.beginPath(),e.arc(h.x,h.y,d,0,Math.PI*2),e.strokeStyle=`rgba(170, 170, 170, ${u*.4})`,e.lineWidth=2,e.stroke()}}drawGrid(e){if(!this.puzzle||!this.options.colors.grid)return;e.strokeStyle=this.options.colors.grid,e.lineWidth=12,e.lineCap="round";let t=(s,n,o)=>{if(o!==2)if(o===1){let r={x:s.x+(n.x-s.x)*.35,y:s.y+(n.y-s.y)*.35},h={x:s.x+(n.x-s.x)*(.5+.15),y:s.y+(n.y-s.y)*(.5+.15)};e.beginPath(),e.moveTo(s.x,s.y),e.lineTo(r.x,r.y),e.stroke(),e.beginPath(),e.moveTo(h.x,h.y),e.lineTo(n.x,n.y),e.stroke()}else e.beginPath(),e.moveTo(s.x,s.y),e.lineTo(n.x,n.y),e.stroke()};for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<this.puzzle.cols;n++)t(this.getCanvasCoords(n,s),this.getCanvasCoords(n+1,s),this.puzzle.hEdges[s][n].type);for(let s=0;s<this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++)t(this.getCanvasCoords(n,s),this.getCanvasCoords(n,s+1),this.puzzle.vEdges[s][n].type)}drawConstraints(e){if(!this.puzzle)return;let t=Date.now(),s=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2,n=new Set(this.invalidatedCells.map(l=>`${l.x},${l.y}`)),o=new Set(this.errorCells.map(l=>`${l.x},${l.y}`)),i=new Set(this.invalidatedEdges.map(l=>`${l.type},${l.r},${l.c}`)),r=new Set(this.errorEdges.map(l=>`${l.type},${l.r},${l.c}`)),h=new Set(this.invalidatedNodes.map(l=>`${l.x},${l.y}`)),f=new Set(this.errorNodes.map(l=>`${l.x},${l.y}`));for(let l=0;l<this.puzzle.rows;l++)for(let p=0;p<this.puzzle.cols;p++){let a=this.puzzle.cells[l][p],c=this.getCanvasCoords(p+.5,l+.5),x=`${p},${l}`,P=n.has(x),b=o.has(x),y=1,m,g=this.getColorCode(a.color),S=this.options.colors.error;if(b&&this.options.blinkMarksOnError&&(m=this.lerpColor(g,S,s)),P){let C=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),v=this.options.animations.blinkDuration;if(C<v){if(this.options.blinkMarksOnError){let w=Math.min(1,C/200),k=C>v*.8?(v-C)/(v*.2):1,E=Math.min(w,k);m=this.lerpColor(g,S,s*E)}}else y=Math.max(.3,1-(C-v)/this.options.animations.fadeDuration)}e.save(),y<1&&(e.globalAlpha*=y),this.drawConstraintItem(e,a,c,m),e.restore()}e.lineWidth=2;let d=8,u=l=>l===3||l===3?this.options.colors.hexagon:l===4||l===4?this.options.colors.hexagonMain:l===5||l===5?this.options.colors.hexagonSymmetry:this.options.colors.hexagon;for(let l=0;l<=this.puzzle.rows;l++)for(let p=0;p<this.puzzle.cols;p++){let a=this.puzzle.hEdges[l][p].type;if(a===3||a===4||a===5){let c=this.getCanvasCoords(p+.5,l);e.save();let x=`h,${l},${p}`,P=i.has(x),b=r.has(x),y=u(a);if(b&&this.options.blinkMarksOnError){let m=this.lerpColor(y,this.options.colors.error,s);this.drawHexagon(e,c.x,c.y,d,m)}else if(P){let m=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),g=this.options.animations.blinkDuration;if(m<g)if(this.options.blinkMarksOnError){let S=Math.min(1,m/200),C=m>g*.8?(g-m)/(g*.2):1,v=Math.min(S,C),w=this.lerpColor(y,this.options.colors.error,s*v);this.drawHexagon(e,c.x,c.y,d,w)}else this.drawHexagon(e,c.x,c.y,d,y);else e.globalAlpha*=Math.max(.3,1-(m-g)/this.options.animations.fadeDuration),this.drawHexagon(e,c.x,c.y,d,y)}else this.drawHexagon(e,c.x,c.y,d,y);e.restore()}}for(let l=0;l<this.puzzle.rows;l++)for(let p=0;p<=this.puzzle.cols;p++){let a=this.puzzle.vEdges[l][p].type;if(a===3||a===4||a===5){let c=this.getCanvasCoords(p,l+.5);e.save();let x=`v,${l},${p}`,P=i.has(x),b=r.has(x),y=u(a);if(b&&this.options.blinkMarksOnError){let m=this.lerpColor(y,this.options.colors.error,s);this.drawHexagon(e,c.x,c.y,d,m)}else if(P){let m=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),g=this.options.animations.blinkDuration;if(m<g)if(this.options.blinkMarksOnError){let S=Math.min(1,m/200),C=m>g*.8?(g-m)/(g*.2):1,v=Math.min(S,C),w=this.lerpColor(y,this.options.colors.error,s*v);this.drawHexagon(e,c.x,c.y,d,w)}else this.drawHexagon(e,c.x,c.y,d,y);else e.globalAlpha*=Math.max(.3,1-(m-g)/this.options.animations.fadeDuration),this.drawHexagon(e,c.x,c.y,d,y)}else this.drawHexagon(e,c.x,c.y,d,y);e.restore()}}for(let l=0;l<=this.puzzle.rows;l++)for(let p=0;p<=this.puzzle.cols;p++){let a=this.puzzle.nodes[l][p].type;if(a===3||a===4||a===5){let c=this.getCanvasCoords(p,l);e.save();let x=`${p},${l}`,P=h.has(x),b=f.has(x),y=u(a);if(b&&this.options.blinkMarksOnError){let m=this.lerpColor(y,this.options.colors.error,s);this.drawHexagon(e,c.x,c.y,d,m)}else if(P){let m=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),g=this.options.animations.blinkDuration;if(m<g)if(this.options.blinkMarksOnError){let S=Math.min(1,m/200),C=m>g*.8?(g-m)/(g*.2):1,v=Math.min(S,C),w=this.lerpColor(y,this.options.colors.error,s*v);this.drawHexagon(e,c.x,c.y,d,w)}else this.drawHexagon(e,c.x,c.y,d,y);else e.globalAlpha*=Math.max(.3,1-(m-g)/this.options.animations.fadeDuration),this.drawHexagon(e,c.x,c.y,d,y)}else this.drawHexagon(e,c.x,c.y,d,y);e.restore()}}}drawConstraintItem(e,t,s,n){t.type===1?(e.fillStyle=n||this.getColorCode(t.color),this.drawRoundedRect(e,s.x-26/2,s.y-26/2,26,26,8)):t.type===2?this.drawStar(e,s.x,s.y,12,16,8,t.color,n):t.type===3||t.type===4?this.drawTetris(e,s.x,s.y,t.shape||[],t.type===4,t.color,!1,n):t.type===5||t.type===6?this.drawTetris(e,s.x,s.y,t.shape||[],t.type===6,t.color,!0,n):t.type===7?this.drawEraser(e,s.x,s.y,14,3,t.color,n):t.type===8&&this.drawTriangle(e,s.x,s.y,t.count||0,t.color,n)}drawNodes(e){if(!this.puzzle)return;let t=(s,n)=>{let o=[];return s>0&&o.push(this.puzzle.hEdges[n][s-1].type),s<this.puzzle.cols&&o.push(this.puzzle.hEdges[n][s].type),n>0&&o.push(this.puzzle.vEdges[n-1][s].type),n<this.puzzle.rows&&o.push(this.puzzle.vEdges[n][s].type),o.length>0&&o.every(i=>i===2)};for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++){if(t(n,s))continue;let o=this.puzzle.nodes[s][n];if(o.type===3||o.type===4||o.type===5)continue;let i=this.getCanvasCoords(n,s);if(o.type===1)this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(i.x,i.y,this.options.startNodeRadius,0,Math.PI*2),e.fill();else if(o.type===2){let r=this.getExitDir(n,s);if(!r)continue;this.options.colors.node&&(e.strokeStyle=this.options.colors.node),e.lineWidth=12,e.lineCap="round",e.beginPath(),e.moveTo(i.x,i.y),e.lineTo(i.x+r.x*this.options.exitLength,i.y+r.y*this.options.exitLength),e.stroke()}else this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(i.x,i.y,this.options.nodeRadius,0,Math.PI*2),e.fill()}}drawPath(e,t,s,n,o,i=null){if(t.length===0||!n||n==="transparent")return;let r=this.colorToRgba(n),h=`rgb(${r.r},${r.g},${r.b})`,f=o*r.a,{canvas:d,ctx:u}=this.prepareOffscreen();this.drawPathInternal(u,t,s,h,i),e.save(),e.setTransform(1,0,0,1,0,0),e.globalAlpha=f,e.drawImage(d,0,0),e.restore()}drawPathInternal(e,t,s,n,o=null){e.save(),e.strokeStyle=n,e.fillStyle=n,e.lineWidth=this.options.pathWidth,e.lineCap="round",e.lineJoin="round",e.beginPath();let i=this.getCanvasCoords(t[0].x,t[0].y);e.moveTo(i.x,i.y);for(let h=1;h<t.length;h++){let f=this.getCanvasCoords(t[h].x,t[h].y);e.lineTo(f.x,f.y)}let r=o||this.currentMousePos;(s||o)&&e.lineTo(r.x,r.y),e.stroke(),e.beginPath(),e.arc(i.x,i.y,this.options.startNodeRadius,0,Math.PI*2),e.fill(),(s||o)&&(e.beginPath(),e.arc(r.x,r.y,this.options.pathWidth/2,0,Math.PI*2),e.fill()),e.restore()}drawRoundedRect(e,t,s,n,o,i){e.beginPath(),e.moveTo(t+i,s),e.lineTo(t+n-i,s),e.quadraticCurveTo(t+n,s,t+n,s+i),e.lineTo(t+n,s+o-i),e.quadraticCurveTo(t+n,s+o,t+n-i,s+o),e.lineTo(t+i,s+o),e.quadraticCurveTo(t,s+o,t,s+o-i),e.lineTo(t,s+i),e.quadraticCurveTo(t,s,t+i,s),e.closePath(),e.fill()}drawHexagon(e,t,s,n,o){if(!(!this.options.colors.hexagon&&!o)){e.fillStyle=o||this.options.colors.hexagon,e.beginPath();for(let i=0;i<6;i++){let r=Math.PI/3*i,h=t+n*Math.cos(r),f=s+n*Math.sin(r);i===0?e.moveTo(h,f):e.lineTo(h,f)}e.closePath(),e.fill()}}drawEraser(e,t,s,n,o,i,r){e.strokeStyle=r||this.getColorCode(i),e.lineWidth=n*.5,e.lineCap="butt";let h=.5;e.beginPath();for(let f=0;f<o;f++){let d=Math.PI*2/o*f+h,u=t+n*Math.cos(d),l=s+n*Math.sin(d);e.moveTo(t,s),e.lineTo(u,l)}e.stroke()}drawStar(e,t,s,n,o,i,r,h){e.fillStyle=h||this.getColorCode(r),e.beginPath();for(let f=0;f<i*2;f++){let d=f%2===0?o:n,u=Math.PI/i*f,l=t+d*Math.cos(u),p=s+d*Math.sin(u);f===0?e.moveTo(l,p):e.lineTo(l,p)}e.closePath(),e.fill()}drawTriangle(e,t,s,n,o,i){if(n<=0)return;let r=i||this.getColorCode(o,"#ffcc00");e.fillStyle=r;let f=12*.8,d=f*2.2,u=(p,a)=>{e.beginPath();for(let c=0;c<3;c++){let x=Math.PI*2*c/3-Math.PI/2,P=p+f*Math.cos(x),b=a+f*Math.sin(x);c===0?e.moveTo(P,b):e.lineTo(P,b)}e.closePath(),e.fill()},l=(n-1)*d*.5;for(let p=0;p<n;p++)u(t-l+p*d,s)}drawTetris(e,t,s,n,o,i,r,h){if(!n||n.length===0)return;let f=12,d=2,u=n[0].length*f+(n[0].length-1)*d,l=n.length*f+(n.length-1)*d;e.save(),e.translate(t,s),o&&e.rotate(Math.PI/8);let p=h||this.getColorCode(i,r?"#00ffff":"#ffcc00");if(r){e.strokeStyle=p,e.lineWidth=2;for(let a=0;a<n.length;a++)for(let c=0;c<n[a].length;c++)if(n[a][c]){let x=c*(f+d)-u/2,P=a*(f+d)-l/2;e.strokeRect(x+1,P+1,f-2,f-2)}}else{e.fillStyle=p;for(let a=0;a<n.length;a++)for(let c=0;c<n[a].length;c++)if(n[a][c]){let x=c*(f+d)-u/2,P=a*(f+d)-l/2;e.fillRect(x,P,f,f)}}e.restore()}getColorCode(e,t="#666"){return this.options.colors.colorList&&this.options.colors.colorList[e]!==void 0?this.options.colors.colorList[e]:this.options.colors.colorMap&&this.options.colors.colorMap[e]!==void 0?this.options.colors.colorMap[e]:t}colorToRgba(e){if(!e||e==="transparent")return{r:0,g:0,b:0,a:0};if(e.startsWith("rgba")||e.startsWith("rgb")){let s=e.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);if(s)return{r:parseInt(s[1]),g:parseInt(s[2]),b:parseInt(s[3]),a:s[4]?parseFloat(s[4]):1}}let t=e.startsWith("#")?e.slice(1):e;if((t.length===3||t.length===4)&&(t=t.split("").map(s=>s+s).join("")),t.length===6){let s=parseInt(t,16);return{r:s>>16&255,g:s>>8&255,b:s&255,a:1}}else if(t.length===8){let s=parseInt(t,16);return{r:s>>24&255,g:s>>16&255,b:s>>8&255,a:(s&255)/255}}return{r:0,g:0,b:0,a:1}}lerpColor(e,t,s){try{let n=this.colorToRgba(e),o=this.colorToRgba(t),i=Math.round(n.r+(o.r-n.r)*s),r=Math.round(n.g+(o.g-n.g)*s),h=Math.round(n.b+(o.b-n.b)*s),f=n.a+(o.a-n.a)*s;return`rgba(${i},${r},${h},${f})`}catch{return e}}setAlpha(e,t){let s=this.colorToRgba(e);return`rgba(${s.r},${s.g},${s.b},${t})`}getSymmetryPath(e){return!this.puzzle||!this.puzzle.symmetry?[]:e.map(t=>this.getSymmetricalPoint(t))}getSymmetricalPoint(e,t=!1){if(!this.puzzle||!this.puzzle.symmetry)return{...e};let{cols:s,rows:n,symmetry:o}=this.puzzle;return o===1?{x:s-e.x,y:e.y}:o===2?{x:e.x,y:n-e.y}:o===3?{x:s-e.x,y:n-e.y}:{...e}}getSymmetryTipPos(e,t){if(!this.puzzle||!this.puzzle.symmetry||!e||t.length===0)return null;let s=this.getSymmetryPath(t),n=t[t.length-1],o=s[s.length-1],i=this.getCanvasCoords(n.x,n.y),r=this.getCanvasCoords(o.x,o.y),h=e.x-i.x,f=e.y-i.y,d=this.getSymmetricalPoint({x:h/this.options.cellSize,y:f/this.options.cellSize},!0),u=this.getSymmetricalPoint({x:0,y:0},!0);return{x:r.x+(d.x-u.x)*this.options.cellSize,y:r.y+(d.y-u.y)*this.options.cellSize}}isPathAtExit(e,t){if(e.length===0||!t)return!1;let s=e[e.length-1],n=this.getExitDir(s.x,s.y);if(!n)return!1;let o=this.getCanvasCoords(s.x,s.y),i=t.x-o.x,r=t.y-o.y;return i*n.x+r*n.y>=this.options.exitLength*.9}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}sanitizeOptions(e){let t={};for(let s in e){let n=e[s];if(n&&typeof n=="object"&&!Array.isArray(n)){t[s]={};for(let o in n)typeof n[o]!="function"&&(t[s][o]=n[o])}else typeof n!="function"&&(t[s]=n)}return t}prepareOffscreen(){let e=this.options.pixelRatio;if(!this.offscreenCanvas){if(typeof document<"u")this.offscreenCanvas=document.createElement("canvas");else if(typeof OffscreenCanvas<"u")this.offscreenCanvas=new OffscreenCanvas(this.canvas.width,this.canvas.height);else throw new Error("Offscreen canvas not supported in this environment.");this.offscreenCtx=this.offscreenCanvas.getContext("2d")}if((this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),!this.offscreenCtx)throw new Error("Could not get offscreen 2D context.");return this.offscreenCtx.setTransform(e,0,0,e,0,0),this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width/e,this.offscreenCanvas.height/e),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx}}};var Se=class{bytes=[];cur=0;bit=0;write(e,t){for(let s=0;s<t;s++)e&1<<s&&(this.cur|=1<<this.bit),this.bit++,this.bit===8&&(this.bytes.push(this.cur),this.cur=0,this.bit=0)}finish(){return this.bit>0&&this.bytes.push(this.cur),new Uint8Array(this.bytes)}},we=class{constructor(e){this.buf=e}i=0;bit=0;read(e){let t=0;for(let s=0;s<e;s++)this.buf[this.i]&1<<this.bit&&(t|=1<<s),this.bit++,this.bit===8&&(this.bit=0,this.i++);return t}get hasMore(){return this.i<this.buf.length}},ke=new Uint8Array(512),He=new Uint8Array(256);{let B=1;for(let e=0;e<255;e++)ke[e]=B,ke[e+255]=B,He[B]=e,B<<=1,B&256&&(B^=285)}var re="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",Ee=new Int16Array(128).fill(-1);for(let B=0;B<re.length;B++)Ee[re.charCodeAt(B)]=B;var he=new Uint8Array(126),pe=new Int16Array(64).fill(-1);{let B=1;for(let e=0;e<63;e++)he[e]=B,pe[B]=e,B<<=1,B&64&&(B^=67);for(let e=63;e<126;e++)he[e]=he[e-63]}function Pe(B,e){return B^e}function xe(B,e){return B===0||e===0?0:he[pe[B]+pe[e]]}function Ae(B){if(B===0)throw new Error("GF64 inverse of zero");return he[63-pe[B]]}function Ce(B,e){return e===0?1:B===0?0:he[pe[B]*e%63]}function Ie(B){let e=new Map;for(let t of B)for(let s of t)if(s.shape){let n=JSON.stringify(s.shape);e.has(n)||e.set(n,s.shape)}return[...e.values()]}var Me=class{static async serialize(e){let t=new Se,s=0;e.puzzle&&(s|=1),e.seed&&(s|=2),e.options&&(s|=4),e.path&&(s|=8),e.filter&&(s|=32);let n=e.parityMode==="recovery";n&&(s|=16),t.write(s,8),e.puzzle&&this.writePuzzle(t,e.puzzle),e.seed&&this.writeSeed(t,e.seed),e.options&&this.writeOptions(t,e.options),e.path&&this.writePath(t,e.path),e.filter&&this.writeFilter(t,e.filter);let o=t.finish(),i=new Uint8Array(await new Response(new Blob([o.buffer]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()),r=i.length+1<o.length,h=r?i:o,f=r?1:0,d=new Uint8Array(h.length+1);d[0]=f,d.set(h,1);let u=0;for(let a of d)u^=a;let l=new Uint8Array(d.length+1);l.set(d),l[d.length]=u;let p=this.toBase64Url(l);return n?this.encodeRobustShareCode(p):p}static async deserialize(e){let t=i=>{try{let r=i.replace(/-/g,"+").replace(/_/g,"/");for(;r.length%4;)r+="=";let h=atob(r);return Uint8Array.from(h,f=>f.charCodeAt(0))}catch{return null}},s=i=>{if(i.length<2)return null;let r=0;for(let d=0;d<i.length-1;d++)r^=i[d];let h=r===i[i.length-1]?i.slice(0,-1):null;if(!h||h.length<1)return null;let f=h[0];return f!==0&&f!==1?null:{payload:h.slice(1),compressed:f===1}},n=async i=>{let r=t(i);if(!r)return null;let h=s(r);if(!h)return null;try{let f=await this.finalizeDeserialize(h.payload,h.compressed);if(f.puzzle||f.seed||f.options||f.path||f.filter)return f}catch{return null}return null},o=this.extractShareCodeCandidates(e);for(let i of o){let r=await n(i);if(r)return r}for(let i of o)if(!(i.length>=1e3))for(let r=0;r<=i.length;r++)for(let h=0;h<re.length;h++){let f=i.slice(0,r)+re[h]+i.slice(r),d=await n(f);if(d)return d}throw new Error("Invalid parity data or unrecoverable corruption")}static toBase64Url(e){return btoa(String.fromCharCode(...e)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}static share64Value(e){let t=e.charCodeAt(0);return t<Ee.length?Ee[t]:-1}static solveLinearGF64(e,t){let s=e.length,n=e.map((o,i)=>[...o,t[i]]);for(let o=0;o<s;o++){let i=o;for(;i<s&&n[i][o]===0;)i++;if(i===s)throw new Error("Singular matrix");i!==o&&([n[o],n[i]]=[n[i],n[o]]);let r=Ae(n[o][o]);for(let h=o;h<=s;h++)n[o][h]=xe(n[o][h],r);for(let h=0;h<s;h++){if(h===o||n[h][o]===0)continue;let f=n[h][o];for(let d=o;d<=s;d++)n[h][d]=Pe(n[h][d],xe(f,n[o][d]))}}return n.map(o=>o[s])}static encodeRobustShareCode(e){if(e.length===0)return"r.0-8.0-8.0-8";let t=5,s=Math.max(8,Math.ceil(e.length/59)),n=Math.ceil(e.length/s);if(n+t>63)throw new Error("Share code is too long for recovery mode");let o=[];for(let p=0;p<n;p++){let a=[];for(let c=0;c<s;c++){let x=p*s+c;if(x<e.length){let P=this.share64Value(e[x]);if(P<0)throw new Error("Invalid core character for robust code");a.push(P)}else a.push(0)}o.push(a)}let i=Array.from({length:t},()=>Array(s).fill(0));for(let p=0;p<s;p++)for(let a=0;a<t;a++){let c=0;for(let x=0;x<n;x++){let P=Ce(x+1,a);c=Pe(c,xe(o[x][p],P))}i[a][p]=c}let r=p=>{let a=0;for(let c=0;c<p.length;c++)a=a+(c+1)*p[c]&4095;return a},h=(p,a)=>{let c=r(a),x="";for(let P of a)x+=re[P];return`${re[p]}${re[c>>6&63]}${re[c&63]}${x}`},f=[];for(let p=0;p<n;p++)f.push(h(p,o[p]));for(let p=0;p<t;p++)f.push(h(n+p,i[p]));let d=f.join("."),u=`${e.length.toString(36)}-${s.toString(36)}`;return`r.${Array.from({length:8},()=>u).join(".")}.${d}`}static decodeRobustShareCode(e){if(!e.startsWith("r."))return null;let t=-1,s=-1,n="",o=/^r\.([0-9a-z]+)\.([0-9a-z]+)(?:\.(.*))?$/.exec(e);if(o&&(t=Number.parseInt(o[1],36),s=Number.parseInt(o[2],36),n=o[3]||"",t>=0&&s>=1))return this.decodeRobustCore(t,s,n);let i=e.slice(2).split("."),r=-1;for(let h=0;h<i.length;h++){let f=i[h],d=/^([0-9a-z]+)-([0-9a-z]+)$/.exec(f);if(!d)continue;let u=Number.parseInt(d[1],36),l=Number.parseInt(d[2],36);Number.isFinite(u)&&u>=0&&Number.isFinite(l)&&l>=1&&(t=u,s=l,r=h)}return r<0||t<0||s<1?null:(n=i.slice(r+1).join("."),this.decodeRobustCore(t,s,n))}static decodeRobustCore(e,t,s){let o=e===0?0:Math.ceil(e/t),i=o+5;if(i>63)return null;if(e===0)return"";let r=t+3;if(s.length<r)return null;let h=a=>{let c=0;for(let x=0;x<a.length;x++)c=c+(x+1)*a[x]&4095;return c},f=Array(i).fill(null);for(let a of s.split(".")){if(a.length!==r)continue;let c=this.share64Value(a[0]),x=this.share64Value(a[1]),P=this.share64Value(a[2]);if(c<0||c>=i||x<0||P<0)continue;let b=[],y=!0;for(let g=3;g<a.length;g++){let S=this.share64Value(a[g]);if(S<0){y=!1;break}b.push(S)}if(!y)continue;let m=x<<6|P;h(b)===m&&(f[c]=b)}let d=new Set;for(let a=0;a<o;a++)f[a]||d.add(a);if(d.size>5)return null;let u=[];for(let a=0;a<5;a++)f[o+a]&&u.push(a);if(d.size>u.length)return null;let l=[...d];if(l.length>0){let a=u.slice(0,l.length);for(let c=0;c<t;c++){let x=a.map(y=>l.map(m=>Ce(m+1,y))),P=a.map(y=>{let m=f[o+y][c];for(let g=0;g<o;g++)d.has(g)||(m=Pe(m,xe(f[g][c],Ce(g+1,y))));return m}),b=this.solveLinearGF64(x,P);for(let y=0;y<l.length;y++){let m=l[y];f[m]||(f[m]=Array(t).fill(0)),f[m][c]=b[y]}}}let p="";for(let a=0;a<o;a++){let c=f[a];if(!c)return null;for(let x of c)p+=re[x]}return p.slice(0,e)}static extractShareCodeCandidates(e){let t=new Set;e&&t.add(e);let s=this.decodeRobustShareCode(e);return s&&t.add(s),[...t]}static async finalizeDeserialize(e,t){let s=t?new Uint8Array(await new Response(new Blob([e.buffer]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer()):e,n=new we(s),o=n.read(8),i={};return o&1&&(i.puzzle=this.readPuzzle(n)),o&2&&(i.seed=this.readSeed(n)),o&4&&(i.options=this.readOptions(n)),o&8&&(i.path=this.readPath(n)),o&32&&(i.filter=this.readFilter(n)),i}static writePuzzle(e,t){e.write(t.rows,6),e.write(t.cols,6),e.write(t.symmetry??0,2);let s=Ie(t.cells);e.write(s.length,5);for(let o of s){e.write(o.length,4),e.write(o[0].length,4);for(let i of o)for(let r of i)e.write(r,1)}let n=new Map;s.forEach((o,i)=>n.set(JSON.stringify(o),i));for(let o of t.cells)for(let i of o)e.write(i.type,4),e.write(i.color,3),i.type===8?e.write(i.count||0,2):i.shape?(e.write(1,1),e.write(n.get(JSON.stringify(i.shape)),5)):e.write(0,1);for(let o=0;o<t.rows;o++)for(let i=0;i<t.cols+1;i++)e.write(t.vEdges[o][i].type,3);for(let o=0;o<t.rows+1;o++)for(let i=0;i<t.cols;i++)e.write(t.hEdges[o][i].type,3);for(let o=0;o<t.rows+1;o++)for(let i=0;i<t.cols+1;i++)e.write(t.nodes[o][i].type,3)}static readPuzzle(e){let t=e.read(6),s=e.read(6),n=e.read(2),o=e.read(5),i=[];for(let u=0;u<o;u++){let l=e.read(4),p=e.read(4),a=[];for(let c=0;c<l;c++){let x=[];for(let P=0;P<p;P++)x.push(e.read(1));a.push(x)}i.push(a)}let r=[];for(let u=0;u<t;u++){let l=[];for(let p=0;p<s;p++){let a=e.read(4),c=e.read(3),x={type:a,color:c};a===8?x.count=e.read(2):e.read(1)&&(x.shape=i[e.read(5)].map(P=>P.slice())),l.push(x)}r.push(l)}let h=Array.from({length:t},()=>Array.from({length:s+1},()=>({type:e.read(3)}))),f=Array.from({length:t+1},()=>Array.from({length:s},()=>({type:e.read(3)}))),d=Array.from({length:t+1},()=>Array.from({length:s+1},()=>({type:e.read(3)})));return{rows:t,cols:s,cells:r,vEdges:h,hEdges:f,nodes:d,symmetry:n}}static writeSeed(e,t){e.write(t.type,2),e.write(t.value.length,8);for(let s=0;s<t.value.length;s++)e.write(parseInt(t.value[s],16),4)}static readSeed(e){let t=e.read(2),s=e.read(8),n="";for(let o=0;o<s;o++)n+=e.read(4).toString(16);return{type:t,value:n}}static writeOptions(e,t){if(e.write(t.rows??0,6),e.write(t.cols??0,6),e.write(+!!t.useHexagons,1),e.write(+!!t.useSquares,1),e.write(+!!t.useStars,1),e.write(+!!t.useTetris,1),e.write(+!!t.useTetrisNegative,1),e.write(+!!t.useEraser,1),e.write(+!!t.useTriangles,1),e.write(+!!t.useBrokenEdges,1),e.write(t.symmetry??0,2),e.write(Math.round((t.complexity??0)*254),8),e.write(Math.round((t.difficulty??0)*254),8),e.write(Math.round((t.pathLength??0)*254),8),t.availableColors&&t.availableColors.length>0){e.write(1,1),e.write(t.availableColors.length,4);for(let s of t.availableColors)e.write(s,3)}else e.write(0,1);if(t.defaultColors){let s=Object.entries(t.defaultColors);e.write(s.length,4);for(let[n,o]of s){let i=isNaN(Number(n))?ae[n]:Number(n);e.write(i,4),e.write(o,3)}}else e.write(0,4)}static readOptions(e){let t={},s=e.read(6),n=e.read(6);s>0&&(t.rows=s),n>0&&(t.cols=n),e.read(1)&&(t.useHexagons=!0),e.read(1)&&(t.useSquares=!0),e.read(1)&&(t.useStars=!0),e.read(1)&&(t.useTetris=!0),e.read(1)&&(t.useTetrisNegative=!0),e.read(1)&&(t.useEraser=!0),e.read(1)&&(t.useTriangles=!0),e.read(1)&&(t.useBrokenEdges=!0),t.symmetry=e.read(2);let o=()=>Math.round(e.read(8)/254*1e3)/1e3;if(t.complexity=o(),t.difficulty=o(),t.pathLength=o(),e.read(1)){let r=e.read(4);t.availableColors=[];for(let h=0;h<r;h++)t.availableColors.push(e.read(3))}let i=e.read(4);if(i>0){t.defaultColors={};for(let r=0;r<i;r++){let h=e.read(4),f=e.read(3);t.defaultColors[h]=f}}return t}static writePath(e,t){if(e.write(t.points.length,12),t.points.length!==0){e.write(t.points[0].x,6),e.write(t.points[0].y,6);for(let s=1;s<t.points.length;s++){let n=t.points[s-1],o=t.points[s],i=o.x-n.x,r=o.y-n.y,h=0;r===-1?h=0:i===1?h=1:r===1?h=2:i===-1&&(h=3),e.write(h,2)}}}static readPath(e){let t=e.read(12);if(t===0)return{points:[]};let s=[],n=e.read(6),o=e.read(6);s.push({x:n,y:o});for(let i=1;i<t;i++){let r=e.read(2);r===0?o--:r===1?n++:r===2?o++:r===3&&n--,s.push({x:n,y:o})}return{points:s}}static writeColorHex24(e,t){let s=/^#[0-9a-fA-F]{6}$/.test(t)?t:"#000000";e.write(parseInt(s.slice(1),16),24)}static readColorHex24(e){return`#${e.read(24).toString(16).padStart(6,"0")}`}static writeFilter(e,t){e.write(+!!t.enabled,1),e.write(t.mode==="rgb"?1:0,1),this.writeColorHex24(e,t.customColor??"#ffffff");let s=t.rgbColors??["#ff0000","#00ff00","#0000ff"];this.writeColorHex24(e,s[0]),this.writeColorHex24(e,s[1]),this.writeColorHex24(e,s[2]),e.write(Math.max(0,Math.min(2,t.rgbIndex??0)),2),e.write(Math.max(0,Math.min(255,Math.round(t.threshold??128))),8)}static readFilter(e){return{enabled:!!e.read(1),mode:e.read(1)?"rgb":"custom",customColor:this.readColorHex24(e),rgbColors:[this.readColorHex24(e),this.readColorHex24(e),this.readColorHex24(e)],rgbIndex:e.read(2),threshold:e.read(8)}}};var Te=class{generator;validator;constructor(){this.generator=new ue,this.validator=new le}createPuzzle(e,t,s={}){return this.generator.generate(e,t,s).export()}validateSolution(e,t){let s=ie.fromData(e);return this.validator.validate(s,t)}calculateDifficulty(e){let t=ie.fromData(e);return this.validator.calculateDifficulty(t)}};if(typeof self<"u"&&"postMessage"in self&&!("document"in self)){let B=new Te,e=null,t=null;self.addEventListener("message",s=>{let{type:n,payload:o}=s.data;switch(n){case"init":{let{canvas:i,options:r}=o;e=new de(i,void 0,r),e.on("path:complete",({path:h})=>{if(self.postMessage({type:"drawingEnded"}),self.postMessage({type:"pathComplete",payload:h}),r.autoValidate&&t){let f=B.validateSolution(t,{points:h});e.setValidationResult(f.isValid,f.invalidatedCells,f.invalidatedEdges,f.errorCells,f.errorEdges,f.invalidatedNodes,f.errorNodes),self.postMessage({type:"validationResult",payload:f})}});break}case"createPuzzle":{let{rows:i,cols:r,genOptions:h}=o,f=B.createPuzzle(i,r,h);self.postMessage({type:"puzzleCreated",payload:{puzzle:f,genOptions:h}});break}case"setPuzzle":{t=o.puzzle,e&&t&&(e.setPuzzle(t),o.options&&e.setOptions(o.options));break}case"setOptions":{e&&e.setOptions(o);break}case"setPath":{e&&e.setPath(o.path);break}case"setValidationResult":{e&&e.setValidationResult(o.isValid,o.invalidatedCells,o.invalidatedEdges,o.errorCells,o.errorEdges,o.invalidatedNodes,o.errorNodes);break}case"setCanvasRect":{e&&e.setCanvasRect(o);break}case"validate":{if(t){let i=B.validateSolution(t,{points:o.path});e&&e.setValidationResult(i.isValid,i.invalidatedCells,i.invalidatedEdges,i.errorCells,i.errorEdges,i.invalidatedNodes,i.errorNodes),self.postMessage({type:"validationResult",payload:i})}break}case"event":{let{eventType:i,eventData:r}=o;if(e)if(i==="mousedown"||i==="touchstart"){let h=e.handleStart(r,i==="touchstart"?"touch":"mouse");self.postMessage({type:"drawingStarted",payload:h})}else i==="mousemove"||i==="touchmove"?e.handleMove(r):(i==="mouseup"||i==="touchend")&&(e.handleEnd(r,i==="touchend"?"touch":"mouse"),self.postMessage({type:"drawingEnded"}));break}}})}export{ae as CellType,j as Color,Re as Direction,ce as EdgeType,ie as Grid,fe as NodeType,ue as PuzzleGenerator,Me as PuzzleSerializer,le as PuzzleValidator,Ne as RngType,ye as SymmetryType,Te as WitnessCore,de as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
