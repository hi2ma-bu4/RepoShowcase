/*!
 * MiniWitness 1.1.6
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var re=(s=>(s[s.Up=0]="Up",s[s.Right=1]="Right",s[s.Down=2]="Down",s[s.Left=3]="Left",s))(re||{}),X=(o=>(o[o.None=0]="None",o[o.Square=1]="Square",o[o.Star=2]="Star",o[o.Tetris=3]="Tetris",o[o.TetrisRotated=4]="TetrisRotated",o[o.Eraser=5]="Eraser",o))(X||{}),j=(s=>(s[s.Normal=0]="Normal",s[s.Broken=1]="Broken",s[s.Absent=2]="Absent",s[s.Hexagon=3]="Hexagon",s))(j||{}),J=(s=>(s[s.Normal=0]="Normal",s[s.Start=1]="Start",s[s.End=2]="End",s[s.Hexagon=3]="Hexagon",s))(J||{}),Q=(s=>(s[s.None=0]="None",s[s.Horizontal=1]="Horizontal",s[s.Vertical=2]="Vertical",s[s.Rotational=3]="Rotational",s))(Q||{}),$={None:0,Black:1,White:2,Red:3,Blue:4};var W=class L{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];symmetry=0;constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:$.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes,symmetry:this.symmetry}))}static fromData(e){let t=new L(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t.symmetry=e.symmetry||0,t}};var U=class{validate(e,t){let n=t.points;if(n.length<2)return{isValid:!1,errorReason:"Path too short"};let s=e.symmetry||0,i=[];if(s!==0)for(let c of n)i.push(this.getSymmetricalPoint(e,c));let o=n[0],a=n[n.length-1];if(e.nodes[o.y][o.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[a.y][a.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};if(s!==0){let c=i[0],d=i[i.length-1];if(e.nodes[c.y][c.x].type!==1)return{isValid:!1,errorReason:"Symmetrical path must start at Start Node"};if(e.nodes[d.y][d.x].type!==2)return{isValid:!1,errorReason:"Symmetrical path must end at End Node"}}let h=new Set,u=new Set;if(h.add(`${o.x},${o.y}`),s!==0){let c=i[0];if(h.has(`${c.x},${c.y}`))return{isValid:!1,errorReason:"Paths collide at start"};h.add(`${c.x},${c.y}`)}for(let c=0;c<n.length-1;c++){let d=n[c],f=n[c+1];if(Math.abs(d.x-f.x)+Math.abs(d.y-f.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let p=`${f.x},${f.y}`;if(h.has(p))return{isValid:!1,errorReason:"Self-intersecting path or path collision"};if(h.add(p),this.isBrokenEdge(e,d,f))return{isValid:!1,errorReason:"Passed through broken edge"};if(u.add(this.getEdgeKey(d,f)),s!==0){let g=i[c],m=i[c+1],x=`${m.x},${m.y}`;if(h.has(x))return{isValid:!1,errorReason:"Path collision"};if(h.add(x),this.isBrokenEdge(e,g,m))return{isValid:!1,errorReason:"Symmetrical path passed through broken edge"};let b=this.getEdgeKey(g,m);if(u.has(b))return{isValid:!1,errorReason:"Paths cross the same edge"};u.add(b)}}let l=this.calculateRegions(e,n,i),r=this.getMissedHexagons(e,n,i);return this.validateWithErasers(e,l,r.edges,r.nodes)}isBrokenEdge(e,t,n){let s;if(t.x===n.x){let i=Math.min(t.y,n.y);s=e.vEdges[i][t.x].type}else{let i=Math.min(t.x,n.x);s=e.hEdges[t.y][i].type}return s===1||s===2}isAbsentEdge(e,t,n){if(t.x===n.x){let s=Math.min(t.y,n.y);return e.vEdges[s][t.x].type===2}else{let s=Math.min(t.x,n.x);return e.hEdges[t.y][s].type===2}}getMissedHexagons(e,t,n=[]){let s=new Set,i=new Set;for(let h=0;h<t.length;h++)i.add(`${t[h].x},${t[h].y}`),h<t.length-1&&s.add(this.getEdgeKey(t[h],t[h+1]));for(let h=0;h<n.length;h++)i.add(`${n[h].x},${n[h].y}`),h<n.length-1&&s.add(this.getEdgeKey(n[h],n[h+1]));let o=[];for(let h=0;h<=e.rows;h++)for(let u=0;u<e.cols;u++)if(e.hEdges[h][u].type===3){let l=this.getEdgeKey({x:u,y:h},{x:u+1,y:h});s.has(l)||o.push({type:"h",r:h,c:u})}for(let h=0;h<e.rows;h++)for(let u=0;u<=e.cols;u++)if(e.vEdges[h][u].type===3){let l=this.getEdgeKey({x:u,y:h},{x:u,y:h+1});s.has(l)||o.push({type:"v",r:h,c:u})}let a=[];for(let h=0;h<=e.rows;h++)for(let u=0;u<=e.cols;u++)e.nodes[h][u].type===3&&(i.has(`${u},${h}`)||a.push({x:u,y:h}));return{edges:o,nodes:a}}validateWithErasers(e,t,n,s){let i=[],o=!0;for(let d=0;d<t.length;d++){let f=t[d],y=f.filter(b=>e.cells[b.y][b.x].type===5),p=f.filter(b=>e.cells[b.y][b.x].type!==0&&e.cells[b.y][b.x].type!==5),g=[];for(let b=0;b<n.length;b++)this.isHexagonAdjacentToRegion(e,n[b],f)&&g.push(b);let m=[];for(let b=0;b<s.length;b++)this.isNodeHexagonAdjacentToRegion(e,s[b],f)&&m.push(b);let x=this.getPossibleErasures(e,f,y,p,g,m);if(x.length===0){o=!1;let b=this.getBestEffortErasures(e,f,y,p,g,m);i.push([b])}else x.sort((b,P)=>{let R=b.invalidatedCells.length+b.invalidatedHexagons.length+b.invalidatedNodeHexagons.length,I=P.invalidatedCells.length+P.invalidatedHexagons.length+P.invalidatedNodeHexagons.length;return R-I}),i.push(x)}if(o){let d=this.findGlobalAssignment(i,n.length,s.length);if(d)return{isValid:!0,invalidatedCells:d.invalidatedCells,invalidatedEdges:d.invalidatedHexIndices.map(f=>n[f]),invalidatedNodes:d.invalidatedNodeHexIndices.map(f=>s[f])}}let a=[],h=[],u=new Set,l=new Set;for(let d of i){let f=d[0];a.push(...f.errorCells),h.push(...f.invalidatedCells);for(let y of f.invalidatedHexagons)u.add(y);for(let y of f.invalidatedNodeHexagons)l.add(y)}let r=[];for(let d=0;d<n.length;d++)u.has(d)||r.push(n[d]);let c=[];for(let d=0;d<s.length;d++)l.has(d)||c.push(s[d]);return{isValid:!1,errorReason:"Constraints failed",errorCells:a,errorEdges:r,errorNodes:c,invalidatedCells:h,invalidatedEdges:Array.from(u).map(d=>n[d]),invalidatedNodes:Array.from(l).map(d=>s[d])}}isHexagonAdjacentToRegion(e,t,n){let s=new Set(n.map(i=>`${i.x},${i.y}`));if(t.type==="h"){if(t.r>0&&s.has(`${t.c},${t.r-1}`)||t.r<e.rows&&s.has(`${t.c},${t.r}`))return!0}else if(t.c>0&&s.has(`${t.c-1},${t.r}`)||t.c<e.cols&&s.has(`${t.c},${t.r}`))return!0;return!1}isNodeHexagonAdjacentToRegion(e,t,n){let s=new Set(n.map(o=>`${o.x},${o.y}`)),i=[{x:t.x-1,y:t.y-1},{x:t.x,y:t.y-1},{x:t.x-1,y:t.y},{x:t.x,y:t.y}];for(let o of i)if(o.x>=0&&o.x<e.cols&&o.y>=0&&o.y<e.rows&&s.has(`${o.x},${o.y}`))return!0;return!1}getPossibleErasures(e,t,n,s,i,o){let a=[],h=n.length;if(h===0)return this.getRegionErrors(e,t,[]).length===0&&i.length===0&&o.length===0&&a.push({invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!0,errorCells:[]}),a;let u=[...s.map(r=>({type:"cell",pos:r})),...i.map(r=>({type:"hex",index:r})),...o.map(r=>({type:"nodeHex",index:r}))],l=this.getRegionErrors(e,t,[]).length===0&&i.length===0&&o.length===0;for(let r=0;r<=h;r++){let c=this.getNCombinations(n,r);for(let d of c){let f=new Set(d.map(p=>`${p.x},${p.y}`)),y=n.filter(p=>!f.has(`${p.x},${p.y}`));for(let p=0;p<=u.length;p++){if(y.length!==r+p)continue;let g=this.getNCombinations(u,p);for(let m of g){let x=m.filter(C=>C.type==="cell").map(C=>C.pos),b=m.filter(C=>C.type==="hex").map(C=>C.index),P=m.filter(C=>C.type==="nodeHex").map(C=>C.index);if(this.getRegionErrors(e,t,[...x,...d]).length===0){let C=!0;if(l)p>0&&(C=!1);else for(let N=0;N<m.length;N++){let A=[...m.slice(0,N),...m.slice(N+1)],v=A.filter(w=>w.type==="cell").map(w=>w.pos),S=new Set(A.filter(w=>w.type==="hex").map(w=>w.index)),z=new Set(A.filter(w=>w.type==="nodeHex").map(w=>w.index)),D=i.every(w=>S.has(w)),E=o.every(w=>z.has(w));if(this.getRegionErrors(e,t,v).length===0&&D&&E){C=!1;break}}C&&a.push({invalidatedCells:[...x,...d],invalidatedHexagons:b,invalidatedNodeHexagons:P,isValid:!0,errorCells:[]})}}}}}return a}getBestEffortErasures(e,t,n,s,i,o){let a=this.getRegionErrors(e,t,[]);if(a.length===0&&i.length===0&&o.length===0)return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:[...n]};if(n.length>0){let l=[...s.map(f=>({type:"cell",pos:f})),...i.map(f=>({type:"hex",index:f})),...o.map(f=>({type:"nodeHex",index:f}))],r=null,c=1/0,d=f=>{let y=[],p=[],g=[],m=0;for(let C of f)m<n.length&&(C.type==="cell"?y.push(C.pos):C.type==="hex"?p.push(C.index):g.push(C.index),m++);let x=n.length-m,b=Math.floor(x/2),P=n.slice(m,m+b);m+=b*2;let R=this.getRegionErrors(e,t,[...y,...P]);for(let C=m;C<n.length;C++)R.push(n[C]);let I=R.length;I<c&&(c=I,r={invalidatedCells:[...y,...P],invalidatedHexagons:p,invalidatedNodeHexagons:g,isValid:!1,errorCells:R})};d([...a.map(f=>({type:"cell",pos:f})),...i.map(f=>({type:"hex",index:f})),...o.map(f=>({type:"nodeHex",index:f}))]),d(l);for(let f of a)d([{type:"cell",pos:f}]);if(r)return r}let u=[...a,...n];return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:u}}getNCombinations(e,t){let n=[],s=(i,o)=>{if(o.length===t){n.push([...o]);return}for(let a=i;a<e.length;a++)o.push(e[a]),s(a+1,o),o.pop()};return s(0,[]),n}checkRegionValid(e,t,n){return this.getRegionErrors(e,t,n).length===0}getRegionErrors(e,t,n){let s=new Set(n.map(r=>`${r.x},${r.y}`)),i=new Map,o=new Map,a=new Set,h=new Set,u=[];for(let r of t){if(s.has(`${r.x},${r.y}`))continue;let c=e.cells[r.y][r.x];if(c.type===0)continue;let d=c.color;d!==$.None&&(i.set(d,(i.get(d)||0)+1),o.has(d)||o.set(d,[]),o.get(d).push(r)),c.type===1?h.add(d):c.type===2?a.add(d):(c.type===3||c.type===4)&&c.shape&&u.push({shape:c.shape,rotatable:c.type===4,pos:r})}let l=[];if(h.size>1)for(let r of t)s.has(`${r.x},${r.y}`)||e.cells[r.y][r.x].type===1&&l.push(r);for(let r of a)if(i.get(r)!==2){let c=o.get(r)||[];for(let d of c)e.cells[d.y][d.x].type===2&&l.push(d)}if(u.length>0&&!this.checkTetrisConstraint(t,u.map(r=>({shape:r.shape,rotatable:r.rotatable}))))for(let r of u)l.push(r.pos);return l}findGlobalAssignment(e,t,n){let s=e.length,i=new Array(t).fill(0),o=new Array(n).fill(0),a=[],h=[],u=[],l=r=>{if(r===s)return i.every(c=>c===1)&&o.every(c=>c===1);for(let c of e[r]){let d=!0;for(let f of c.invalidatedHexagons)if(i[f]>0){d=!1;break}if(d){for(let f of c.invalidatedNodeHexagons)if(o[f]>0){d=!1;break}}if(d){for(let f of c.invalidatedHexagons)i[f]++,h.push(f);for(let f of c.invalidatedNodeHexagons)o[f]++,u.push(f);if(a.push(...c.invalidatedCells),l(r+1))return!0;for(let f of c.invalidatedHexagons)i[f]--,h.pop();for(let f of c.invalidatedNodeHexagons)o[f]--,u.pop();for(let f=0;f<c.invalidatedCells.length;f++)a.pop()}}return!1};return l(0)?{invalidatedCells:a,invalidatedHexIndices:h,invalidatedNodeHexIndices:u}:null}checkTetrisConstraint(e,t){if(t.reduce((r,c)=>r+this.getShapeArea(c.shape),0)!==e.length)return!1;let s=Math.min(...e.map(r=>r.x)),i=Math.min(...e.map(r=>r.y)),o=Math.max(...e.map(r=>r.x)),a=Math.max(...e.map(r=>r.y)),h=o-s+1,u=a-i+1,l=Array.from({length:u},()=>Array(h).fill(!1));for(let r of e)l[r.y-i][r.x-s]=!0;return this.canTile(l,t)}getShapeArea(e){let t=0;for(let n of e)for(let s of n)s&&t++;return t}canTile(e,t){let n=-1,s=-1;for(let i=0;i<e.length;i++){for(let o=0;o<e[0].length;o++)if(e[i][o]){n=i,s=o;break}if(n!==-1)break}if(n===-1)return t.length===0;if(t.length===0)return!1;for(let i=0;i<t.length;i++){let o=t[i],a=[...t.slice(0,i),...t.slice(i+1)],h=o.rotatable?this.getAllRotations(o.shape):[o.shape];for(let u of h){let l=[];for(let r=0;r<u.length;r++)for(let c=0;c<u[0].length;c++)u[r][c]&&l.push({r,c});for(let r of l){let c=n-r.r,d=s-r.c;if(this.canPlace(e,u,c,d)){if(this.placePiece(e,u,c,d,!1),this.canTile(e,a))return!0;this.placePiece(e,u,c,d,!0)}}}}return!1}canPlace(e,t,n,s){for(let i=0;i<t.length;i++)for(let o=0;o<t[0].length;o++)if(t[i][o]){let a=n+i,h=s+o;if(a<0||a>=e.length||h<0||h>=e[0].length||!e[a][h])return!1}return!0}placePiece(e,t,n,s,i){for(let o=0;o<t.length;o++)for(let a=0;a<t[0].length;a++)t[o][a]&&(e[n+o][s+a]=i)}getAllRotations(e){let t=[],n=new Set,s=e;for(let i=0;i<4;i++){let o=JSON.stringify(s);n.has(o)||(t.push(s),n.add(o)),s=this.rotate90(s)}return t}rotate90(e){let t=e.length,n=e[0].length,s=Array.from({length:n},()=>Array(t).fill(0));for(let i=0;i<t;i++)for(let o=0;o<n;o++)s[o][t-1-i]=e[i][o];return s}calculateRegions(e,t,n=[]){let s=[],i=new Set,o=new Set;for(let h=0;h<t.length-1;h++)o.add(this.getEdgeKey(t[h],t[h+1]));for(let h=0;h<n.length-1;h++)o.add(this.getEdgeKey(n[h],n[h+1]));let a=this.getExternalCells(e);for(let h=0;h<e.rows;h++)for(let u=0;u<e.cols;u++){if(i.has(`${u},${h}`)||a.has(`${u},${h}`))continue;let l=[],r=[{x:u,y:h}];for(i.add(`${u},${h}`);r.length>0;){let c=r.shift();l.push(c);let d=[{nx:c.x,ny:c.y-1,p1:{x:c.x,y:c.y},p2:{x:c.x+1,y:c.y}},{nx:c.x,ny:c.y+1,p1:{x:c.x,y:c.y+1},p2:{x:c.x+1,y:c.y+1}},{nx:c.x-1,ny:c.y,p1:{x:c.x,y:c.y},p2:{x:c.x,y:c.y+1}},{nx:c.x+1,ny:c.y,p1:{x:c.x+1,y:c.y},p2:{x:c.x+1,y:c.y+1}}];for(let f of d)if(f.nx>=0&&f.nx<e.cols&&f.ny>=0&&f.ny<e.rows){let y=`${f.nx},${f.ny}`;if(!i.has(y)&&!a.has(y)){let p=this.getEdgeKey(f.p1,f.p2);!o.has(p)&&!this.isAbsentEdge(e,f.p1,f.p2)&&(i.add(y),r.push({x:f.nx,y:f.ny}))}}}s.push(l)}return s}getExternalCells(e){let t=new Set,n=[];for(let s=0;s<e.cols;s++)e.hEdges[0][s].type===2&&(t.has(`${s},0`)||(t.add(`${s},0`),n.push({x:s,y:0}))),e.hEdges[e.rows][s].type===2&&(t.has(`${s},${e.rows-1}`)||(t.add(`${s},${e.rows-1}`),n.push({x:s,y:e.rows-1})));for(let s=0;s<e.rows;s++)e.vEdges[s][0].type===2&&(t.has(`0,${s}`)||(t.add(`0,${s}`),n.push({x:0,y:s}))),e.vEdges[s][e.cols].type===2&&(t.has(`${e.cols-1},${s}`)||(t.add(`${e.cols-1},${s}`),n.push({x:e.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),i=[{nx:s.x,ny:s.y-1,edge:e.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:e.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:e.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:e.vEdges[s.y][s.x+1]}];for(let o of i)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return t}getSymmetricalPoint(e,t){let n=e.symmetry||0;return n===1?{x:e.cols-t.x,y:t.y}:n===2?{x:t.x,y:e.rows-t.y}:n===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getSymmetricalPointIndex(e,t){let n=e.cols+1,s=Math.floor(t/n),i=t%n,o=e.symmetry||0,a=s,h=i;return o===1?h=e.cols-i:o===2?a=e.rows-s:o===3&&(h=e.cols-i,a=e.rows-s),a*n+h}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}calculateDifficulty(e){let t=e.rows,n=e.cols,s=n+1,i=(t+1)*s,o=Array.from({length:i},()=>[]),a=[],h=[],u=new Set,l=new Set;for(let v=0;v<=t;v++)for(let S=0;S<=n;S++){let z=v*s+S;if(e.nodes[v][S].type===1&&a.push(z),e.nodes[v][S].type===2&&h.push(z),e.nodes[v][S].type===3&&l.add(z),S<n){let D=z+1,E=e.hEdges[v][S].type,w=E===3,H=E===1||E===2;o[z].push({next:D,isHexagon:w,isBroken:H}),o[D].push({next:z,isHexagon:w,isBroken:H}),w&&u.add(this.getEdgeKey({x:S,y:v},{x:S+1,y:v}))}if(v<t){let D=z+s,E=e.vEdges[v][S].type,w=E===3,H=E===1||E===2;o[z].push({next:D,isHexagon:w,isBroken:H}),o[D].push({next:z,isHexagon:w,isBroken:H}),w&&u.add(this.getEdgeKey({x:S,y:v},{x:S,y:v+1}))}}let r={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},c=u.size+l.size,d=new Set,f=Math.max(1e3,t*n*200);for(let v of a){let S=l.has(v)?1:0,z=e.symmetry||0,D=1n<<BigInt(v);if(z!==0){let E=this.getSymmetricalPointIndex(e,v);if(E===v)continue;D|=1n<<BigInt(E)}this.exploreSearchSpace(e,v,D,[v],S,c,o,h,d,r,f)}if(r.solutions===0)return 0;let y=u.size+l.size,p=new Set;u.size>0&&p.add(999);let g=0,m=0;for(let v=0;v<t;v++)for(let S=0;S<n;S++){let z=e.cells[v][S];z.type!==0&&(y++,p.add(z.type),z.type===3?g++:z.type===4&&(g++,m++))}let x=r.branchingPoints/(r.totalNodesVisited||1),b=Math.log10(r.totalNodesVisited+1),P=(x*10+b*1.5)/(Math.log2(r.solutions+1)*.5+1);P-=u.size*.05,P+=l.size*.12,g>0&&(P+=m*.5,P+=(g-m)*.2);let R=t*n,I=y/R,C=I<.25?Math.pow(I/.25,4):1,N=p.size<=1?.5:1;P*=C*N;let A=Math.log2(R)/5;return P*=A,Math.max(.01,Math.min(1,P/4))}exploreSearchSpace(e,t,n,s,i,o,a,h,u,l,r){if(l.totalNodesVisited++,l.maxDepth=Math.max(l.maxDepth,s.length),l.totalNodesVisited>r)return;let c=e.symmetry||0;if(h.includes(t)){if(i===o){let y={points:s.map(p=>({x:p%(e.cols+1),y:Math.floor(p/(e.cols+1))}))};if(c!==0){let p=this.getSymmetricalPointIndex(e,t),g=e.cols+1;if(e.nodes[Math.floor(p/g)][p%g].type!==2)return}if(this.validate(e,y).isValid){let p=this.getFingerprint(e,y.points);u.has(p)||(u.add(p),l.solutions++)}}return}if(!this.canReachEndOptimized(t,n,a,h)){l.backtracks++;return}let d=[];for(let y of a[t]){if(y.isBroken||n&1n<<BigInt(y.next))continue;if(c!==0){let g=this.getSymmetricalPointIndex(e,t),m=this.getSymmetricalPointIndex(e,y.next);if(y.next===m||t===m&&y.next===g)continue}let p=!0;for(let g of a[t])if(g.isHexagon){let m=s.length>=2&&g.next===s[s.length-2],x=g.next===y.next;if(!m&&!x){p=!1;break}}p&&d.push(y)}if(d.length>1&&l.branchingPoints++,e.rows*e.cols>30)for(let y=d.length-1;y>0;y--){let p=Math.floor(Math.random()*(y+1));[d[y],d[p]]=[d[p],d[y]]}let f=e.cols+1;for(let y of d){let p=e.nodes[Math.floor(y.next/f)][y.next%f].type===3?1:0;s.push(y.next);let g=n|1n<<BigInt(y.next);if(c!==0){let m=this.getSymmetricalPointIndex(e,y.next);g|=1n<<BigInt(m)}if(this.exploreSearchSpace(e,y.next,g,s,i+(y.isHexagon?1:0)+p,o,a,h,u,l,r),s.pop(),l.totalNodesVisited>r)return}}countSolutions(e,t=100){let n=e.rows,s=e.cols,i=s+1,o=(n+1)*i,a=Array.from({length:o},()=>[]),h=[],u=[],l=new Set,r=new Set;for(let f=0;f<=n;f++)for(let y=0;y<=s;y++){let p=f*i+y;if(e.nodes[f][y].type===1&&h.push(p),e.nodes[f][y].type===2&&u.push(p),e.nodes[f][y].type===3&&r.add(p),y<s){let g=p+1,m=e.hEdges[f][y].type,x=m===3,b=m===1||m===2;a[p].push({next:g,isHexagon:x,isBroken:b}),a[g].push({next:p,isHexagon:x,isBroken:b}),x&&l.add(this.getEdgeKey({x:y,y:f},{x:y+1,y:f}))}if(f<n){let g=p+i,m=e.vEdges[f][y].type,x=m===3,b=m===1||m===2;a[p].push({next:g,isHexagon:x,isBroken:b}),a[g].push({next:p,isHexagon:x,isBroken:b}),x&&l.add(this.getEdgeKey({x:y,y:f},{x:y,y:f+1}))}}let c=new Set,d=l.size+r.size;for(let f of h){let y=r.has(f)?1:0,p=e.symmetry||0,g=1n<<BigInt(f);if(p!==0){let m=this.getSymmetricalPointIndex(e,f);if(m===f)continue;g|=1n<<BigInt(m)}this.findPathsOptimized(e,f,g,[f],y,d,a,u,c,t)}return c.size}findPathsOptimized(e,t,n,s,i,o,a,h,u,l){if(u.size>=l)return;let r=e.symmetry||0;if(h.includes(t)){if(i===o){if(r!==0){let d=this.getSymmetricalPointIndex(e,t),f=e.cols+1;if(e.nodes[Math.floor(d/f)][d%f].type!==2)return}let c={points:s.map(d=>({x:d%(e.cols+1),y:Math.floor(d/(e.cols+1))}))};this.validate(e,c).isValid&&u.add(this.getFingerprint(e,c.points))}return}if(this.canReachEndOptimized(t,n,a,h))for(let c of a[t]){if(c.isBroken||n&1n<<BigInt(c.next))continue;if(r!==0){let g=this.getSymmetricalPointIndex(e,t),m=this.getSymmetricalPointIndex(e,c.next);if(c.next===m||t===m&&c.next===g)continue}let d=!0;for(let g of a[t])if(g.isHexagon){let m=s.length>=2&&g.next===s[s.length-2],x=g.next===c.next;if(!m&&!x){d=!1;break}}if(!d)continue;let f=e.cols+1,y=e.nodes[Math.floor(c.next/f)][c.next%f].type===3?1:0;s.push(c.next);let p=n|1n<<BigInt(c.next);if(r!==0){let g=this.getSymmetricalPointIndex(e,c.next);p|=1n<<BigInt(g)}if(this.findPathsOptimized(e,c.next,p,s,i+(c.isHexagon?1:0)+y,o,a,h,u,l),s.pop(),u.size>=l)return}}canReachEndOptimized(e,t,n,s){let i=[e],o=t,a=0;for(;a<i.length;){let h=i[a++];if(s.includes(h))return!0;for(let u of n[h])!u.isBroken&&!(o&1n<<BigInt(u.next))&&(o|=1n<<BigInt(u.next),i.push(u.next))}return!1}getFingerprint(e,t){return this.calculateRegions(e,t).map(i=>i.map(a=>e.cells[a.y][a.x]).filter(a=>a.type!==0).map(a=>`${a.type}:${a.color}`).sort().join(",")).sort().filter(i=>i.length>0).join("|")||"empty"}};var _=class{generate(e,t,n={}){let s=n.difficulty??.5,i=new U,o=null,a=-1,h=e*t>30?50:80,u=5,l=n.symmetry||0,r={x:0,y:e},c={x:t,y:0};l===1?c={x:0,y:0}:l===2?c={x:t,y:e}:l===3&&(c={x:t,y:e});let d=null;for(let f=0;f<h;f++){f%u===0&&(d=this.generateRandomPath(new W(e,t),r,c,n.pathLength,l));let y=this.generateFromPath(e,t,d,n);if(!this.checkAllRequestedConstraintsPresent(y,n))continue;let p=i.calculateDifficulty(y);if(p===0)continue;let g=Math.abs(p-s);if((o===null||g<Math.abs(a-s))&&(a=p,o=y),s>.8&&p>.8||g<.05)break}if(!o){let f=this.generateRandomPath(new W(e,t),r,c,n.pathLength);return this.generateFromPath(e,t,f,n)}return o}generateFromPath(e,t,n,s){let i=new W(e,t),o=s.symmetry||0;i.symmetry=o;let a={x:0,y:e},h={x:t,y:0};if(o===1?h={x:0,y:0}:o===2?h={x:t,y:e}:o===3&&(h={x:t,y:e}),i.nodes[a.y][a.x].type=1,i.nodes[h.y][h.x].type=2,o!==0){let l=this.getSymmetricalPoint(i,a,o),r=this.getSymmetricalPoint(i,h,o);i.nodes[l.y][l.x].type=1,i.nodes[r.y][r.x].type=2}let u=o!==0?n.map(l=>this.getSymmetricalPoint(i,l,o)):[];return this.applyConstraintsBasedOnPath(i,n,s,u),s.useBrokenEdges&&this.applyBrokenEdges(i,n,s),this.cleanGrid(i),i}generateRandomPath(e,t,n,s,i=0){if(s===void 0)return this.generateSingleRandomPath(e,t,n,void 0,i);let o=e.rows+e.cols,a=(e.rows+1)*(e.cols+1)-1,h=o+s*(a-o),u=[],l=1/0,r=50;for(let c=0;c<r;c++){let d=this.generateSingleRandomPath(e,t,n,s,i),f=d.length-1,y=Math.abs(f-h);if(y<l&&(l=y,u=d),l<=1)break}return u}generateSingleRandomPath(e,t,n,s,i=0){let o=new Set,a=[],h=u=>{o.add(`${u.x},${u.y}`);let l=this.getSymmetricalPoint(e,u,i);if(o.add(`${l.x},${l.y}`),a.push(u),u.x===n.x&&u.y===n.y)return!0;let r=this.getValidNeighbors(e,u,o);i!==0&&(r=r.filter(c=>{let d=this.getSymmetricalPoint(e,c,i);if(d.x<0||d.x>e.cols||d.y<0||d.y>e.rows||o.has(`${d.x},${d.y}`)||c.x===d.x&&c.y===d.y)return!1;let f=this.getEdgeKey(u,c),y=this.getEdgeKey(l,d);return f!==y})),s!==void 0?r.sort((c,d)=>{let f=Math.abs(c.x-n.x)+Math.abs(c.y-n.y),y=Math.abs(d.x-n.x)+Math.abs(d.y-n.y);return(f-y)*(1-s*2)+(Math.random()-.5)*1.5}):this.shuffleArray(r);for(let c of r)if(h(c))return!0;return a.pop(),o.delete(`${u.x},${u.y}`),o.delete(`${l.x},${l.y}`),!1};return h(t),a}getValidNeighbors(e,t,n){let s=[],i=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of i){let a=t.x+o.x,h=t.y+o.y;a>=0&&a<=e.cols&&h>=0&&h<=e.rows&&(n.has(`${a},${h}`)||s.push({x:a,y:h}))}return s}applyBrokenEdges(e,t,n){let s=n.complexity??.5,i=new Set;for(let l=0;l<t.length-1;l++)i.add(this.getEdgeKey(t[l],t[l+1]));let o=[];for(let l=0;l<=e.rows;l++)for(let r=0;r<e.cols;r++){let c={x:r,y:l},d={x:r+1,y:l};i.has(this.getEdgeKey(c,d))||o.push({type:"h",r:l,c:r,p1:c,p2:d})}for(let l=0;l<e.rows;l++)for(let r=0;r<=e.cols;r++){let c={x:r,y:l},d={x:r,y:l+1};i.has(this.getEdgeKey(c,d))||o.push({type:"v",r:l,c:r,p1:c,p2:d})}this.shuffleArray(o);let a=Math.max(1,Math.floor(s*(e.rows*e.cols)/4)),h=0;for(let l of o){if(h>=a)break;l.type==="h"?e.hEdges[l.r][l.c].type=1:e.vEdges[l.r][l.c].type=1,h++}let u=!0;for(;u;){u=!1;for(let l=0;l<=e.rows;l++)for(let r=0;r<e.cols;r++)e.hEdges[l][r].type===1&&this.canBecomeAbsent(e,{type:"h",r:l,c:r})&&(e.hEdges[l][r].type=2,u=!0);for(let l=0;l<e.rows;l++)for(let r=0;r<=e.cols;r++)e.vEdges[l][r].type===1&&this.canBecomeAbsent(e,{type:"v",r:l,c:r})&&(e.vEdges[l][r].type=2,u=!0)}for(let l=0;l<=e.rows;l++)for(let r=0;r<=e.cols;r++){let c=[];if(r>0&&c.push({e:e.hEdges[l][r-1],type:"h",r:l,c:r-1}),r<e.cols&&c.push({e:e.hEdges[l][r],type:"h",r:l,c:r}),l>0&&c.push({e:e.vEdges[l-1][r],type:"v",r:l-1,c:r}),l<e.rows&&c.push({e:e.vEdges[l][r],type:"v",r:l,c:r}),c.length>0&&c.every(d=>d.e.type===1||d.e.type===2)&&c.every(d=>!this.isAdjacentToMark(e,d)))for(let d of c)d.e.type=2}}canBecomeAbsent(e,t){if(this.isAdjacentToMark(e,t))return!1;if(t.type==="h"){if(t.r===0||t.r===e.rows)return!0}else if(t.c===0||t.c===e.cols)return!0;let n=t.type==="h"?[{x:t.c,y:t.r},{x:t.c+1,y:t.r}]:[{x:t.c,y:t.r},{x:t.c,y:t.r+1}];for(let s of n){let i=[{type:"h",r:s.y,c:s.x-1},{type:"h",r:s.y,c:s.x},{type:"v",r:s.y-1,c:s.x},{type:"v",r:s.y,c:s.x}];for(let o of i)if(o.c>=0&&o.c<=e.cols&&o.r>=0&&o.r<=e.rows){if(o.type==="h"&&o.c<e.cols){if(e.hEdges[o.r][o.c].type===2)return!0}else if(o.type==="v"&&o.r<e.rows&&e.vEdges[o.r][o.c].type===2)return!0}}return!1}cleanGrid(e){let t=[];for(let o=0;o<=e.rows;o++)for(let a=0;a<=e.cols;a++)e.nodes[o][a].type===1&&t.push({x:a,y:o});let n=new Set,s=[...t];for(let o of t)n.add(`${o.x},${o.y}`);for(;s.length>0;){let o=s.shift(),a=[{nx:o.x,ny:o.y-1,edge:e.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:e.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:e.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:e.hEdges[o.y]?.[o.x]}];for(let h of a)h.edge&&h.edge.type!==2&&(n.has(`${h.nx},${h.ny}`)||(n.add(`${h.nx},${h.ny}`),s.push({x:h.nx,y:h.ny})))}for(let o=0;o<=e.rows;o++)for(let a=0;a<e.cols;a++)(!n.has(`${a},${o}`)||!n.has(`${a+1},${o}`))&&(e.hEdges[o][a].type=2);for(let o=0;o<e.rows;o++)for(let a=0;a<=e.cols;a++)(!n.has(`${a},${o}`)||!n.has(`${a},${o+1}`))&&(e.vEdges[o][a].type=2);let i=this.getExternalCells(e);for(let o of i){let[a,h]=o.split(",").map(Number);e.cells[h][a].type=0}}getExternalCells(e){let t=new Set,n=[];for(let s=0;s<e.cols;s++)e.hEdges[0][s].type===2&&(t.has(`${s},0`)||(t.add(`${s},0`),n.push({x:s,y:0}))),e.hEdges[e.rows][s].type===2&&(t.has(`${s},${e.rows-1}`)||(t.add(`${s},${e.rows-1}`),n.push({x:s,y:e.rows-1})));for(let s=0;s<e.rows;s++)e.vEdges[s][0].type===2&&(t.has(`0,${s}`)||(t.add(`0,${s}`),n.push({x:0,y:s}))),e.vEdges[s][e.cols].type===2&&(t.has(`${e.cols-1},${s}`)||(t.add(`${e.cols-1},${s}`),n.push({x:e.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),i=[{nx:s.x,ny:s.y-1,edge:e.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:e.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:e.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:e.vEdges[s.y][s.x+1]}];for(let o of i)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return t}isAdjacentToMark(e,t){if(t.type==="h"){if(t.r>0&&e.cells[t.r-1][t.c].type!==0||t.r<e.rows&&e.cells[t.r][t.c].type!==0)return!0}else if(t.c>0&&e.cells[t.r][t.c-1].type!==0||t.c<e.cols&&e.cells[t.r][t.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let t=0;t<e.rows;t++)for(let n=0;n<e.cols;n++){if(e.cells[t][n].type===0)continue;if([e.hEdges[t][n],e.hEdges[t+1][n],e.vEdges[t][n],e.vEdges[t][n+1]].every(i=>i.type===1||i.type===2))return!0}return!1}getSymmetricalPoint(e,t,n){return n===1?{x:e.cols-t.x,y:t.y}:n===2?{x:t.x,y:e.rows-t.y}:n===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,t,n,s=[]){let i=n.complexity??.5,o=n.useHexagons??!0,a=n.useSquares??!0,h=n.useStars??!0,u=n.useTetris??!1,l=n.useEraser??!1,r=0,c=0,d=0,f=0,y=0,p=0,g=Math.floor(e.rows*e.cols*.45);if(o){let m=n.difficulty??.5;for(let x=0;x<t.length-1;x++){let P=this.getValidNeighbors(e,t[x],new Set).length>2,R=i*(m<.4?.6:.3);P&&(R=m<.4?R*1:R*.5),Math.random()<R&&(this.setEdgeHexagon(e,t[x],t[x+1]),r++)}for(let x=0;x<t.length;x++){let b=t[x];if(e.nodes[b.y][b.x].type!==0||this.hasIncidentHexagonEdge(e,b))continue;let P=i*(m>.6?.15:.05);Math.random()<P&&(e.nodes[b.y][b.x].type=3,r++)}if(r===0&&t.length>=2){let x=Math.floor(Math.random()*(t.length-1));this.setEdgeHexagon(e,t[x],t[x+1])}}if(a||h||u||l){let m=this.calculateRegions(e,t,s),x=n.availableColors??[$.Black,$.White,$.Red,$.Blue],b=n.defaultColors??{},P=(N,A)=>{if(b[N]!==void 0)return b[N];let v=X[N];return v&&b[v]!==void 0?b[v]:A},R=Array.from({length:m.length},(N,A)=>A);this.shuffleArray(R);let I=new Set,C={square:a,star:h,tetris:u,eraser:l};for(let N=0;N<R.length;N++){let A=R[N],v=m[A],S=R.length-N,z=C.square&&c===0||C.star&&d===0||C.tetris&&f===0||C.eraser&&y===0,D=.2+i*.6;if(z&&S<=3?D=1:z&&S<=6&&(D=.7),Math.random()>D)continue;let E=[...v];this.shuffleArray(E);let w=x[Math.floor(Math.random()*x.length)];if(a&&!h&&S<=2&&I.size===1){let V=x.filter(O=>!I.has(O));V.length>0&&(w=V[Math.floor(Math.random()*V.length)])}let H=a&&Math.random()<.5+i*.3;if(a&&c===0&&S<=2&&(H=!0),a&&!h&&S<=2&&I.size<2&&c>0&&(H=!0),H&&E.length>0){let V=Math.min(E.length,Math.max(4,Math.floor(v.length/4))),O=Math.floor(Math.random()*(V/2))+Math.ceil(V/2);for(let B=0;B<O&&E.length!==0;B++){let G=E.pop();e.cells[G.y][G.x].type=1,e.cells[G.y][G.x].color=w,c++,I.add(w)}}if(u&&p<g){let V=Math.random()<.1+i*.4;f===0&&S<=2&&(V=!0);let O=f===0&&S<=2?6:4;if(V&&E.length>0&&v.length<=O*4&&p+v.length<=g){let B=this.generateTiling(v,O,n);if(B){for(let G of B){if(E.length===0)break;let T=E.pop();e.cells[T.y][T.x].type=G.isRotated?4:3,e.cells[T.y][T.x].shape=G.isRotated?G.displayShape:G.shape;let F=P(3,$.None);if(h&&Math.random()<.5){let M=x.filter(k=>k!==$.Blue&&k!==F);M.length>0&&(F=M[Math.floor(Math.random()*M.length)])}e.cells[T.y][T.x].color=F,f++}p+=v.length}}}if(l&&y<1){let V=.05+i*.2,O=Math.random()<V;if(S<=2&&(O=!0),O&&E.length>=1){let B=[];h&&B.push("star"),a&&B.push("square");let G=[];o&&(G=this.getRegionBoundaryEdges(e,v,t,s),G.length>0&&B.push("hexagon")),u&&B.push("tetris");let T=B.length>0?B[Math.floor(Math.random()*B.length)]:null;E.length>=2&&(!T||Math.random()<.01)&&(T="eraser");let F=!1;if(T==="hexagon"){let M=G.filter(k=>!this.isEdgeAdjacentToHexagonNode(e,k));if(M.length>0){let k=M[Math.floor(Math.random()*M.length)];k.type==="h"?e.hEdges[k.r][k.c].type=3:e.vEdges[k.r][k.c].type=3,r++,F=!0}}else if(T==="square"&&E.length>=2){let M=E.pop();e.cells[M.y][M.x].type=1;let k=v.find(q=>e.cells[q.y][q.x].type===1),K=k?e.cells[k.y][k.x].color:void 0;e.cells[M.y][M.x].color=x.find(q=>q!==K)||$.Red,c++,F=!0}else if(T==="star"&&E.length>=2){let M=E.pop();e.cells[M.y][M.x].type=2,e.cells[M.y][M.x].color=x[Math.floor(Math.random()*x.length)],d++,F=!0}else if(T==="tetris"&&E.length>=2){let M=this.generateTiling(v,4,n),k=[];if(M&&M.length>0){let K=0;for(let q of M){let Y=this.getShapeArea(q.shape);if(K+Y<v.length)k.push(q),K+=Y;else break}}if(k.length===0&&v.length>1&&(k=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),k.length>0){for(let K of k){if(E.length<2)break;let q=E.pop();e.cells[q.y][q.x].type=K.isRotated?4:3,e.cells[q.y][q.x].shape=K.isRotated?K.displayShape:K.shape;let Y=$.None;if(h&&Math.random()<.3){let ne=x.filter(ie=>ie!==$.Blue);Y=ne[Math.floor(Math.random()*ne.length)]}e.cells[q.y][q.x].color=Y,f++}F=!0}}else if(T==="eraser"&&E.length>=2){let M=E.pop();e.cells[M.y][M.x].type=5,e.cells[M.y][M.x].color=P(5,$.White),y++,F=!0}if(!F&&E.length>=2){let M=E.pop();e.cells[M.y][M.x].type=5,e.cells[M.y][M.x].color=P(5,$.White),y++,F=!0}if(F){let M=E.pop();e.cells[M.y][M.x].type=5;let k=P(5,$.White);if(h&&Math.random()<.4){let K=x.filter(q=>q!==k);K.length>0&&(k=K[Math.floor(Math.random()*K.length)])}e.cells[M.y][M.x].color=k,y++}}}if(h){let V=Math.max(1,Math.floor(v.length/8));for(let O=0;O<V;O++)for(let B of x){if(E.length<1)break;if(Math.random()>.3+i*.4)continue;let G=v.filter(T=>e.cells[T.y][T.x].color===B).length;if(G===1){let T=E.pop();e.cells[T.y][T.x].type=2,e.cells[T.y][T.x].color=B,d++}else if(G===0&&E.length>=2)for(let T=0;T<2;T++){let F=E.pop();e.cells[F.y][F.x].type=2,e.cells[F.y][F.x].color=B,d++}}}}if(a&&!h&&I.size<2){for(let N of m)if(N.every(A=>e.cells[A.y][A.x].type===0)){let A=x.find(S=>!I.has(S))||$.White,v=N[Math.floor(Math.random()*N.length)];e.cells[v.y][v.x].type=1,e.cells[v.y][v.x].color=A,I.add(A),c++;break}}}}calculateRegions(e,t,n=[]){let s=[],i=new Set,o=new Set;for(let a=0;a<t.length-1;a++)o.add(this.getEdgeKey(t[a],t[a+1]));for(let a=0;a<n.length-1;a++)o.add(this.getEdgeKey(n[a],n[a+1]));for(let a=0;a<e.rows;a++)for(let h=0;h<e.cols;h++){if(i.has(`${h},${a}`))continue;let u=[],l=[{x:h,y:a}];for(i.add(`${h},${a}`);l.length>0;){let r=l.shift();u.push(r);let c=[{dx:0,dy:-1,p1:{x:r.x,y:r.y},p2:{x:r.x+1,y:r.y}},{dx:0,dy:1,p1:{x:r.x,y:r.y+1},p2:{x:r.x+1,y:r.y+1}},{dx:-1,dy:0,p1:{x:r.x,y:r.y},p2:{x:r.x,y:r.y+1}},{dx:1,dy:0,p1:{x:r.x+1,y:r.y},p2:{x:r.x+1,y:r.y+1}}];for(let d of c){let f=r.x+d.dx,y=r.y+d.dy;f>=0&&f<e.cols&&y>=0&&y<e.rows&&!i.has(`${f},${y}`)&&!o.has(this.getEdgeKey(d.p1,d.p2))&&!this.isAbsentEdge(e,d.p1,d.p2)&&(i.add(`${f},${y}`),l.push({x:f,y}))}}s.push(u)}return s}isAbsentEdge(e,t,n){if(t.x===n.x){let s=Math.min(t.y,n.y);return e.vEdges[s][t.x].type===2}else{let s=Math.min(t.x,n.x);return e.hEdges[t.y][s].type===2}}getRegionBoundaryEdges(e,t,n,s=[]){let i=new Set;for(let h=0;h<n.length-1;h++)i.add(this.getEdgeKey(n[h],n[h+1]));for(let h=0;h<s.length-1;h++)i.add(this.getEdgeKey(s[h],s[h+1]));let o=[];for(let h of t){let u=[{type:"h",r:h.y,c:h.x},{type:"h",r:h.y+1,c:h.x},{type:"v",r:h.y,c:h.x},{type:"v",r:h.y,c:h.x+1}];for(let l of u){let r=l.type==="h"?{x:l.c,y:l.r}:{x:l.c,y:l.r},c=l.type==="h"?{x:l.c+1,y:l.r}:{x:l.c,y:l.r+1},d=this.getEdgeKey(r,c);!i.has(d)&&!this.isAbsentEdge(e,r,c)&&o.push(l)}}let a=new Map;for(let h of o)a.set(`${h.type},${h.r},${h.c}`,h);return Array.from(a.values())}setEdgeHexagon(e,t,n){t.x===n.x?e.vEdges[Math.min(t.y,n.y)][t.x].type=3:e.hEdges[t.y][Math.min(t.x,n.x)].type=3}hasIncidentHexagonEdge(e,t){return t.x>0&&e.hEdges[t.y][t.x-1].type===3||t.x<e.cols&&e.hEdges[t.y][t.x].type===3||t.y>0&&e.vEdges[t.y-1][t.x].type===3||t.y<e.rows&&e.vEdges[t.y][t.x].type===3}isEdgeAdjacentToHexagonNode(e,t){return t.type==="h"?e.nodes[t.r][t.c].type===3||e.nodes[t.r][t.c+1].type===3:e.nodes[t.r][t.c].type===3||e.nodes[t.r+1][t.c].type===3}checkAllRequestedConstraintsPresent(e,t){let n=t.useHexagons??!0,s=t.useSquares??!0,i=t.useStars??!0,o=t.useTetris??!1,a=t.useEraser??!1;if(t.useBrokenEdges??!1){let u=!1;for(let l=0;l<=e.rows;l++)for(let r=0;r<e.cols;r++)if(e.hEdges[l][r].type===1||e.hEdges[l][r].type===2){u=!0;break}if(!u){for(let l=0;l<e.rows;l++)for(let r=0;r<=e.cols;r++)if(e.vEdges[l][r].type===1||e.vEdges[l][r].type===2){u=!0;break}}if(!u)return!1}if(n){let u=!1;for(let l=0;l<=e.rows;l++)for(let r=0;r<e.cols;r++)if(e.hEdges[l][r].type===3){u=!0;break}if(!u){for(let l=0;l<e.rows;l++)for(let r=0;r<=e.cols;r++)if(e.vEdges[l][r].type===3){u=!0;break}}if(!u){for(let l=0;l<=e.rows;l++)for(let r=0;r<=e.cols;r++)if(e.nodes[l][r].type===3){u=!0;break}}if(!u)return!1}if(s||i||o||a){let u=!1,l=!1,r=!1,c=!1,d=new Set;for(let f=0;f<e.rows;f++)for(let y=0;y<e.cols;y++){let p=e.cells[f][y].type;p===1&&(u=!0,d.add(e.cells[f][y].color)),p===2&&(l=!0),(p===3||p===4)&&(r=!0),p===5&&(c=!0)}if(s&&!u||i&&!l||o&&!r||a&&!c||s&&u&&!l&&d.size<2)return!1}return!this.hasIsolatedMark(e)}generateTiling(e,t,n){let s=Math.min(...e.map(r=>r.x)),i=Math.min(...e.map(r=>r.y)),o=Math.max(...e.map(r=>r.x)),a=Math.max(...e.map(r=>r.y)),h=o-s+1,u=a-i+1,l=Array.from({length:u},()=>Array(h).fill(!1));for(let r of e)l[r.y-i][r.x-s]=!0;return this.tilingDfs(l,[],t,n)}tilingDfs(e,t,n,s){let i=-1,o=-1;for(let u=0;u<e.length;u++){for(let l=0;l<e[0].length;l++)if(e[u][l]){i=u,o=l;break}if(i!==-1)break}if(i===-1)return t;if(t.length>=n)return null;let a=s.difficulty??.5,h=[...this.TETRIS_SHAPES];this.shuffleArray(h),a>.6&&h.sort((u,l)=>this.getShapeArea(l)-this.getShapeArea(u));for(let u of h){let l=this.isRotationallyInvariant(u),r=l?[u]:this.getAllRotations(u);this.shuffleArray(r);for(let c of r){let d=[];for(let f=0;f<c.length;f++)for(let y=0;y<c[0].length;y++)c[f][y]&&d.push({r:f,c:y});for(let f of d){let y=i-f.r,p=o-f.c;if(this.canPlace(e,c,y,p)){this.placePiece(e,c,y,p,!1);let g=this.tilingDfs(e,[...t,{shape:c,displayShape:u,isRotated:!l&&Math.random()<.3+a*.6}],n,s);if(g)return g;this.placePiece(e,c,y,p,!0)}}}}return null}getShapeArea(e){let t=0;for(let n of e)for(let s of n)s&&t++;return t}isRotationallyInvariant(e){let t=this.getShapeArea(e);return t===1||t===4&&e.length===2&&e[0].length===2}getAllRotations(e){let t=[],n=new Set,s=e;for(let i=0;i<4;i++){let o=JSON.stringify(s);n.has(o)||(t.push(s),n.add(o)),s=this.rotate90(s)}return t}rotate90(e){let t=e.length,n=e[0].length,s=Array.from({length:n},()=>Array(t).fill(0));for(let i=0;i<t;i++)for(let o=0;o<n;o++)s[o][t-1-i]=e[i][o];return s}canPlace(e,t,n,s){for(let i=0;i<t.length;i++)for(let o=0;o<t[0].length;o++)if(t[i][o]){let a=n+i,h=s+o;if(a<0||a>=e.length||h<0||h>=e[0].length||!e[a][h])return!1}return!0}placePiece(e,t,n,s,i){for(let o=0;o<t.length;o++)for(let a=0;a<t[0].length;a++)t[o][a]&&(e[n+o][s+a]=i)}shuffleArray(e){for(let t=e.length-1;t>0;t--){let n=Math.floor(Math.random()*(t+1));[e[t],e[n]]=[e[n],e[t]]}}};var Z=class{bytes=[];cur=0;bit=0;write(e,t){for(let n=0;n<t;n++)e&1<<n&&(this.cur|=1<<this.bit),this.bit++,this.bit===8&&(this.bytes.push(this.cur),this.cur=0,this.bit=0)}finish(){return this.bit>0&&this.bytes.push(this.cur),new Uint8Array(this.bytes)}},ee=class{constructor(e){this.buf=e}i=0;bit=0;read(e){let t=0;for(let n=0;n<e;n++)this.buf[this.i]&1<<this.bit&&(t|=1<<n),this.bit++,this.bit===8&&(this.bit=0,this.i++);return t}};function ae(L){let e=new Map;for(let t of L)for(let n of t)if(n.shape){let s=JSON.stringify(n.shape);e.has(s)||e.set(s,n.shape)}return[...e.values()]}var te=class{static async serialize(e,t){let n=new Z;n.write(e.rows,6),n.write(e.cols,6),n.write(e.symmetry??0,2);let s=ae(e.cells);n.write(s.length,5);for(let l of s){n.write(l.length,4),n.write(l[0].length,4);for(let r of l)for(let c of r)n.write(c,1)}let i=new Map;s.forEach((l,r)=>i.set(JSON.stringify(l),r));for(let l of e.cells)for(let r of l)n.write(r.type,3),n.write(r.color,3),r.shape?(n.write(1,1),n.write(i.get(JSON.stringify(r.shape)),5)):n.write(0,1);for(let l=0;l<e.rows;l++)for(let r=0;r<e.cols+1;r++)n.write(e.vEdges[l][r].type,2);for(let l=0;l<e.rows+1;l++)for(let r=0;r<e.cols;r++)n.write(e.hEdges[l][r].type,2);for(let l=0;l<e.rows+1;l++)for(let r=0;r<e.cols+1;r++)n.write(e.nodes[l][r].type,2);n.write(+!!t.useHexagons,1),n.write(+!!t.useSquares,1),n.write(+!!t.useStars,1),n.write(+!!t.useTetris,1),n.write(+!!t.useEraser,1),n.write(+!!t.useBrokenEdges,1),n.write(t.symmetry??0,2),n.write(Math.round((t.complexity??0)*254),8),n.write(Math.round((t.difficulty??0)*254),8),n.write(Math.round((t.pathLength??0)*254),8);let o=n.finish(),a=new Uint8Array(await new Response(new Blob([o.buffer]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()),h=0;for(let l of a)h^=l;let u=new Uint8Array(a.length+1);return u.set(a),u[a.length]=h,btoa(String.fromCharCode(...u)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}static async deserialize(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4;)t+="=";let n=atob(t),s=Uint8Array.from(n,z=>z.charCodeAt(0)),i=0;for(let z=0;z<s.length-1;z++)i^=s[z];if(i!==s.at(-1))throw new Error("Invalid parity data");let o=new Uint8Array(await new Response(new Blob([s.slice(0,-1).buffer]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer()),a=new ee(o),h=a.read(6),u=a.read(6),l=a.read(2),r=a.read(5),c=[];for(let z=0;z<r;z++){let D=a.read(4),E=a.read(4),w=[];for(let H=0;H<D;H++){let V=[];for(let O=0;O<E;O++)V.push(a.read(1));w.push(V)}c.push(w)}let d=[];for(let z=0;z<h;z++){let D=[];for(let E=0;E<u;E++){let w=a.read(3),H=a.read(3),V=a.read(1),O={type:w,color:H};V&&(O.shape=c[a.read(5)].map(B=>B.slice())),D.push(O)}d.push(D)}let f=Array.from({length:h},()=>Array.from({length:u+1},()=>({type:a.read(2)}))),y=Array.from({length:h+1},()=>Array.from({length:u},()=>({type:a.read(2)}))),p=Array.from({length:h+1},()=>Array.from({length:u+1},()=>({type:a.read(2)}))),g=()=>{let z=a.read(8);return Math.round(z/254*1e3)/1e3},m={},x=!!a.read(1),b=!!a.read(1),P=!!a.read(1),R=!!a.read(1),I=!!a.read(1),C=!!a.read(1),N=a.read(2);x&&(m.useHexagons=!0),b&&(m.useSquares=!0),P&&(m.useStars=!0),R&&(m.useTetris=!0),I&&(m.useEraser=!0),C&&(m.useBrokenEdges=!0),m.symmetry=N;let A=g(),v=g(),S=g();return A!==0&&(m.complexity=A),v!==0&&(m.difficulty=v),S!==0&&(m.pathLength=S),{puzzle:{rows:h,cols:u,cells:d,vEdges:f,hEdges:y,nodes:p,symmetry:l},options:m}}};var se=class{canvas;ctx;puzzle=null;options;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;invalidatedCells=[];invalidatedEdges=[];invalidatedNodes=[];errorCells=[];errorEdges=[];errorNodes=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;constructor(e,t,n={}){if(typeof window>"u"){this.canvas={},this.ctx={},this.options=this.mergeOptions(n);return}if(typeof e=="string"){let i=document.getElementById(e);if(!(i instanceof HTMLCanvasElement))throw new Error(`Element with id "${e}" is not a canvas.`);this.canvas=i}else this.canvas=e;let s=this.canvas.getContext("2d");if(!s)throw new Error("Could not get 2D context.");this.ctx=s,this.ctx.imageSmoothingEnabled=!1,this.options=this.mergeOptions(n),t&&this.setPuzzle(t),this.initEvents(),this.animate()}mergeOptions(e){let t={blinkDuration:e.animations?.blinkDuration??this.options?.animations?.blinkDuration??1e3,fadeDuration:e.animations?.fadeDuration??this.options?.animations?.fadeDuration??1e3,blinkPeriod:e.animations?.blinkPeriod??this.options?.animations?.blinkPeriod??800},n={path:e.colors?.path??this.options?.colors?.path??"#ffcc00",error:e.colors?.error??this.options?.colors?.error??"#ff4444",success:e.colors?.success??this.options?.colors?.success??"#ffcc00",symmetry:e.colors?.symmetry??this.options?.colors?.symmetry??"rgba(255, 255, 255, 0.5)",interrupted:e.colors?.interrupted??this.options?.colors?.interrupted??"#ffcc00",grid:e.colors?.grid??this.options?.colors?.grid??"#555",node:e.colors?.node??this.options?.colors?.node??"#555",hexagon:e.colors?.hexagon??this.options?.colors?.hexagon??"#000",colorMap:e.colors?.colorMap??this.options?.colors?.colorMap??{[$.Black]:"#000",[$.White]:"#fff",[$.Red]:"#f00",[$.Blue]:"#00f",[$.None]:"#ffcc00"},colorList:e.colors?.colorList??this.options?.colors?.colorList};return{gridPadding:e.gridPadding??this.options?.gridPadding??60,cellSize:e.cellSize??this.options?.cellSize??80,nodeRadius:e.nodeRadius??this.options?.nodeRadius??6,startNodeRadius:e.startNodeRadius??this.options?.startNodeRadius??22,pathWidth:e.pathWidth??this.options?.pathWidth??18,exitLength:e.exitLength??this.options?.exitLength??25,autoResize:e.autoResize??this.options?.autoResize??!0,animations:t,colors:n,onPathComplete:e.onPathComplete??this.options?.onPathComplete??(()=>{})}}setPuzzle(e){this.puzzle=e,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw()}setOptions(e){this.options=this.mergeOptions({...this.options,...e}),this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}setValidationResult(e,t=[],n=[],s=[],i=[],o=[],a=[]){this.invalidatedCells=t,this.invalidatedEdges=n,this.invalidatedNodes=o,this.errorCells=s,this.errorEdges=i,this.errorNodes=a,this.eraserAnimationStartTime=Date.now(),e?(this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0}resizeCanvas(){!this.puzzle||!this.canvas||(this.canvas.width=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,this.canvas.height=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2)}initEvents(){typeof window>"u"||(this.canvas.addEventListener("mousedown",e=>this.handleStart(e)),window.addEventListener("mousemove",e=>this.handleMove(e)),window.addEventListener("mouseup",e=>this.handleEnd(e)),this.canvas.addEventListener("touchstart",e=>{this.handleStart(e.touches[0])&&e.preventDefault()},{passive:!1}),window.addEventListener("touchmove",e=>{this.isDrawing&&e.preventDefault(),this.handleMove(e.touches[0])},{passive:!1}),window.addEventListener("touchend",e=>{this.isDrawing&&e.preventDefault(),this.handleEnd(e.changedTouches[0])},{passive:!1}))}getCanvasCoords(e,t){return{x:this.options.gridPadding+e*this.options.cellSize,y:this.options.gridPadding+t*this.options.cellSize}}getExitDir(e,t){return!this.puzzle||this.puzzle.nodes[t]?.[e]?.type!==2?null:e===this.puzzle.cols?{x:1,y:0}:e===0?{x:-1,y:0}:t===0?{x:0,y:-1}:t===this.puzzle.rows?{x:0,y:1}:{x:1,y:0}}handleStart(e){if(!this.puzzle)return!1;let t=this.canvas.getBoundingClientRect(),n=(e.clientX-t.left)*(this.canvas.width/t.width),s=(e.clientY-t.top)*(this.canvas.height/t.height);for(let i=0;i<=this.puzzle.rows;i++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[i][o].type===1){let a=this.getCanvasCoords(o,i);if(Math.hypot(a.x-n,a.y-s)<this.options.startNodeRadius)return this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.isDrawing=!0,this.path=[{x:o,y:i}],this.currentMousePos=a,this.exitTipPos=null,this.draw(),!0}return!1}handleMove(e){if(!this.puzzle||!this.isDrawing)return;let t=this.canvas.getBoundingClientRect(),n=(e.clientX-t.left)*(this.canvas.width/t.width),s=(e.clientY-t.top)*(this.canvas.height/t.height),i=this.path[this.path.length-1],o=this.getCanvasCoords(i.x,i.y),a=n-o.x,h=s-o.y,u=this.puzzle.symmetry||0,l=this.getExitDir(i.x,i.y);if(l){let f=a*l.x+h*l.y;if(f>0){let y=Math.min(f,this.options.exitLength);this.currentMousePos={x:o.x+l.x*y,y:o.y+l.y*y},this.draw();return}}let r=(f,y)=>{let p=this.getEdgeType(i,f);if(f.x<0||f.x>this.puzzle.cols||f.y<0||f.y>this.puzzle.rows||p===2){this.currentMousePos=o;return}let g=p===1?this.options.cellSize*.35:this.options.cellSize,m=this.getEdgeKey(i,f);if(!(this.path.length>=2&&f.x===this.path[this.path.length-2].x&&f.y===this.path[this.path.length-2].y)){for(let P=0;P<this.path.length-1;P++)if(this.getEdgeKey(this.path[P],this.path[P+1])===m){g=0;break}}if(this.path.some(P=>P.x===f.x&&P.y===f.y)&&this.path.length>=2){let P=this.path[this.path.length-2];(f.x!==P.x||f.y!==P.y)&&(g=Math.min(g,this.options.cellSize*.5-this.options.pathWidth*.5))}if(u!==0){let P=this.getSymmetricalPoint(i),R=this.getSymmetricalPoint(f),I=this.getEdgeType(P,R),C=this.getSymmetryPath(this.path),N=this.getEdgeKey(P,R);if(R.x<0||R.x>this.puzzle.cols||R.y<0||R.y>this.puzzle.rows||I===2){this.currentMousePos=o;return}I===1&&(g=Math.min(g,this.options.cellSize*.35));let A=C.some(w=>w.x===f.x&&w.y===f.y),v=this.path.some(w=>w.x===R.x&&w.y===R.y),S=f.x===R.x&&f.y===R.y,z=C.some((w,H)=>H<C.length-1&&this.getEdgeKey(C[H],C[H+1])===m),D=this.path.some((w,H)=>H<this.path.length-1&&this.getEdgeKey(this.path[H],this.path[H+1])===N);(A||v||S||z||D||m===N)&&(g=Math.min(g,this.options.cellSize*.5-this.options.pathWidth*.5))}f.x!==i.x?this.currentMousePos={x:o.x+Math.max(-g,Math.min(g,y)),y:o.y}:this.currentMousePos={x:o.x,y:o.y+Math.max(-g,Math.min(g,y))}};if(Math.abs(a)>Math.abs(h)){let f=a>0?1:-1;r({x:i.x+f,y:i.y},a)}else{let f=h>0?1:-1;r({x:i.x,y:i.y+f},h)}let c=[{x:i.x+1,y:i.y},{x:i.x-1,y:i.y},{x:i.x,y:i.y+1},{x:i.x,y:i.y-1}],d=this.getSymmetryPath(this.path);for(let f of c)if(f.x>=0&&f.x<=this.puzzle.cols&&f.y>=0&&f.y<=this.puzzle.rows){let y=this.getCanvasCoords(f.x,f.y);if(Math.hypot(y.x-this.currentMousePos.x,y.y-this.currentMousePos.y)<this.options.cellSize*.3){let g=this.path.findIndex(m=>m.x===f.x&&m.y===f.y);if(g===-1){if(u!==0){let m=this.getSymmetricalPoint(f);if(f.x===m.x&&f.y===m.y||this.path.some(P=>P.x===m.x&&P.y===m.y)||d.some(P=>P.x===f.x&&P.y===f.y))continue;let x=this.getEdgeKey(i,f),b=this.getEdgeKey(this.getSymmetricalPoint(i),m);if(x===b)continue}this.path.push(f)}else g===this.path.length-2&&this.path.pop()}}this.draw()}handleEnd(e){if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let t=this.path[this.path.length-1],n=this.getCanvasCoords(t.x,t.y),s=this.getExitDir(t.x,t.y);if(s&&Math.hypot(this.currentMousePos.x-n.x,this.currentMousePos.y-n.y)>this.options.exitLength*.1){this.exitTipPos={...this.currentMousePos},this.options.onPathComplete(this.path);return}this.exitTipPos=s?{...this.currentMousePos}:null,this.startFade(this.options.colors.interrupted)}getEdgeType(e,t){if(!this.puzzle)return 2;if(e.x===t.x){let n=Math.min(e.y,t.y);return n<0||n>=this.puzzle.rows?2:this.puzzle.vEdges[n][e.x].type}else{let n=Math.min(e.x,t.x);return n<0||n>=this.puzzle.cols?2:this.puzzle.hEdges[e.y][n].type}}startFade(e="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=e,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){if(!(typeof window>"u")){if(this.draw(),this.isFading){let e=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=e,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0)}requestAnimationFrame(()=>this.animate())}}draw(){if(!this.puzzle||!this.ctx)return;let e=this.ctx,t=Date.now();if(e.globalAlpha=1,e.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(e),this.drawConstraints(e),this.drawNodes(e),this.path.length===0&&!this.isDrawing&&this.drawRipples(e),this.isFading){if(this.drawPath(e,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let n=this.getSymmetryPath(this.fadingPath),s=this.options.colors.symmetry,i=null;if(this.fadingTipPos){let o=(this.fadingTipPos.x-this.options.gridPadding)/this.options.cellSize,a=(this.fadingTipPos.y-this.options.gridPadding)/this.options.cellSize,h=this.getSymmetricalPoint({x:o,y:a});i={x:h.x*this.options.cellSize+this.options.gridPadding,y:h.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,n,!1,s,this.fadeOpacity,i)}}else if(this.path.length>0){let n=this.isInvalidPath?this.options.colors.error:this.options.colors.path;if(this.isSuccessFading&&(n=this.options.colors.success),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let s=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),i=this.options.animations.blinkDuration;if(s<i)if(this.isSuccessFading)(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&(n=this.options.colors.error);else{let o=Math.min(1,s/200),a=s>i*.8?(i-s)/(i*.2):1,h=Math.min(o,a),u=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;n=this.lerpColor(this.options.colors.path,this.options.colors.error,u*h)}}if(this.drawPath(e,this.path,this.isDrawing,n,1,this.isDrawing?this.currentMousePos:this.exitTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let s=this.getSymmetryPath(this.path),i=this.options.colors.symmetry;if(this.isInvalidPath?i=this.options.colors.error:this.isSuccessFading&&(i=this.options.colors.success),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let a=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),h=this.options.animations.blinkDuration;if(a<h)if(this.isSuccessFading)(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&(i=this.options.colors.error);else{let u=Math.min(1,a/200),l=a>h*.8?(h-a)/(h*.2):1,r=Math.min(u,l),c=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;i=this.lerpColor(this.options.colors.symmetry,this.options.colors.error,c*r)}}let o=null;if(this.isDrawing||this.exitTipPos){let a=this.isDrawing?this.currentMousePos:this.exitTipPos,h=(a.x-this.options.gridPadding)/this.options.cellSize,u=(a.y-this.options.gridPadding)/this.options.cellSize,l=this.getSymmetricalPoint({x:h,y:u},!0);o={x:l.x*this.options.cellSize+this.options.gridPadding,y:l.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,s,this.isDrawing,i,1,o)}}}drawRipples(e){if(!this.puzzle)return;let t=(Date.now()-this.startTime)/500;for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)if(this.puzzle.nodes[n][s].type===2){let o=this.getCanvasCoords(s,n),a=this.getExitDir(s,n);if(!a)continue;let h={x:o.x+a.x*this.options.exitLength,y:o.y+a.y*this.options.exitLength},u=t%4,l=u*5,r=Math.max(0,1-u/3);e.beginPath(),e.arc(h.x,h.y,l,0,Math.PI*2),e.strokeStyle=`rgba(170, 170, 170, ${r*.4})`,e.lineWidth=2,e.stroke()}}drawGrid(e){if(!this.puzzle||!this.options.colors.grid)return;e.strokeStyle=this.options.colors.grid,e.lineWidth=12,e.lineCap="round";let t=(n,s,i)=>{if(i!==2)if(i===1){let a={x:n.x+(s.x-n.x)*.35,y:n.y+(s.y-n.y)*.35},h={x:n.x+(s.x-n.x)*(.5+.15),y:n.y+(s.y-n.y)*(.5+.15)};e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(a.x,a.y),e.stroke(),e.beginPath(),e.moveTo(h.x,h.y),e.lineTo(s.x,s.y),e.stroke()}else e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(s.x,s.y),e.stroke()};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<this.puzzle.cols;s++)t(this.getCanvasCoords(s,n),this.getCanvasCoords(s+1,n),this.puzzle.hEdges[n][s].type);for(let n=0;n<this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)t(this.getCanvasCoords(s,n),this.getCanvasCoords(s,n+1),this.puzzle.vEdges[n][s].type)}drawConstraints(e){if(!this.puzzle)return;let t=Date.now(),n=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;for(let i=0;i<this.puzzle.rows;i++)for(let o=0;o<this.puzzle.cols;o++){let a=this.puzzle.cells[i][o],h=this.getCanvasCoords(o+.5,i+.5),u=this.invalidatedCells.some(y=>y.x===o&&y.y===i),l=this.errorCells.some(y=>y.x===o&&y.y===i),r=1,c,d=this.getColorCode(a.color),f=this.options.colors.error;if(l&&(c=this.lerpColor(d,f,n)),u){let y=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),p=this.options.animations.blinkDuration;if(this.isFading)r=this.fadeOpacity;else if(y<p){let g=Math.min(1,y/200),m=y>p*.8?(p-y)/(p*.2):1,x=Math.min(g,m);c=this.lerpColor(d,f,n*x)}else r=Math.max(.3,1-(y-p)/this.options.animations.fadeDuration)}if(r<1||c){let{canvas:y,ctx:p}=this.prepareOffscreen();this.drawConstraintItem(p,a,h,c),e.save(),e.globalAlpha=r,e.drawImage(y,0,0),e.restore()}else this.drawConstraintItem(e,a,h)}e.lineWidth=2;let s=8;for(let i=0;i<=this.puzzle.rows;i++)for(let o=0;o<this.puzzle.cols;o++)if(this.puzzle.hEdges[i][o].type===3){let a=this.getCanvasCoords(o+.5,i);e.save();let h=this.invalidatedEdges.some(l=>l.type==="h"&&l.r===i&&l.c===o);if(this.errorEdges.some(l=>l.type==="h"&&l.r===i&&l.c===o)){let l=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(e,a.x,a.y,s,l)}else if(h){let l=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),r=this.options.animations.blinkDuration;if(this.isFading)e.globalAlpha*=this.fadeOpacity;else if(l<r){let c=Math.min(1,l/200),d=l>r*.8?(r-l)/(r*.2):1,f=Math.min(c,d),y=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*f);this.drawHexagon(e,a.x,a.y,s,y)}else e.globalAlpha*=Math.max(.3,1-(l-r)/this.options.animations.fadeDuration),this.drawHexagon(e,a.x,a.y,s)}else this.drawHexagon(e,a.x,a.y,s);e.restore()}for(let i=0;i<this.puzzle.rows;i++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.vEdges[i][o].type===3){let a=this.getCanvasCoords(o,i+.5);e.save();let h=this.invalidatedEdges.some(l=>l.type==="v"&&l.r===i&&l.c===o);if(this.errorEdges.some(l=>l.type==="v"&&l.r===i&&l.c===o)){let l=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(e,a.x,a.y,s,l)}else if(h){let l=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),r=this.options.animations.blinkDuration;if(this.isFading)e.globalAlpha*=this.fadeOpacity;else if(l<r){let c=Math.min(1,l/200),d=l>r*.8?(r-l)/(r*.2):1,f=Math.min(c,d),y=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*f);this.drawHexagon(e,a.x,a.y,s,y)}else e.globalAlpha*=Math.max(.3,1-(l-r)/this.options.animations.fadeDuration),this.drawHexagon(e,a.x,a.y,s)}else this.drawHexagon(e,a.x,a.y,s);e.restore()}for(let i=0;i<=this.puzzle.rows;i++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[i][o].type===3){let a=this.getCanvasCoords(o,i);e.save();let h=this.invalidatedNodes.some(l=>l.x===o&&l.y===i);if(this.errorNodes.some(l=>l.x===o&&l.y===i)){let l=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(e,a.x,a.y,s,l)}else if(h){let l=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),r=this.options.animations.blinkDuration;if(this.isFading)e.globalAlpha*=this.fadeOpacity;else if(l<r){let c=Math.min(1,l/200),d=l>r*.8?(r-l)/(r*.2):1,f=Math.min(c,d),y=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*f);this.drawHexagon(e,a.x,a.y,s,y)}else e.globalAlpha*=Math.max(.3,1-(l-r)/this.options.animations.fadeDuration),this.drawHexagon(e,a.x,a.y,s)}else this.drawHexagon(e,a.x,a.y,s);e.restore()}}drawConstraintItem(e,t,n,s){t.type===1?(e.fillStyle=s||this.getColorCode(t.color),this.drawRoundedRect(e,n.x-26/2,n.y-26/2,26,26,8)):t.type===2?this.drawStar(e,n.x,n.y,12,16,8,t.color,s):t.type===3||t.type===4?this.drawTetris(e,n.x,n.y,t.shape||[],t.type===4,t.color,s):t.type===5&&this.drawEraser(e,n.x,n.y,14,3,t.color,s)}drawNodes(e){if(!this.puzzle)return;let t=(n,s)=>{let i=[];return n>0&&i.push(this.puzzle.hEdges[s][n-1].type),n<this.puzzle.cols&&i.push(this.puzzle.hEdges[s][n].type),s>0&&i.push(this.puzzle.vEdges[s-1][n].type),s<this.puzzle.rows&&i.push(this.puzzle.vEdges[s][n].type),i.length>0&&i.every(o=>o===2)};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++){if(t(s,n))continue;let i=this.puzzle.nodes[n][s];if(i.type===3)continue;let o=this.getCanvasCoords(s,n);if(i.type===1)this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill();else if(i.type===2){let a=this.getExitDir(s,n);if(!a)continue;this.options.colors.node&&(e.strokeStyle=this.options.colors.node),e.lineWidth=12,e.lineCap="round",e.beginPath(),e.moveTo(o.x,o.y),e.lineTo(o.x+a.x*this.options.exitLength,o.y+a.y*this.options.exitLength),e.stroke()}else this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.nodeRadius,0,Math.PI*2),e.fill()}}drawPath(e,t,n,s,i,o=null){if(t.length===0||!s)return;let a=i,h=s;if(s.startsWith("rgba")){let r=s.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);if(r){let c=r[1],d=r[2],f=r[3],y=r[4]?parseFloat(r[4]):1;h=`rgb(${c},${d},${f})`,a*=y}}else if(s==="transparent")return;let{canvas:u,ctx:l}=this.prepareOffscreen();this.drawPathInternal(l,t,n,h,o),e.save(),e.globalAlpha=a,e.drawImage(u,0,0),e.restore()}drawPathInternal(e,t,n,s,i=null){e.save(),e.strokeStyle=s,e.fillStyle=s,e.lineWidth=this.options.pathWidth,e.lineCap="round",e.lineJoin="round",e.beginPath();let o=this.getCanvasCoords(t[0].x,t[0].y);e.moveTo(o.x,o.y);for(let h=1;h<t.length;h++){let u=this.getCanvasCoords(t[h].x,t[h].y);e.lineTo(u.x,u.y)}let a=i||this.currentMousePos;(n||i)&&e.lineTo(a.x,a.y),e.stroke(),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill(),(n||i)&&(e.beginPath(),e.arc(a.x,a.y,this.options.pathWidth/2,0,Math.PI*2),e.fill()),e.restore()}drawRoundedRect(e,t,n,s,i,o){e.beginPath(),e.moveTo(t+o,n),e.lineTo(t+s-o,n),e.quadraticCurveTo(t+s,n,t+s,n+o),e.lineTo(t+s,n+i-o),e.quadraticCurveTo(t+s,n+i,t+s-o,n+i),e.lineTo(t+o,n+i),e.quadraticCurveTo(t,n+i,t,n+i-o),e.lineTo(t,n+o),e.quadraticCurveTo(t,n,t+o,n),e.closePath(),e.fill()}drawHexagon(e,t,n,s,i){if(!(!this.options.colors.hexagon&&!i)){e.fillStyle=i||this.options.colors.hexagon,e.beginPath();for(let o=0;o<6;o++){let a=Math.PI/3*o,h=t+s*Math.cos(a),u=n+s*Math.sin(a);o===0?e.moveTo(h,u):e.lineTo(h,u)}e.closePath(),e.fill()}}drawEraser(e,t,n,s,i,o,a){e.strokeStyle=a||this.getColorCode(o),e.lineWidth=s*.5,e.lineCap="butt";let h=.5;e.beginPath();for(let u=0;u<i;u++){let l=Math.PI*2/i*u+h,r=t+s*Math.cos(l),c=n+s*Math.sin(l);e.moveTo(t,n),e.lineTo(r,c)}e.stroke()}drawStar(e,t,n,s,i,o,a,h){e.fillStyle=h||this.getColorCode(a),e.beginPath();for(let u=0;u<o*2;u++){let l=u%2===0?i:s,r=Math.PI/o*u,c=t+l*Math.cos(r),d=n+l*Math.sin(r);u===0?e.moveTo(c,d):e.lineTo(c,d)}e.closePath(),e.fill()}drawTetris(e,t,n,s,i,o,a){if(!s||s.length===0)return;let h=12,u=2,l=s[0].length*h+(s[0].length-1)*u,r=s.length*h+(s.length-1)*u;e.save(),e.translate(t,n),i&&e.rotate(Math.PI/8),e.fillStyle=a||this.getColorCode(o,"#ffcc00");for(let c=0;c<s.length;c++)for(let d=0;d<s[c].length;d++)if(s[c][d]){let f=d*(h+u)-l/2,y=c*(h+u)-r/2;e.fillRect(f,y,h,h)}e.restore()}getColorCode(e,t="#666"){return this.options.colors.colorList&&this.options.colors.colorList[e]!==void 0?this.options.colors.colorList[e]:this.options.colors.colorMap&&this.options.colors.colorMap[e]!==void 0?this.options.colors.colorMap[e]:t}hexToRgb(e){let t=e.startsWith("#")?e.slice(1):e;t.length===3&&(t=t.split("").map(s=>s+s).join(""));let n=parseInt(t,16);return{r:n>>16&255,g:n>>8&255,b:n&255}}rgbToHex(e,t,n){return"#"+((1<<24)+(e<<16)+(t<<8)+n).toString(16).slice(1)}lerpColor(e,t,n){try{let s=this.hexToRgb(e),i=this.hexToRgb(t);return this.rgbToHex(Math.round(s.r+(i.r-s.r)*n),Math.round(s.g+(i.g-s.g)*n),Math.round(s.b+(i.b-s.b)*n))}catch{return e}}getSymmetryPath(e){return!this.puzzle||!this.puzzle.symmetry?[]:e.map(t=>this.getSymmetricalPoint(t))}getSymmetricalPoint(e,t=!1){if(!this.puzzle||!this.puzzle.symmetry)return{...e};let{cols:n,rows:s,symmetry:i}=this.puzzle;return i===1?{x:n-e.x,y:e.y}:i===2?{x:e.x,y:s-e.y}:i===3?{x:n-e.x,y:s-e.y}:{...e}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}prepareOffscreen(){return typeof document>"u"?{canvas:{},ctx:{}}:(this.offscreenCanvas||(this.offscreenCanvas=document.createElement("canvas"),this.offscreenCtx=this.offscreenCanvas.getContext("2d")),(this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx})}};var oe=class{generator;validator;constructor(){this.generator=new _,this.validator=new U}createPuzzle(e,t,n={}){return this.generator.generate(e,t,n).export()}validateSolution(e,t){let n=W.fromData(e);return this.validator.validate(n,t)}calculateDifficulty(e){let t=W.fromData(e);return this.validator.calculateDifficulty(t)}};export{X as CellType,$ as Color,re as Direction,j as EdgeType,W as Grid,J as NodeType,_ as PuzzleGenerator,te as PuzzleSerializer,U as PuzzleValidator,Q as SymmetryType,oe as WitnessCore,se as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
