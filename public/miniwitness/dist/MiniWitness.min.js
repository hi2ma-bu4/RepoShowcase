/*!
 * MiniWitness 1.3.3
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var Ee=(n=>(n[n.Up=0]="Up",n[n.Right=1]="Right",n[n.Down=2]="Down",n[n.Left=3]="Left",n))(Ee||{}),re=(a=>(a[a.None=0]="None",a[a.Square=1]="Square",a[a.Star=2]="Star",a[a.Tetris=3]="Tetris",a[a.TetrisRotated=4]="TetrisRotated",a[a.TetrisNegative=5]="TetrisNegative",a[a.TetrisNegativeRotated=6]="TetrisNegativeRotated",a[a.Eraser=7]="Eraser",a[a.Triangle=8]="Triangle",a))(re||{}),le=(o=>(o[o.Normal=0]="Normal",o[o.Broken=1]="Broken",o[o.Absent=2]="Absent",o[o.Hexagon=3]="Hexagon",o[o.HexagonMain=4]="HexagonMain",o[o.HexagonSymmetry=5]="HexagonSymmetry",o))(le||{}),he=(o=>(o[o.Normal=0]="Normal",o[o.Start=1]="Start",o[o.End=2]="End",o[o.Hexagon=3]="Hexagon",o[o.HexagonMain=4]="HexagonMain",o[o.HexagonSymmetry=5]="HexagonSymmetry",o))(he||{}),ue=(n=>(n[n.None=0]="None",n[n.Horizontal=1]="Horizontal",n[n.Vertical=2]="Vertical",n[n.Rotational=3]="Rotational",n))(ue||{}),X={None:0,Black:1,White:2,Red:3,Blue:4},Se=(s=>(s[s.Mulberry32=0]="Mulberry32",s[s.XorShift128Plus=1]="XorShift128Plus",s[s.MathRandom=2]="MathRandom",s))(Se||{});var oe=class Q{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];symmetry=0;seed;constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:X.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes,symmetry:this.symmetry,seed:this.seed}))}static fromData(e){let t=new Q(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t.symmetry=e.symmetry||0,t.seed=e.seed,t}};var de=class{state;constructor(e){this.state=e>>>0}next(){let e=(this.state+=1831565813)|0;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}},pe=class{s0;s1;constructor(e,t){this.s0=e>>>0,this.s1=t>>>0,this.s0===0&&this.s1===0&&(this.s1=1)}next(){let e=this.s0,t=this.s1;return this.s0=t,e^=e<<23,this.s1=e^t^e>>>17^t>>>26,(this.s1+t>>>0)/4294967296}},ge=class{next(){return Math.random()}};function ye(Q,e){switch(Q){case 0:return new de(Number(e&0xffffffffn));case 1:return new pe(Number(e&0xffffffffn),Number(e>>32n&0xffffffffn));case 2:return new ge;default:return new de(Number(e&0xffffffffn))}}var ae=class{tetrisCache=new Map;rng=null;setRng(e){this.rng=e}validate(e,t,s){let n=t.points;if(n.length<2)return{isValid:!1,errorReason:"Path too short"};let l=e.symmetry||0,o=[];if(l!==0)for(let y of n)o.push(this.getSymmetricalPoint(e,y));let i=n[0],f=n[n.length-1];if(e.nodes[i.y][i.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[f.y][f.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};if(l!==0){let y=o[0],p=o[o.length-1];if(e.nodes[y.y][y.x].type!==1)return{isValid:!1,errorReason:"Symmetrical path must start at Start Node"};if(e.nodes[p.y][p.x].type!==2)return{isValid:!1,errorReason:"Symmetrical path must end at End Node"}}let a=new Set,d=new Set;if(a.add(`${i.x},${i.y}`),l!==0){let y=o[0];if(a.has(`${y.x},${y.y}`))return{isValid:!1,errorReason:"Paths collide at start"};a.add(`${y.x},${y.y}`)}for(let y=0;y<n.length-1;y++){let p=n[y],x=n[y+1];if(Math.abs(p.x-x.x)+Math.abs(p.y-x.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let m=`${x.x},${x.y}`;if(a.has(m))return{isValid:!1,errorReason:"Self-intersecting path or path collision"};if(a.add(m),this.isBrokenEdge(e,p,x))return{isValid:!1,errorReason:"Passed through broken edge"};if(d.add(this.getEdgeKey(p,x)),l!==0){let b=o[y],S=o[y+1],E=`${S.x},${S.y}`;if(a.has(E))return{isValid:!1,errorReason:"Path collision"};if(a.add(E),this.isBrokenEdge(e,b,S))return{isValid:!1,errorReason:"Symmetrical path passed through broken edge"};let P=this.getEdgeKey(b,S);if(d.has(P))return{isValid:!1,errorReason:"Paths cross the same edge"};d.add(P)}}let h=this.calculateRegions(e,n,o,s),c=this.getMissedHexagons(e,n,o),u=new Set;for(let y=0;y<n.length-1;y++)u.add(this.getEdgeKey(n[y],n[y+1]));if(l!==0)for(let y=0;y<o.length-1;y++)u.add(this.getEdgeKey(o[y],o[y+1]));let r=this.validateWithErasers(e,h,c.edges,c.nodes,u);return r.regions=h,r}validateFast(e,t,s,n){let l=this.calculateRegions(e,t,s,n),o=this.getMissedHexagons(e,t,s),i=new Set;for(let a=0;a<t.length-1;a++)i.add(this.getEdgeKey(t[a],t[a+1]));if((e.symmetry||0)!==0)for(let a=0;a<s.length-1;a++)i.add(this.getEdgeKey(s[a],s[a+1]));return this.validateWithErasers(e,l,o.edges,o.nodes,i)}isBrokenEdge(e,t,s){let n;if(t.x===s.x){let l=Math.min(t.y,s.y);n=e.vEdges[l][t.x].type}else{let l=Math.min(t.x,s.x);n=e.hEdges[t.y][l].type}return n===1||n===2}isAbsentEdge(e,t,s){if(t.x===s.x){let n=Math.min(t.y,s.y);return e.vEdges[n][t.x].type===2}else{let n=Math.min(t.x,s.x);return e.hEdges[t.y][n].type===2}}getMissedHexagons(e,t,s=[]){let n=new Set,l=new Set;for(let d=0;d<t.length;d++)l.add(`${t[d].x},${t[d].y}`),d<t.length-1&&n.add(this.getEdgeKey(t[d],t[d+1]));let o=new Set,i=new Set;for(let d=0;d<s.length;d++)i.add(`${s[d].x},${s[d].y}`),d<s.length-1&&o.add(this.getEdgeKey(s[d],s[d+1]));let f=[];for(let d=0;d<=e.rows;d++)for(let h=0;h<e.cols;h++){let c=e.hEdges[d][h].type;if(c===3||c===4||c===5){let u=this.getEdgeKey({x:h,y:d},{x:h+1,y:d}),r=!1;c===3?r=n.has(u)||o.has(u):c===4?r=n.has(u):c===5&&(r=o.has(u)),r||f.push({type:"h",r:d,c:h})}}for(let d=0;d<e.rows;d++)for(let h=0;h<=e.cols;h++){let c=e.vEdges[d][h].type;if(c===3||c===4||c===5){let u=this.getEdgeKey({x:h,y:d},{x:h,y:d+1}),r=!1;c===3?r=n.has(u)||o.has(u):c===4?r=n.has(u):c===5&&(r=o.has(u)),r||f.push({type:"v",r:d,c:h})}}let a=[];for(let d=0;d<=e.rows;d++)for(let h=0;h<=e.cols;h++){let c=e.nodes[d][h].type;if(c===3||c===4||c===5){let u=`${h},${d}`,r=!1;c===3?r=l.has(u)||i.has(u):c===4?r=l.has(u):c===5&&(r=i.has(u)),r||a.push({x:h,y:d})}}return{edges:f,nodes:a}}validateWithErasers(e,t,s,n,l){let o=[],i=!0;for(let r=0;r<t.length;r++){let y=t[r],p=y.filter(S=>e.cells[S.y][S.x].type===7),x=y.filter(S=>e.cells[S.y][S.x].type!==0&&e.cells[S.y][S.x].type!==7),g=[];for(let S=0;S<s.length;S++)this.isHexagonAdjacentToRegion(e,s[S],y)&&g.push(S);let m=[];for(let S=0;S<n.length;S++)this.isNodeHexagonAdjacentToRegion(e,n[S],y)&&m.push(S);let b=this.getPossibleErasures(e,y,p,x,g,m,l);if(b.length===0){i=!1;let S=this.getBestEffortErasures(e,y,p,x,g,m,l);o.push([S])}else b.sort((S,E)=>{let P=S.invalidatedCells.length+S.invalidatedHexagons.length+S.invalidatedNodeHexagons.length,v=E.invalidatedCells.length+E.invalidatedHexagons.length+E.invalidatedNodeHexagons.length;if(P!==v)return P-v;let w=S.invalidatedHexagons.length+S.invalidatedNodeHexagons.length,N=E.invalidatedHexagons.length+E.invalidatedNodeHexagons.length;return w!==N?N-w:S.invalidatedCells.length-E.invalidatedCells.length}),o.push(b)}if(i){let r=this.findGlobalAssignment(o,s.length,n.length);if(r)return{isValid:!0,invalidatedCells:r.invalidatedCells,invalidatedEdges:r.invalidatedHexIndices.map(y=>s[y]),invalidatedNodes:r.invalidatedNodeHexIndices.map(y=>n[y])}}let f=[],a=[],d=new Set,h=new Set;for(let r of o){let y=r[0];f.push(...y.errorCells),a.push(...y.invalidatedCells);for(let p of y.invalidatedHexagons)d.add(p);for(let p of y.invalidatedNodeHexagons)h.add(p)}let c=[];for(let r=0;r<s.length;r++)d.has(r)||c.push(s[r]);let u=[];for(let r=0;r<n.length;r++)h.has(r)||u.push(n[r]);return{isValid:!1,errorReason:"Constraints failed",errorCells:f,errorEdges:c,errorNodes:u,invalidatedCells:a,invalidatedEdges:Array.from(d).map(r=>s[r]),invalidatedNodes:Array.from(h).map(r=>n[r])}}isHexagonAdjacentToRegion(e,t,s){let n=new Set(s.map(l=>`${l.x},${l.y}`));if(t.type==="h"){if(t.r>0&&n.has(`${t.c},${t.r-1}`)||t.r<e.rows&&n.has(`${t.c},${t.r}`))return!0}else if(t.c>0&&n.has(`${t.c-1},${t.r}`)||t.c<e.cols&&n.has(`${t.c},${t.r}`))return!0;return!1}isNodeHexagonAdjacentToRegion(e,t,s){let n=new Set(s.map(o=>`${o.x},${o.y}`)),l=[{x:t.x-1,y:t.y-1},{x:t.x,y:t.y-1},{x:t.x-1,y:t.y},{x:t.x,y:t.y}];for(let o of l)if(o.x>=0&&o.x<e.cols&&o.y>=0&&o.y<e.rows&&n.has(`${o.x},${o.y}`))return!0;return!1}getPossibleErasures(e,t,s,n,l,o,i){let f=[],a=s.length;if(a===0)return this.getRegionErrors(e,t,[],i).length===0&&l.length===0&&o.length===0&&f.push({invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!0,errorCells:[]}),f;let d=[...n.map(c=>({type:"cell",pos:c})),...l.map(c=>({type:"hex",index:c})),...o.map(c=>({type:"nodeHex",index:c}))],h=this.getRegionErrors(e,t,[],i).length===0&&l.length===0&&o.length===0;for(let c=0;c<=a;c++){let u=this.getNCombinations(s,c);for(let r of u){let y=new Set(r.map(x=>`${x.x},${x.y}`)),p=s.filter(x=>!y.has(`${x.x},${x.y}`));for(let x=0;x<=d.length;x++){if(p.length!==c+x)continue;let g=this.getNCombinations(d,x);for(let m of g){let b=m.filter(w=>w.type==="cell").map(w=>w.pos),S=m.filter(w=>w.type==="hex").map(w=>w.index),E=m.filter(w=>w.type==="nodeHex").map(w=>w.index);if(this.getRegionErrors(e,t,[...b,...r],i).length===0){let w=!0;if(h)x>0&&(w=!1);else for(let N=0;N<m.length;N++){let C=[...m.slice(0,N),...m.slice(N+1)],z=C.filter(V=>V.type==="cell").map(V=>V.pos),D=new Set(C.filter(V=>V.type==="hex").map(V=>V.index)),W=new Set(C.filter(V=>V.type==="nodeHex").map(V=>V.index)),O=l.every(V=>D.has(V)),$=o.every(V=>W.has(V));if(this.getRegionErrors(e,t,z,i).length===0&&O&&$){w=!1;break}}w&&f.push({invalidatedCells:[...b,...r],invalidatedHexagons:S,invalidatedNodeHexagons:E,isValid:!0,errorCells:[]})}}}}}return f}getBestEffortErasures(e,t,s,n,l,o,i){let f=this.getRegionErrors(e,t,[],i);if(f.length===0&&l.length===0&&o.length===0)return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:[...s]};if(s.length>0){let h=[...n.map(y=>({type:"cell",pos:y})),...l.map(y=>({type:"hex",index:y})),...o.map(y=>({type:"nodeHex",index:y}))],c=null,u=1/0,r=y=>{let p=[],x=[],g=[],m=0;for(let C of y)m<s.length&&(C.type==="cell"?p.push(C.pos):C.type==="hex"?x.push(C.index):g.push(C.index),m++);let b=s.length-m,S=Math.floor(b/2),E=s.slice(m,m+S);m+=S*2;let P=this.getRegionErrors(e,t,[...p,...E],i);for(let C=m;C<s.length;C++)P.push(s[C]);let v=Math.max(0,l.length-x.length),w=Math.max(0,o.length-g.length),N=P.length+v+w;N<u&&(u=N,c={invalidatedCells:[...p,...E],invalidatedHexagons:x,invalidatedNodeHexagons:g,isValid:!1,errorCells:P})};r([...f.map(y=>({type:"cell",pos:y})),...l.map(y=>({type:"hex",index:y})),...o.map(y=>({type:"nodeHex",index:y}))]),r(h);for(let y of f)r([{type:"cell",pos:y}]);if(c)return c}let d=[...f,...s];return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:d}}getNCombinations(e,t){let s=[],n=(l,o)=>{if(o.length===t){s.push([...o]);return}for(let i=l;i<e.length;i++)o.push(e[i]),n(i+1,o),o.pop()};return n(0,[]),s}checkRegionValid(e,t,s,n){return this.getRegionErrors(e,t,s,n).length===0}getRegionErrors(e,t,s,n){let l=new Set(s.map(r=>`${r.x},${r.y}`)),o=new Map,i=new Map,f=new Set,a=new Set,d=[],h=[],c=[];for(let r of t){if(l.has(`${r.x},${r.y}`))continue;let y=e.cells[r.y][r.x];if(y.type===0)continue;let p=y.color;p!==X.None&&(o.set(p,(o.get(p)||0)+1),i.has(p)||i.set(p,[]),i.get(p).push(r)),y.type===1?a.add(p):y.type===2?f.add(p):y.type===3||y.type===4?y.shape&&d.push({shape:y.shape,rotatable:y.type===4,pos:r}):y.type===5||y.type===6?y.shape&&h.push({shape:y.shape,rotatable:y.type===6,pos:r}):y.type===8&&c.push({count:y.count||0,pos:r})}let u=[];if(a.size>1)for(let r of t)l.has(`${r.x},${r.y}`)||e.cells[r.y][r.x].type===1&&u.push(r);for(let r of f)if(o.get(r)!==2){let y=i.get(r)||[];for(let p of y)e.cells[p.y][p.x].type===2&&u.push(p)}for(let r of c){let y=0,p=[this.getEdgeKey({x:r.pos.x,y:r.pos.y},{x:r.pos.x+1,y:r.pos.y}),this.getEdgeKey({x:r.pos.x,y:r.pos.y+1},{x:r.pos.x+1,y:r.pos.y+1}),this.getEdgeKey({x:r.pos.x,y:r.pos.y},{x:r.pos.x,y:r.pos.y+1}),this.getEdgeKey({x:r.pos.x+1,y:r.pos.y},{x:r.pos.x+1,y:r.pos.y+1})];for(let x of p)n.has(x)&&y++;y!==r.count&&u.push(r.pos)}if((d.length>0||h.length>0)&&!this.checkTetrisConstraint(e,t,d.map(r=>({shape:r.shape,rotatable:r.rotatable})),h.map(r=>({shape:r.shape,rotatable:r.rotatable})))){for(let r of d)u.push(r.pos);for(let r of h)u.push(r.pos)}return u}findGlobalAssignment(e,t,s){let n=e.length,l=new Array(t).fill(0),o=new Array(s).fill(0),i=[],f=[],a=[],d=h=>{if(h===n)return l.every(c=>c===1)&&o.every(c=>c===1);for(let c of e[h]){let u=!0;for(let r of c.invalidatedHexagons)if(l[r]>0){u=!1;break}if(u){for(let r of c.invalidatedNodeHexagons)if(o[r]>0){u=!1;break}}if(u){for(let r of c.invalidatedHexagons)l[r]++,f.push(r);for(let r of c.invalidatedNodeHexagons)o[r]++,a.push(r);if(i.push(...c.invalidatedCells),d(h+1))return!0;for(let r of c.invalidatedHexagons)l[r]--,f.pop();for(let r of c.invalidatedNodeHexagons)o[r]--,a.pop();for(let r=0;r<c.invalidatedCells.length;r++)i.pop()}}return!1};return d(0)?{invalidatedCells:i,invalidatedHexIndices:f,invalidatedNodeHexIndices:a}:null}checkTetrisConstraint(e,t,s,n=[]){let l=s.reduce((v,w)=>v+this.getShapeArea(w.shape),0),o=n.reduce((v,w)=>v+this.getShapeArea(w.shape),0),i=l-o;if(i<0||i!==0&&i!==t.length)return!1;let f=e.rows,a=e.cols;this.tetrisCache.size>1e4&&this.tetrisCache.clear();let d=new Uint8Array(f*a);for(let v of t)d[v.y*a+v.x]=1;let h=(v,w)=>`${this.getShapeKey(v.shape)}-${v.rotatable}-${w}`,c=[...s.map(v=>h(v,1)),...n.map(v=>h(v,-1))].sort().join("|"),u=`${f}x${a}:${d.join("")}:${c}`;if(this.tetrisCache.has(u))return this.tetrisCache.get(u);let r=new Int8Array(f*a);if(i>0)for(let v=0;v<d.length;v++)r[v]=d[v];let y=new Int8Array(f*a),p=[],x=[...s.map(v=>({...v,sign:1})),...n.map(v=>({...v,sign:-1}))];for(let v of x){let w=v.rotatable?this.getAllRotations(v.shape):[v.shape],N=this.getShapeKey(w[0]),C=p.find(z=>z.sign===v.sign&&(v.rotatable?z.rotations.length>1:z.rotations.length===1)&&this.getShapeKey(z.rotations[0].shape)===N);C?C.count++:p.push({rotations:w.map(z=>({shape:z,h:z.length,w:z[0].length})),sign:v.sign,area:this.getShapeArea(v.shape),count:1})}p.sort((v,w)=>w.sign-v.sign||w.area-v.area);let g=i>0?t.length:0,m=0,b=l,S=o,E=(v,w,N)=>{if(g>b||m>S)return!1;if(v===p.length)return g===0&&m===0;let C=p[v],z=w+1,D=z===C.count;C.sign===1?b-=C.area:S-=C.area;for(let W of C.rotations){let O=W.h,$=W.w,V=w===0?0:N;for(let H=V;H<=f*a-(O>0?(O-1)*a+$:0);H++){let B=Math.floor(H/a),M=H%a;if(B>f-O||M>a-$)continue;let k=!0,T=[];for(let F=0;F<O;F++){for(let q=0;q<$;q++)if(W.shape[F][q]){let Z=(B+F)*a+(M+q);C.sign===1?y[Z]<r[Z]?g--:m++:y[Z]<=r[Z]?g++:m--,y[Z]+=C.sign,T.push(Z),y[Z]<0&&(k=!1),C.sign===1&&y[Z]>1+o&&(k=!1)}if(!k)break}if(k){if(D){if(E(v+1,0,0)){for(let F of T)y[F]-=C.sign,C.sign===1?y[F]<r[F]?g++:m--:y[F]<=r[F]?g--:m++;return C.sign===1?b+=C.area:S+=C.area,!0}}else if(E(v,z,H)){for(let F of T)y[F]-=C.sign,C.sign===1?y[F]<r[F]?g++:m--:y[F]<=r[F]?g--:m++;return C.sign===1?b+=C.area:S+=C.area,!0}}for(let F of T)y[F]-=C.sign,C.sign===1?y[F]<r[F]?g++:m--:y[F]<=r[F]?g--:m++}}return C.sign===1?b+=C.area:S+=C.area,!1},P=E(0,0,0);return this.tetrisCache.set(u,P),P}getShapeArea(e){let t=0;for(let s of e)for(let n of s)n&&t++;return t}getShapeKey(e){return JSON.stringify(e)}getAllRotations(e){let t=[],s=new Set,n=e;for(let l=0;l<4;l++){let o=this.getShapeKey(n);s.has(o)||(t.push(n),s.add(o)),n=this.rotate90(n)}return t}rotate90(e){let t=e.length,s=e[0].length,n=Array.from({length:s},()=>Array(t).fill(0));for(let l=0;l<t;l++)for(let o=0;o<s;o++)n[o][t-1-l]=e[l][o];return n}calculateRegions(e,t,s=[],n){let l=[],o=e.rows,i=e.cols,f=new Uint8Array(o*i),a=new Uint8Array((o+1)*i),d=new Uint8Array(o*(i+1)),h=(u,r)=>{u.x===r.x?d[Math.min(u.y,r.y)*(i+1)+u.x]=1:a[u.y*i+Math.min(u.x,r.x)]=1};for(let u=0;u<t.length-1;u++)h(t[u],t[u+1]);for(let u=0;u<s.length-1;u++)h(s[u],s[u+1]);for(let u=0;u<=o;u++)for(let r=0;r<i;r++)e.hEdges[u][r].type===2&&(a[u*i+r]=1);for(let u=0;u<o;u++)for(let r=0;r<=i;r++)e.vEdges[u][r].type===2&&(d[u*(i+1)+r]=1);let c=n||this.getExternalCells(e);for(let u=0;u<o;u++)for(let r=0;r<i;r++){let y=u*i+r;if(f[y]||c&&c.has(`${r},${u}`))continue;let p=[],x=[y];f[y]=1;let g=0;for(;g<x.length;){let m=x[g++],b=m%i,S=Math.floor(m/i);if(p.push({x:b,y:S}),S>0&&!a[S*i+b]){let E=(S-1)*i+b;!f[E]&&(!c||!c.has(`${b},${S-1}`))&&(f[E]=1,x.push(E))}if(S<o-1&&!a[(S+1)*i+b]){let E=(S+1)*i+b;!f[E]&&(!c||!c.has(`${b},${S+1}`))&&(f[E]=1,x.push(E))}if(b>0&&!d[S*(i+1)+b]){let E=S*i+(b-1);!f[E]&&(!c||!c.has(`${b-1},${S}`))&&(f[E]=1,x.push(E))}if(b<i-1&&!d[S*(i+1)+(b+1)]){let E=S*i+(b+1);!f[E]&&(!c||!c.has(`${b+1},${S}`))&&(f[E]=1,x.push(E))}}l.push(p)}return l}getExternalCells(e){let t=new Set,s=[];for(let n=0;n<e.cols;n++)e.hEdges[0][n].type===2&&(t.has(`${n},0`)||(t.add(`${n},0`),s.push({x:n,y:0}))),e.hEdges[e.rows][n].type===2&&(t.has(`${n},${e.rows-1}`)||(t.add(`${n},${e.rows-1}`),s.push({x:n,y:e.rows-1})));for(let n=0;n<e.rows;n++)e.vEdges[n][0].type===2&&(t.has(`0,${n}`)||(t.add(`0,${n}`),s.push({x:0,y:n}))),e.vEdges[n][e.cols].type===2&&(t.has(`${e.cols-1},${n}`)||(t.add(`${e.cols-1},${n}`),s.push({x:e.cols-1,y:n})));for(;s.length>0;){let n=s.shift(),l=[{nx:n.x,ny:n.y-1,edge:e.hEdges[n.y][n.x]},{nx:n.x,ny:n.y+1,edge:e.hEdges[n.y+1][n.x]},{nx:n.x-1,ny:n.y,edge:e.vEdges[n.y][n.x]},{nx:n.x+1,ny:n.y,edge:e.vEdges[n.y][n.x+1]}];for(let o of l)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),s.push({x:o.nx,y:o.ny}))}return t}getSymmetricalPoint(e,t){let s=e.symmetry||0;return s===1?{x:e.cols-t.x,y:t.y}:s===2?{x:t.x,y:e.rows-t.y}:s===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getSymmetricalPointIndex(e,t){let s=e.cols+1,n=Math.floor(t/s),l=t%s,o=e.symmetry||0,i=n,f=l;return o===1?f=e.cols-l:o===2?i=e.rows-n:o===3&&(f=e.cols-l,i=e.rows-n),i*s+f}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}calculateDifficulty(e,t){let s=e.rows,n=e.cols,l=n+1,o=(s+1)*l,i=Array.from({length:o},()=>[]),f=[],a=[],d=new Map,h=0,c=new Set,u=new Set;for(let M=0;M<=s;M++)for(let k=0;k<=n;k++){let T=M*l+k;if(e.nodes[M][k].type===1&&f.push(T),e.nodes[M][k].type===2&&a.push(T),(e.nodes[M][k].type===3||e.nodes[M][k].type===4||e.nodes[M][k].type===5)&&(d.set(`n${k},${M}`,h++),u.add(T)),k<n){let F=T+1,q=e.hEdges[M][k].type,Z=q===3||q===4||q===5,Y=q===1||q===2;i[T].push({next:F,hexType:q,isBroken:Y}),i[F].push({next:T,hexType:q,isBroken:Y}),Z&&(d.set(`eh${k},${M}`,h++),c.add(this.getEdgeKey({x:k,y:M},{x:k+1,y:M})))}if(M<s){let F=T+l,q=e.vEdges[M][k].type,Z=q===3||q===4||q===5,Y=q===1||q===2;i[T].push({next:F,hexType:q,isBroken:Y}),i[F].push({next:T,hexType:q,isBroken:Y}),Z&&(d.set(`ev${k},${M}`,h++),c.add(this.getEdgeKey({x:k,y:M},{x:k,y:M+1})))}}let r={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},y=h,p=new Set,x=Math.max(1e3,s*n*200),g=this.getExternalCells(e),m=!1;for(let M=0;M<s;M++){for(let k=0;k<n;k++)if(e.cells[M][k].type!==0){m=!0;break}if(m)break}this.tetrisCache.clear();let b=t?t.map(M=>M.y*l+M.x):f;for(let M of b){let k=e.cols+1,T=Math.floor(M/k),F=M%k,q=0n,Z=e.nodes[T][F].type;(Z===3||Z===4)&&(q|=1n<<BigInt(d.get(`n${F},${T}`)));let Y=e.symmetry||0;if(Y!==0){let _=this.getSymmetricalPointIndex(e,M),G=Math.floor(_/k),I=_%k,J=e.nodes[G][I].type;(J===3||J===5)&&(q|=1n<<BigInt(d.get(`n${I},${G}`)))}let j=1n<<BigInt(M);if(Y!==0){let _=this.getSymmetricalPointIndex(e,M);if(_===M)continue;j|=1n<<BigInt(_)}this.exploreSearchSpace(e,M,j,[M],q,y,i,a,p,r,x,g,m,d)}if(r.solutions===0)return 0;let S=c.size+u.size,E=new Set;c.size>0&&E.add(999);let P=0,v=0,w=0;for(let M=0;M<s;M++)for(let k=0;k<n;k++){let T=e.cells[M][k];T.type!==0&&(S++,E.add(T.type),T.type===3?P++:T.type===4?(P++,v++):T.type===8&&w++)}let N=r.branchingPoints/(r.totalNodesVisited||1),C=Math.log10(r.totalNodesVisited+1),z=(N*10+C*1.5)/(Math.log2(r.solutions+1)*.5+1);z-=c.size*.05,z+=u.size*.12,P>0&&(z+=(P-v)*.5,z+=v*.2);let D=0,W=0;for(let M=0;M<s;M++)for(let k=0;k<n;k++){let T=e.cells[M][k];T.type===5?D++:T.type===6&&(D++,W++)}D>0&&(z+=(D-W)*.6,z+=W*.3),w>0&&(z+=w*.25);let O=s*n,$=S/O,V=$<.25?Math.pow($/.25,4):1,H=E.size<=1?.5:1;z*=V*H;let B=Math.log2(O)/5;return z*=B,Math.max(.01,Math.min(1,z/4))}exploreSearchSpace(e,t,s,n,l,o,i,f,a,d,h,c,u=!0,r){if(d.totalNodesVisited++,d.maxDepth=Math.max(d.maxDepth,n.length),d.totalNodesVisited>h)return;let y=e.symmetry||0;if(f.includes(t)){let g=0,m=l;for(;m>0n;)m&1n&&g++,m>>=1n;if(g===o){let b=n.map(P=>({x:P%(e.cols+1),y:Math.floor(P/(e.cols+1))})),S={points:b};if(y!==0){let P=this.getSymmetricalPointIndex(e,t),v=e.cols+1;if(e.nodes[Math.floor(P/v)][P%v].type!==2)return}let E=y!==0?b.map(P=>this.getSymmetricalPoint(e,P)):[];if(u){let P=this.validateFast(e,b,E,c);if(P.isValid){let v=this.getFingerprint(e,b,E,P.regions,c);a.has(v)||(a.add(v),d.solutions++)}}else{let P=this.getFingerprint(e,b,E,void 0,c);a.has(P)||(a.add(P),d.solutions++)}}return}if(!this.canReachEndOptimized(t,s,i,f)){d.backtracks++;return}let p=[];for(let g of i[t]){if(g.isBroken||s&1n<<BigInt(g.next))continue;if(y!==0){let b=this.getSymmetricalPointIndex(e,t),S=this.getSymmetricalPointIndex(e,g.next);if(g.next===S||t===S&&g.next===b)continue}let m=!0;for(let b of i[t])if(b.hexType===3||b.hexType===4){let E=n.length>=2&&b.next===n[n.length-2],P=b.next===g.next;if(!E&&!P){m=!1;break}}if(m){if(y!==0){let b=this.getSymmetricalPointIndex(e,t),S=this.getSymmetricalPointIndex(e,g.next);for(let E of i[b])if(E.hexType===3||E.hexType===5){let v=n.length>=2?this.getSymmetricalPointIndex(e,n[n.length-2]):-1,w=E.next===v,N=E.next===S;if(!w&&!N){m=!1;break}}}m&&p.push(g)}}if(p.length>1&&d.branchingPoints++,e.rows*e.cols>30)for(let g=p.length-1;g>0;g--){let m=this.rng?this.rng.next():Math.random(),b=Math.floor(m*(g+1));[p[g],p[b]]=[p[b],p[g]]}let x=e.cols+1;for(let g of p){let m=l,b=Math.floor(g.next/x),S=g.next%x,E=e.nodes[b][S].type;(E===3||E===4)&&(m|=1n<<BigInt(r.get(`n${S},${b}`)));let P=n[n.length-1],v=Math.floor(P/x),w=P%x;if(v===b){let C=Math.min(w,S);(g.hexType===3||g.hexType===4)&&(m|=1n<<BigInt(r.get(`eh${C},${b}`)))}else{let C=Math.min(v,b);(g.hexType===3||g.hexType===4)&&(m|=1n<<BigInt(r.get(`ev${S},${C}`)))}if(y!==0){let C=this.getSymmetricalPointIndex(e,g.next),z=Math.floor(C/x),D=C%x,W=e.nodes[z][D].type;(W===3||W===5)&&(m|=1n<<BigInt(r.get(`n${D},${z}`)));let O=this.getSymmetricalPointIndex(e,P),$=Math.floor(O/x),V=O%x;if($===z){let H=Math.min(V,D),B=e.hEdges[z][H].type;(B===3||B===5)&&(m|=1n<<BigInt(r.get(`eh${H},${z}`)))}else{let H=Math.min($,z),B=e.vEdges[H][D].type;(B===3||B===5)&&(m|=1n<<BigInt(r.get(`ev${D},${H}`)))}}n.push(g.next);let N=s|1n<<BigInt(g.next);if(y!==0){let C=this.getSymmetricalPointIndex(e,g.next);N|=1n<<BigInt(C)}if(this.exploreSearchSpace(e,g.next,N,n,m,o,i,f,a,d,h,c,u,r),n.pop(),d.totalNodesVisited>h)return}}countSolutions(e,t=100,s){let n=e.rows,l=e.cols,o=l+1,i=(n+1)*o,f=Array.from({length:i},()=>[]),a=[],d=[],h=new Map,c=0;for(let g=0;g<=n;g++)for(let m=0;m<=l;m++){let b=g*o+m;if(e.nodes[g][m].type===1&&a.push(b),e.nodes[g][m].type===2&&d.push(b),(e.nodes[g][m].type===3||e.nodes[g][m].type===4||e.nodes[g][m].type===5)&&h.set(`n${m},${g}`,c++),m<l){let S=b+1,E=e.hEdges[g][m].type,P=E===3||E===4||E===5,v=E===1||E===2;f[b].push({next:S,hexType:E,isBroken:v}),f[S].push({next:b,hexType:E,isBroken:v}),P&&h.set(`eh${m},${g}`,c++)}if(g<n){let S=b+o,E=e.vEdges[g][m].type,P=E===3||E===4||E===5,v=E===1||E===2;f[b].push({next:S,hexType:E,isBroken:v}),f[S].push({next:b,hexType:E,isBroken:v}),P&&h.set(`ev${m},${g}`,c++)}}let u=new Set,r=c,y=this.getExternalCells(e),p=!1;for(let g=0;g<n;g++){for(let m=0;m<l;m++)if(e.cells[g][m].type!==0){p=!0;break}if(p)break}this.tetrisCache.clear();let x=s?s.map(g=>g.y*o+g.x):a;for(let g of x){let m=e.cols+1,b=Math.floor(g/m),S=g%m,E=0n,P=e.nodes[b][S].type;(P===3||P===4)&&(E|=1n<<BigInt(h.get(`n${S},${b}`)));let v=e.symmetry||0;if(v!==0){let N=this.getSymmetricalPointIndex(e,g),C=Math.floor(N/m),z=N%m,D=e.nodes[C][z].type;(D===3||D===5)&&(E|=1n<<BigInt(h.get(`n${z},${C}`)))}let w=1n<<BigInt(g);if(v!==0){let N=this.getSymmetricalPointIndex(e,g);if(N===g)continue;w|=1n<<BigInt(N)}this.findPathsOptimized(e,g,w,[g],E,r,f,d,u,t,y,p,h)}return u.size}findPathsOptimized(e,t,s,n,l,o,i,f,a,d,h,c=!0,u){if(a.size>=d)return;let r=e.symmetry||0;if(f.includes(t)){let y=0,p=l;for(;p>0n;)p&1n&&y++,p>>=1n;if(y===o){let x=n.map(m=>({x:m%(e.cols+1),y:Math.floor(m/(e.cols+1))}));if(r!==0){let m=this.getSymmetricalPointIndex(e,t),b=e.cols+1;if(e.nodes[Math.floor(m/b)][m%b].type!==2)return}let g=r!==0?x.map(m=>this.getSymmetricalPoint(e,m)):[];if(!c)a.add(this.getFingerprint(e,x,g,void 0,h));else{let m=this.validateFast(e,x,g,h);m.isValid&&a.add(this.getFingerprint(e,x,g,m.regions,h))}}return}if(this.canReachEndOptimized(t,s,i,f))for(let y of i[t]){if(y.isBroken||s&1n<<BigInt(y.next))continue;if(r!==0){let w=this.getSymmetricalPointIndex(e,t),N=this.getSymmetricalPointIndex(e,y.next);if(y.next===N||t===N&&y.next===w)continue}let p=!0;for(let w of i[t])if(w.hexType===3||w.hexType===4){let C=n.length>=2&&w.next===n[n.length-2],z=w.next===y.next;if(!C&&!z){p=!1;break}}if(!p)continue;if(r!==0){let w=this.getSymmetricalPointIndex(e,t),N=this.getSymmetricalPointIndex(e,y.next);for(let C of i[w])if(C.hexType===3||C.hexType===5){let D=n.length>=2?this.getSymmetricalPointIndex(e,n[n.length-2]):-1,W=C.next===D,O=C.next===N;if(!W&&!O){p=!1;break}}}if(!p)continue;let x=e.cols+1,g=l,m=Math.floor(y.next/x),b=y.next%x,S=e.nodes[m][b].type;(S===3||S===4)&&(g|=1n<<BigInt(u.get(`n${b},${m}`)));let E=Math.floor(t/x),P=t%x;if(E===m){let w=Math.min(P,b);(y.hexType===3||y.hexType===4)&&(g|=1n<<BigInt(u.get(`eh${w},${m}`)))}else{let w=Math.min(E,m);(y.hexType===3||y.hexType===4)&&(g|=1n<<BigInt(u.get(`ev${b},${w}`)))}if(r!==0){let w=this.getSymmetricalPointIndex(e,y.next),N=Math.floor(w/x),C=w%x,z=e.nodes[N][C].type;(z===3||z===5)&&(g|=1n<<BigInt(u.get(`n${C},${N}`)));let D=this.getSymmetricalPointIndex(e,t),W=Math.floor(D/x),O=D%x;if(W===N){let $=Math.min(O,C),V=e.hEdges[N][$].type;(V===3||V===5)&&(g|=1n<<BigInt(u.get(`eh${$},${N}`)))}else{let $=Math.min(W,N),V=e.vEdges[$][C].type;(V===3||V===5)&&(g|=1n<<BigInt(u.get(`ev${C},${$}`)))}}n.push(y.next);let v=s|1n<<BigInt(y.next);if(r!==0){let w=this.getSymmetricalPointIndex(e,y.next);v|=1n<<BigInt(w)}if(this.findPathsOptimized(e,y.next,v,n,g,o,i,f,a,d,h,c,u),n.pop(),a.size>=d)return}}canReachEndOptimized(e,t,s,n){let l=[e],o=t,i=0;for(;i<l.length;){let f=l[i++];if(n.includes(f))return!0;for(let a of s[f])!a.isBroken&&!(o&1n<<BigInt(a.next))&&(o|=1n<<BigInt(a.next),l.push(a.next))}return!1}getFingerprint(e,t,s,n,l){let i=(n||this.calculateRegions(e,t,s,l)).map(a=>{let d="",h=[];for(let c of a){let u=e.cells[c.y][c.x];u.type!==0&&h.push(u.type<<8|u.color)}h.sort((c,u)=>c-u);for(let c of h)d+=c.toString(36)+",";return d}).sort(),f="";for(let a of i)a.length>0&&(f+=a+"|");return f||"empty"}};var ce=class{isWorker;TETRIS_SHAPES_WITH_ROTATIONS=[];rng=null;constructor(){this.isWorker=typeof self<"u"&&"postMessage"in self&&!("document"in self);for(let e of this.TETRIS_SHAPES)this.TETRIS_SHAPES_WITH_ROTATIONS.push(this.getAllRotations(e))}stringToSeed(e){try{if(/^[0-9a-fA-F]+$/.test(e))return BigInt("0x"+e)}catch{}let t=0n;for(let s=0;s<e.length;s++)t=(t<<5n)-t+BigInt(e.charCodeAt(s));return t}generate(e,t,s={}){let n=s.rngType??0,l=s.seed;l||(l=Math.floor(Math.random()*4294967295).toString(16));let o=l,i=this.stringToSeed(l),f=s.difficulty??.5,a=new ae,d=null,h=-1,c=e*t<=16,u=this.isWorker?e*t>30?120:c?250:150:e*t>30?80:c?200:100,r=this.isWorker?8:c?12:6,y=s.symmetry||0,p=s.starts?[...s.starts]:[{x:0,y:e}];if(y!==0){let S=[];for(let E of p){let P=this.getSymmetricalPoint({rows:e,cols:t},E,y);p.some(v=>v.x===P.x&&v.y===P.y)||S.push(P)}p.push(...S)}let x=s.ends?[...s.ends]:[];if(x.length===0&&(y===1?x=[{x:0,y:0}]:y===2?x=[{x:t,y:e}]:y===3?x=[{x:t,y:e}]:x=[{x:t,y:0}]),y!==0){let S=[];for(let E of x){let P=this.getSymmetricalPoint({rows:e,cols:t},E,y);x.some(v=>v.x===P.x&&v.y===P.y)||S.push(P)}x.push(...S)}let g=null,m=null,b=null;for(let S=0;S<u;S++){let E=(i^0x5deece66dn)+0xbn;if(this.rng=ye(n,i^0x5deece66dn),a.setRng(this.rng),S%r===0){g=this.generateRandomPath(new oe(e,t),p,x,s.pathLength,y);let W=new oe(e,t),O=y!==0?g.map($=>this.getSymmetricalPoint(W,$,y)):[];m=this.calculateRegions(W,g,O),b=m.map($=>this.getRegionBoundaryEdges(W,$,g,O))}let P=this.generateFromPath(e,t,g,s,p,x,m,b);if(!a.validate(P,{points:g}).isValid){i=E;continue}let w=g[0],N=[w];if(y!==0){let W=this.getSymmetricalPoint(P,w,y);(W.x!==w.x||W.y!==w.y)&&N.push(W)}let C=p.filter(W=>!N.some(O=>O.x===W.x&&O.y===W.y));if(C.length>0&&a.countSolutions(P,10,C)>2){i=E;continue}if(!this.checkAllRequestedConstraintsPresent(P,s)){i=E;continue}let z=a.calculateDifficulty(P);if(z===0){i=E;continue}let D=Math.abs(z-f);if((d===null||D<Math.abs(h-f))&&(h=z,d=P,d.seed=o),f>.8&&z>.8){d.seed=o;break}if(D<.01){d.seed=o;break}i=E}if(!d){for(let P=0;P<50;P++){this.rng=ye(n,i),a.setRng(this.rng);let v=this.generateRandomPath(new oe(e,t),p,x,s.pathLength,y),w=this.generateFromPath(e,t,v,s,p,x);if(a.validate(w,{points:v}).isValid)return w.seed=o,w;i=(i^0x5deece66dn)+0xbn}this.rng=ye(n,i),a.setRng(this.rng);let S=this.generateRandomPath(new oe(e,t),p,x,s.pathLength,y),E=this.generateFromPath(e,t,S,s,p,x);return E.seed=o,E}return d}generateFromPath(e,t,s,n,l,o,i,f){let a=new oe(e,t),d=n.symmetry||0;a.symmetry=d;for(let c of l)a.nodes[c.y][c.x].type=1;for(let c of o)a.nodes[c.y][c.x].type=2;let h=d!==0?s.map(c=>this.getSymmetricalPoint(a,c,d)):[];return this.applyConstraintsBasedOnPath(a,s,n,h,i,f),n.useBrokenEdges&&this.applyBrokenEdges(a,s,n),this.cleanGrid(a),a}generateRandomPath(e,t,s,n,l=0){if(n===void 0)return this.generateSingleRandomPath(e,t,s,void 0,l);let o=e.rows+e.cols,i=(e.rows+1)*(e.cols+1)-1,f=o+n*(i-o),a=[],d=1/0,h=e.rows*e.cols>30?30:50;for(let c=0;c<h;c++){let u=this.generateSingleRandomPath(e,t,s,n,l);if(u.length===0)continue;let r=u.length-1,y=Math.abs(r-f);if(y<d&&(d=y,a=u),d<=2)break}return a}generateSingleRandomPath(e,t,s,n,l=0){let o=new Set,i=[],f=0,a=e.rows*e.cols*200,d=t[Math.floor(this.rng.next()*t.length)],h=new Set(s.map(u=>`${u.x},${u.y}`)),c=u=>{if(f++,f>a)return!1;o.add(`${u.x},${u.y}`);let r=this.getSymmetricalPoint(e,u,l);if(o.add(`${r.x},${r.y}`),i.push(u),h.has(`${u.x},${u.y}`))if(l!==0){let p=this.getSymmetricalPoint(e,u,l);if(h.has(`${p.x},${p.y}`))return!0}else return!0;let y=this.getValidNeighbors(e,u,o);l!==0&&(y=y.filter(p=>{let x=this.getSymmetricalPoint(e,p,l);if(x.x<0||x.x>e.cols||x.y<0||x.y>e.rows||o.has(`${x.x},${x.y}`)||p.x===x.x&&p.y===x.y)return!1;let g=this.getEdgeKey(u,p),m=this.getEdgeKey(r,x);return g!==m})),n!==void 0?y.sort((p,x)=>{let g=E=>Math.min(...s.map(P=>Math.abs(E.x-P.x)+Math.abs(E.y-P.y))),m=g(p),b=g(x);return(m-b)*(1-n*2)+(this.rng.next()-.5)*1.5}):this.shuffleArray(y);for(let p of y)if(c(p))return!0;return i.pop(),o.delete(`${u.x},${u.y}`),o.delete(`${r.x},${r.y}`),!1};return c(d),i}getValidNeighbors(e,t,s){let n=[],l=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of l){let i=t.x+o.x,f=t.y+o.y;i>=0&&i<=e.cols&&f>=0&&f<=e.rows&&(s.has(`${i},${f}`)||n.push({x:i,y:f}))}return n}applyBrokenEdges(e,t,s){let n=s.complexity??.5,l=s.symmetry??0,o=new Set;for(let h=0;h<t.length-1;h++)if(o.add(this.getEdgeKey(t[h],t[h+1])),l!==0){let c=this.getSymmetricalPoint(e,t[h],l),u=this.getSymmetricalPoint(e,t[h+1],l);o.add(this.getEdgeKey(c,u))}let i=[];for(let h=0;h<=e.rows;h++)for(let c=0;c<e.cols;c++){let u={x:c,y:h},r={x:c+1,y:h};o.has(this.getEdgeKey(u,r))||i.push({type:"h",r:h,c,p1:u,p2:r})}for(let h=0;h<e.rows;h++)for(let c=0;c<=e.cols;c++){let u={x:c,y:h},r={x:c,y:h+1};o.has(this.getEdgeKey(u,r))||i.push({type:"v",r:h,c,p1:u,p2:r})}this.shuffleArray(i);let f=Math.max(1,Math.floor(n*(e.rows*e.cols)/4)),a=0;for(let h of i){if(a>=f)break;h.type==="h"?e.hEdges[h.r][h.c].type=1:e.vEdges[h.r][h.c].type=1,a++}let d=!0;for(;d;){d=!1;for(let h=0;h<=e.rows;h++)for(let c=0;c<e.cols;c++)e.hEdges[h][c].type===1&&this.canBecomeAbsent(e,{type:"h",r:h,c})&&(e.hEdges[h][c].type=2,d=!0);for(let h=0;h<e.rows;h++)for(let c=0;c<=e.cols;c++)e.vEdges[h][c].type===1&&this.canBecomeAbsent(e,{type:"v",r:h,c})&&(e.vEdges[h][c].type=2,d=!0)}for(let h=0;h<=e.rows;h++)for(let c=0;c<=e.cols;c++){let u=[];if(c>0&&u.push({e:e.hEdges[h][c-1],type:"h",r:h,c:c-1}),c<e.cols&&u.push({e:e.hEdges[h][c],type:"h",r:h,c}),h>0&&u.push({e:e.vEdges[h-1][c],type:"v",r:h-1,c}),h<e.rows&&u.push({e:e.vEdges[h][c],type:"v",r:h,c}),u.length>0&&u.every(r=>r.e.type===1||r.e.type===2)&&u.every(r=>!this.isAdjacentToMark(e,r)))for(let r of u)r.e.type=2}}canBecomeAbsent(e,t){if(this.isAdjacentToMark(e,t))return!1;if(t.type==="h"){if(t.r===0||t.r===e.rows)return!0}else if(t.c===0||t.c===e.cols)return!0;let s=t.type==="h"?[{x:t.c,y:t.r},{x:t.c+1,y:t.r}]:[{x:t.c,y:t.r},{x:t.c,y:t.r+1}];for(let n of s){let l=[{type:"h",r:n.y,c:n.x-1},{type:"h",r:n.y,c:n.x},{type:"v",r:n.y-1,c:n.x},{type:"v",r:n.y,c:n.x}];for(let o of l)if(o.c>=0&&o.c<=e.cols&&o.r>=0&&o.r<=e.rows){if(o.type==="h"&&o.c<e.cols){if(e.hEdges[o.r][o.c].type===2)return!0}else if(o.type==="v"&&o.r<e.rows&&e.vEdges[o.r][o.c].type===2)return!0}}return!1}cleanGrid(e){let t=[];for(let o=0;o<=e.rows;o++)for(let i=0;i<=e.cols;i++)e.nodes[o][i].type===1&&t.push({x:i,y:o});let s=new Set,n=[...t];for(let o of t)s.add(`${o.x},${o.y}`);for(;n.length>0;){let o=n.shift(),i=[{nx:o.x,ny:o.y-1,edge:e.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:e.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:e.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:e.hEdges[o.y]?.[o.x]}];for(let f of i)f.edge&&f.edge.type!==2&&(s.has(`${f.nx},${f.ny}`)||(s.add(`${f.nx},${f.ny}`),n.push({x:f.nx,y:f.ny})))}for(let o=0;o<=e.rows;o++)for(let i=0;i<e.cols;i++)(!s.has(`${i},${o}`)||!s.has(`${i+1},${o}`))&&(e.hEdges[o][i].type=2);for(let o=0;o<e.rows;o++)for(let i=0;i<=e.cols;i++)(!s.has(`${i},${o}`)||!s.has(`${i},${o+1}`))&&(e.vEdges[o][i].type=2);let l=this.getExternalCells(e);for(let o of l){let[i,f]=o.split(",").map(Number);e.cells[f][i].type=0}}getExternalCells(e){let t=new Set,s=[];for(let n=0;n<e.cols;n++)e.hEdges[0][n].type===2&&(t.has(`${n},0`)||(t.add(`${n},0`),s.push({x:n,y:0}))),e.hEdges[e.rows][n].type===2&&(t.has(`${n},${e.rows-1}`)||(t.add(`${n},${e.rows-1}`),s.push({x:n,y:e.rows-1})));for(let n=0;n<e.rows;n++)e.vEdges[n][0].type===2&&(t.has(`0,${n}`)||(t.add(`0,${n}`),s.push({x:0,y:n}))),e.vEdges[n][e.cols].type===2&&(t.has(`${e.cols-1},${n}`)||(t.add(`${e.cols-1},${n}`),s.push({x:e.cols-1,y:n})));for(;s.length>0;){let n=s.shift(),l=[{nx:n.x,ny:n.y-1,edge:e.hEdges[n.y][n.x]},{nx:n.x,ny:n.y+1,edge:e.hEdges[n.y+1][n.x]},{nx:n.x-1,ny:n.y,edge:e.vEdges[n.y][n.x]},{nx:n.x+1,ny:n.y,edge:e.vEdges[n.y][n.x+1]}];for(let o of l)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),s.push({x:o.nx,y:o.ny}))}return t}isAdjacentToMark(e,t){if(t.type==="h"){if(t.r>0&&e.cells[t.r-1][t.c].type!==0||t.r<e.rows&&e.cells[t.r][t.c].type!==0)return!0}else if(t.c>0&&e.cells[t.r][t.c-1].type!==0||t.c<e.cols&&e.cells[t.r][t.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let t=0;t<e.rows;t++)for(let s=0;s<e.cols;s++){if(e.cells[t][s].type===0)continue;if([e.hEdges[t][s],e.hEdges[t+1][s],e.vEdges[t][s],e.vEdges[t][s+1]].every(l=>l.type===1||l.type===2))return!0}return!1}getSymmetricalPoint(e,t,s){return s===1?{x:e.cols-t.x,y:t.y}:s===2?{x:t.x,y:e.rows-t.y}:s===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,t,s,n=[],l,o){let i=s.complexity??.5,f=s.useHexagons??!0,a=s.useSquares??!0,d=s.useStars??!0,h=s.useTetris??!1,c=s.useTetrisNegative??!1,u=s.useEraser??!1,r=s.useTriangles??!1,y=0,p=0,x=0,g=0,m=0,b=0,S=Math.floor(e.rows*e.cols*.6);if(f){let E=s.difficulty??.5,P=s.symmetry||0;for(let v=0;v<t.length-1;v++){let N=this.getValidNeighbors(e,t[v],new Set).length>2,C=i*(E<.4?.6:.3);if(N&&(C=E<.4?C*1:C*.5),this.rng.next()<C){let z=3,D=t[v],W=t[v+1];if(P!==0){let O=this.rng.next();O<.3?z=4:O<.6&&(z=5,D=this.getSymmetricalPoint(e,t[v],P),W=this.getSymmetricalPoint(e,t[v+1],P))}this.setEdgeHexagon(e,D,W,z),y++}}for(let v=0;v<t.length;v++){let w=t[v];if(e.nodes[w.y][w.x].type!==0||this.hasIncidentHexagonEdge(e,w))continue;let N=i*(E>.6?.15:.05);if(this.rng.next()<N){let C=3,z=w;if(P!==0){let D=this.rng.next();D<.3?C=4:D<.6&&(C=5,z=this.getSymmetricalPoint(e,w,P))}e.nodes[z.y][z.x].type=C,y++}}if(y===0&&t.length>=2){let v=Math.floor(this.rng.next()*(t.length-1)),w=s.symmetry||0,N=3,C=t[v],z=t[v+1];if(w!==0){let D=this.rng.next();D<.3?N=4:D<.6&&(N=5,C=this.getSymmetricalPoint(e,t[v],w),z=this.getSymmetricalPoint(e,t[v+1],w))}this.setEdgeHexagon(e,C,z,N)}}if(a||d||h||u||r){let E=l||this.calculateRegions(e,t,n),P=s.availableColors??[X.Black,X.White,X.Red,X.Blue],v=s.defaultColors??{},w=($,V)=>{if(v[$]!==void 0)return v[$];let H=re[$];return H&&v[H]!==void 0?v[H]:$===4?w(3,V):$===6?w(5,V):V},N=Array.from({length:E.length},($,V)=>V);this.shuffleArray(N);let C=new Set,z={square:a,star:d,tetris:h,tetrisNegative:c,eraser:u,triangle:r},D=0,W=0,O=new Set;for(let $=0;$<t.length-1;$++)O.add(this.getEdgeKey(t[$],t[$+1]));for(let $=0;$<n.length-1;$++)O.add(this.getEdgeKey(n[$],n[$+1]));for(let $=0;$<N.length;$++){let V=N[$],H=E[V],B=N.length-$,M=z.square&&p===0||z.star&&x===0||z.tetris&&g===0||z.tetrisNegative&&D===0||z.eraser&&m===0||z.triangle&&W===0,k=.2+i*.6;if(M&&B<=3?k=1:M&&B<=6&&(k=.7),this.rng.next()>k)continue;let T=[...H];this.shuffleArray(T);let F=new Set,q=P[Math.floor(this.rng.next()*P.length)];if(a&&C.size<2){let Y=P.filter(j=>!C.has(j));Y.length>0&&(q=Y[Math.floor(this.rng.next()*Y.length)])}let Z=a&&this.rng.next()<.5+i*.3;if(a&&p===0&&B<=2&&(Z=!0),a&&!d&&B<=2&&C.size<2&&p>0&&(Z=!0),Z&&T.length>0){let Y=Math.min(T.length,Math.max(4,Math.floor(H.length/4))),j=Math.floor(this.rng.next()*(Y/2))+Math.ceil(Y/2);for(let _=0;_<j&&T.length!==0;_++){let G=T.pop();e.cells[G.y][G.x].type=1,e.cells[G.y][G.x].color=q,p++,C.add(q),F.add(q)}}if(h||c){let Y=this.rng.next()<.1+i*.4;g===0&&B<=3&&(Y=!0),c&&D===0&&B<=2&&(Y=!0);let j=g===0&&B<=2?6:4,_=b+H.length<=S||M&&h&&g===0&&H.length<=30||M&&c&&D===0&&H.length<=30;if(Y&&T.length>0&&_){let G=H.length<=25?this.generateTiling(H,j,s):null;if(G){let I=[],J=.2+i*.3;if(c&&D===0&&B<=3&&(J=.9),c&&this.rng.next()<J){let A=s.difficulty??.5;if(this.rng.next()<.1&&T.length>=2){let K=!1;if(T.length>=3&&this.rng.next()<.8){let ee=this.rng.next()<.5,ne=1+Math.floor(this.rng.next()*2),se=this.TETRIS_SHAPES.filter(ie=>this.getShapeArea(ie)===ne),te=se[Math.floor(this.rng.next()*se.length)],U=this.findStandardTriple(te);U&&(ee?(G.push({shape:te,displayShape:te,isRotated:!this.isRotationallyInvariant(te)&&this.rng.next()<A*.7,isNegative:!1}),G.push({shape:U.n,displayShape:U.n,isRotated:!this.isRotationallyInvariant(U.n)&&this.rng.next()<A*.7,isNegative:!1}),I.push({shape:U.p,displayShape:U.p,isRotated:!this.isRotationallyInvariant(U.p)&&this.rng.next()<A*.7,isNegative:!0})):(G.push({shape:U.p,displayShape:U.p,isRotated:!this.isRotationallyInvariant(U.p)&&this.rng.next()<A*.7,isNegative:!1}),I.push({shape:te,displayShape:te,isRotated:!this.isRotationallyInvariant(te)&&this.rng.next()<A*.7,isNegative:!0}),I.push({shape:U.n,displayShape:U.n,isRotated:!this.isRotationallyInvariant(U.n)&&this.rng.next()<A*.7,isNegative:!0})),K=!0)}if(!K){let ee=3+Math.floor(this.rng.next()*2),ne=this.TETRIS_SHAPES.filter(se=>this.getShapeArea(se)===ee);if(this.shuffleArray(ne),ne.length>0){let se=ne[0],te=ne[0];G.push({shape:se,displayShape:se,isRotated:!this.isRotationallyInvariant(se)&&this.rng.next()<A*.7,isNegative:!1}),I.push({shape:te,displayShape:te,isRotated:!this.isRotationallyInvariant(te)&&this.rng.next()<A*.7,isNegative:!0})}}}else if(G.length>0){let K=this.rng.next()<.3?2:1;for(let ee=0;ee<K&&!(T.length<1);ee++){let ne=Math.floor(this.rng.next()*G.length),se=G[ne];if(se.isNegative)continue;let te=!1;if(T.length>=2&&this.rng.next()<.2){let U=this.findStandardTriple(se.shape);if(U){let ie=this.findStandardTriple(U.p);ie&&(G[ne]={shape:ie.p,displayShape:ie.p,isRotated:!this.isRotationallyInvariant(ie.p)&&this.rng.next()<A*.7,isNegative:!1},I.push({shape:U.n,displayShape:U.n,isRotated:!this.isRotationallyInvariant(U.n)&&this.rng.next()<A*.7,isNegative:!0}),I.push({shape:ie.n,displayShape:ie.n,isRotated:!this.isRotationallyInvariant(ie.n)&&this.rng.next()<A*.7,isNegative:!0}),te=!0)}}if(!te){let U=this.findStandardTriple(se.shape);U&&(G.some(Pe=>!Pe.isNegative&&this.isSameShape(Pe.shape,U.n))||(G[ne]={shape:U.p,displayShape:U.p,isRotated:!this.isRotationallyInvariant(U.p)&&this.rng.next()<A*.7,isNegative:!1},I.push({shape:U.n,displayShape:U.n,isRotated:!this.isRotationallyInvariant(U.n)&&this.rng.next()<A*.7,isNegative:!0})))}}}}let R=[...G,...I];if(R.length>T.length)continue;for(let A of R){if(T.length===0)break;let L=T.pop();if(A.isNegative)e.cells[L.y][L.x].type=A.isRotated?6:5,e.cells[L.y][L.x].color=w(5,X.None),D++;else{e.cells[L.y][L.x].type=A.isRotated?4:3;let ee=w(3,X.None),ne=ee;if(d&&this.rng.next()<.3){let se=P.filter(te=>te!==ee&&!F.has(te));se.length>0&&(ne=se[Math.floor(this.rng.next()*se.length)],F.add(ne))}e.cells[L.y][L.x].color=ne}e.cells[L.y][L.x].shape=A.isRotated?A.displayShape:A.shape,g++}b+=H.length}}}if(r){let Y=this.rng.next()<.2+i*.5;if(W===0&&B<=2&&(Y=!0),Y&&T.length>0){this.shuffleArray(T);let j=Math.min(T.length,Math.max(1,Math.floor(H.length/3))),_=0;for(let G=0;G<T.length&&_<j;G++){let I=T[G],J=[this.getEdgeKey({x:I.x,y:I.y},{x:I.x+1,y:I.y}),this.getEdgeKey({x:I.x,y:I.y+1},{x:I.x+1,y:I.y+1}),this.getEdgeKey({x:I.x,y:I.y},{x:I.x,y:I.y+1}),this.getEdgeKey({x:I.x+1,y:I.y},{x:I.x+1,y:I.y+1})],R=0;for(let A of J)O.has(A)&&R++;if(R>=1&&R<=3){e.cells[I.y][I.x].type=8,e.cells[I.y][I.x].count=R;let A=w(8,X.None),L=A;if(d&&this.rng.next()<.3){let K=P.filter(ee=>ee!==A&&!F.has(ee));K.length>0&&(L=K[Math.floor(this.rng.next()*K.length)],F.add(L))}e.cells[I.y][I.x].color=L,T.splice(G,1),G--,W++,_++}}}}if(u&&m<1){let Y=.05+i*.2,j=this.rng.next()<Y;if(B<=2&&(j=!0),j&&T.length>=1){let _=[];d&&_.push("star"),a&&_.push("square");let G=[];f&&(G=o?o[V]:this.getRegionBoundaryEdges(e,H,t,n),G.length>0&&_.push("hexagon")),h&&_.push("tetris"),c&&_.push("tetrisNegative"),r&&_.push("triangle"),this.shuffleArray(_),T.length>=2&&_.push("eraser");let I=!1;for(let J of _){if(I)break;if(J==="hexagon"){let R=G.filter(A=>!this.isEdgeAdjacentToHexagonNode(e,A));if(R.length>0){let A=R[Math.floor(this.rng.next()*R.length)];A.type==="h"?e.hEdges[A.r][A.c].type=3:e.vEdges[A.r][A.c].type=3,y++,I=!0}}else if(J==="square"&&T.length>=2){let R=T.pop();e.cells[R.y][R.x].type=1;let A=H.find(K=>e.cells[K.y][K.x].type===1),L=A?e.cells[A.y][A.x].color:void 0;e.cells[R.y][R.x].color=P.find(K=>K!==L)||X.Red,p++,I=!0}else if(J==="star"&&T.length>=2){let R=T.pop();e.cells[R.y][R.x].type=2,e.cells[R.y][R.x].color=P[Math.floor(this.rng.next()*P.length)],x++,I=!0}else if(J==="tetris"&&T.length>=2){let R=this.generateTiling(H,4,s),A=[];if(R&&R.length>0){let L=0;for(let K of R){let ee=this.getShapeArea(K.shape);if(L+ee<H.length)A.push(K),L+=ee;else break}}if(A.length===0&&H.length>1&&(A=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),A.length>0){for(let L of A){if(T.length<2)break;let K=T.pop();e.cells[K.y][K.x].type=L.isRotated?4:3,e.cells[K.y][K.x].shape=L.isRotated?L.displayShape:L.shape,e.cells[K.y][K.x].color=w(e.cells[K.y][K.x].type,X.None),g++}I=!0}}else if(J==="tetrisNegative"&&this.canPlaceGeneratedTetrisNegative(e,H,T)){if(!this.hasRegionTetrisSymbol(e,H)){let A=T.pop();e.cells[A.y][A.x].type=3,e.cells[A.y][A.x].shape=[[1]],e.cells[A.y][A.x].color=w(3,X.None),g++}let R=T.pop();e.cells[R.y][R.x].type=5,e.cells[R.y][R.x].shape=[[1]],e.cells[R.y][R.x].color=w(5,X.None),D++}else if(J==="triangle"&&T.length>=2){let R=T.pop();e.cells[R.y][R.x].type=8;let A=[this.getEdgeKey({x:R.x,y:R.y},{x:R.x+1,y:R.y}),this.getEdgeKey({x:R.x,y:R.y+1},{x:R.x+1,y:R.y+1}),this.getEdgeKey({x:R.x,y:R.y},{x:R.x,y:R.y+1}),this.getEdgeKey({x:R.x+1,y:R.y},{x:R.x+1,y:R.y+1})],L=0;for(let ee of A)O.has(ee)&&L++;let K=(L+1)%4;K===0&&(K=1),e.cells[R.y][R.x].count=K,e.cells[R.y][R.x].color=w(8,X.None),W++,I=!0}else if(J==="eraser"&&this.canPlaceGeneratedEraser(e,H,T)){let R=T.pop();e.cells[R.y][R.x].type=7,e.cells[R.y][R.x].color=w(7,X.White),m++,I=!0}}if(I&&this.canPlaceGeneratedEraser(e,H,T)){let J=T.pop();e.cells[J.y][J.x].type=7;let R=w(7,X.White),A=R;if(d&&this.rng.next()<.3){let L=P.filter(K=>K!==R&&!F.has(K));L.length>0&&(A=L[Math.floor(this.rng.next()*L.length)],F.add(A))}e.cells[J.y][J.x].color=A,m++}}}if(d){for(let j of P){if(T.length<1)break;if(H.filter(G=>e.cells[G.y][G.x].color===j).length===1&&(j!==X.White||F.has(j))){let G=T.pop();e.cells[G.y][G.x].type=2,e.cells[G.y][G.x].color=j,x++}}let Y=Math.max(1,Math.floor(H.length/8));for(let j=0;j<Y&&!(T.length<2);j++)for(let _ of P){if(T.length<2)break;if(this.rng.next()>.3+i*.4)continue;if(H.filter(I=>e.cells[I.y][I.x].color===_).length===0)for(let I=0;I<2;I++){let J=T.pop();e.cells[J.y][J.x].type=2,e.cells[J.y][J.x].color=_,x++}}}}if(a&&C.size<2){let $=C.values().next().value;if(!($!==void 0&&x>0&&Array.from({length:e.rows*e.cols}).some((H,B)=>{let M=Math.floor(B/e.cols),k=B%e.cols;return e.cells[M][k].type===2&&e.cells[M][k].color===$}))){for(let H of E){if(C.size>=2)break;if(H.some(M=>e.cells[M.y][M.x].type===1))continue;let B=H.filter(M=>e.cells[M.y][M.x].type===0);if(B.length>0){let M=P.find(T=>!C.has(T))||X.White,k=B[Math.floor(this.rng.next()*B.length)];e.cells[k.y][k.x].type=1,e.cells[k.y][k.x].color=M,C.add(M),p++}}if(C.size<2&&d&&$!==void 0)for(let H of E){let B=H.filter(M=>e.cells[M.y][M.x].type===0);if(B.length>0){let M=B[Math.floor(this.rng.next()*B.length)];e.cells[M.y][M.x].type=2,e.cells[M.y][M.x].color=$,x++;break}}}}}}calculateRegions(e,t,s=[]){let n=[],l=e.rows,o=e.cols,i=new Uint8Array(l*o),f=new Uint8Array((l+1)*o),a=new Uint8Array(l*(o+1)),d=(h,c)=>{h.x===c.x?a[Math.min(h.y,c.y)*(o+1)+h.x]=1:f[h.y*o+Math.min(h.x,c.x)]=1};for(let h=0;h<t.length-1;h++)d(t[h],t[h+1]);for(let h=0;h<s.length-1;h++)d(s[h],s[h+1]);for(let h=0;h<=l;h++)for(let c=0;c<o;c++)e.hEdges[h][c].type===2&&(f[h*o+c]=1);for(let h=0;h<l;h++)for(let c=0;c<=o;c++)e.vEdges[h][c].type===2&&(a[h*(o+1)+c]=1);for(let h=0;h<l;h++)for(let c=0;c<o;c++){let u=h*o+c;if(i[u])continue;let r=[],y=[u];i[u]=1;let p=0;for(;p<y.length;){let x=y[p++],g=x%o,m=Math.floor(x/o);if(r.push({x:g,y:m}),m>0&&!f[m*o+g]){let b=(m-1)*o+g;i[b]||(i[b]=1,y.push(b))}if(m<l-1&&!f[(m+1)*o+g]){let b=(m+1)*o+g;i[b]||(i[b]=1,y.push(b))}if(g>0&&!a[m*(o+1)+g]){let b=m*o+(g-1);i[b]||(i[b]=1,y.push(b))}if(g<o-1&&!a[m*(o+1)+(g+1)]){let b=m*o+(g+1);i[b]||(i[b]=1,y.push(b))}}n.push(r)}return n}isAbsentEdge(e,t,s){if(t.x===s.x){let n=Math.min(t.y,s.y);return e.vEdges[n][t.x].type===2}else{let n=Math.min(t.x,s.x);return e.hEdges[t.y][n].type===2}}getRegionBoundaryEdges(e,t,s,n=[]){let l=new Set;for(let f=0;f<s.length-1;f++)l.add(this.getEdgeKey(s[f],s[f+1]));for(let f=0;f<n.length-1;f++)l.add(this.getEdgeKey(n[f],n[f+1]));let o=[];for(let f of t){let a=[{type:"h",r:f.y,c:f.x},{type:"h",r:f.y+1,c:f.x},{type:"v",r:f.y,c:f.x},{type:"v",r:f.y,c:f.x+1}];for(let d of a){let h=d.type==="h"?{x:d.c,y:d.r}:{x:d.c,y:d.r},c=d.type==="h"?{x:d.c+1,y:d.r}:{x:d.c,y:d.r+1},u=this.getEdgeKey(h,c);!l.has(u)&&!this.isAbsentEdge(e,h,c)&&o.push(d)}}let i=new Map;for(let f of o)i.set(`${f.type},${f.r},${f.c}`,f);return Array.from(i.values())}setEdgeHexagon(e,t,s,n=3){t.x===s.x?e.vEdges[Math.min(t.y,s.y)][t.x].type=n:e.hEdges[t.y][Math.min(t.x,s.x)].type=n}hasIncidentHexagonEdge(e,t){let s=n=>n===3||n===4||n===5;return!!(t.x>0&&s(e.hEdges[t.y][t.x-1].type)||t.x<e.cols&&s(e.hEdges[t.y][t.x].type)||t.y>0&&s(e.vEdges[t.y-1][t.x].type)||t.y<e.rows&&s(e.vEdges[t.y][t.x].type))}isEdgeAdjacentToHexagonNode(e,t){let s=n=>n===3||n===4||n===5;return t.type==="h"?s(e.nodes[t.r][t.c].type)||s(e.nodes[t.r][t.c+1].type):s(e.nodes[t.r][t.c].type)||s(e.nodes[t.r+1][t.c].type)}checkAllRequestedConstraintsPresent(e,t){let s=t.useHexagons??!0,n=t.useSquares??!0,l=t.useStars??!0,o=t.useTetris??!1,i=t.useTetrisNegative??!1,f=t.useEraser??!1,a=t.useTriangles??!1;if(t.useBrokenEdges??!1){let h=!1;for(let c=0;c<=e.rows;c++)for(let u=0;u<e.cols;u++)if(e.hEdges[c][u].type===1||e.hEdges[c][u].type===2){h=!0;break}if(!h){for(let c=0;c<e.rows;c++)for(let u=0;u<=e.cols;u++)if(e.vEdges[c][u].type===1||e.vEdges[c][u].type===2){h=!0;break}}if(!h)return!1}if(s){let h=!1,c=r=>r===3||r===4||r===5,u=r=>r===3||r===4||r===5;for(let r=0;r<=e.rows;r++)for(let y=0;y<e.cols;y++)if(c(e.hEdges[r][y].type)){h=!0;break}if(!h){for(let r=0;r<e.rows;r++)for(let y=0;y<=e.cols;y++)if(c(e.vEdges[r][y].type)){h=!0;break}}if(!h){for(let r=0;r<=e.rows;r++)for(let y=0;y<=e.cols;y++)if(u(e.nodes[r][y].type)){h=!0;break}}if(!h)return!1}if(n||l||o||f){let h=!1,c=!1,u=!1,r=!1,y=!1,p=!1,x=new Set,g=new Set;for(let m=0;m<e.rows;m++)for(let b=0;b<e.cols;b++){let S=e.cells[m][b].type;S===1&&(h=!0,x.add(e.cells[m][b].color)),S===2&&(c=!0,g.add(e.cells[m][b].color)),(S===3||S===4)&&(u=!0),(S===5||S===6)&&(r=!0),S===7&&(y=!0),S===8&&(p=!0)}if(n&&!h||l&&!c||o&&!u||i&&!r||f&&!y||a&&!p)return!1;if(n&&h&&x.size<2){let m=x.values().next().value;if(m===void 0||!g.has(m))return!1}}return!this.hasIsolatedMark(e)}generateTiling(e,t,s){let n=Math.min(...e.map(h=>h.x)),l=Math.min(...e.map(h=>h.y)),o=Math.max(...e.map(h=>h.x)),i=Math.max(...e.map(h=>h.y)),f=o-n+1,a=i-l+1,d=Array.from({length:a},()=>Array(f).fill(!1));for(let h of e)d[h.y-l][h.x-n]=!0;return this.tilingDfs(d,[],t,s)}tilingDfs(e,t,s,n){let l=-1,o=-1;for(let a=0;a<e.length;a++){for(let d=0;d<e[0].length;d++)if(e[a][d]){l=a,o=d;break}if(l!==-1)break}if(l===-1)return t;if(t.length>=s)return null;let i=n.difficulty??.5,f=Array.from({length:this.TETRIS_SHAPES.length},(a,d)=>d);this.shuffleArray(f),i>.6&&f.sort((a,d)=>this.getShapeArea(this.TETRIS_SHAPES[d])-this.getShapeArea(this.TETRIS_SHAPES[a]));for(let a of f){let d=this.TETRIS_SHAPES[a],h=this.TETRIS_SHAPES_WITH_ROTATIONS[a],c=Array.from({length:h.length},(u,r)=>r);this.shuffleArray(c);for(let u of c){let r=h[u],y=[];for(let p=0;p<r.length;p++)for(let x=0;x<r[0].length;x++)r[p][x]&&y.push({r:p,c:x});for(let p of y){let x=l-p.r,g=o-p.c;if(this.canPlace(e,r,x,g)){this.placePiece(e,r,x,g,!1);let m=h.length>1&&this.rng.next()<.3+i*.6,b=this.tilingDfs(e,[...t,{shape:r,displayShape:d,isRotated:m}],s,n);if(b)return b;this.placePiece(e,r,x,g,!0)}}}}return null}getShapeArea(e){let t=0;for(let s of e)for(let n of s)n&&t++;return t}isRotationallyInvariant(e){return this.getAllRotations(e).length===1}getAllRotations(e){let t=[],s=new Set,n=e;for(let l=0;l<4;l++){let o=JSON.stringify(n);s.has(o)||(t.push(n),s.add(o)),n=this.rotate90(n)}return t}rotate90(e){let t=e.length,s=e[0].length,n=Array.from({length:s},()=>Array(t).fill(0));for(let l=0;l<t;l++)for(let o=0;o<s;o++)n[o][t-1-l]=e[l][o];return n}canPlace(e,t,s,n){for(let l=0;l<t.length;l++)for(let o=0;o<t[0].length;o++)if(t[l][o]){let i=s+l,f=n+o;if(i<0||i>=e.length||f<0||f>=e[0].length||!e[i][f])return!1}return!0}placePiece(e,t,s,n,l){for(let o=0;o<t.length;o++)for(let i=0;i<t[0].length;i++)t[o][i]&&(e[s+o][n+i]=l)}isSameShape(e,t){let s=this.getAllRotations(e),n=JSON.stringify(t);return s.some(l=>JSON.stringify(l)===n)}countRegionNonEraserSymbols(e,t){let s=0;for(let n of t){let l=e.cells[n.y][n.x].type;l!==0&&l!==7&&s++}return s}hasRegionTetrisSymbol(e,t){for(let s of t){let n=e.cells[s.y][s.x].type;if(n===3||n===4)return!0}return!1}canPlaceGeneratedTetrisNegative(e,t,s){return s.length<1?!1:this.hasRegionTetrisSymbol(e,t)?!0:s.length>=2}canPlaceGeneratedEraser(e,t,s){return s.length<1?!1:this.countRegionNonEraserSymbols(e,t)>0?!0:s.length>=2}canTilePieceWith(e,t,s){let n=this.getShapeArea(e),l=this.getShapeArea(t),o=this.getShapeArea(s);if(n!==l+o)return!1;let i=this.getAllRotations(t),f=this.getAllRotations(s),a=e.length,d=e[0].length;for(let h of i)for(let c of f){let u=h.length,r=h[0].length,y=c.length,p=c[0].length;for(let x=0;x<=a-u;x++)for(let g=0;g<=d-r;g++)for(let m=0;m<=a-y;m++)for(let b=0;b<=d-p;b++){let S=Array.from({length:a},()=>Array(d).fill(0)),E=!0;for(let P=0;P<u;P++)for(let v=0;v<r;v++)h[P][v]&&(S[x+P][g+v]=1);for(let P=0;P<y;P++){for(let v=0;v<p;v++)if(c[P][v]){if(S[m+P][b+v]){E=!1;break}S[m+P][b+v]=1}if(!E)break}if(E){let P=!0;for(let v=0;v<a;v++){for(let w=0;w<d;w++)if(S[v][w]!==e[v][w]){P=!1;break}if(!P)break}if(P)return!0}}}return!1}findStandardTriple(e){let t=this.getShapeArea(e),s=[...this.TETRIS_SHAPES];this.shuffleArray(s);for(let n of s){let l=this.getShapeArea(n),o=t+l;if(o>5)continue;let i=this.TETRIS_SHAPES.filter(f=>this.getShapeArea(f)===o);for(let f of i)if(this.canTilePieceWith(f,e,n))return{p:f,n}}return null}shuffleArray(e){for(let t=e.length-1;t>0;t--){let s=Math.floor(this.rng.next()*(t+1));[e[t],e[s]]=[e[s],e[t]]}}};var fe=class{canvas;ctx=null;worker=null;puzzle=null;options;listeners=new Map;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;invalidatedCells=[];invalidatedEdges=[];invalidatedNodes=[];errorCells=[];errorEdges=[];errorNodes=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;canvasRect=null;isDestroyed=!1;animationFrameId=null;timeoutId=null;boundMouseDown=null;boundMouseMove=null;boundMouseUp=null;boundTouchStart=null;boundTouchMove=null;boundTouchEnd=null;boundUpdateRect=null;constructor(e,t,s={}){if(typeof e=="string"){if(typeof document>"u")throw new Error("Cannot look up canvas by ID in a non-browser environment.");let n=document.getElementById(e);if(!(n instanceof HTMLCanvasElement))throw new Error(`Element with id "${e}" is not a canvas.`);this.canvas=n}else this.canvas=e;if(this.options=this.mergeOptions(s),this.options.useWorker&&typeof window<"u"&&this.canvas instanceof HTMLCanvasElement&&this.canvas.transferControlToOffscreen){let n=this.options.workerScript??import.meta.url;if(n){this.worker=new Worker(n,{type:"module"});let l=this.canvas.transferControlToOffscreen(),o=this.sanitizeOptions(this.options);this.worker.postMessage({type:"init",payload:{canvas:l,options:o}},[l]),this.worker.addEventListener("message",i=>{let{type:f,payload:a}=i.data;f==="drawingStarted"?this.isDrawing=a!==!1:f==="drawingEnded"?this.isDrawing=!1:f==="pathComplete"?(this.options.onPathComplete&&this.options.onPathComplete(a),this.emit("path:complete",{path:a})):f==="puzzleCreated"?this.options.onPuzzleCreated&&this.options.onPuzzleCreated(a):f==="validationResult"?(this.options.onValidationResult&&this.options.onValidationResult(a),this.emit("goal:validated",{result:a})):f==="uiEvent"&&this.emit(a.type,a.data)})}}if(!this.worker){let n=this.canvas.getContext("2d");if(!n)throw new Error("Could not get 2D context.");this.ctx=n,this.ctx.imageSmoothingEnabled=!1,this.animate()}t&&this.setPuzzle(t),this.initEvents()}mergeOptions(e){let t={blinkDuration:e.animations?.blinkDuration??this.options?.animations?.blinkDuration??1e3,fadeDuration:e.animations?.fadeDuration??this.options?.animations?.fadeDuration??1e3,blinkPeriod:e.animations?.blinkPeriod??this.options?.animations?.blinkPeriod??800},s={path:e.colors?.path??this.options?.colors?.path??"#ffcc00",error:e.colors?.error??this.options?.colors?.error??"#ff4444",success:e.colors?.success??this.options?.colors?.success??"#ffcc00",symmetry:e.colors?.symmetry??this.options?.colors?.symmetry??"rgba(255, 255, 255, 0.5)",interrupted:e.colors?.interrupted??this.options?.colors?.interrupted??"#ffcc00",grid:e.colors?.grid??this.options?.colors?.grid??"#555",node:e.colors?.node??this.options?.colors?.node??"#555",hexagon:e.colors?.hexagon??this.options?.colors?.hexagon??"#000",hexagonMain:e.colors?.hexagonMain??this.options?.colors?.hexagonMain??"#00ffff",hexagonSymmetry:e.colors?.hexagonSymmetry??this.options?.colors?.hexagonSymmetry??"#ffff00",colorMap:e.colors?.colorMap??this.options?.colors?.colorMap??{[X.Black]:"#000",[X.White]:"#fff",[X.Red]:"#f00",[X.Blue]:"#00f",[X.None]:"#ffcc00"},colorList:e.colors?.colorList??this.options?.colors?.colorList};return{gridPadding:e.gridPadding??this.options?.gridPadding??60,cellSize:e.cellSize??this.options?.cellSize??80,nodeRadius:e.nodeRadius??this.options?.nodeRadius??6,startNodeRadius:e.startNodeRadius??this.options?.startNodeRadius??22,pathWidth:e.pathWidth??this.options?.pathWidth??18,exitLength:e.exitLength??this.options?.exitLength??25,autoResize:e.autoResize??this.options?.autoResize??!0,blinkMarksOnError:e.blinkMarksOnError??this.options?.blinkMarksOnError??!0,stayPathOnError:e.stayPathOnError??this.options?.stayPathOnError??!0,autoValidate:e.autoValidate??this.options?.autoValidate??!1,useWorker:e.useWorker??this.options?.useWorker??!1,workerScript:e.workerScript??this.options?.workerScript,animations:t,colors:s,onPathComplete:e.onPathComplete??this.options?.onPathComplete??(()=>{}),onPuzzleCreated:e.onPuzzleCreated??this.options?.onPuzzleCreated,onValidationResult:e.onValidationResult??this.options?.onValidationResult,pixelRatio:e.pixelRatio??this.options?.pixelRatio??(typeof window<"u"?window.devicePixelRatio:1)}}setPuzzle(e){if(this.worker){this.puzzle=e,this.options.autoResize&&this.resizeCanvas(),this.worker.postMessage({type:"setPuzzle",payload:{puzzle:e}}),this.emit("puzzle:created",{puzzle:e});return}this.puzzle=e,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw(),this.emit("puzzle:created",{puzzle:e})}setOptions(e){if(this.options=this.mergeOptions({...this.options,...e}),this.worker){this.options.autoResize&&this.puzzle&&this.resizeCanvas();let t=this.sanitizeOptions(e);this.worker.postMessage({type:"setOptions",payload:t});return}this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}addEventListener(e,t){this.listeners.has(e)||this.listeners.set(e,new Set),this.listeners.get(e).add(t)}removeEventListener(e,t){let s=this.listeners.get(e);s&&s.delete(t)}on(e,t){return this.addEventListener(e,t),this}off(e,t){return this.removeEventListener(e,t),this}emit(e,t){let s=this.listeners.get(e);if(s&&s.forEach(n=>n(t)),typeof self<"u"&&self.postMessage&&!this.worker&&typeof OffscreenCanvas<"u"&&this.canvas instanceof OffscreenCanvas){let l=["render:before","render:after"],o=["path:complete","puzzle:created","goal:validated"];if(!l.includes(e)&&!o.includes(e))try{self.postMessage({type:"uiEvent",payload:{type:e,data:t}})}catch{}}}setValidationResult(e,t=[],s=[],n=[],l=[],o=[],i=[]){this.worker||(this.invalidatedCells=t,this.invalidatedEdges=s,this.invalidatedNodes=o,this.errorCells=n,this.errorEdges=l,this.errorNodes=i,this.eraserAnimationStartTime=Date.now(),e?(this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0,this.emit("goal:reached",{path:this.path,isValid:e}))}resizeCanvas(){if(!this.puzzle||!this.canvas)return;let e=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,t=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2,s=this.options.pixelRatio;if(typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement)try{this.canvas.width=e*s,this.canvas.height=t*s}catch{}else this.canvas.width=e*s,this.canvas.height=t*s;this.worker&&this.boundUpdateRect&&this.boundUpdateRect()}setCanvasRect(e){let t={left:e.left,top:e.top,width:e.width,height:e.height};this.canvasRect=t,this.worker&&this.worker.postMessage({type:"setCanvasRect",payload:t})}createPuzzle(e,t,s){this.worker&&this.worker.postMessage({type:"createPuzzle",payload:{rows:e,cols:t,genOptions:s}})}initEvents(){typeof window>"u"||typeof HTMLCanvasElement>"u"||!(this.canvas instanceof HTMLCanvasElement)||(this.boundMouseDown=e=>{this.handleStart(e)&&e.cancelable&&e.preventDefault()},this.boundMouseMove=e=>{this.isDrawing&&e.cancelable&&e.preventDefault(),this.handleMove(e)},this.boundMouseUp=e=>{this.isDrawing&&e.cancelable&&e.preventDefault(),this.handleEnd(e)},this.boundTouchStart=e=>{this.handleStart(e.touches[0])&&e.cancelable&&e.preventDefault()},this.boundTouchMove=e=>{this.isDrawing&&(e.cancelable&&e.preventDefault(),this.handleMove(e.touches[0]))},this.boundTouchEnd=e=>{this.isDrawing&&(e.cancelable&&e.preventDefault(),this.handleEnd(e.changedTouches[0]))},this.canvas.addEventListener("mousedown",this.boundMouseDown),window.addEventListener("mousemove",this.boundMouseMove,{passive:!1}),window.addEventListener("mouseup",this.boundMouseUp,{passive:!1}),this.canvas.addEventListener("touchstart",this.boundTouchStart,{passive:!1}),window.addEventListener("touchmove",this.boundTouchMove,{passive:!1}),window.addEventListener("touchend",this.boundTouchEnd,{passive:!1}),this.worker&&(this.boundUpdateRect=()=>{if(this.canvas instanceof HTMLCanvasElement){let e=this.canvas.getBoundingClientRect();this.setCanvasRect(e)}},window.addEventListener("resize",this.boundUpdateRect),window.addEventListener("scroll",this.boundUpdateRect),this.boundUpdateRect()))}destroy(){this.isDestroyed=!0,this.worker&&(this.worker.terminate(),this.worker=null),this.animationFrameId!==null&&typeof cancelAnimationFrame<"u"&&cancelAnimationFrame(this.animationFrameId),this.timeoutId!==null&&clearTimeout(this.timeoutId),!(typeof window>"u"||typeof HTMLCanvasElement>"u"||!(this.canvas instanceof HTMLCanvasElement))&&(this.boundMouseDown&&this.canvas.removeEventListener("mousedown",this.boundMouseDown),this.boundMouseMove&&window.removeEventListener("mousemove",this.boundMouseMove),this.boundMouseUp&&window.removeEventListener("mouseup",this.boundMouseUp),this.boundTouchStart&&this.canvas.removeEventListener("touchstart",this.boundTouchStart),this.boundTouchMove&&window.removeEventListener("touchmove",this.boundTouchMove),this.boundTouchEnd&&window.removeEventListener("touchend",this.boundTouchEnd),this.boundUpdateRect&&(window.removeEventListener("resize",this.boundUpdateRect),window.removeEventListener("scroll",this.boundUpdateRect)),this.boundMouseDown=null,this.boundMouseMove=null,this.boundMouseUp=null,this.boundTouchStart=null,this.boundTouchMove=null,this.boundTouchEnd=null)}getCanvasCoords(e,t){return{x:this.options.gridPadding+e*this.options.cellSize,y:this.options.gridPadding+t*this.options.cellSize}}getExitDir(e,t){if(!this.puzzle||this.puzzle.nodes[t]?.[e]?.type!==2)return null;let{cols:s,rows:n}=this.puzzle,l=e===0,o=e===s,i=t===0,f=t===n;return!l&&!o&&!i&&!f?null:(l||o)&&(i||f)?s>=n?l?{x:-1,y:0}:{x:1,y:0}:i?{x:0,y:-1}:{x:0,y:1}:l?{x:-1,y:0}:o?{x:1,y:0}:i?{x:0,y:-1}:f?{x:0,y:1}:null}handleStart(e){if(this.worker)return this.isDrawing=!0,this.worker.postMessage({type:"event",payload:{eventType:"mousedown",eventData:{clientX:e.clientX,clientY:e.clientY}}}),!0;if(!this.puzzle)return!1;let t=this.options.pixelRatio,s=this.canvasRect||(typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width/t,height:this.canvas.height/t}),n=(e.clientX-s.left)*(this.canvas.width/t/s.width),l=(e.clientY-s.top)*(this.canvas.height/t/s.height);for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++)if(this.puzzle.nodes[o][i].type===1){let f=this.getCanvasCoords(i,o);if(Math.hypot(f.x-n,f.y-l)<this.options.startNodeRadius)return this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.isDrawing=!0,this.path=[{x:i,y:o}],this.currentMousePos=f,this.exitTipPos=null,this.draw(),this.emit("path:start",{x:i,y:o}),!0}return!1}handleMove(e){if(this.worker){this.isDrawing&&this.worker.postMessage({type:"event",payload:{eventType:"mousemove",eventData:{clientX:e.clientX,clientY:e.clientY}}});return}if(!this.puzzle||!this.isDrawing)return;let t=this.options.pixelRatio,s=this.canvasRect||(typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width/t,height:this.canvas.height/t}),n=(e.clientX-s.left)*(this.canvas.width/t/s.width),l=(e.clientY-s.top)*(this.canvas.height/t/s.height),o=this.path[this.path.length-1],i=this.getCanvasCoords(o.x,o.y),f=n-i.x,a=l-i.y,d=this.puzzle.symmetry||0,h=this.getExitDir(o.x,o.y),c=Math.abs(f)>Math.abs(a)?{x:f>0?1:-1,y:0}:{x:0,y:a>0?1:-1};if(h&&c.x===h.x&&c.y===h.y){let p=f*h.x+a*h.y,x=Math.max(0,Math.min(p,this.options.exitLength));this.currentMousePos={x:i.x+h.x*x,y:i.y+h.y*x},this.draw();return}let u=(p,x)=>{let g=this.getEdgeType(o,p);if(p.x<0||p.x>this.puzzle.cols||p.y<0||p.y>this.puzzle.rows||g===2){this.currentMousePos=i;return}let m=g===1?this.options.cellSize*.35:this.options.cellSize,b=this.getEdgeKey(o,p);if(!(this.path.length>=2&&p.x===this.path[this.path.length-2].x&&p.y===this.path[this.path.length-2].y)){for(let P=0;P<this.path.length-1;P++)if(this.getEdgeKey(this.path[P],this.path[P+1])===b){m=0;break}}if(this.path.some(P=>P.x===p.x&&P.y===p.y)&&this.path.length>=2){let P=this.path[this.path.length-2];(p.x!==P.x||p.y!==P.y)&&(m=Math.min(m,this.options.cellSize*.5-this.options.pathWidth*.5))}if(d!==0){let P=this.getSymmetricalPoint(o),v=this.getSymmetricalPoint(p),w=this.getEdgeType(P,v),N=this.getSymmetryPath(this.path),C=this.getEdgeKey(P,v);if(v.x<0||v.x>this.puzzle.cols||v.y<0||v.y>this.puzzle.rows||w===2){this.currentMousePos=i;return}w===1&&(m=Math.min(m,this.options.cellSize*.35));let z=N.some(H=>H.x===p.x&&H.y===p.y),D=this.path.some(H=>H.x===v.x&&H.y===v.y),W=p.x===v.x&&p.y===v.y,O=N.some((H,B)=>B<N.length-1&&this.getEdgeKey(N[B],N[B+1])===b),$=this.path.some((H,B)=>B<this.path.length-1&&this.getEdgeKey(this.path[B],this.path[B+1])===C);(z||D||W||O||$||b===C)&&(m=Math.min(m,this.options.cellSize*.5-this.options.pathWidth*.5))}p.x!==o.x?this.currentMousePos={x:i.x+Math.max(-m,Math.min(m,x)),y:i.y}:this.currentMousePos={x:i.x,y:i.y+Math.max(-m,Math.min(m,x))}};if(Math.abs(f)>Math.abs(a)){let p=f>0?1:-1;u({x:o.x+p,y:o.y},f)}else{let p=a>0?1:-1;u({x:o.x,y:o.y+p},a)}let r=[{x:o.x+1,y:o.y},{x:o.x-1,y:o.y},{x:o.x,y:o.y+1},{x:o.x,y:o.y-1}],y=this.getSymmetryPath(this.path);for(let p of r)if(p.x>=0&&p.x<=this.puzzle.cols&&p.y>=0&&p.y<=this.puzzle.rows){let x=this.getCanvasCoords(p.x,p.y);if(Math.hypot(x.x-this.currentMousePos.x,x.y-this.currentMousePos.y)<this.options.cellSize*.3){let m=this.path.findIndex(b=>b.x===p.x&&b.y===p.y);if(m===-1){if(d!==0){let b=this.getSymmetricalPoint(p);if(p.x===b.x&&p.y===b.y||this.path.some(P=>P.x===b.x&&P.y===b.y)||y.some(P=>P.x===p.x&&P.y===p.y))continue;let S=this.getEdgeKey(o,p),E=this.getEdgeKey(this.getSymmetricalPoint(o),b);if(S===E)continue}this.path.push(p),this.emit("path:move",{x:p.x,y:p.y,path:this.path,currentMousePos:this.currentMousePos})}else if(m===this.path.length-2){let b=this.path.pop();b&&this.emit("path:move",{x:b.x,y:b.y,path:this.path,currentMousePos:this.currentMousePos})}}}this.draw()}handleEnd(e){if(this.worker){this.isDrawing&&(this.isDrawing=!1,this.worker.postMessage({type:"event",payload:{eventType:"mouseup",eventData:{clientX:e.clientX,clientY:e.clientY}}}));return}if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let t=this.path[this.path.length-1],s=this.getCanvasCoords(t.x,t.y),n=this.getExitDir(t.x,t.y),l=!1;if(n){let o=this.currentMousePos.x-s.x,i=this.currentMousePos.y-s.y;if(o*n.x+i*n.y>0){this.exitTipPos={x:s.x+n.x*this.options.exitLength,y:s.y+n.y*this.options.exitLength},l=!0,this.options.onPathComplete(this.path),this.emit("path:complete",{path:this.path}),this.emit("path:end",{path:this.path,isExit:!0});return}}this.exitTipPos=n?{...this.currentMousePos}:null,this.emit("path:end",{path:this.path,isExit:!1}),this.startFade(this.options.colors.interrupted)}getEdgeType(e,t){if(!this.puzzle)return 2;if(e.x===t.x){let s=Math.min(e.y,t.y);return s<0||s>=this.puzzle.rows?2:this.puzzle.vEdges[s][e.x].type}else{let s=Math.min(e.x,t.x);return s<0||s>=this.puzzle.cols?2:this.puzzle.hEdges[e.y][s].type}}startFade(e="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=e,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){if(this.isDestroyed)return;let e=Date.now();if(this.isFading){let t=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=t,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0,this.isInvalidPath&&(this.isInvalidPath=!1,this.emit("goal:validated",{result:{isValid:!1}})))}this.isSuccessFading&&e-this.successFadeStartTime>this.options.animations.blinkDuration+this.options.animations.fadeDuration&&(this.isSuccessFading=!1,this.emit("goal:validated",{result:{isValid:!0}})),this.isInvalidPath&&!this.options.stayPathOnError&&!this.isFading&&this.path.length>0&&this.startFade(this.options.colors.error),this.draw(),typeof requestAnimationFrame<"u"?this.animationFrameId=requestAnimationFrame(()=>this.animate()):(this.timeoutId=setTimeout(()=>this.animate(),1e3/60),this.timeoutId&&this.timeoutId.unref&&this.timeoutId.unref())}lastGoalReachable=!1;draw(){if(!this.puzzle||!this.ctx)return;let e=this.ctx;this.emit("render:before",{ctx:e});let t=Date.now(),s=this.options.pixelRatio;if(e.setTransform(s,0,0,s,0,0),e.globalAlpha=1,e.clearRect(0,0,this.canvas.width/s,this.canvas.height/s),this.drawGrid(e),this.drawConstraints(e),this.drawNodes(e),this.path.length===0&&!this.isDrawing&&this.drawRipples(e),this.isFading){if(this.drawPath(e,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let n=this.getSymmetryPath(this.fadingPath),l=this.options.colors.symmetry;if(this.isInvalidPath){let i=this.colorToRgba(l).a;l=this.setAlpha(this.options.colors.error,i)}let o=null;if(this.fadingTipPos){let i=(this.fadingTipPos.x-this.options.gridPadding)/this.options.cellSize,f=(this.fadingTipPos.y-this.options.gridPadding)/this.options.cellSize,a=this.getSymmetricalPoint({x:i,y:f});o={x:a.x*this.options.cellSize+this.options.gridPadding,y:a.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,n,!1,l,this.fadeOpacity,o)}}else if(this.path.length>0){let n=this.options.colors.path,l=this.colorToRgba(n).a,o=this.options.colors.error,i=this.isInvalidPath?this.setAlpha(o,l):n;this.isSuccessFading&&!this.puzzle.symmetry&&(i=this.setAlpha(this.options.colors.success,l));let f=1;if(!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let h=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),c=this.options.animations.blinkDuration;h<c&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(i=this.setAlpha(this.options.colors.error,l),this.options.stayPathOnError||(f=Math.max(0,1-h/this.options.animations.fadeDuration)))}let a=null;if(this.isDrawing||this.exitTipPos){let h=this.isDrawing?this.currentMousePos:this.exitTipPos;if(this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let c=(h.x-this.options.gridPadding)/this.options.cellSize,u=(h.y-this.options.gridPadding)/this.options.cellSize,r=this.getSymmetricalPoint({x:c,y:u},!0);a={x:r.x*this.options.cellSize+this.options.gridPadding,y:r.y*this.options.cellSize+this.options.gridPadding}}}let d=this.isPathAtExit(this.path,this.isDrawing?this.currentMousePos:this.exitTipPos);if(d!==this.lastGoalReachable&&(this.lastGoalReachable=d,this.emit("goal:reachable",{reachable:d})),d&&!this.isInvalidPath&&!this.isSuccessFading){let h=this.colorToRgba(i).a,c=(Math.sin(t*Math.PI*2/600)+1)/2;i=this.lerpColor(i,"#ffffff",c*.6),i=this.setAlpha(i,h)}if(this.drawPath(e,this.path,this.isDrawing,i,f,this.isDrawing?this.currentMousePos:this.exitTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let h=this.getSymmetryPath(this.path),c=this.options.colors.symmetry,u=this.colorToRgba(c).a,r=c,y=f;if(this.isInvalidPath&&(r=this.setAlpha(o,u)),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let p=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),x=this.options.animations.blinkDuration;p<x&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(r=this.setAlpha(this.options.colors.error,u))}if(d&&!this.isInvalidPath&&!this.isSuccessFading){let p=(Math.sin(t*Math.PI*2/400)+1)/2;r=this.lerpColor(r,"#ffffff",p*.6),r=this.setAlpha(r,u)}this.drawPath(e,h,this.isDrawing,r,y,a)}}this.emit("render:after",{ctx:e})}drawRipples(e){if(!this.puzzle)return;let t=(Date.now()-this.startTime)/500;for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++)if(this.puzzle.nodes[s][n].type===2){let o=this.getCanvasCoords(n,s),i=this.getExitDir(n,s);if(!i)continue;let f={x:o.x+i.x*this.options.exitLength,y:o.y+i.y*this.options.exitLength},a=t%4,d=a*5,h=Math.max(0,1-a/3);e.beginPath(),e.arc(f.x,f.y,d,0,Math.PI*2),e.strokeStyle=`rgba(170, 170, 170, ${h*.4})`,e.lineWidth=2,e.stroke()}}drawGrid(e){if(!this.puzzle||!this.options.colors.grid)return;e.strokeStyle=this.options.colors.grid,e.lineWidth=12,e.lineCap="round";let t=(s,n,l)=>{if(l!==2)if(l===1){let i={x:s.x+(n.x-s.x)*.35,y:s.y+(n.y-s.y)*.35},f={x:s.x+(n.x-s.x)*(.5+.15),y:s.y+(n.y-s.y)*(.5+.15)};e.beginPath(),e.moveTo(s.x,s.y),e.lineTo(i.x,i.y),e.stroke(),e.beginPath(),e.moveTo(f.x,f.y),e.lineTo(n.x,n.y),e.stroke()}else e.beginPath(),e.moveTo(s.x,s.y),e.lineTo(n.x,n.y),e.stroke()};for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<this.puzzle.cols;n++)t(this.getCanvasCoords(n,s),this.getCanvasCoords(n+1,s),this.puzzle.hEdges[s][n].type);for(let s=0;s<this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++)t(this.getCanvasCoords(n,s),this.getCanvasCoords(n,s+1),this.puzzle.vEdges[s][n].type)}drawConstraints(e){if(!this.puzzle)return;let t=Date.now(),s=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;for(let o=0;o<this.puzzle.rows;o++)for(let i=0;i<this.puzzle.cols;i++){let f=this.puzzle.cells[o][i],a=this.getCanvasCoords(i+.5,o+.5),d=this.invalidatedCells.some(p=>p.x===i&&p.y===o),h=this.errorCells.some(p=>p.x===i&&p.y===o),c=1,u,r=this.getColorCode(f.color),y=this.options.colors.error;if(h&&this.options.blinkMarksOnError&&(u=this.lerpColor(r,y,s)),d){let p=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),x=this.options.animations.blinkDuration;if(p<x){if(this.options.blinkMarksOnError){let g=Math.min(1,p/200),m=p>x*.8?(x-p)/(x*.2):1,b=Math.min(g,m);u=this.lerpColor(r,y,s*b)}}else c=Math.max(.3,1-(p-x)/this.options.animations.fadeDuration)}if(c<1||u){let{canvas:p,ctx:x}=this.prepareOffscreen();this.drawConstraintItem(x,f,a,u),e.save(),e.setTransform(1,0,0,1,0,0),e.globalAlpha=c,e.drawImage(p,0,0),e.restore()}else this.drawConstraintItem(e,f,a)}e.lineWidth=2;let n=8,l=o=>o===3||o===3?this.options.colors.hexagon:o===4||o===4?this.options.colors.hexagonMain:o===5||o===5?this.options.colors.hexagonSymmetry:this.options.colors.hexagon;for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<this.puzzle.cols;i++){let f=this.puzzle.hEdges[o][i].type;if(f===3||f===4||f===5){let a=this.getCanvasCoords(i+.5,o);e.save();let d=this.invalidatedEdges.some(u=>u.type==="h"&&u.r===o&&u.c===i),h=this.errorEdges.some(u=>u.type==="h"&&u.r===o&&u.c===i),c=l(f);if(h&&this.options.blinkMarksOnError){let u=this.lerpColor(c,this.options.colors.error,s);this.drawHexagon(e,a.x,a.y,n,u)}else if(d){let u=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),r=this.options.animations.blinkDuration;if(u<r)if(this.options.blinkMarksOnError){let y=Math.min(1,u/200),p=u>r*.8?(r-u)/(r*.2):1,x=Math.min(y,p),g=this.lerpColor(c,this.options.colors.error,s*x);this.drawHexagon(e,a.x,a.y,n,g)}else this.drawHexagon(e,a.x,a.y,n,c);else e.globalAlpha*=Math.max(.3,1-(u-r)/this.options.animations.fadeDuration),this.drawHexagon(e,a.x,a.y,n,c)}else this.drawHexagon(e,a.x,a.y,n,c);e.restore()}}for(let o=0;o<this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++){let f=this.puzzle.vEdges[o][i].type;if(f===3||f===4||f===5){let a=this.getCanvasCoords(i,o+.5);e.save();let d=this.invalidatedEdges.some(u=>u.type==="v"&&u.r===o&&u.c===i),h=this.errorEdges.some(u=>u.type==="v"&&u.r===o&&u.c===i),c=l(f);if(h&&this.options.blinkMarksOnError){let u=this.lerpColor(c,this.options.colors.error,s);this.drawHexagon(e,a.x,a.y,n,u)}else if(d){let u=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),r=this.options.animations.blinkDuration;if(u<r)if(this.options.blinkMarksOnError){let y=Math.min(1,u/200),p=u>r*.8?(r-u)/(r*.2):1,x=Math.min(y,p),g=this.lerpColor(c,this.options.colors.error,s*x);this.drawHexagon(e,a.x,a.y,n,g)}else this.drawHexagon(e,a.x,a.y,n,c);else e.globalAlpha*=Math.max(.3,1-(u-r)/this.options.animations.fadeDuration),this.drawHexagon(e,a.x,a.y,n,c)}else this.drawHexagon(e,a.x,a.y,n,c);e.restore()}}for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++){let f=this.puzzle.nodes[o][i].type;if(f===3||f===4||f===5){let a=this.getCanvasCoords(i,o);e.save();let d=this.invalidatedNodes.some(u=>u.x===i&&u.y===o),h=this.errorNodes.some(u=>u.x===i&&u.y===o),c=l(f);if(h&&this.options.blinkMarksOnError){let u=this.lerpColor(c,this.options.colors.error,s);this.drawHexagon(e,a.x,a.y,n,u)}else if(d){let u=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),r=this.options.animations.blinkDuration;if(u<r)if(this.options.blinkMarksOnError){let y=Math.min(1,u/200),p=u>r*.8?(r-u)/(r*.2):1,x=Math.min(y,p),g=this.lerpColor(c,this.options.colors.error,s*x);this.drawHexagon(e,a.x,a.y,n,g)}else this.drawHexagon(e,a.x,a.y,n,c);else e.globalAlpha*=Math.max(.3,1-(u-r)/this.options.animations.fadeDuration),this.drawHexagon(e,a.x,a.y,n,c)}else this.drawHexagon(e,a.x,a.y,n,c);e.restore()}}}drawConstraintItem(e,t,s,n){t.type===1?(e.fillStyle=n||this.getColorCode(t.color),this.drawRoundedRect(e,s.x-26/2,s.y-26/2,26,26,8)):t.type===2?this.drawStar(e,s.x,s.y,12,16,8,t.color,n):t.type===3||t.type===4?this.drawTetris(e,s.x,s.y,t.shape||[],t.type===4,t.color,!1,n):t.type===5||t.type===6?this.drawTetris(e,s.x,s.y,t.shape||[],t.type===6,t.color,!0,n):t.type===7?this.drawEraser(e,s.x,s.y,14,3,t.color,n):t.type===8&&this.drawTriangle(e,s.x,s.y,t.count||0,t.color,n)}drawNodes(e){if(!this.puzzle)return;let t=(s,n)=>{let l=[];return s>0&&l.push(this.puzzle.hEdges[n][s-1].type),s<this.puzzle.cols&&l.push(this.puzzle.hEdges[n][s].type),n>0&&l.push(this.puzzle.vEdges[n-1][s].type),n<this.puzzle.rows&&l.push(this.puzzle.vEdges[n][s].type),l.length>0&&l.every(o=>o===2)};for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++){if(t(n,s))continue;let l=this.puzzle.nodes[s][n];if(l.type===3||l.type===4||l.type===5)continue;let o=this.getCanvasCoords(n,s);if(l.type===1)this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill();else if(l.type===2){let i=this.getExitDir(n,s);if(!i)continue;this.options.colors.node&&(e.strokeStyle=this.options.colors.node),e.lineWidth=12,e.lineCap="round",e.beginPath(),e.moveTo(o.x,o.y),e.lineTo(o.x+i.x*this.options.exitLength,o.y+i.y*this.options.exitLength),e.stroke()}else this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.nodeRadius,0,Math.PI*2),e.fill()}}drawPath(e,t,s,n,l,o=null){if(t.length===0||!n||n==="transparent")return;let i=this.colorToRgba(n),f=`rgb(${i.r},${i.g},${i.b})`,a=l*i.a,{canvas:d,ctx:h}=this.prepareOffscreen();this.drawPathInternal(h,t,s,f,o),e.save(),e.setTransform(1,0,0,1,0,0),e.globalAlpha=a,e.drawImage(d,0,0),e.restore()}drawPathInternal(e,t,s,n,l=null){e.save(),e.strokeStyle=n,e.fillStyle=n,e.lineWidth=this.options.pathWidth,e.lineCap="round",e.lineJoin="round",e.beginPath();let o=this.getCanvasCoords(t[0].x,t[0].y);e.moveTo(o.x,o.y);for(let f=1;f<t.length;f++){let a=this.getCanvasCoords(t[f].x,t[f].y);e.lineTo(a.x,a.y)}let i=l||this.currentMousePos;(s||l)&&e.lineTo(i.x,i.y),e.stroke(),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill(),(s||l)&&(e.beginPath(),e.arc(i.x,i.y,this.options.pathWidth/2,0,Math.PI*2),e.fill()),e.restore()}drawRoundedRect(e,t,s,n,l,o){e.beginPath(),e.moveTo(t+o,s),e.lineTo(t+n-o,s),e.quadraticCurveTo(t+n,s,t+n,s+o),e.lineTo(t+n,s+l-o),e.quadraticCurveTo(t+n,s+l,t+n-o,s+l),e.lineTo(t+o,s+l),e.quadraticCurveTo(t,s+l,t,s+l-o),e.lineTo(t,s+o),e.quadraticCurveTo(t,s,t+o,s),e.closePath(),e.fill()}drawHexagon(e,t,s,n,l){if(!(!this.options.colors.hexagon&&!l)){e.fillStyle=l||this.options.colors.hexagon,e.beginPath();for(let o=0;o<6;o++){let i=Math.PI/3*o,f=t+n*Math.cos(i),a=s+n*Math.sin(i);o===0?e.moveTo(f,a):e.lineTo(f,a)}e.closePath(),e.fill()}}drawEraser(e,t,s,n,l,o,i){e.strokeStyle=i||this.getColorCode(o),e.lineWidth=n*.5,e.lineCap="butt";let f=.5;e.beginPath();for(let a=0;a<l;a++){let d=Math.PI*2/l*a+f,h=t+n*Math.cos(d),c=s+n*Math.sin(d);e.moveTo(t,s),e.lineTo(h,c)}e.stroke()}drawStar(e,t,s,n,l,o,i,f){e.fillStyle=f||this.getColorCode(i),e.beginPath();for(let a=0;a<o*2;a++){let d=a%2===0?l:n,h=Math.PI/o*a,c=t+d*Math.cos(h),u=s+d*Math.sin(h);a===0?e.moveTo(c,u):e.lineTo(c,u)}e.closePath(),e.fill()}drawTriangle(e,t,s,n,l,o){if(n<=0)return;let i=o||this.getColorCode(l,"#ffcc00");e.fillStyle=i;let a=12*.8,d=a*2.2,h=(u,r)=>{e.beginPath();for(let y=0;y<3;y++){let p=Math.PI*2*y/3-Math.PI/2,x=u+a*Math.cos(p),g=r+a*Math.sin(p);y===0?e.moveTo(x,g):e.lineTo(x,g)}e.closePath(),e.fill()},c=(n-1)*d*.5;for(let u=0;u<n;u++)h(t-c+u*d,s)}drawTetris(e,t,s,n,l,o,i,f){if(!n||n.length===0)return;let a=12,d=2,h=n[0].length*a+(n[0].length-1)*d,c=n.length*a+(n.length-1)*d;e.save(),e.translate(t,s),l&&e.rotate(Math.PI/8);let u=f||this.getColorCode(o,i?"#00ffff":"#ffcc00");if(i){e.strokeStyle=u,e.lineWidth=2;for(let r=0;r<n.length;r++)for(let y=0;y<n[r].length;y++)if(n[r][y]){let p=y*(a+d)-h/2,x=r*(a+d)-c/2;e.strokeRect(p+1,x+1,a-2,a-2)}}else{e.fillStyle=u;for(let r=0;r<n.length;r++)for(let y=0;y<n[r].length;y++)if(n[r][y]){let p=y*(a+d)-h/2,x=r*(a+d)-c/2;e.fillRect(p,x,a,a)}}e.restore()}getColorCode(e,t="#666"){return this.options.colors.colorList&&this.options.colors.colorList[e]!==void 0?this.options.colors.colorList[e]:this.options.colors.colorMap&&this.options.colors.colorMap[e]!==void 0?this.options.colors.colorMap[e]:t}colorToRgba(e){if(!e||e==="transparent")return{r:0,g:0,b:0,a:0};if(e.startsWith("rgba")||e.startsWith("rgb")){let s=e.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);if(s)return{r:parseInt(s[1]),g:parseInt(s[2]),b:parseInt(s[3]),a:s[4]?parseFloat(s[4]):1}}let t=e.startsWith("#")?e.slice(1):e;if((t.length===3||t.length===4)&&(t=t.split("").map(s=>s+s).join("")),t.length===6){let s=parseInt(t,16);return{r:s>>16&255,g:s>>8&255,b:s&255,a:1}}else if(t.length===8){let s=parseInt(t,16);return{r:s>>24&255,g:s>>16&255,b:s>>8&255,a:(s&255)/255}}return{r:0,g:0,b:0,a:1}}lerpColor(e,t,s){try{let n=this.colorToRgba(e),l=this.colorToRgba(t),o=Math.round(n.r+(l.r-n.r)*s),i=Math.round(n.g+(l.g-n.g)*s),f=Math.round(n.b+(l.b-n.b)*s),a=n.a+(l.a-n.a)*s;return`rgba(${o},${i},${f},${a})`}catch{return e}}setAlpha(e,t){let s=this.colorToRgba(e);return`rgba(${s.r},${s.g},${s.b},${t})`}getSymmetryPath(e){return!this.puzzle||!this.puzzle.symmetry?[]:e.map(t=>this.getSymmetricalPoint(t))}getSymmetricalPoint(e,t=!1){if(!this.puzzle||!this.puzzle.symmetry)return{...e};let{cols:s,rows:n,symmetry:l}=this.puzzle;return l===1?{x:s-e.x,y:e.y}:l===2?{x:e.x,y:n-e.y}:l===3?{x:s-e.x,y:n-e.y}:{...e}}isPathAtExit(e,t){if(e.length===0||!t)return!1;let s=e[e.length-1],n=this.getExitDir(s.x,s.y);if(!n)return!1;let l=this.getCanvasCoords(s.x,s.y),o=t.x-l.x,i=t.y-l.y;return o*n.x+i*n.y>=this.options.exitLength*.9}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}sanitizeOptions(e){let t={};for(let s in e){let n=e[s];if(n&&typeof n=="object"&&!Array.isArray(n)){t[s]={};for(let l in n)typeof n[l]!="function"&&(t[s][l]=n[l])}else typeof n!="function"&&(t[s]=n)}return t}prepareOffscreen(){let e=this.options.pixelRatio;if(!this.offscreenCanvas){if(typeof document<"u")this.offscreenCanvas=document.createElement("canvas");else if(typeof OffscreenCanvas<"u")this.offscreenCanvas=new OffscreenCanvas(this.canvas.width,this.canvas.height);else throw new Error("Offscreen canvas not supported in this environment.");this.offscreenCtx=this.offscreenCanvas.getContext("2d")}if((this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),!this.offscreenCtx)throw new Error("Could not get offscreen 2D context.");return this.offscreenCtx.setTransform(e,0,0,e,0,0),this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width/e,this.offscreenCanvas.height/e),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx}}};var me=class{bytes=[];cur=0;bit=0;write(e,t){for(let s=0;s<t;s++)e&1<<s&&(this.cur|=1<<this.bit),this.bit++,this.bit===8&&(this.bytes.push(this.cur),this.cur=0,this.bit=0)}finish(){return this.bit>0&&this.bytes.push(this.cur),new Uint8Array(this.bytes)}},xe=class{constructor(e){this.buf=e}i=0;bit=0;read(e){let t=0;for(let s=0;s<e;s++)this.buf[this.i]&1<<this.bit&&(t|=1<<s),this.bit++,this.bit===8&&(this.bit=0,this.i++);return t}};function we(Q){let e=new Map;for(let t of Q)for(let s of t)if(s.shape){let n=JSON.stringify(s.shape);e.has(n)||e.set(n,s.shape)}return[...e.values()]}var be=class{static async serialize(e,t){let s=new me;s.write(e.rows,6),s.write(e.cols,6),s.write(e.symmetry??0,2);let n=we(e.cells);s.write(n.length,5);for(let d of n){s.write(d.length,4),s.write(d[0].length,4);for(let h of d)for(let c of h)s.write(c,1)}let l=new Map;n.forEach((d,h)=>l.set(JSON.stringify(d),h));for(let d of e.cells)for(let h of d)s.write(h.type,4),s.write(h.color,3),h.type===8?s.write(h.count||0,2):h.shape?(s.write(1,1),s.write(l.get(JSON.stringify(h.shape)),5)):s.write(0,1);for(let d=0;d<e.rows;d++)for(let h=0;h<e.cols+1;h++)s.write(e.vEdges[d][h].type,3);for(let d=0;d<e.rows+1;d++)for(let h=0;h<e.cols;h++)s.write(e.hEdges[d][h].type,3);for(let d=0;d<e.rows+1;d++)for(let h=0;h<e.cols+1;h++)s.write(e.nodes[d][h].type,3);s.write(+!!t.useHexagons,1),s.write(+!!t.useSquares,1),s.write(+!!t.useStars,1),s.write(+!!t.useTetris,1),s.write(+!!t.useTetrisNegative,1),s.write(+!!t.useEraser,1),s.write(+!!t.useTriangles,1),s.write(+!!t.useBrokenEdges,1),s.write(t.symmetry??0,2),s.write(Math.round((t.complexity??0)*254),8),s.write(Math.round((t.difficulty??0)*254),8),s.write(Math.round((t.pathLength??0)*254),8);let o=s.finish(),i=new Uint8Array(await new Response(new Blob([o.buffer]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()),f=0;for(let d of i)f^=d;let a=new Uint8Array(i.length+1);return a.set(i),a[i.length]=f,btoa(String.fromCharCode(...a)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}static async deserialize(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4;)t+="=";let s=atob(t),n=Uint8Array.from(s,O=>O.charCodeAt(0)),l=0;for(let O=0;O<n.length-1;O++)l^=n[O];if(l!==n.at(-1))throw new Error("Invalid parity data");let o=new Uint8Array(await new Response(new Blob([n.slice(0,-1).buffer]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer()),i=new xe(o),f=i.read(6),a=i.read(6),d=i.read(2),h=i.read(5),c=[];for(let O=0;O<h;O++){let $=i.read(4),V=i.read(4),H=[];for(let B=0;B<$;B++){let M=[];for(let k=0;k<V;k++)M.push(i.read(1));H.push(M)}c.push(H)}let u=[];for(let O=0;O<f;O++){let $=[];for(let V=0;V<a;V++){let H=i.read(4),B=i.read(3),M={type:H,color:B};H===8?M.count=i.read(2):i.read(1)&&(M.shape=c[i.read(5)].map(T=>T.slice())),$.push(M)}u.push($)}let r=Array.from({length:f},()=>Array.from({length:a+1},()=>({type:i.read(3)}))),y=Array.from({length:f+1},()=>Array.from({length:a},()=>({type:i.read(3)}))),p=Array.from({length:f+1},()=>Array.from({length:a+1},()=>({type:i.read(3)}))),x=()=>{let O=i.read(8);return Math.round(O/254*1e3)/1e3},g={},m=!!i.read(1),b=!!i.read(1),S=!!i.read(1),E=!!i.read(1),P=!!i.read(1),v=!!i.read(1),w=!!i.read(1),N=!!i.read(1),C=i.read(2);m&&(g.useHexagons=!0),b&&(g.useSquares=!0),S&&(g.useStars=!0),E&&(g.useTetris=!0),P&&(g.useTetrisNegative=!0),v&&(g.useEraser=!0),w&&(g.useTriangles=!0),N&&(g.useBrokenEdges=!0),g.symmetry=C;let z=x(),D=x(),W=x();return z!==0&&(g.complexity=z),D!==0&&(g.difficulty=D),W!==0&&(g.pathLength=W),{puzzle:{rows:f,cols:a,cells:u,vEdges:r,hEdges:y,nodes:p,symmetry:d},options:g}}};var ve=class{generator;validator;constructor(){this.generator=new ce,this.validator=new ae}createPuzzle(e,t,s={}){return this.generator.generate(e,t,s).export()}validateSolution(e,t){let s=oe.fromData(e);return this.validator.validate(s,t)}calculateDifficulty(e){let t=oe.fromData(e);return this.validator.calculateDifficulty(t)}};if(typeof self<"u"&&"postMessage"in self&&!("document"in self)){let Q=new ve,e=null,t=null;self.addEventListener("message",s=>{let{type:n,payload:l}=s.data;switch(n){case"init":{let{canvas:o,options:i}=l;e=new fe(o,void 0,{...i,onPathComplete:f=>{if(self.postMessage({type:"drawingEnded"}),i.autoValidate&&t){let a=Q.validateSolution(t,{points:f});e.setValidationResult(a.isValid,a.invalidatedCells,a.invalidatedEdges,a.errorCells,a.errorEdges,a.invalidatedNodes,a.errorNodes),self.postMessage({type:"validationResult",payload:a})}else self.postMessage({type:"pathComplete",payload:f})}});break}case"createPuzzle":{let{rows:o,cols:i,genOptions:f}=l,a=Q.createPuzzle(o,i,f);self.postMessage({type:"puzzleCreated",payload:{puzzle:a,genOptions:f}});break}case"setPuzzle":{t=l.puzzle,e&&t&&(e.setPuzzle(t),l.options&&e.setOptions(l.options));break}case"setOptions":{e&&e.setOptions(l);break}case"setCanvasRect":{e&&e.setCanvasRect(l);break}case"validate":{if(t){let o=Q.validateSolution(t,{points:l.path});e&&e.setValidationResult(o.isValid,o.invalidatedCells,o.invalidatedEdges,o.errorCells,o.errorEdges,o.invalidatedNodes,o.errorNodes),self.postMessage({type:"validationResult",payload:o})}break}case"event":{let{eventType:o,eventData:i}=l;if(e)if(o==="mousedown"||o==="touchstart"){let f=e.handleStart(i);self.postMessage({type:"drawingStarted",payload:f})}else o==="mousemove"||o==="touchmove"?e.handleMove(i):(o==="mouseup"||o==="touchend")&&(e.handleEnd(i),self.postMessage({type:"drawingEnded"}));break}}})}export{re as CellType,X as Color,Ee as Direction,le as EdgeType,oe as Grid,he as NodeType,ce as PuzzleGenerator,be as PuzzleSerializer,ae as PuzzleValidator,Se as RngType,ue as SymmetryType,ve as WitnessCore,fe as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
