/*!
 * MiniWitness 1.2.5
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var pe=(s=>(s[s.Up=0]="Up",s[s.Right=1]="Right",s[s.Down=2]="Down",s[s.Left=3]="Left",s))(pe||{}),oe=(f=>(f[f.None=0]="None",f[f.Square=1]="Square",f[f.Star=2]="Star",f[f.Tetris=3]="Tetris",f[f.TetrisRotated=4]="TetrisRotated",f[f.TetrisNegative=5]="TetrisNegative",f[f.TetrisNegativeRotated=6]="TetrisNegativeRotated",f[f.Eraser=7]="Eraser",f))(oe||{}),ie=(o=>(o[o.Normal=0]="Normal",o[o.Broken=1]="Broken",o[o.Absent=2]="Absent",o[o.Hexagon=3]="Hexagon",o[o.HexagonMain=4]="HexagonMain",o[o.HexagonSymmetry=5]="HexagonSymmetry",o))(ie||{}),re=(o=>(o[o.Normal=0]="Normal",o[o.Start=1]="Start",o[o.End=2]="End",o[o.Hexagon=3]="Hexagon",o[o.HexagonMain=4]="HexagonMain",o[o.HexagonSymmetry=5]="HexagonSymmetry",o))(re||{}),le=(s=>(s[s.None=0]="None",s[s.Horizontal=1]="Horizontal",s[s.Vertical=2]="Vertical",s[s.Rotational=3]="Rotational",s))(le||{}),q={None:0,Black:1,White:2,Red:3,Blue:4,Cyan:5};var ee=class te{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];symmetry=0;constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:q.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes,symmetry:this.symmetry}))}static fromData(e){let t=new te(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t.symmetry=e.symmetry||0,t}};var ne=class{tetrisCache=new Map;validate(e,t,n){let s=t.points;if(s.length<2)return{isValid:!1,errorReason:"Path too short"};let l=e.symmetry||0,o=[];if(l!==0)for(let c of s)o.push(this.getSymmetricalPoint(e,c));let i=s[0],f=s[s.length-1];if(e.nodes[i.y][i.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[f.y][f.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};if(l!==0){let c=o[0],d=o[o.length-1];if(e.nodes[c.y][c.x].type!==1)return{isValid:!1,errorReason:"Symmetrical path must start at Start Node"};if(e.nodes[d.y][d.x].type!==2)return{isValid:!1,errorReason:"Symmetrical path must end at End Node"}}let y=new Set,u=new Set;if(y.add(`${i.x},${i.y}`),l!==0){let c=o[0];if(y.has(`${c.x},${c.y}`))return{isValid:!1,errorReason:"Paths collide at start"};y.add(`${c.x},${c.y}`)}for(let c=0;c<s.length-1;c++){let d=s[c],m=s[c+1];if(Math.abs(d.x-m.x)+Math.abs(d.y-m.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let p=`${m.x},${m.y}`;if(y.has(p))return{isValid:!1,errorReason:"Self-intersecting path or path collision"};if(y.add(p),this.isBrokenEdge(e,d,m))return{isValid:!1,errorReason:"Passed through broken edge"};if(u.add(this.getEdgeKey(d,m)),l!==0){let v=o[c],g=o[c+1],C=`${g.x},${g.y}`;if(y.has(C))return{isValid:!1,errorReason:"Path collision"};if(y.add(C),this.isBrokenEdge(e,v,g))return{isValid:!1,errorReason:"Symmetrical path passed through broken edge"};let P=this.getEdgeKey(v,g);if(u.has(P))return{isValid:!1,errorReason:"Paths cross the same edge"};u.add(P)}}let r=this.calculateRegions(e,s,o,n),h=this.getMissedHexagons(e,s,o),a=this.validateWithErasers(e,r,h.edges,h.nodes);return a.regions=r,a}validateFast(e,t,n,s){let l=this.calculateRegions(e,t,n,s),o=this.getMissedHexagons(e,t,n);return this.validateWithErasers(e,l,o.edges,o.nodes)}isBrokenEdge(e,t,n){let s;if(t.x===n.x){let l=Math.min(t.y,n.y);s=e.vEdges[l][t.x].type}else{let l=Math.min(t.x,n.x);s=e.hEdges[t.y][l].type}return s===1||s===2}isAbsentEdge(e,t,n){if(t.x===n.x){let s=Math.min(t.y,n.y);return e.vEdges[s][t.x].type===2}else{let s=Math.min(t.x,n.x);return e.hEdges[t.y][s].type===2}}getMissedHexagons(e,t,n=[]){let s=new Set,l=new Set;for(let u=0;u<t.length;u++)l.add(`${t[u].x},${t[u].y}`),u<t.length-1&&s.add(this.getEdgeKey(t[u],t[u+1]));let o=new Set,i=new Set;for(let u=0;u<n.length;u++)i.add(`${n[u].x},${n[u].y}`),u<n.length-1&&o.add(this.getEdgeKey(n[u],n[u+1]));let f=[];for(let u=0;u<=e.rows;u++)for(let r=0;r<e.cols;r++){let h=e.hEdges[u][r].type;if(h===3||h===4||h===5){let a=this.getEdgeKey({x:r,y:u},{x:r+1,y:u}),c=!1;h===3?c=s.has(a)||o.has(a):h===4?c=s.has(a):h===5&&(c=o.has(a)),c||f.push({type:"h",r:u,c:r})}}for(let u=0;u<e.rows;u++)for(let r=0;r<=e.cols;r++){let h=e.vEdges[u][r].type;if(h===3||h===4||h===5){let a=this.getEdgeKey({x:r,y:u},{x:r,y:u+1}),c=!1;h===3?c=s.has(a)||o.has(a):h===4?c=s.has(a):h===5&&(c=o.has(a)),c||f.push({type:"v",r:u,c:r})}}let y=[];for(let u=0;u<=e.rows;u++)for(let r=0;r<=e.cols;r++){let h=e.nodes[u][r].type;if(h===3||h===4||h===5){let a=`${r},${u}`,c=!1;h===3?c=l.has(a)||i.has(a):h===4?c=l.has(a):h===5&&(c=i.has(a)),c||y.push({x:r,y:u})}}return{edges:f,nodes:y}}validateWithErasers(e,t,n,s){let l=[],o=!0;for(let a=0;a<t.length;a++){let c=t[a],d=c.filter(g=>e.cells[g.y][g.x].type===7),m=c.filter(g=>e.cells[g.y][g.x].type!==0&&e.cells[g.y][g.x].type!==7),x=[];for(let g=0;g<n.length;g++)this.isHexagonAdjacentToRegion(e,n[g],c)&&x.push(g);let p=[];for(let g=0;g<s.length;g++)this.isNodeHexagonAdjacentToRegion(e,s[g],c)&&p.push(g);let v=this.getPossibleErasures(e,c,d,m,x,p);if(v.length===0){o=!1;let g=this.getBestEffortErasures(e,c,d,m,x,p);l.push([g])}else v.sort((g,C)=>{let P=g.invalidatedCells.length+g.invalidatedHexagons.length+g.invalidatedNodeHexagons.length,S=C.invalidatedCells.length+C.invalidatedHexagons.length+C.invalidatedNodeHexagons.length;return P-S}),l.push(v)}if(o){let a=this.findGlobalAssignment(l,n.length,s.length);if(a)return{isValid:!0,invalidatedCells:a.invalidatedCells,invalidatedEdges:a.invalidatedHexIndices.map(c=>n[c]),invalidatedNodes:a.invalidatedNodeHexIndices.map(c=>s[c])}}let i=[],f=[],y=new Set,u=new Set;for(let a of l){let c=a[0];i.push(...c.errorCells),f.push(...c.invalidatedCells);for(let d of c.invalidatedHexagons)y.add(d);for(let d of c.invalidatedNodeHexagons)u.add(d)}let r=[];for(let a=0;a<n.length;a++)y.has(a)||r.push(n[a]);let h=[];for(let a=0;a<s.length;a++)u.has(a)||h.push(s[a]);return{isValid:!1,errorReason:"Constraints failed",errorCells:i,errorEdges:r,errorNodes:h,invalidatedCells:f,invalidatedEdges:Array.from(y).map(a=>n[a]),invalidatedNodes:Array.from(u).map(a=>s[a])}}isHexagonAdjacentToRegion(e,t,n){let s=new Set(n.map(l=>`${l.x},${l.y}`));if(t.type==="h"){if(t.r>0&&s.has(`${t.c},${t.r-1}`)||t.r<e.rows&&s.has(`${t.c},${t.r}`))return!0}else if(t.c>0&&s.has(`${t.c-1},${t.r}`)||t.c<e.cols&&s.has(`${t.c},${t.r}`))return!0;return!1}isNodeHexagonAdjacentToRegion(e,t,n){let s=new Set(n.map(o=>`${o.x},${o.y}`)),l=[{x:t.x-1,y:t.y-1},{x:t.x,y:t.y-1},{x:t.x-1,y:t.y},{x:t.x,y:t.y}];for(let o of l)if(o.x>=0&&o.x<e.cols&&o.y>=0&&o.y<e.rows&&s.has(`${o.x},${o.y}`))return!0;return!1}getPossibleErasures(e,t,n,s,l,o){let i=[],f=n.length;if(f===0)return this.getRegionErrors(e,t,[]).length===0&&l.length===0&&o.length===0&&i.push({invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!0,errorCells:[]}),i;let y=[...s.map(r=>({type:"cell",pos:r})),...l.map(r=>({type:"hex",index:r})),...o.map(r=>({type:"nodeHex",index:r}))],u=this.getRegionErrors(e,t,[]).length===0&&l.length===0&&o.length===0;for(let r=0;r<=f;r++){let h=this.getNCombinations(n,r);for(let a of h){let c=new Set(a.map(m=>`${m.x},${m.y}`)),d=n.filter(m=>!c.has(`${m.x},${m.y}`));for(let m=0;m<=y.length;m++){if(d.length!==r+m)continue;let x=this.getNCombinations(y,m);for(let p of x){let v=p.filter(b=>b.type==="cell").map(b=>b.pos),g=p.filter(b=>b.type==="hex").map(b=>b.index),C=p.filter(b=>b.type==="nodeHex").map(b=>b.index);if(this.getRegionErrors(e,t,[...v,...a]).length===0){let b=!0;if(u)m>0&&(b=!1);else for(let M=0;M<p.length;M++){let N=[...p.slice(0,M),...p.slice(M+1)],w=N.filter(z=>z.type==="cell").map(z=>z.pos),R=new Set(N.filter(z=>z.type==="hex").map(z=>z.index)),B=new Set(N.filter(z=>z.type==="nodeHex").map(z=>z.index)),$=l.every(z=>R.has(z)),A=o.every(z=>B.has(z));if(this.getRegionErrors(e,t,w).length===0&&$&&A){b=!1;break}}b&&i.push({invalidatedCells:[...v,...a],invalidatedHexagons:g,invalidatedNodeHexagons:C,isValid:!0,errorCells:[]})}}}}}return i}getBestEffortErasures(e,t,n,s,l,o){let i=this.getRegionErrors(e,t,[]);if(i.length===0&&l.length===0&&o.length===0)return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:[...n]};if(n.length>0){let u=[...s.map(c=>({type:"cell",pos:c})),...l.map(c=>({type:"hex",index:c})),...o.map(c=>({type:"nodeHex",index:c}))],r=null,h=1/0,a=c=>{let d=[],m=[],x=[],p=0;for(let b of c)p<n.length&&(b.type==="cell"?d.push(b.pos):b.type==="hex"?m.push(b.index):x.push(b.index),p++);let v=n.length-p,g=Math.floor(v/2),C=n.slice(p,p+g);p+=g*2;let P=this.getRegionErrors(e,t,[...d,...C]);for(let b=p;b<n.length;b++)P.push(n[b]);let S=P.length;S<h&&(h=S,r={invalidatedCells:[...d,...C],invalidatedHexagons:m,invalidatedNodeHexagons:x,isValid:!1,errorCells:P})};a([...i.map(c=>({type:"cell",pos:c})),...l.map(c=>({type:"hex",index:c})),...o.map(c=>({type:"nodeHex",index:c}))]),a(u);for(let c of i)a([{type:"cell",pos:c}]);if(r)return r}let y=[...i,...n];return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:y}}getNCombinations(e,t){let n=[],s=(l,o)=>{if(o.length===t){n.push([...o]);return}for(let i=l;i<e.length;i++)o.push(e[i]),s(i+1,o),o.pop()};return s(0,[]),n}checkRegionValid(e,t,n){return this.getRegionErrors(e,t,n).length===0}getRegionErrors(e,t,n){let s=new Set(n.map(h=>`${h.x},${h.y}`)),l=new Map,o=new Map,i=new Set,f=new Set,y=[],u=[];for(let h of t){if(s.has(`${h.x},${h.y}`))continue;let a=e.cells[h.y][h.x];if(a.type===0)continue;let c=a.color;c!==q.None&&(l.set(c,(l.get(c)||0)+1),o.has(c)||o.set(c,[]),o.get(c).push(h)),a.type===1?f.add(c):a.type===2?i.add(c):a.type===3||a.type===4?a.shape&&y.push({shape:a.shape,rotatable:a.type===4,pos:h}):(a.type===5||a.type===6)&&a.shape&&u.push({shape:a.shape,rotatable:a.type===6,pos:h})}let r=[];if(f.size>1)for(let h of t)s.has(`${h.x},${h.y}`)||e.cells[h.y][h.x].type===1&&r.push(h);for(let h of i)if(l.get(h)!==2){let a=o.get(h)||[];for(let c of a)e.cells[c.y][c.x].type===2&&r.push(c)}if((y.length>0||u.length>0)&&!this.checkTetrisConstraint(e,t,y.map(h=>({shape:h.shape,rotatable:h.rotatable})),u.map(h=>({shape:h.shape,rotatable:h.rotatable})))){for(let h of y)r.push(h.pos);for(let h of u)r.push(h.pos)}return r}findGlobalAssignment(e,t,n){let s=e.length,l=new Array(t).fill(0),o=new Array(n).fill(0),i=[],f=[],y=[],u=r=>{if(r===s)return l.every(h=>h===1)&&o.every(h=>h===1);for(let h of e[r]){let a=!0;for(let c of h.invalidatedHexagons)if(l[c]>0){a=!1;break}if(a){for(let c of h.invalidatedNodeHexagons)if(o[c]>0){a=!1;break}}if(a){for(let c of h.invalidatedHexagons)l[c]++,f.push(c);for(let c of h.invalidatedNodeHexagons)o[c]++,y.push(c);if(i.push(...h.invalidatedCells),u(r+1))return!0;for(let c of h.invalidatedHexagons)l[c]--,f.pop();for(let c of h.invalidatedNodeHexagons)o[c]--,y.pop();for(let c=0;c<h.invalidatedCells.length;c++)i.pop()}}return!1};return u(0)?{invalidatedCells:i,invalidatedHexIndices:f,invalidatedNodeHexIndices:y}:null}checkTetrisConstraint(e,t,n,s=[]){let l=n.reduce((b,M)=>b+this.getShapeArea(M.shape),0),o=s.reduce((b,M)=>b+this.getShapeArea(M.shape),0),i=l-o;if(i<0||i!==0&&i!==t.length)return!1;let f=e.rows,y=e.cols;this.tetrisCache.size>1e4&&this.tetrisCache.clear();let u=new Uint8Array(f*y);for(let b of t)u[b.y*y+b.x]=1;let r=(b,M)=>`${this.getShapeKey(b.shape)}-${b.rotatable}-${M}`,h=[...n.map(b=>r(b,1)),...s.map(b=>r(b,-1))].sort().join("|"),a=`${f}x${y}:${u.join("")}:${h}`;if(this.tetrisCache.has(a))return this.tetrisCache.get(a);let c=new Int8Array(f*y);if(i>0)for(let b=0;b<u.length;b++)c[b]=u[b];let d=new Int8Array(f*y),m=[],x=[...n.map(b=>({...b,sign:1})),...s.map(b=>({...b,sign:-1}))];for(let b of x){let M=b.rotatable?this.getAllRotations(b.shape):[b.shape],N=this.getShapeKey(M[0]),w=m.find(R=>R.sign===b.sign&&(b.rotatable?R.rotations.length>1:R.rotations.length===1)&&this.getShapeKey(R.rotations[0].shape)===N);w?w.count++:m.push({rotations:M.map(R=>({shape:R,h:R.length,w:R[0].length})),sign:b.sign,area:this.getShapeArea(b.shape),count:1})}m.sort((b,M)=>M.sign-b.sign||M.area-b.area);let p=i>0?t.length:0,v=0,g=l,C=o,P=(b,M,N)=>{if(p>g||v>C)return!1;if(b===m.length)return p===0&&v===0;let w=m[b],R=M+1,B=R===w.count;w.sign===1?g-=w.area:C-=w.area;for(let $ of w.rotations){let A=$.h,z=$.w,E=M===0?0:N;for(let T=E;T<=f*y-(A>0?(A-1)*y+z:0);T++){let H=Math.floor(T/y),K=T%y;if(H>f-A||K>y-z)continue;let V=!0,j=[];for(let k=0;k<A;k++){for(let U=0;U<z;U++)if($.shape[k][U]){let G=(H+k)*y+(K+U);w.sign===1?d[G]<c[G]?p--:v++:d[G]<=c[G]?p++:v--,d[G]+=w.sign,j.push(G),d[G]<0&&(V=!1),w.sign===1&&d[G]>1+o&&(V=!1)}if(!V)break}if(V){if(B){if(P(b+1,0,0)){for(let k of j)d[k]-=w.sign,w.sign===1?d[k]<c[k]?p++:v--:d[k]<=c[k]?p--:v++;return w.sign===1?g+=w.area:C+=w.area,!0}}else if(P(b,R,T)){for(let k of j)d[k]-=w.sign,w.sign===1?d[k]<c[k]?p++:v--:d[k]<=c[k]?p--:v++;return w.sign===1?g+=w.area:C+=w.area,!0}}for(let k of j)d[k]-=w.sign,w.sign===1?d[k]<c[k]?p++:v--:d[k]<=c[k]?p--:v++}}return w.sign===1?g+=w.area:C+=w.area,!1},S=P(0,0,0);return this.tetrisCache.set(a,S),S}getShapeArea(e){let t=0;for(let n of e)for(let s of n)s&&t++;return t}getShapeKey(e){return JSON.stringify(e)}getAllRotations(e){let t=[],n=new Set,s=e;for(let l=0;l<4;l++){let o=this.getShapeKey(s);n.has(o)||(t.push(s),n.add(o)),s=this.rotate90(s)}return t}rotate90(e){let t=e.length,n=e[0].length,s=Array.from({length:n},()=>Array(t).fill(0));for(let l=0;l<t;l++)for(let o=0;o<n;o++)s[o][t-1-l]=e[l][o];return s}calculateRegions(e,t,n=[],s){let l=[],o=e.rows,i=e.cols,f=new Uint8Array(o*i),y=new Uint8Array((o+1)*i),u=new Uint8Array(o*(i+1)),r=(a,c)=>{a.x===c.x?u[Math.min(a.y,c.y)*(i+1)+a.x]=1:y[a.y*i+Math.min(a.x,c.x)]=1};for(let a=0;a<t.length-1;a++)r(t[a],t[a+1]);for(let a=0;a<n.length-1;a++)r(n[a],n[a+1]);for(let a=0;a<=o;a++)for(let c=0;c<i;c++)e.hEdges[a][c].type===2&&(y[a*i+c]=1);for(let a=0;a<o;a++)for(let c=0;c<=i;c++)e.vEdges[a][c].type===2&&(u[a*(i+1)+c]=1);let h=s||this.getExternalCells(e);for(let a=0;a<o;a++)for(let c=0;c<i;c++){let d=a*i+c;if(f[d]||h&&h.has(`${c},${a}`))continue;let m=[],x=[d];f[d]=1;let p=0;for(;p<x.length;){let v=x[p++],g=v%i,C=Math.floor(v/i);if(m.push({x:g,y:C}),C>0&&!y[C*i+g]){let P=(C-1)*i+g;!f[P]&&(!h||!h.has(`${g},${C-1}`))&&(f[P]=1,x.push(P))}if(C<o-1&&!y[(C+1)*i+g]){let P=(C+1)*i+g;!f[P]&&(!h||!h.has(`${g},${C+1}`))&&(f[P]=1,x.push(P))}if(g>0&&!u[C*(i+1)+g]){let P=C*i+(g-1);!f[P]&&(!h||!h.has(`${g-1},${C}`))&&(f[P]=1,x.push(P))}if(g<i-1&&!u[C*(i+1)+(g+1)]){let P=C*i+(g+1);!f[P]&&(!h||!h.has(`${g+1},${C}`))&&(f[P]=1,x.push(P))}}l.push(m)}return l}getExternalCells(e){let t=new Set,n=[];for(let s=0;s<e.cols;s++)e.hEdges[0][s].type===2&&(t.has(`${s},0`)||(t.add(`${s},0`),n.push({x:s,y:0}))),e.hEdges[e.rows][s].type===2&&(t.has(`${s},${e.rows-1}`)||(t.add(`${s},${e.rows-1}`),n.push({x:s,y:e.rows-1})));for(let s=0;s<e.rows;s++)e.vEdges[s][0].type===2&&(t.has(`0,${s}`)||(t.add(`0,${s}`),n.push({x:0,y:s}))),e.vEdges[s][e.cols].type===2&&(t.has(`${e.cols-1},${s}`)||(t.add(`${e.cols-1},${s}`),n.push({x:e.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),l=[{nx:s.x,ny:s.y-1,edge:e.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:e.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:e.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:e.vEdges[s.y][s.x+1]}];for(let o of l)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return t}getSymmetricalPoint(e,t){let n=e.symmetry||0;return n===1?{x:e.cols-t.x,y:t.y}:n===2?{x:t.x,y:e.rows-t.y}:n===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getSymmetricalPointIndex(e,t){let n=e.cols+1,s=Math.floor(t/n),l=t%n,o=e.symmetry||0,i=s,f=l;return o===1?f=e.cols-l:o===2?i=e.rows-s:o===3&&(f=e.cols-l,i=e.rows-s),i*n+f}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}calculateDifficulty(e){let t=e.rows,n=e.cols,s=n+1,l=(t+1)*s,o=Array.from({length:l},()=>[]),i=[],f=[],y=new Map,u=0,r=new Set,h=new Set;for(let E=0;E<=t;E++)for(let T=0;T<=n;T++){let H=E*s+T;if(e.nodes[E][T].type===1&&i.push(H),e.nodes[E][T].type===2&&f.push(H),(e.nodes[E][T].type===3||e.nodes[E][T].type===4||e.nodes[E][T].type===5)&&(y.set(`n${T},${E}`,u++),h.add(H)),T<n){let K=H+1,V=e.hEdges[E][T].type,j=V===3||V===4||V===5,k=V===1||V===2;o[H].push({next:K,hexType:V,isBroken:k}),o[K].push({next:H,hexType:V,isBroken:k}),j&&(y.set(`eh${T},${E}`,u++),r.add(this.getEdgeKey({x:T,y:E},{x:T+1,y:E})))}if(E<t){let K=H+s,V=e.vEdges[E][T].type,j=V===3||V===4||V===5,k=V===1||V===2;o[H].push({next:K,hexType:V,isBroken:k}),o[K].push({next:H,hexType:V,isBroken:k}),j&&(y.set(`ev${T},${E}`,u++),r.add(this.getEdgeKey({x:T,y:E},{x:T,y:E+1})))}}let a={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},c=u,d=new Set,m=Math.max(1e3,t*n*200),x=this.getExternalCells(e),p=!1;for(let E=0;E<t;E++){for(let T=0;T<n;T++)if(e.cells[E][T].type!==0){p=!0;break}if(p)break}this.tetrisCache.clear();for(let E of i){let T=e.cols+1,H=Math.floor(E/T),K=E%T,V=0n,j=e.nodes[H][K].type;(j===3||j===4)&&(V|=1n<<BigInt(y.get(`n${K},${H}`)));let k=e.symmetry||0;if(k!==0){let G=this.getSymmetricalPointIndex(e,E),O=Math.floor(G/T),W=G%T,X=e.nodes[O][W].type;(X===3||X===5)&&(V|=1n<<BigInt(y.get(`n${W},${O}`)))}let U=1n<<BigInt(E);if(k!==0){let G=this.getSymmetricalPointIndex(e,E);if(G===E)continue;U|=1n<<BigInt(G)}this.exploreSearchSpace(e,E,U,[E],V,c,o,f,d,a,m,x,p,y)}if(a.solutions===0)return 0;let v=r.size+h.size,g=new Set;r.size>0&&g.add(999);let C=0,P=0;for(let E=0;E<t;E++)for(let T=0;T<n;T++){let H=e.cells[E][T];H.type!==0&&(v++,g.add(H.type),H.type===3?C++:H.type===4&&(C++,P++))}let S=a.branchingPoints/(a.totalNodesVisited||1),b=Math.log10(a.totalNodesVisited+1),M=(S*10+b*1.5)/(Math.log2(a.solutions+1)*.5+1);M-=r.size*.05,M+=h.size*.12,C>0&&(M+=(C-P)*.5,M+=P*.2);let N=0,w=0;for(let E=0;E<t;E++)for(let T=0;T<n;T++){let H=e.cells[E][T];H.type===5?N++:H.type===6&&(N++,w++)}N>0&&(M+=(N-w)*.6,M+=w*.3);let R=t*n,B=v/R,$=B<.25?Math.pow(B/.25,4):1,A=g.size<=1?.5:1;M*=$*A;let z=Math.log2(R)/5;return M*=z,Math.max(.01,Math.min(1,M/4))}exploreSearchSpace(e,t,n,s,l,o,i,f,y,u,r,h,a=!0,c){if(u.totalNodesVisited++,u.maxDepth=Math.max(u.maxDepth,s.length),u.totalNodesVisited>r)return;let d=e.symmetry||0;if(f.includes(t)){let p=0,v=l;for(;v>0n;)v&1n&&p++,v>>=1n;if(p===o){let g=s.map(S=>({x:S%(e.cols+1),y:Math.floor(S/(e.cols+1))})),C={points:g};if(d!==0){let S=this.getSymmetricalPointIndex(e,t),b=e.cols+1;if(e.nodes[Math.floor(S/b)][S%b].type!==2)return}let P=d!==0?g.map(S=>this.getSymmetricalPoint(e,S)):[];if(a){let S=this.validateFast(e,g,P,h);if(S.isValid){let b=this.getFingerprint(e,g,P,S.regions,h);y.has(b)||(y.add(b),u.solutions++)}}else{let S=this.getFingerprint(e,g,P,void 0,h);y.has(S)||(y.add(S),u.solutions++)}}return}if(!this.canReachEndOptimized(t,n,i,f)){u.backtracks++;return}let m=[];for(let p of i[t]){if(p.isBroken||n&1n<<BigInt(p.next))continue;if(d!==0){let g=this.getSymmetricalPointIndex(e,t),C=this.getSymmetricalPointIndex(e,p.next);if(p.next===C||t===C&&p.next===g)continue}let v=!0;for(let g of i[t])if(g.hexType===3||g.hexType===4){let P=s.length>=2&&g.next===s[s.length-2],S=g.next===p.next;if(!P&&!S){v=!1;break}}if(v){if(d!==0){let g=this.getSymmetricalPointIndex(e,t),C=this.getSymmetricalPointIndex(e,p.next);for(let P of i[g])if(P.hexType===3||P.hexType===5){let b=s.length>=2?this.getSymmetricalPointIndex(e,s[s.length-2]):-1,M=P.next===b,N=P.next===C;if(!M&&!N){v=!1;break}}}v&&m.push(p)}}if(m.length>1&&u.branchingPoints++,e.rows*e.cols>30)for(let p=m.length-1;p>0;p--){let v=Math.floor(Math.random()*(p+1));[m[p],m[v]]=[m[v],m[p]]}let x=e.cols+1;for(let p of m){let v=l,g=Math.floor(p.next/x),C=p.next%x,P=e.nodes[g][C].type;(P===3||P===4)&&(v|=1n<<BigInt(c.get(`n${C},${g}`)));let S=s[s.length-1],b=Math.floor(S/x),M=S%x;if(b===g){let w=Math.min(M,C);(p.hexType===3||p.hexType===4)&&(v|=1n<<BigInt(c.get(`eh${w},${g}`)))}else{let w=Math.min(b,g);(p.hexType===3||p.hexType===4)&&(v|=1n<<BigInt(c.get(`ev${C},${w}`)))}if(d!==0){let w=this.getSymmetricalPointIndex(e,p.next),R=Math.floor(w/x),B=w%x,$=e.nodes[R][B].type;($===3||$===5)&&(v|=1n<<BigInt(c.get(`n${B},${R}`)));let A=this.getSymmetricalPointIndex(e,S),z=Math.floor(A/x),E=A%x;if(z===R){let T=Math.min(E,B),H=e.hEdges[R][T].type;(H===3||H===5)&&(v|=1n<<BigInt(c.get(`eh${T},${R}`)))}else{let T=Math.min(z,R),H=e.vEdges[T][B].type;(H===3||H===5)&&(v|=1n<<BigInt(c.get(`ev${B},${T}`)))}}s.push(p.next);let N=n|1n<<BigInt(p.next);if(d!==0){let w=this.getSymmetricalPointIndex(e,p.next);N|=1n<<BigInt(w)}if(this.exploreSearchSpace(e,p.next,N,s,v,o,i,f,y,u,r,h,a,c),s.pop(),u.totalNodesVisited>r)return}}countSolutions(e,t=100){let n=e.rows,s=e.cols,l=s+1,o=(n+1)*l,i=Array.from({length:o},()=>[]),f=[],y=[],u=new Map,r=0;for(let m=0;m<=n;m++)for(let x=0;x<=s;x++){let p=m*l+x;if(e.nodes[m][x].type===1&&f.push(p),e.nodes[m][x].type===2&&y.push(p),(e.nodes[m][x].type===3||e.nodes[m][x].type===4||e.nodes[m][x].type===5)&&u.set(`n${x},${m}`,r++),x<s){let v=p+1,g=e.hEdges[m][x].type,C=g===3||g===4||g===5,P=g===1||g===2;i[p].push({next:v,hexType:g,isBroken:P}),i[v].push({next:p,hexType:g,isBroken:P}),C&&u.set(`eh${x},${m}`,r++)}if(m<n){let v=p+l,g=e.vEdges[m][x].type,C=g===3||g===4||g===5,P=g===1||g===2;i[p].push({next:v,hexType:g,isBroken:P}),i[v].push({next:p,hexType:g,isBroken:P}),C&&u.set(`ev${x},${m}`,r++)}}let h=new Set,a=r,c=this.getExternalCells(e),d=!1;for(let m=0;m<n;m++){for(let x=0;x<s;x++)if(e.cells[m][x].type!==0){d=!0;break}if(d)break}this.tetrisCache.clear();for(let m of f){let x=e.cols+1,p=Math.floor(m/x),v=m%x,g=0n,C=e.nodes[p][v].type;(C===3||C===4)&&(g|=1n<<BigInt(u.get(`n${v},${p}`)));let P=e.symmetry||0;if(P!==0){let b=this.getSymmetricalPointIndex(e,m),M=Math.floor(b/x),N=b%x,w=e.nodes[M][N].type;(w===3||w===5)&&(g|=1n<<BigInt(u.get(`n${N},${M}`)))}let S=1n<<BigInt(m);if(P!==0){let b=this.getSymmetricalPointIndex(e,m);if(b===m)continue;S|=1n<<BigInt(b)}this.findPathsOptimized(e,m,S,[m],g,a,i,y,h,t,c,d,u)}return h.size}findPathsOptimized(e,t,n,s,l,o,i,f,y,u,r,h=!0,a){if(y.size>=u)return;let c=e.symmetry||0;if(f.includes(t)){let d=0,m=l;for(;m>0n;)m&1n&&d++,m>>=1n;if(d===o){let x=s.map(v=>({x:v%(e.cols+1),y:Math.floor(v/(e.cols+1))}));if(c!==0){let v=this.getSymmetricalPointIndex(e,t),g=e.cols+1;if(e.nodes[Math.floor(v/g)][v%g].type!==2)return}let p=c!==0?x.map(v=>this.getSymmetricalPoint(e,v)):[];if(!h)y.add(this.getFingerprint(e,x,p,void 0,r));else{let v=this.validateFast(e,x,p,r);v.isValid&&y.add(this.getFingerprint(e,x,p,v.regions,r))}}return}if(this.canReachEndOptimized(t,n,i,f))for(let d of i[t]){if(d.isBroken||n&1n<<BigInt(d.next))continue;if(c!==0){let M=this.getSymmetricalPointIndex(e,t),N=this.getSymmetricalPointIndex(e,d.next);if(d.next===N||t===N&&d.next===M)continue}let m=!0;for(let M of i[t])if(M.hexType===3||M.hexType===4){let w=s.length>=2&&M.next===s[s.length-2],R=M.next===d.next;if(!w&&!R){m=!1;break}}if(!m)continue;if(c!==0){let M=this.getSymmetricalPointIndex(e,t),N=this.getSymmetricalPointIndex(e,d.next);for(let w of i[M])if(w.hexType===3||w.hexType===5){let B=s.length>=2?this.getSymmetricalPointIndex(e,s[s.length-2]):-1,$=w.next===B,A=w.next===N;if(!$&&!A){m=!1;break}}}if(!m)continue;let x=e.cols+1,p=l,v=Math.floor(d.next/x),g=d.next%x,C=e.nodes[v][g].type;(C===3||C===4)&&(p|=1n<<BigInt(a.get(`n${g},${v}`)));let P=Math.floor(t/x),S=t%x;if(P===v){let M=Math.min(S,g);(d.hexType===3||d.hexType===4)&&(p|=1n<<BigInt(a.get(`eh${M},${v}`)))}else{let M=Math.min(P,v);(d.hexType===3||d.hexType===4)&&(p|=1n<<BigInt(a.get(`ev${g},${M}`)))}if(c!==0){let M=this.getSymmetricalPointIndex(e,d.next),N=Math.floor(M/x),w=M%x,R=e.nodes[N][w].type;(R===3||R===5)&&(p|=1n<<BigInt(a.get(`n${w},${N}`)));let B=this.getSymmetricalPointIndex(e,t),$=Math.floor(B/x),A=B%x;if($===N){let z=Math.min(A,w),E=e.hEdges[N][z].type;(E===3||E===5)&&(p|=1n<<BigInt(a.get(`eh${z},${N}`)))}else{let z=Math.min($,N),E=e.vEdges[z][w].type;(E===3||E===5)&&(p|=1n<<BigInt(a.get(`ev${w},${z}`)))}}s.push(d.next);let b=n|1n<<BigInt(d.next);if(c!==0){let M=this.getSymmetricalPointIndex(e,d.next);b|=1n<<BigInt(M)}if(this.findPathsOptimized(e,d.next,b,s,p,o,i,f,y,u,r,h,a),s.pop(),y.size>=u)return}}canReachEndOptimized(e,t,n,s){let l=[e],o=t,i=0;for(;i<l.length;){let f=l[i++];if(s.includes(f))return!0;for(let y of n[f])!y.isBroken&&!(o&1n<<BigInt(y.next))&&(o|=1n<<BigInt(y.next),l.push(y.next))}return!1}getFingerprint(e,t,n,s,l){let i=(s||this.calculateRegions(e,t,n,l)).map(y=>{let u="",r=[];for(let h of y){let a=e.cells[h.y][h.x];a.type!==0&&r.push(a.type<<8|a.color)}r.sort((h,a)=>h-a);for(let h of r)u+=h.toString(36)+",";return u}).sort(),f="";for(let y of i)y.length>0&&(f+=y+"|");return f||"empty"}};var ae=class{isWorker;TETRIS_SHAPES_WITH_ROTATIONS=[];constructor(){this.isWorker=typeof self<"u"&&"postMessage"in self&&!("document"in self);for(let e of this.TETRIS_SHAPES)this.TETRIS_SHAPES_WITH_ROTATIONS.push(this.getAllRotations(e))}generate(e,t,n={}){let s=n.difficulty??.5,l=new ne,o=null,i=-1,f=e*t<=16,y=this.isWorker?e*t>30?120:f?250:150:e*t>30?80:f?200:100,u=this.isWorker?8:f?12:6,r=n.symmetry||0,h={x:0,y:e},a={x:t,y:0};r===1?a={x:0,y:0}:r===2?a={x:t,y:e}:r===3&&(a={x:t,y:e});let c=null,d=null,m=null;for(let x=0;x<y;x++){if(x%u===0){c=this.generateRandomPath(new ee(e,t),h,a,n.pathLength,r);let P=new ee(e,t),S=r!==0?c.map(b=>this.getSymmetricalPoint(P,b,r)):[];d=this.calculateRegions(P,c,S),m=d.map(b=>this.getRegionBoundaryEdges(P,b,c,S))}let p=this.generateFromPath(e,t,c,n,d,m);if(!l.validate(p,{points:c}).isValid||!this.checkAllRequestedConstraintsPresent(p,n))continue;let g=l.calculateDifficulty(p);if(g===0)continue;let C=Math.abs(g-s);if((o===null||C<Math.abs(i-s))&&(i=g,o=p),s>.8&&g>.8||C<.01)break}if(!o){for(let x=0;x<50;x++){let p=this.generateRandomPath(new ee(e,t),h,a,n.pathLength,r),v=this.generateFromPath(e,t,p,n);if(this.checkAllRequestedConstraintsPresent(v,n)&&l.validate(v,{points:p}).isValid)return v}return new ee(e,t)}return o}generateFromPath(e,t,n,s,l,o){let i=new ee(e,t),f=s.symmetry||0;i.symmetry=f;let y={x:0,y:e},u={x:t,y:0};if(f===1?u={x:0,y:0}:f===2?u={x:t,y:e}:f===3&&(u={x:t,y:e}),i.nodes[y.y][y.x].type=1,i.nodes[u.y][u.x].type=2,f!==0){let h=this.getSymmetricalPoint(i,y,f),a=this.getSymmetricalPoint(i,u,f);i.nodes[h.y][h.x].type=1,i.nodes[a.y][a.x].type=2}let r=f!==0?n.map(h=>this.getSymmetricalPoint(i,h,f)):[];return this.applyConstraintsBasedOnPath(i,n,s,r,l,o),s.useBrokenEdges&&this.applyBrokenEdges(i,n,s),this.cleanGrid(i),i}generateRandomPath(e,t,n,s,l=0){if(s===void 0)return this.generateSingleRandomPath(e,t,n,void 0,l);let o=e.rows+e.cols,i=(e.rows+1)*(e.cols+1)-1,f=o+s*(i-o),y=[],u=1/0,r=e.rows*e.cols>30?30:50;for(let h=0;h<r;h++){let a=this.generateSingleRandomPath(e,t,n,s,l);if(a.length===0)continue;let c=a.length-1,d=Math.abs(c-f);if(d<u&&(u=d,y=a),u<=2)break}return y}generateSingleRandomPath(e,t,n,s,l=0){let o=new Set,i=[],f=0,y=e.rows*e.cols*200,u=r=>{if(f++,f>y)return!1;o.add(`${r.x},${r.y}`);let h=this.getSymmetricalPoint(e,r,l);if(o.add(`${h.x},${h.y}`),i.push(r),r.x===n.x&&r.y===n.y)return!0;let a=this.getValidNeighbors(e,r,o);l!==0&&(a=a.filter(c=>{let d=this.getSymmetricalPoint(e,c,l);if(d.x<0||d.x>e.cols||d.y<0||d.y>e.rows||o.has(`${d.x},${d.y}`)||c.x===d.x&&c.y===d.y)return!1;let m=this.getEdgeKey(r,c),x=this.getEdgeKey(h,d);return m!==x})),s!==void 0?a.sort((c,d)=>{let m=Math.abs(c.x-n.x)+Math.abs(c.y-n.y),x=Math.abs(d.x-n.x)+Math.abs(d.y-n.y);return(m-x)*(1-s*2)+(Math.random()-.5)*1.5}):this.shuffleArray(a);for(let c of a)if(u(c))return!0;return i.pop(),o.delete(`${r.x},${r.y}`),o.delete(`${h.x},${h.y}`),!1};return u(t),i}getValidNeighbors(e,t,n){let s=[],l=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of l){let i=t.x+o.x,f=t.y+o.y;i>=0&&i<=e.cols&&f>=0&&f<=e.rows&&(n.has(`${i},${f}`)||s.push({x:i,y:f}))}return s}applyBrokenEdges(e,t,n){let s=n.complexity??.5,l=n.symmetry??0,o=new Set;for(let r=0;r<t.length-1;r++)if(o.add(this.getEdgeKey(t[r],t[r+1])),l!==0){let h=this.getSymmetricalPoint(e,t[r],l),a=this.getSymmetricalPoint(e,t[r+1],l);o.add(this.getEdgeKey(h,a))}let i=[];for(let r=0;r<=e.rows;r++)for(let h=0;h<e.cols;h++){let a={x:h,y:r},c={x:h+1,y:r};o.has(this.getEdgeKey(a,c))||i.push({type:"h",r,c:h,p1:a,p2:c})}for(let r=0;r<e.rows;r++)for(let h=0;h<=e.cols;h++){let a={x:h,y:r},c={x:h,y:r+1};o.has(this.getEdgeKey(a,c))||i.push({type:"v",r,c:h,p1:a,p2:c})}this.shuffleArray(i);let f=Math.max(1,Math.floor(s*(e.rows*e.cols)/4)),y=0;for(let r of i){if(y>=f)break;r.type==="h"?e.hEdges[r.r][r.c].type=1:e.vEdges[r.r][r.c].type=1,y++}let u=!0;for(;u;){u=!1;for(let r=0;r<=e.rows;r++)for(let h=0;h<e.cols;h++)e.hEdges[r][h].type===1&&this.canBecomeAbsent(e,{type:"h",r,c:h})&&(e.hEdges[r][h].type=2,u=!0);for(let r=0;r<e.rows;r++)for(let h=0;h<=e.cols;h++)e.vEdges[r][h].type===1&&this.canBecomeAbsent(e,{type:"v",r,c:h})&&(e.vEdges[r][h].type=2,u=!0)}for(let r=0;r<=e.rows;r++)for(let h=0;h<=e.cols;h++){let a=[];if(h>0&&a.push({e:e.hEdges[r][h-1],type:"h",r,c:h-1}),h<e.cols&&a.push({e:e.hEdges[r][h],type:"h",r,c:h}),r>0&&a.push({e:e.vEdges[r-1][h],type:"v",r:r-1,c:h}),r<e.rows&&a.push({e:e.vEdges[r][h],type:"v",r,c:h}),a.length>0&&a.every(c=>c.e.type===1||c.e.type===2)&&a.every(c=>!this.isAdjacentToMark(e,c)))for(let c of a)c.e.type=2}}canBecomeAbsent(e,t){if(this.isAdjacentToMark(e,t))return!1;if(t.type==="h"){if(t.r===0||t.r===e.rows)return!0}else if(t.c===0||t.c===e.cols)return!0;let n=t.type==="h"?[{x:t.c,y:t.r},{x:t.c+1,y:t.r}]:[{x:t.c,y:t.r},{x:t.c,y:t.r+1}];for(let s of n){let l=[{type:"h",r:s.y,c:s.x-1},{type:"h",r:s.y,c:s.x},{type:"v",r:s.y-1,c:s.x},{type:"v",r:s.y,c:s.x}];for(let o of l)if(o.c>=0&&o.c<=e.cols&&o.r>=0&&o.r<=e.rows){if(o.type==="h"&&o.c<e.cols){if(e.hEdges[o.r][o.c].type===2)return!0}else if(o.type==="v"&&o.r<e.rows&&e.vEdges[o.r][o.c].type===2)return!0}}return!1}cleanGrid(e){let t=[];for(let o=0;o<=e.rows;o++)for(let i=0;i<=e.cols;i++)e.nodes[o][i].type===1&&t.push({x:i,y:o});let n=new Set,s=[...t];for(let o of t)n.add(`${o.x},${o.y}`);for(;s.length>0;){let o=s.shift(),i=[{nx:o.x,ny:o.y-1,edge:e.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:e.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:e.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:e.hEdges[o.y]?.[o.x]}];for(let f of i)f.edge&&f.edge.type!==2&&(n.has(`${f.nx},${f.ny}`)||(n.add(`${f.nx},${f.ny}`),s.push({x:f.nx,y:f.ny})))}for(let o=0;o<=e.rows;o++)for(let i=0;i<e.cols;i++)(!n.has(`${i},${o}`)||!n.has(`${i+1},${o}`))&&(e.hEdges[o][i].type=2);for(let o=0;o<e.rows;o++)for(let i=0;i<=e.cols;i++)(!n.has(`${i},${o}`)||!n.has(`${i},${o+1}`))&&(e.vEdges[o][i].type=2);let l=this.getExternalCells(e);for(let o of l){let[i,f]=o.split(",").map(Number);e.cells[f][i].type=0}}getExternalCells(e){let t=new Set,n=[];for(let s=0;s<e.cols;s++)e.hEdges[0][s].type===2&&(t.has(`${s},0`)||(t.add(`${s},0`),n.push({x:s,y:0}))),e.hEdges[e.rows][s].type===2&&(t.has(`${s},${e.rows-1}`)||(t.add(`${s},${e.rows-1}`),n.push({x:s,y:e.rows-1})));for(let s=0;s<e.rows;s++)e.vEdges[s][0].type===2&&(t.has(`0,${s}`)||(t.add(`0,${s}`),n.push({x:0,y:s}))),e.vEdges[s][e.cols].type===2&&(t.has(`${e.cols-1},${s}`)||(t.add(`${e.cols-1},${s}`),n.push({x:e.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),l=[{nx:s.x,ny:s.y-1,edge:e.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:e.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:e.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:e.vEdges[s.y][s.x+1]}];for(let o of l)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return t}isAdjacentToMark(e,t){if(t.type==="h"){if(t.r>0&&e.cells[t.r-1][t.c].type!==0||t.r<e.rows&&e.cells[t.r][t.c].type!==0)return!0}else if(t.c>0&&e.cells[t.r][t.c-1].type!==0||t.c<e.cols&&e.cells[t.r][t.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let t=0;t<e.rows;t++)for(let n=0;n<e.cols;n++){if(e.cells[t][n].type===0)continue;if([e.hEdges[t][n],e.hEdges[t+1][n],e.vEdges[t][n],e.vEdges[t][n+1]].every(l=>l.type===1||l.type===2))return!0}return!1}getSymmetricalPoint(e,t,n){return n===1?{x:e.cols-t.x,y:t.y}:n===2?{x:t.x,y:e.rows-t.y}:n===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,t,n,s=[],l,o){let i=n.complexity??.5,f=n.useHexagons??!0,y=n.useSquares??!0,u=n.useStars??!0,r=n.useTetris??!1,h=n.useTetrisNegative??!1,a=n.useEraser??!1,c=0,d=0,m=0,x=0,p=0,v=0,g=Math.floor(e.rows*e.cols*.6);if(f){let C=n.difficulty??.5,P=n.symmetry||0;for(let S=0;S<t.length-1;S++){let M=this.getValidNeighbors(e,t[S],new Set).length>2,N=i*(C<.4?.6:.3);if(M&&(N=C<.4?N*1:N*.5),Math.random()<N){let w=3,R=t[S],B=t[S+1];if(P!==0){let $=Math.random();$<.3?w=4:$<.6&&(w=5,R=this.getSymmetricalPoint(e,t[S],P),B=this.getSymmetricalPoint(e,t[S+1],P))}this.setEdgeHexagon(e,R,B,w),c++}}for(let S=0;S<t.length;S++){let b=t[S];if(e.nodes[b.y][b.x].type!==0||this.hasIncidentHexagonEdge(e,b))continue;let M=i*(C>.6?.15:.05);if(Math.random()<M){let N=3,w=b;if(P!==0){let R=Math.random();R<.3?N=4:R<.6&&(N=5,w=this.getSymmetricalPoint(e,b,P))}e.nodes[w.y][w.x].type=N,c++}}if(c===0&&t.length>=2){let S=Math.floor(Math.random()*(t.length-1)),b=n.symmetry||0,M=3,N=t[S],w=t[S+1];if(b!==0){let R=Math.random();R<.3?M=4:R<.6&&(M=5,N=this.getSymmetricalPoint(e,t[S],b),w=this.getSymmetricalPoint(e,t[S+1],b))}this.setEdgeHexagon(e,N,w,M)}}if(y||u||r||a){let C=l||this.calculateRegions(e,t,s),P=n.availableColors??[q.Black,q.White,q.Red,q.Blue],S=n.defaultColors??{},b=(B,$)=>{if(S[B]!==void 0)return S[B];let A=oe[B];return A&&S[A]!==void 0?S[A]:$},M=Array.from({length:C.length},(B,$)=>$);this.shuffleArray(M);let N=new Set,w={square:y,star:u,tetris:r,tetrisNegative:h,eraser:a},R=0;for(let B=0;B<M.length;B++){let $=M[B],A=C[$],z=M.length-B,E=w.square&&d===0||w.star&&m===0||w.tetris&&x===0||w.tetrisNegative&&R===0||w.eraser&&p===0,T=.2+i*.6;if(E&&z<=3?T=1:E&&z<=6&&(T=.7),Math.random()>T)continue;let H=[...A];this.shuffleArray(H);let K=new Set,V=P[Math.floor(Math.random()*P.length)];if(y&&N.size<2){let k=P.filter(U=>!N.has(U));k.length>0&&(V=k[Math.floor(Math.random()*k.length)])}let j=y&&Math.random()<.5+i*.3;if(y&&d===0&&z<=2&&(j=!0),y&&!u&&z<=2&&N.size<2&&d>0&&(j=!0),j&&H.length>0){let k=Math.min(H.length,Math.max(4,Math.floor(A.length/4))),U=Math.floor(Math.random()*(k/2))+Math.ceil(k/2);for(let G=0;G<U&&H.length!==0;G++){let O=H.pop();e.cells[O.y][O.x].type=1,e.cells[O.y][O.x].color=V,d++,N.add(V),K.add(V)}}if(r||h){let k=Math.random()<.1+i*.4;x===0&&z<=3&&(k=!0),h&&R===0&&z<=2&&(k=!0);let U=x===0&&z<=2?6:4,G=v+A.length<=g||E&&r&&x===0&&A.length<=30||E&&h&&R===0&&A.length<=30;if(k&&H.length>0&&G){let O=A.length<=25?this.generateTiling(A,U,n):null;if(O){let W=[],X=.2+i*.3;if(h&&R===0&&z<=3&&(X=.9),h&&Math.random()<X){let I=n.difficulty??.5;if(Math.random()<.1&&H.length>=2){let _=!1;if(H.length>=3&&Math.random()<.8){let Z=Math.random()<.5,Q=1+Math.floor(Math.random()*2),J=this.TETRIS_SHAPES.filter(se=>this.getShapeArea(se)===Q),Y=J[Math.floor(Math.random()*J.length)],F=this.findStandardTriple(Y);F&&(Z?(O.push({shape:Y,displayShape:Y,isRotated:!this.isRotationallyInvariant(Y)&&Math.random()<I*.7,isNegative:!1}),O.push({shape:F.n,displayShape:F.n,isRotated:!this.isRotationallyInvariant(F.n)&&Math.random()<I*.7,isNegative:!1}),W.push({shape:F.p,displayShape:F.p,isRotated:!this.isRotationallyInvariant(F.p)&&Math.random()<I*.7,isNegative:!0})):(O.push({shape:F.p,displayShape:F.p,isRotated:!this.isRotationallyInvariant(F.p)&&Math.random()<I*.7,isNegative:!1}),W.push({shape:Y,displayShape:Y,isRotated:!this.isRotationallyInvariant(Y)&&Math.random()<I*.7,isNegative:!0}),W.push({shape:F.n,displayShape:F.n,isRotated:!this.isRotationallyInvariant(F.n)&&Math.random()<I*.7,isNegative:!0})),_=!0)}if(!_){let Z=3+Math.floor(Math.random()*2),Q=this.TETRIS_SHAPES.filter(J=>this.getShapeArea(J)===Z);if(this.shuffleArray(Q),Q.length>0){let J=Q[0],Y=Q[0];O.push({shape:J,displayShape:J,isRotated:!this.isRotationallyInvariant(J)&&Math.random()<I*.7,isNegative:!1}),W.push({shape:Y,displayShape:Y,isRotated:!this.isRotationallyInvariant(Y)&&Math.random()<I*.7,isNegative:!0})}}}else if(O.length>0){let _=Math.random()<.3?2:1;for(let Z=0;Z<_&&!(H.length<1);Z++){let Q=Math.floor(Math.random()*O.length),J=O[Q];if(J.isNegative)continue;let Y=!1;if(H.length>=2&&Math.random()<.2){let F=this.findStandardTriple(J.shape);if(F){let se=this.findStandardTriple(F.p);se&&(O[Q]={shape:se.p,displayShape:se.p,isRotated:!this.isRotationallyInvariant(se.p)&&Math.random()<I*.7,isNegative:!1},W.push({shape:F.n,displayShape:F.n,isRotated:!this.isRotationallyInvariant(F.n)&&Math.random()<I*.7,isNegative:!0}),W.push({shape:se.n,displayShape:se.n,isRotated:!this.isRotationallyInvariant(se.n)&&Math.random()<I*.7,isNegative:!0}),Y=!0)}}if(!Y){let F=this.findStandardTriple(J.shape);F&&(O.some(ye=>!ye.isNegative&&this.isSameShape(ye.shape,F.n))||(O[Q]={shape:F.p,displayShape:F.p,isRotated:!this.isRotationallyInvariant(F.p)&&Math.random()<I*.7,isNegative:!1},W.push({shape:F.n,displayShape:F.n,isRotated:!this.isRotationallyInvariant(F.n)&&Math.random()<I*.7,isNegative:!0})))}}}}let D=[...O,...W];for(let I of D){if(H.length===0)break;let L=H.pop();if(I.isNegative)e.cells[L.y][L.x].type=I.isRotated?6:5,e.cells[L.y][L.x].color=b(5,q.Cyan),R++;else{e.cells[L.y][L.x].type=I.isRotated?4:3;let Z=b(3,q.None),Q=Z;if(u&&Math.random()<.3){let J=P.filter(Y=>Y!==Z&&!K.has(Y));J.length>0&&(Q=J[Math.floor(Math.random()*J.length)],K.add(Q))}e.cells[L.y][L.x].color=Q}e.cells[L.y][L.x].shape=I.isRotated?I.displayShape:I.shape,x++}v+=A.length}}}if(a&&p<1){let k=.05+i*.2,U=Math.random()<k;if(z<=2&&(U=!0),U&&H.length>=1){let G=[];u&&G.push("star"),y&&G.push("square");let O=[];f&&(O=o?o[$]:this.getRegionBoundaryEdges(e,A,t,s),O.length>0&&G.push("hexagon")),r&&G.push("tetris"),h&&G.push("tetrisNegative"),this.shuffleArray(G),H.length>=2&&G.push("eraser");let W=!1;for(let X of G){if(W)break;if(X==="hexagon"){let D=O.filter(I=>!this.isEdgeAdjacentToHexagonNode(e,I));if(D.length>0){let I=D[Math.floor(Math.random()*D.length)];I.type==="h"?e.hEdges[I.r][I.c].type=3:e.vEdges[I.r][I.c].type=3,c++,W=!0}}else if(X==="square"&&H.length>=2){let D=H.pop();e.cells[D.y][D.x].type=1;let I=A.find(_=>e.cells[_.y][_.x].type===1),L=I?e.cells[I.y][I.x].color:void 0;e.cells[D.y][D.x].color=P.find(_=>_!==L)||q.Red,d++,W=!0}else if(X==="star"&&H.length>=2){let D=H.pop();e.cells[D.y][D.x].type=2,e.cells[D.y][D.x].color=P[Math.floor(Math.random()*P.length)],m++,W=!0}else if(X==="tetris"&&H.length>=2){let D=this.generateTiling(A,4,n),I=[];if(D&&D.length>0){let L=0;for(let _ of D){let Z=this.getShapeArea(_.shape);if(L+Z<A.length)I.push(_),L+=Z;else break}}if(I.length===0&&A.length>1&&(I=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),I.length>0){for(let L of I){if(H.length<2)break;let _=H.pop();e.cells[_.y][_.x].type=L.isRotated?4:3,e.cells[_.y][_.x].shape=L.isRotated?L.displayShape:L.shape,e.cells[_.y][_.x].color=q.None,x++}W=!0}}else if(X==="tetrisNegative"&&H.length>=2){let D=H.pop();e.cells[D.y][D.x].type=5,e.cells[D.y][D.x].shape=[[1]],e.cells[D.y][D.x].color=b(5,q.Cyan),R++,W=!0}else if(X==="eraser"&&H.length>=2){let D=H.pop();e.cells[D.y][D.x].type=7,e.cells[D.y][D.x].color=b(7,q.White),p++,W=!0}}if(W){let X=H.pop();e.cells[X.y][X.x].type=7;let D=b(7,q.White),I=D;if(u&&Math.random()<.3){let L=P.filter(_=>_!==D&&!K.has(_));L.length>0&&(I=L[Math.floor(Math.random()*L.length)],K.add(I))}e.cells[X.y][X.x].color=I,p++}}}if(u){for(let U of P){if(H.length<1)break;if(A.filter(O=>e.cells[O.y][O.x].color===U).length===1&&(U!==q.White||K.has(U))){let O=H.pop();e.cells[O.y][O.x].type=2,e.cells[O.y][O.x].color=U,m++}}let k=Math.max(1,Math.floor(A.length/8));for(let U=0;U<k&&!(H.length<2);U++)for(let G of P){if(H.length<2)break;if(Math.random()>.3+i*.4)continue;if(A.filter(W=>e.cells[W.y][W.x].color===G).length===0)for(let W=0;W<2;W++){let X=H.pop();e.cells[X.y][X.x].type=2,e.cells[X.y][X.x].color=G,m++}}}}if(y&&N.size<2){let B=N.values().next().value;if(!(B!==void 0&&m>0&&Array.from({length:e.rows*e.cols}).some((A,z)=>{let E=Math.floor(z/e.cols),T=z%e.cols;return e.cells[E][T].type===2&&e.cells[E][T].color===B}))){for(let A of C){if(N.size>=2)break;if(A.some(E=>e.cells[E.y][E.x].type===1))continue;let z=A.filter(E=>e.cells[E.y][E.x].type===0);if(z.length>0){let E=P.find(H=>!N.has(H))||q.White,T=z[Math.floor(Math.random()*z.length)];e.cells[T.y][T.x].type=1,e.cells[T.y][T.x].color=E,N.add(E),d++}}if(N.size<2&&u&&B!==void 0)for(let A of C){let z=A.filter(E=>e.cells[E.y][E.x].type===0);if(z.length>0){let E=z[Math.floor(Math.random()*z.length)];e.cells[E.y][E.x].type=2,e.cells[E.y][E.x].color=B,m++;break}}}}}}calculateRegions(e,t,n=[]){let s=[],l=e.rows,o=e.cols,i=new Uint8Array(l*o),f=new Uint8Array((l+1)*o),y=new Uint8Array(l*(o+1)),u=(r,h)=>{r.x===h.x?y[Math.min(r.y,h.y)*(o+1)+r.x]=1:f[r.y*o+Math.min(r.x,h.x)]=1};for(let r=0;r<t.length-1;r++)u(t[r],t[r+1]);for(let r=0;r<n.length-1;r++)u(n[r],n[r+1]);for(let r=0;r<=l;r++)for(let h=0;h<o;h++)e.hEdges[r][h].type===2&&(f[r*o+h]=1);for(let r=0;r<l;r++)for(let h=0;h<=o;h++)e.vEdges[r][h].type===2&&(y[r*(o+1)+h]=1);for(let r=0;r<l;r++)for(let h=0;h<o;h++){let a=r*o+h;if(i[a])continue;let c=[],d=[a];i[a]=1;let m=0;for(;m<d.length;){let x=d[m++],p=x%o,v=Math.floor(x/o);if(c.push({x:p,y:v}),v>0&&!f[v*o+p]){let g=(v-1)*o+p;i[g]||(i[g]=1,d.push(g))}if(v<l-1&&!f[(v+1)*o+p]){let g=(v+1)*o+p;i[g]||(i[g]=1,d.push(g))}if(p>0&&!y[v*(o+1)+p]){let g=v*o+(p-1);i[g]||(i[g]=1,d.push(g))}if(p<o-1&&!y[v*(o+1)+(p+1)]){let g=v*o+(p+1);i[g]||(i[g]=1,d.push(g))}}s.push(c)}return s}isAbsentEdge(e,t,n){if(t.x===n.x){let s=Math.min(t.y,n.y);return e.vEdges[s][t.x].type===2}else{let s=Math.min(t.x,n.x);return e.hEdges[t.y][s].type===2}}getRegionBoundaryEdges(e,t,n,s=[]){let l=new Set;for(let f=0;f<n.length-1;f++)l.add(this.getEdgeKey(n[f],n[f+1]));for(let f=0;f<s.length-1;f++)l.add(this.getEdgeKey(s[f],s[f+1]));let o=[];for(let f of t){let y=[{type:"h",r:f.y,c:f.x},{type:"h",r:f.y+1,c:f.x},{type:"v",r:f.y,c:f.x},{type:"v",r:f.y,c:f.x+1}];for(let u of y){let r=u.type==="h"?{x:u.c,y:u.r}:{x:u.c,y:u.r},h=u.type==="h"?{x:u.c+1,y:u.r}:{x:u.c,y:u.r+1},a=this.getEdgeKey(r,h);!l.has(a)&&!this.isAbsentEdge(e,r,h)&&o.push(u)}}let i=new Map;for(let f of o)i.set(`${f.type},${f.r},${f.c}`,f);return Array.from(i.values())}setEdgeHexagon(e,t,n,s=3){t.x===n.x?e.vEdges[Math.min(t.y,n.y)][t.x].type=s:e.hEdges[t.y][Math.min(t.x,n.x)].type=s}hasIncidentHexagonEdge(e,t){let n=s=>s===3||s===4||s===5;return!!(t.x>0&&n(e.hEdges[t.y][t.x-1].type)||t.x<e.cols&&n(e.hEdges[t.y][t.x].type)||t.y>0&&n(e.vEdges[t.y-1][t.x].type)||t.y<e.rows&&n(e.vEdges[t.y][t.x].type))}isEdgeAdjacentToHexagonNode(e,t){let n=s=>s===3||s===4||s===5;return t.type==="h"?n(e.nodes[t.r][t.c].type)||n(e.nodes[t.r][t.c+1].type):n(e.nodes[t.r][t.c].type)||n(e.nodes[t.r+1][t.c].type)}checkAllRequestedConstraintsPresent(e,t){let n=t.useHexagons??!0,s=t.useSquares??!0,l=t.useStars??!0,o=t.useTetris??!1,i=t.useTetrisNegative??!1,f=t.useEraser??!1;if(t.useBrokenEdges??!1){let u=!1;for(let r=0;r<=e.rows;r++)for(let h=0;h<e.cols;h++)if(e.hEdges[r][h].type===1||e.hEdges[r][h].type===2){u=!0;break}if(!u){for(let r=0;r<e.rows;r++)for(let h=0;h<=e.cols;h++)if(e.vEdges[r][h].type===1||e.vEdges[r][h].type===2){u=!0;break}}if(!u)return!1}if(n){let u=!1,r=a=>a===3||a===4||a===5,h=a=>a===3||a===4||a===5;for(let a=0;a<=e.rows;a++)for(let c=0;c<e.cols;c++)if(r(e.hEdges[a][c].type)){u=!0;break}if(!u){for(let a=0;a<e.rows;a++)for(let c=0;c<=e.cols;c++)if(r(e.vEdges[a][c].type)){u=!0;break}}if(!u){for(let a=0;a<=e.rows;a++)for(let c=0;c<=e.cols;c++)if(h(e.nodes[a][c].type)){u=!0;break}}if(!u)return!1}if(s||l||o||f){let u=!1,r=!1,h=!1,a=!1,c=!1,d=new Set,m=new Set;for(let x=0;x<e.rows;x++)for(let p=0;p<e.cols;p++){let v=e.cells[x][p].type;v===1&&(u=!0,d.add(e.cells[x][p].color)),v===2&&(r=!0,m.add(e.cells[x][p].color)),(v===3||v===4)&&(h=!0),(v===5||v===6)&&(a=!0),v===7&&(c=!0)}if(s&&!u||l&&!r||o&&!h||i&&!a||f&&!c)return!1;if(s&&u&&d.size<2){let x=d.values().next().value;if(x===void 0||!m.has(x))return!1}}return!this.hasIsolatedMark(e)}generateTiling(e,t,n){let s=Math.min(...e.map(r=>r.x)),l=Math.min(...e.map(r=>r.y)),o=Math.max(...e.map(r=>r.x)),i=Math.max(...e.map(r=>r.y)),f=o-s+1,y=i-l+1,u=Array.from({length:y},()=>Array(f).fill(!1));for(let r of e)u[r.y-l][r.x-s]=!0;return this.tilingDfs(u,[],t,n)}tilingDfs(e,t,n,s){let l=-1,o=-1;for(let y=0;y<e.length;y++){for(let u=0;u<e[0].length;u++)if(e[y][u]){l=y,o=u;break}if(l!==-1)break}if(l===-1)return t;if(t.length>=n)return null;let i=s.difficulty??.5,f=Array.from({length:this.TETRIS_SHAPES.length},(y,u)=>u);this.shuffleArray(f),i>.6&&f.sort((y,u)=>this.getShapeArea(this.TETRIS_SHAPES[u])-this.getShapeArea(this.TETRIS_SHAPES[y]));for(let y of f){let u=this.TETRIS_SHAPES[y],r=this.TETRIS_SHAPES_WITH_ROTATIONS[y],h=Array.from({length:r.length},(a,c)=>c);this.shuffleArray(h);for(let a of h){let c=r[a],d=[];for(let m=0;m<c.length;m++)for(let x=0;x<c[0].length;x++)c[m][x]&&d.push({r:m,c:x});for(let m of d){let x=l-m.r,p=o-m.c;if(this.canPlace(e,c,x,p)){this.placePiece(e,c,x,p,!1);let v=r.length>1&&Math.random()<.3+i*.6,g=this.tilingDfs(e,[...t,{shape:c,displayShape:u,isRotated:v}],n,s);if(g)return g;this.placePiece(e,c,x,p,!0)}}}}return null}getShapeArea(e){let t=0;for(let n of e)for(let s of n)s&&t++;return t}isRotationallyInvariant(e){return this.getAllRotations(e).length===1}getAllRotations(e){let t=[],n=new Set,s=e;for(let l=0;l<4;l++){let o=JSON.stringify(s);n.has(o)||(t.push(s),n.add(o)),s=this.rotate90(s)}return t}rotate90(e){let t=e.length,n=e[0].length,s=Array.from({length:n},()=>Array(t).fill(0));for(let l=0;l<t;l++)for(let o=0;o<n;o++)s[o][t-1-l]=e[l][o];return s}canPlace(e,t,n,s){for(let l=0;l<t.length;l++)for(let o=0;o<t[0].length;o++)if(t[l][o]){let i=n+l,f=s+o;if(i<0||i>=e.length||f<0||f>=e[0].length||!e[i][f])return!1}return!0}placePiece(e,t,n,s,l){for(let o=0;o<t.length;o++)for(let i=0;i<t[0].length;i++)t[o][i]&&(e[n+o][s+i]=l)}isSameShape(e,t){let n=this.getAllRotations(e),s=JSON.stringify(t);return n.some(l=>JSON.stringify(l)===s)}canTilePieceWith(e,t,n){let s=this.getShapeArea(e),l=this.getShapeArea(t),o=this.getShapeArea(n);if(s!==l+o)return!1;let i=this.getAllRotations(t),f=this.getAllRotations(n),y=e.length,u=e[0].length;for(let r of i)for(let h of f){let a=r.length,c=r[0].length,d=h.length,m=h[0].length;for(let x=0;x<=y-a;x++)for(let p=0;p<=u-c;p++)for(let v=0;v<=y-d;v++)for(let g=0;g<=u-m;g++){let C=Array.from({length:y},()=>Array(u).fill(0)),P=!0;for(let S=0;S<a;S++)for(let b=0;b<c;b++)r[S][b]&&(C[x+S][p+b]=1);for(let S=0;S<d;S++){for(let b=0;b<m;b++)if(h[S][b]){if(C[v+S][g+b]){P=!1;break}C[v+S][g+b]=1}if(!P)break}if(P){let S=!0;for(let b=0;b<y;b++){for(let M=0;M<u;M++)if(C[b][M]!==e[b][M]){S=!1;break}if(!S)break}if(S)return!0}}}return!1}findStandardTriple(e){let t=this.getShapeArea(e),n=[...this.TETRIS_SHAPES];this.shuffleArray(n);for(let s of n){let l=this.getShapeArea(s),o=t+l;if(o>5)continue;let i=this.TETRIS_SHAPES.filter(f=>this.getShapeArea(f)===o);for(let f of i)if(this.canTilePieceWith(f,e,s))return{p:f,n:s}}return null}shuffleArray(e){for(let t=e.length-1;t>0;t--){let n=Math.floor(Math.random()*(t+1));[e[t],e[n]]=[e[n],e[t]]}}};var he=class{bytes=[];cur=0;bit=0;write(e,t){for(let n=0;n<t;n++)e&1<<n&&(this.cur|=1<<this.bit),this.bit++,this.bit===8&&(this.bytes.push(this.cur),this.cur=0,this.bit=0)}finish(){return this.bit>0&&this.bytes.push(this.cur),new Uint8Array(this.bytes)}},ce=class{constructor(e){this.buf=e}i=0;bit=0;read(e){let t=0;for(let n=0;n<e;n++)this.buf[this.i]&1<<this.bit&&(t|=1<<n),this.bit++,this.bit===8&&(this.bit=0,this.i++);return t}};function me(te){let e=new Map;for(let t of te)for(let n of t)if(n.shape){let s=JSON.stringify(n.shape);e.has(s)||e.set(s,n.shape)}return[...e.values()]}var fe=class{static async serialize(e,t){let n=new he;n.write(e.rows,6),n.write(e.cols,6),n.write(e.symmetry??0,2);let s=me(e.cells);n.write(s.length,5);for(let u of s){n.write(u.length,4),n.write(u[0].length,4);for(let r of u)for(let h of r)n.write(h,1)}let l=new Map;s.forEach((u,r)=>l.set(JSON.stringify(u),r));for(let u of e.cells)for(let r of u)n.write(r.type,3),n.write(r.color,3),r.shape?(n.write(1,1),n.write(l.get(JSON.stringify(r.shape)),5)):n.write(0,1);for(let u=0;u<e.rows;u++)for(let r=0;r<e.cols+1;r++)n.write(e.vEdges[u][r].type,3);for(let u=0;u<e.rows+1;u++)for(let r=0;r<e.cols;r++)n.write(e.hEdges[u][r].type,3);for(let u=0;u<e.rows+1;u++)for(let r=0;r<e.cols+1;r++)n.write(e.nodes[u][r].type,3);n.write(+!!t.useHexagons,1),n.write(+!!t.useSquares,1),n.write(+!!t.useStars,1),n.write(+!!t.useTetris,1),n.write(+!!t.useTetrisNegative,1),n.write(+!!t.useEraser,1),n.write(+!!t.useBrokenEdges,1),n.write(t.symmetry??0,2),n.write(Math.round((t.complexity??0)*254),8),n.write(Math.round((t.difficulty??0)*254),8),n.write(Math.round((t.pathLength??0)*254),8);let o=n.finish(),i=new Uint8Array(await new Response(new Blob([o.buffer]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()),f=0;for(let u of i)f^=u;let y=new Uint8Array(i.length+1);return y.set(i),y[i.length]=f,btoa(String.fromCharCode(...y)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}static async deserialize(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4;)t+="=";let n=atob(t),s=Uint8Array.from(n,$=>$.charCodeAt(0)),l=0;for(let $=0;$<s.length-1;$++)l^=s[$];if(l!==s.at(-1))throw new Error("Invalid parity data");let o=new Uint8Array(await new Response(new Blob([s.slice(0,-1).buffer]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer()),i=new ce(o),f=i.read(6),y=i.read(6),u=i.read(2),r=i.read(5),h=[];for(let $=0;$<r;$++){let A=i.read(4),z=i.read(4),E=[];for(let T=0;T<A;T++){let H=[];for(let K=0;K<z;K++)H.push(i.read(1));E.push(H)}h.push(E)}let a=[];for(let $=0;$<f;$++){let A=[];for(let z=0;z<y;z++){let E=i.read(3),T=i.read(3),H=i.read(1),K={type:E,color:T};H&&(K.shape=h[i.read(5)].map(V=>V.slice())),A.push(K)}a.push(A)}let c=Array.from({length:f},()=>Array.from({length:y+1},()=>({type:i.read(3)}))),d=Array.from({length:f+1},()=>Array.from({length:y},()=>({type:i.read(3)}))),m=Array.from({length:f+1},()=>Array.from({length:y+1},()=>({type:i.read(3)}))),x=()=>{let $=i.read(8);return Math.round($/254*1e3)/1e3},p={},v=!!i.read(1),g=!!i.read(1),C=!!i.read(1),P=!!i.read(1),S=!!i.read(1),b=!!i.read(1),M=!!i.read(1),N=i.read(2);v&&(p.useHexagons=!0),g&&(p.useSquares=!0),C&&(p.useStars=!0),P&&(p.useTetris=!0),S&&(p.useTetrisNegative=!0),b&&(p.useEraser=!0),M&&(p.useBrokenEdges=!0),p.symmetry=N;let w=x(),R=x(),B=x();return w!==0&&(p.complexity=w),R!==0&&(p.difficulty=R),B!==0&&(p.pathLength=B),{puzzle:{rows:f,cols:y,cells:a,vEdges:c,hEdges:d,nodes:m,symmetry:u},options:p}}};var ue=class{canvas;ctx;puzzle=null;options;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;invalidatedCells=[];invalidatedEdges=[];invalidatedNodes=[];errorCells=[];errorEdges=[];errorNodes=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;canvasRect=null;boundMouseDown=null;boundMouseMove=null;boundMouseUp=null;boundTouchStart=null;boundTouchMove=null;boundTouchEnd=null;constructor(e,t,n={}){if(typeof e=="string"){if(typeof document>"u")throw new Error("Cannot look up canvas by ID in a non-browser environment.");let l=document.getElementById(e);if(!(l instanceof HTMLCanvasElement))throw new Error(`Element with id "${e}" is not a canvas.`);this.canvas=l}else this.canvas=e;let s=this.canvas.getContext("2d");if(!s)throw new Error("Could not get 2D context.");this.ctx=s,this.ctx.imageSmoothingEnabled=!1,this.options=this.mergeOptions(n),t&&this.setPuzzle(t),this.initEvents(),this.animate()}mergeOptions(e){let t={blinkDuration:e.animations?.blinkDuration??this.options?.animations?.blinkDuration??1e3,fadeDuration:e.animations?.fadeDuration??this.options?.animations?.fadeDuration??1e3,blinkPeriod:e.animations?.blinkPeriod??this.options?.animations?.blinkPeriod??800},n={path:e.colors?.path??this.options?.colors?.path??"#ffcc00",error:e.colors?.error??this.options?.colors?.error??"#ff4444",success:e.colors?.success??this.options?.colors?.success??"#ffcc00",symmetry:e.colors?.symmetry??this.options?.colors?.symmetry??"rgba(255, 255, 255, 0.5)",interrupted:e.colors?.interrupted??this.options?.colors?.interrupted??"#ffcc00",grid:e.colors?.grid??this.options?.colors?.grid??"#555",node:e.colors?.node??this.options?.colors?.node??"#555",hexagon:e.colors?.hexagon??this.options?.colors?.hexagon??"#000",hexagonMain:e.colors?.hexagonMain??this.options?.colors?.hexagonMain??"#00ffff",hexagonSymmetry:e.colors?.hexagonSymmetry??this.options?.colors?.hexagonSymmetry??"#ffff00",colorMap:e.colors?.colorMap??this.options?.colors?.colorMap??{[q.Black]:"#000",[q.White]:"#fff",[q.Red]:"#f00",[q.Blue]:"#00f",[q.Cyan]:"#00ffff",[q.None]:"#ffcc00"},colorList:e.colors?.colorList??this.options?.colors?.colorList};return{gridPadding:e.gridPadding??this.options?.gridPadding??60,cellSize:e.cellSize??this.options?.cellSize??80,nodeRadius:e.nodeRadius??this.options?.nodeRadius??6,startNodeRadius:e.startNodeRadius??this.options?.startNodeRadius??22,pathWidth:e.pathWidth??this.options?.pathWidth??18,exitLength:e.exitLength??this.options?.exitLength??25,autoResize:e.autoResize??this.options?.autoResize??!0,blinkMarksOnError:e.blinkMarksOnError??this.options?.blinkMarksOnError??!0,stayPathOnError:e.stayPathOnError??this.options?.stayPathOnError??!0,animations:t,colors:n,onPathComplete:e.onPathComplete??this.options?.onPathComplete??(()=>{})}}setPuzzle(e){this.puzzle=e,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw()}setOptions(e){this.options=this.mergeOptions({...this.options,...e}),this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}setValidationResult(e,t=[],n=[],s=[],l=[],o=[],i=[]){this.invalidatedCells=t,this.invalidatedEdges=n,this.invalidatedNodes=o,this.errorCells=s,this.errorEdges=l,this.errorNodes=i,this.eraserAnimationStartTime=Date.now(),e?(this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0}resizeCanvas(){!this.puzzle||!this.canvas||(this.canvas.width=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,this.canvas.height=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2)}setCanvasRect(e){this.canvasRect=e}initEvents(){typeof window>"u"||!(this.canvas instanceof HTMLCanvasElement)||(this.boundMouseDown=e=>this.handleStart(e),this.boundMouseMove=e=>this.handleMove(e),this.boundMouseUp=e=>this.handleEnd(e),this.boundTouchStart=e=>{this.handleStart(e.touches[0])&&e.cancelable&&e.preventDefault()},this.boundTouchMove=e=>{this.isDrawing&&(e.cancelable&&e.preventDefault(),this.handleMove(e.touches[0]))},this.boundTouchEnd=e=>{this.isDrawing&&(e.cancelable&&e.preventDefault(),this.handleEnd(e.changedTouches[0]))},this.canvas.addEventListener("mousedown",this.boundMouseDown),window.addEventListener("mousemove",this.boundMouseMove),window.addEventListener("mouseup",this.boundMouseUp),this.canvas.addEventListener("touchstart",this.boundTouchStart,{passive:!1}),window.addEventListener("touchmove",this.boundTouchMove,{passive:!1}),window.addEventListener("touchend",this.boundTouchEnd,{passive:!1}))}destroy(){typeof window>"u"||!(this.canvas instanceof HTMLCanvasElement)||(this.boundMouseDown&&this.canvas.removeEventListener("mousedown",this.boundMouseDown),this.boundMouseMove&&window.removeEventListener("mousemove",this.boundMouseMove),this.boundMouseUp&&window.removeEventListener("mouseup",this.boundMouseUp),this.boundTouchStart&&this.canvas.removeEventListener("touchstart",this.boundTouchStart),this.boundTouchMove&&window.removeEventListener("touchmove",this.boundTouchMove),this.boundTouchEnd&&window.removeEventListener("touchend",this.boundTouchEnd),this.boundMouseDown=null,this.boundMouseMove=null,this.boundMouseUp=null,this.boundTouchStart=null,this.boundTouchMove=null,this.boundTouchEnd=null)}getCanvasCoords(e,t){return{x:this.options.gridPadding+e*this.options.cellSize,y:this.options.gridPadding+t*this.options.cellSize}}getExitDir(e,t){return!this.puzzle||this.puzzle.nodes[t]?.[e]?.type!==2?null:e===this.puzzle.cols?{x:1,y:0}:e===0?{x:-1,y:0}:t===0?{x:0,y:-1}:t===this.puzzle.rows?{x:0,y:1}:{x:1,y:0}}handleStart(e){if(!this.puzzle)return!1;let t=this.canvasRect||(this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),n=(e.clientX-t.left)*(this.canvas.width/t.width),s=(e.clientY-t.top)*(this.canvas.height/t.height);for(let l=0;l<=this.puzzle.rows;l++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[l][o].type===1){let i=this.getCanvasCoords(o,l);if(Math.hypot(i.x-n,i.y-s)<this.options.startNodeRadius)return this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.isDrawing=!0,this.path=[{x:o,y:l}],this.currentMousePos=i,this.exitTipPos=null,this.draw(),!0}return!1}handleMove(e){if(!this.puzzle||!this.isDrawing)return;let t=this.canvasRect||(this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),n=(e.clientX-t.left)*(this.canvas.width/t.width),s=(e.clientY-t.top)*(this.canvas.height/t.height),l=this.path[this.path.length-1],o=this.getCanvasCoords(l.x,l.y),i=n-o.x,f=s-o.y,y=this.puzzle.symmetry||0,u=this.getExitDir(l.x,l.y),r=Math.abs(i)>Math.abs(f)?{x:i>0?1:-1,y:0}:{x:0,y:f>0?1:-1};if(u&&r.x===u.x&&r.y===u.y){let d=i*u.x+f*u.y,m=Math.max(0,Math.min(d,this.options.exitLength));this.currentMousePos={x:o.x+u.x*m,y:o.y+u.y*m},this.draw();return}let h=(d,m)=>{let x=this.getEdgeType(l,d);if(d.x<0||d.x>this.puzzle.cols||d.y<0||d.y>this.puzzle.rows||x===2){this.currentMousePos=o;return}let p=x===1?this.options.cellSize*.35:this.options.cellSize,v=this.getEdgeKey(l,d);if(!(this.path.length>=2&&d.x===this.path[this.path.length-2].x&&d.y===this.path[this.path.length-2].y)){for(let P=0;P<this.path.length-1;P++)if(this.getEdgeKey(this.path[P],this.path[P+1])===v){p=0;break}}if(this.path.some(P=>P.x===d.x&&P.y===d.y)&&this.path.length>=2){let P=this.path[this.path.length-2];(d.x!==P.x||d.y!==P.y)&&(p=Math.min(p,this.options.cellSize*.5-this.options.pathWidth*.5))}if(y!==0){let P=this.getSymmetricalPoint(l),S=this.getSymmetricalPoint(d),b=this.getEdgeType(P,S),M=this.getSymmetryPath(this.path),N=this.getEdgeKey(P,S);if(S.x<0||S.x>this.puzzle.cols||S.y<0||S.y>this.puzzle.rows||b===2){this.currentMousePos=o;return}b===1&&(p=Math.min(p,this.options.cellSize*.35));let w=M.some(E=>E.x===d.x&&E.y===d.y),R=this.path.some(E=>E.x===S.x&&E.y===S.y),B=d.x===S.x&&d.y===S.y,$=M.some((E,T)=>T<M.length-1&&this.getEdgeKey(M[T],M[T+1])===v),A=this.path.some((E,T)=>T<this.path.length-1&&this.getEdgeKey(this.path[T],this.path[T+1])===N);(w||R||B||$||A||v===N)&&(p=Math.min(p,this.options.cellSize*.5-this.options.pathWidth*.5))}d.x!==l.x?this.currentMousePos={x:o.x+Math.max(-p,Math.min(p,m)),y:o.y}:this.currentMousePos={x:o.x,y:o.y+Math.max(-p,Math.min(p,m))}};if(Math.abs(i)>Math.abs(f)){let d=i>0?1:-1;h({x:l.x+d,y:l.y},i)}else{let d=f>0?1:-1;h({x:l.x,y:l.y+d},f)}let a=[{x:l.x+1,y:l.y},{x:l.x-1,y:l.y},{x:l.x,y:l.y+1},{x:l.x,y:l.y-1}],c=this.getSymmetryPath(this.path);for(let d of a)if(d.x>=0&&d.x<=this.puzzle.cols&&d.y>=0&&d.y<=this.puzzle.rows){let m=this.getCanvasCoords(d.x,d.y);if(Math.hypot(m.x-this.currentMousePos.x,m.y-this.currentMousePos.y)<this.options.cellSize*.3){let p=this.path.findIndex(v=>v.x===d.x&&v.y===d.y);if(p===-1){if(y!==0){let v=this.getSymmetricalPoint(d);if(d.x===v.x&&d.y===v.y||this.path.some(P=>P.x===v.x&&P.y===v.y)||c.some(P=>P.x===d.x&&P.y===d.y))continue;let g=this.getEdgeKey(l,d),C=this.getEdgeKey(this.getSymmetricalPoint(l),v);if(g===C)continue}this.path.push(d)}else p===this.path.length-2&&this.path.pop()}}this.draw()}handleEnd(e){if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let t=this.path[this.path.length-1],n=this.getCanvasCoords(t.x,t.y),s=this.getExitDir(t.x,t.y);if(s){let l=this.currentMousePos.x-n.x,o=this.currentMousePos.y-n.y;if(l*s.x+o*s.y>0){this.exitTipPos={x:n.x+s.x*this.options.exitLength,y:n.y+s.y*this.options.exitLength},this.options.onPathComplete(this.path);return}}this.exitTipPos=s?{...this.currentMousePos}:null,this.startFade(this.options.colors.interrupted)}getEdgeType(e,t){if(!this.puzzle)return 2;if(e.x===t.x){let n=Math.min(e.y,t.y);return n<0||n>=this.puzzle.rows?2:this.puzzle.vEdges[n][e.x].type}else{let n=Math.min(e.x,t.x);return n<0||n>=this.puzzle.cols?2:this.puzzle.hEdges[e.y][n].type}}startFade(e="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=e,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){let e=Date.now();if(this.isFading){let t=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=t,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0)}this.isInvalidPath&&!this.options.stayPathOnError&&!this.isFading&&this.path.length>0&&this.startFade(this.options.colors.error),this.draw(),typeof requestAnimationFrame<"u"&&requestAnimationFrame(()=>this.animate())}draw(){if(!this.puzzle||!this.ctx)return;let e=this.ctx,t=Date.now();if(e.globalAlpha=1,e.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(e),this.drawConstraints(e),this.drawNodes(e),this.path.length===0&&!this.isDrawing&&this.drawRipples(e),this.isFading){if(this.drawPath(e,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let n=this.getSymmetryPath(this.fadingPath),s=this.options.colors.symmetry;if(this.isInvalidPath){let o=this.colorToRgba(s).a;s=this.setAlpha(this.options.colors.error,o)}let l=null;if(this.fadingTipPos){let o=(this.fadingTipPos.x-this.options.gridPadding)/this.options.cellSize,i=(this.fadingTipPos.y-this.options.gridPadding)/this.options.cellSize,f=this.getSymmetricalPoint({x:o,y:i});l={x:f.x*this.options.cellSize+this.options.gridPadding,y:f.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,n,!1,s,this.fadeOpacity,l)}}else if(this.path.length>0){let n=this.options.colors.path,s=this.colorToRgba(n).a,l=this.options.colors.error,o=this.isInvalidPath?this.setAlpha(l,s):n;this.isSuccessFading&&!this.puzzle.symmetry&&(o=this.setAlpha(this.options.colors.success,s));let i=1;if(!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let f=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),y=this.options.animations.blinkDuration;f<y&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(o=this.setAlpha(this.options.colors.error,s),this.options.stayPathOnError||(i=Math.max(0,1-f/this.options.animations.fadeDuration)))}if(this.drawPath(e,this.path,this.isDrawing,o,i,this.isDrawing?this.currentMousePos:this.exitTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let f=this.getSymmetryPath(this.path),y=this.options.colors.symmetry,u=this.colorToRgba(y).a,r=y,h=i;if(this.isInvalidPath&&(r=this.setAlpha(l,u)),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let c=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),d=this.options.animations.blinkDuration;c<d&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(r=this.setAlpha(this.options.colors.error,u))}let a=null;if(this.isDrawing||this.exitTipPos){let c=this.isDrawing?this.currentMousePos:this.exitTipPos,d=(c.x-this.options.gridPadding)/this.options.cellSize,m=(c.y-this.options.gridPadding)/this.options.cellSize,x=this.getSymmetricalPoint({x:d,y:m},!0);a={x:x.x*this.options.cellSize+this.options.gridPadding,y:x.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,f,this.isDrawing,r,h,a)}}}drawRipples(e){if(!this.puzzle)return;let t=(Date.now()-this.startTime)/500;for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)if(this.puzzle.nodes[n][s].type===2){let o=this.getCanvasCoords(s,n),i=this.getExitDir(s,n);if(!i)continue;let f={x:o.x+i.x*this.options.exitLength,y:o.y+i.y*this.options.exitLength},y=t%4,u=y*5,r=Math.max(0,1-y/3);e.beginPath(),e.arc(f.x,f.y,u,0,Math.PI*2),e.strokeStyle=`rgba(170, 170, 170, ${r*.4})`,e.lineWidth=2,e.stroke()}}drawGrid(e){if(!this.puzzle||!this.options.colors.grid)return;e.strokeStyle=this.options.colors.grid,e.lineWidth=12,e.lineCap="round";let t=(n,s,l)=>{if(l!==2)if(l===1){let i={x:n.x+(s.x-n.x)*.35,y:n.y+(s.y-n.y)*.35},f={x:n.x+(s.x-n.x)*(.5+.15),y:n.y+(s.y-n.y)*(.5+.15)};e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(i.x,i.y),e.stroke(),e.beginPath(),e.moveTo(f.x,f.y),e.lineTo(s.x,s.y),e.stroke()}else e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(s.x,s.y),e.stroke()};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<this.puzzle.cols;s++)t(this.getCanvasCoords(s,n),this.getCanvasCoords(s+1,n),this.puzzle.hEdges[n][s].type);for(let n=0;n<this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)t(this.getCanvasCoords(s,n),this.getCanvasCoords(s,n+1),this.puzzle.vEdges[n][s].type)}drawConstraints(e){if(!this.puzzle)return;let t=Date.now(),n=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;for(let o=0;o<this.puzzle.rows;o++)for(let i=0;i<this.puzzle.cols;i++){let f=this.puzzle.cells[o][i],y=this.getCanvasCoords(i+.5,o+.5),u=this.invalidatedCells.some(m=>m.x===i&&m.y===o),r=this.errorCells.some(m=>m.x===i&&m.y===o),h=1,a,c=this.getColorCode(f.color),d=this.options.colors.error;if(r&&this.options.blinkMarksOnError&&(a=this.lerpColor(c,d,n)),u){let m=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),x=this.options.animations.blinkDuration;if(m<x){if(this.options.blinkMarksOnError){let p=Math.min(1,m/200),v=m>x*.8?(x-m)/(x*.2):1,g=Math.min(p,v);a=this.lerpColor(c,d,n*g)}}else h=Math.max(.3,1-(m-x)/this.options.animations.fadeDuration)}if(h<1||a){let{canvas:m,ctx:x}=this.prepareOffscreen();this.drawConstraintItem(x,f,y,a),e.save(),e.globalAlpha=h,e.drawImage(m,0,0),e.restore()}else this.drawConstraintItem(e,f,y)}e.lineWidth=2;let s=8,l=o=>o===3||o===3?this.options.colors.hexagon:o===4||o===4?this.options.colors.hexagonMain:o===5||o===5?this.options.colors.hexagonSymmetry:this.options.colors.hexagon;for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<this.puzzle.cols;i++){let f=this.puzzle.hEdges[o][i].type;if(f===3||f===4||f===5){let y=this.getCanvasCoords(i+.5,o);e.save();let u=this.invalidatedEdges.some(a=>a.type==="h"&&a.r===o&&a.c===i),r=this.errorEdges.some(a=>a.type==="h"&&a.r===o&&a.c===i),h=l(f);if(r&&this.options.blinkMarksOnError){let a=this.lerpColor(h,this.options.colors.error,n);this.drawHexagon(e,y.x,y.y,s,a)}else if(u){let a=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),c=this.options.animations.blinkDuration;if(a<c)if(this.options.blinkMarksOnError){let d=Math.min(1,a/200),m=a>c*.8?(c-a)/(c*.2):1,x=Math.min(d,m),p=this.lerpColor(h,this.options.colors.error,n*x);this.drawHexagon(e,y.x,y.y,s,p)}else this.drawHexagon(e,y.x,y.y,s,h);else e.globalAlpha*=Math.max(.3,1-(a-c)/this.options.animations.fadeDuration),this.drawHexagon(e,y.x,y.y,s,h)}else this.drawHexagon(e,y.x,y.y,s,h);e.restore()}}for(let o=0;o<this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++){let f=this.puzzle.vEdges[o][i].type;if(f===3||f===4||f===5){let y=this.getCanvasCoords(i,o+.5);e.save();let u=this.invalidatedEdges.some(a=>a.type==="v"&&a.r===o&&a.c===i),r=this.errorEdges.some(a=>a.type==="v"&&a.r===o&&a.c===i),h=l(f);if(r&&this.options.blinkMarksOnError){let a=this.lerpColor(h,this.options.colors.error,n);this.drawHexagon(e,y.x,y.y,s,a)}else if(u){let a=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),c=this.options.animations.blinkDuration;if(a<c)if(this.options.blinkMarksOnError){let d=Math.min(1,a/200),m=a>c*.8?(c-a)/(c*.2):1,x=Math.min(d,m),p=this.lerpColor(h,this.options.colors.error,n*x);this.drawHexagon(e,y.x,y.y,s,p)}else this.drawHexagon(e,y.x,y.y,s,h);else e.globalAlpha*=Math.max(.3,1-(a-c)/this.options.animations.fadeDuration),this.drawHexagon(e,y.x,y.y,s,h)}else this.drawHexagon(e,y.x,y.y,s,h);e.restore()}}for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++){let f=this.puzzle.nodes[o][i].type;if(f===3||f===4||f===5){let y=this.getCanvasCoords(i,o);e.save();let u=this.invalidatedNodes.some(a=>a.x===i&&a.y===o),r=this.errorNodes.some(a=>a.x===i&&a.y===o),h=l(f);if(r&&this.options.blinkMarksOnError){let a=this.lerpColor(h,this.options.colors.error,n);this.drawHexagon(e,y.x,y.y,s,a)}else if(u){let a=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),c=this.options.animations.blinkDuration;if(a<c)if(this.options.blinkMarksOnError){let d=Math.min(1,a/200),m=a>c*.8?(c-a)/(c*.2):1,x=Math.min(d,m),p=this.lerpColor(h,this.options.colors.error,n*x);this.drawHexagon(e,y.x,y.y,s,p)}else this.drawHexagon(e,y.x,y.y,s,h);else e.globalAlpha*=Math.max(.3,1-(a-c)/this.options.animations.fadeDuration),this.drawHexagon(e,y.x,y.y,s,h)}else this.drawHexagon(e,y.x,y.y,s,h);e.restore()}}}drawConstraintItem(e,t,n,s){t.type===1?(e.fillStyle=s||this.getColorCode(t.color),this.drawRoundedRect(e,n.x-26/2,n.y-26/2,26,26,8)):t.type===2?this.drawStar(e,n.x,n.y,12,16,8,t.color,s):t.type===3||t.type===4?this.drawTetris(e,n.x,n.y,t.shape||[],t.type===4,t.color,!1,s):t.type===5||t.type===6?this.drawTetris(e,n.x,n.y,t.shape||[],t.type===6,t.color,!0,s):t.type===7&&this.drawEraser(e,n.x,n.y,14,3,t.color,s)}drawNodes(e){if(!this.puzzle)return;let t=(n,s)=>{let l=[];return n>0&&l.push(this.puzzle.hEdges[s][n-1].type),n<this.puzzle.cols&&l.push(this.puzzle.hEdges[s][n].type),s>0&&l.push(this.puzzle.vEdges[s-1][n].type),s<this.puzzle.rows&&l.push(this.puzzle.vEdges[s][n].type),l.length>0&&l.every(o=>o===2)};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++){if(t(s,n))continue;let l=this.puzzle.nodes[n][s];if(l.type===3||l.type===4||l.type===5)continue;let o=this.getCanvasCoords(s,n);if(l.type===1)this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill();else if(l.type===2){let i=this.getExitDir(s,n);if(!i)continue;this.options.colors.node&&(e.strokeStyle=this.options.colors.node),e.lineWidth=12,e.lineCap="round",e.beginPath(),e.moveTo(o.x,o.y),e.lineTo(o.x+i.x*this.options.exitLength,o.y+i.y*this.options.exitLength),e.stroke()}else this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.nodeRadius,0,Math.PI*2),e.fill()}}drawPath(e,t,n,s,l,o=null){if(t.length===0||!s||s==="transparent")return;let i=this.colorToRgba(s),f=`rgb(${i.r},${i.g},${i.b})`,y=l*i.a,{canvas:u,ctx:r}=this.prepareOffscreen();this.drawPathInternal(r,t,n,f,o),e.save(),e.globalAlpha=y,e.drawImage(u,0,0),e.restore()}drawPathInternal(e,t,n,s,l=null){e.save(),e.strokeStyle=s,e.fillStyle=s,e.lineWidth=this.options.pathWidth,e.lineCap="round",e.lineJoin="round",e.beginPath();let o=this.getCanvasCoords(t[0].x,t[0].y);e.moveTo(o.x,o.y);for(let f=1;f<t.length;f++){let y=this.getCanvasCoords(t[f].x,t[f].y);e.lineTo(y.x,y.y)}let i=l||this.currentMousePos;(n||l)&&e.lineTo(i.x,i.y),e.stroke(),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill(),(n||l)&&(e.beginPath(),e.arc(i.x,i.y,this.options.pathWidth/2,0,Math.PI*2),e.fill()),e.restore()}drawRoundedRect(e,t,n,s,l,o){e.beginPath(),e.moveTo(t+o,n),e.lineTo(t+s-o,n),e.quadraticCurveTo(t+s,n,t+s,n+o),e.lineTo(t+s,n+l-o),e.quadraticCurveTo(t+s,n+l,t+s-o,n+l),e.lineTo(t+o,n+l),e.quadraticCurveTo(t,n+l,t,n+l-o),e.lineTo(t,n+o),e.quadraticCurveTo(t,n,t+o,n),e.closePath(),e.fill()}drawHexagon(e,t,n,s,l){if(!(!this.options.colors.hexagon&&!l)){e.fillStyle=l||this.options.colors.hexagon,e.beginPath();for(let o=0;o<6;o++){let i=Math.PI/3*o,f=t+s*Math.cos(i),y=n+s*Math.sin(i);o===0?e.moveTo(f,y):e.lineTo(f,y)}e.closePath(),e.fill()}}drawEraser(e,t,n,s,l,o,i){e.strokeStyle=i||this.getColorCode(o),e.lineWidth=s*.5,e.lineCap="butt";let f=.5;e.beginPath();for(let y=0;y<l;y++){let u=Math.PI*2/l*y+f,r=t+s*Math.cos(u),h=n+s*Math.sin(u);e.moveTo(t,n),e.lineTo(r,h)}e.stroke()}drawStar(e,t,n,s,l,o,i,f){e.fillStyle=f||this.getColorCode(i),e.beginPath();for(let y=0;y<o*2;y++){let u=y%2===0?l:s,r=Math.PI/o*y,h=t+u*Math.cos(r),a=n+u*Math.sin(r);y===0?e.moveTo(h,a):e.lineTo(h,a)}e.closePath(),e.fill()}drawTetris(e,t,n,s,l,o,i,f){if(!s||s.length===0)return;let y=12,u=2,r=s[0].length*y+(s[0].length-1)*u,h=s.length*y+(s.length-1)*u;e.save(),e.translate(t,n),l&&e.rotate(Math.PI/8);let a=f||this.getColorCode(o,i?"#00ffff":"#ffcc00");if(i){e.strokeStyle=a,e.lineWidth=2;for(let c=0;c<s.length;c++)for(let d=0;d<s[c].length;d++)if(s[c][d]){let m=d*(y+u)-r/2,x=c*(y+u)-h/2;e.strokeRect(m+1,x+1,y-2,y-2)}}else{e.fillStyle=a;for(let c=0;c<s.length;c++)for(let d=0;d<s[c].length;d++)if(s[c][d]){let m=d*(y+u)-r/2,x=c*(y+u)-h/2;e.fillRect(m,x,y,y)}}e.restore()}getColorCode(e,t="#666"){return this.options.colors.colorList&&this.options.colors.colorList[e]!==void 0?this.options.colors.colorList[e]:this.options.colors.colorMap&&this.options.colors.colorMap[e]!==void 0?this.options.colors.colorMap[e]:t}colorToRgba(e){if(!e||e==="transparent")return{r:0,g:0,b:0,a:0};if(e.startsWith("rgba")||e.startsWith("rgb")){let n=e.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);if(n)return{r:parseInt(n[1]),g:parseInt(n[2]),b:parseInt(n[3]),a:n[4]?parseFloat(n[4]):1}}let t=e.startsWith("#")?e.slice(1):e;if((t.length===3||t.length===4)&&(t=t.split("").map(n=>n+n).join("")),t.length===6){let n=parseInt(t,16);return{r:n>>16&255,g:n>>8&255,b:n&255,a:1}}else if(t.length===8){let n=parseInt(t,16);return{r:n>>24&255,g:n>>16&255,b:n>>8&255,a:(n&255)/255}}return{r:0,g:0,b:0,a:1}}lerpColor(e,t,n){try{let s=this.colorToRgba(e),l=this.colorToRgba(t),o=Math.round(s.r+(l.r-s.r)*n),i=Math.round(s.g+(l.g-s.g)*n),f=Math.round(s.b+(l.b-s.b)*n),y=s.a+(l.a-s.a)*n;return`rgba(${o},${i},${f},${y})`}catch{return e}}setAlpha(e,t){let n=this.colorToRgba(e);return`rgba(${n.r},${n.g},${n.b},${t})`}getSymmetryPath(e){return!this.puzzle||!this.puzzle.symmetry?[]:e.map(t=>this.getSymmetricalPoint(t))}getSymmetricalPoint(e,t=!1){if(!this.puzzle||!this.puzzle.symmetry)return{...e};let{cols:n,rows:s,symmetry:l}=this.puzzle;return l===1?{x:n-e.x,y:e.y}:l===2?{x:e.x,y:s-e.y}:l===3?{x:n-e.x,y:s-e.y}:{...e}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}prepareOffscreen(){if(!this.offscreenCanvas){if(typeof document<"u")this.offscreenCanvas=document.createElement("canvas");else if(typeof OffscreenCanvas<"u")this.offscreenCanvas=new OffscreenCanvas(this.canvas.width,this.canvas.height);else throw new Error("Offscreen canvas not supported in this environment.");this.offscreenCtx=this.offscreenCanvas.getContext("2d")}if((this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),!this.offscreenCtx)throw new Error("Could not get offscreen 2D context.");return this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx}}};var de=class{generator;validator;constructor(){this.generator=new ae,this.validator=new ne}createPuzzle(e,t,n={}){return this.generator.generate(e,t,n).export()}validateSolution(e,t){let n=ee.fromData(e);return this.validator.validate(n,t)}calculateDifficulty(e){let t=ee.fromData(e);return this.validator.calculateDifficulty(t)}};export{oe as CellType,q as Color,pe as Direction,ie as EdgeType,ee as Grid,re as NodeType,ae as PuzzleGenerator,fe as PuzzleSerializer,ne as PuzzleValidator,le as SymmetryType,de as WitnessCore,ue as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
