/*!
 * MiniWitness 1.2.7
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var ve=(s=>(s[s.Up=0]="Up",s[s.Right=1]="Right",s[s.Down=2]="Down",s[s.Left=3]="Left",s))(ve||{}),oe=(u=>(u[u.None=0]="None",u[u.Square=1]="Square",u[u.Star=2]="Star",u[u.Tetris=3]="Tetris",u[u.TetrisRotated=4]="TetrisRotated",u[u.TetrisNegative=5]="TetrisNegative",u[u.TetrisNegativeRotated=6]="TetrisNegativeRotated",u[u.Eraser=7]="Eraser",u))(oe||{}),ie=(o=>(o[o.Normal=0]="Normal",o[o.Broken=1]="Broken",o[o.Absent=2]="Absent",o[o.Hexagon=3]="Hexagon",o[o.HexagonMain=4]="HexagonMain",o[o.HexagonSymmetry=5]="HexagonSymmetry",o))(ie||{}),re=(o=>(o[o.Normal=0]="Normal",o[o.Start=1]="Start",o[o.End=2]="End",o[o.Hexagon=3]="Hexagon",o[o.HexagonMain=4]="HexagonMain",o[o.HexagonSymmetry=5]="HexagonSymmetry",o))(re||{}),le=(s=>(s[s.None=0]="None",s[s.Horizontal=1]="Horizontal",s[s.Vertical=2]="Vertical",s[s.Rotational=3]="Rotational",s))(le||{}),W={None:0,Black:1,White:2,Red:3,Blue:4,Cyan:5},xe=(n=>(n[n.Mulberry32=0]="Mulberry32",n[n.XorShift128Plus=1]="XorShift128Plus",n[n.MathRandom=2]="MathRandom",n))(xe||{});var te=class j{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];symmetry=0;seed;constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:W.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes,symmetry:this.symmetry,seed:this.seed}))}static fromData(e){let t=new j(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t.symmetry=e.symmetry||0,t.seed=e.seed,t}};var he=class{state;constructor(e){this.state=e>>>0}next(){let e=(this.state+=1831565813)|0;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}},fe=class{s0;s1;constructor(e,t){this.s0=e>>>0,this.s1=t>>>0,this.s0===0&&this.s1===0&&(this.s1=1)}next(){let e=this.s0,t=this.s1;return this.s0=t,e^=e<<23,this.s1=e^t^e>>>17^t>>>26,(this.s1+t>>>0)/4294967296}},ue=class{next(){return Math.random()}};function ce(j,e){switch(j){case 0:return new he(Number(e&0xffffffffn));case 1:return new fe(Number(e&0xffffffffn),Number(e>>32n&0xffffffffn));case 2:return new ue;default:return new he(Number(e&0xffffffffn))}}var se=class{tetrisCache=new Map;rng=null;setRng(e){this.rng=e}validate(e,t,n){let s=t.points;if(s.length<2)return{isValid:!1,errorReason:"Path too short"};let l=e.symmetry||0,o=[];if(l!==0)for(let c of s)o.push(this.getSymmetricalPoint(e,c));let i=s[0],u=s[s.length-1];if(e.nodes[i.y][i.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[u.y][u.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};if(l!==0){let c=o[0],d=o[o.length-1];if(e.nodes[c.y][c.x].type!==1)return{isValid:!1,errorReason:"Symmetrical path must start at Start Node"};if(e.nodes[d.y][d.x].type!==2)return{isValid:!1,errorReason:"Symmetrical path must end at End Node"}}let y=new Set,f=new Set;if(y.add(`${i.x},${i.y}`),l!==0){let c=o[0];if(y.has(`${c.x},${c.y}`))return{isValid:!1,errorReason:"Paths collide at start"};y.add(`${c.x},${c.y}`)}for(let c=0;c<s.length-1;c++){let d=s[c],g=s[c+1];if(Math.abs(d.x-g.x)+Math.abs(d.y-g.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let p=`${g.x},${g.y}`;if(y.has(p))return{isValid:!1,errorReason:"Self-intersecting path or path collision"};if(y.add(p),this.isBrokenEdge(e,d,g))return{isValid:!1,errorReason:"Passed through broken edge"};if(f.add(this.getEdgeKey(d,g)),l!==0){let b=o[c],m=o[c+1],C=`${m.x},${m.y}`;if(y.has(C))return{isValid:!1,errorReason:"Path collision"};if(y.add(C),this.isBrokenEdge(e,b,m))return{isValid:!1,errorReason:"Symmetrical path passed through broken edge"};let P=this.getEdgeKey(b,m);if(f.has(P))return{isValid:!1,errorReason:"Paths cross the same edge"};f.add(P)}}let r=this.calculateRegions(e,s,o,n),h=this.getMissedHexagons(e,s,o),a=this.validateWithErasers(e,r,h.edges,h.nodes);return a.regions=r,a}validateFast(e,t,n,s){let l=this.calculateRegions(e,t,n,s),o=this.getMissedHexagons(e,t,n);return this.validateWithErasers(e,l,o.edges,o.nodes)}isBrokenEdge(e,t,n){let s;if(t.x===n.x){let l=Math.min(t.y,n.y);s=e.vEdges[l][t.x].type}else{let l=Math.min(t.x,n.x);s=e.hEdges[t.y][l].type}return s===1||s===2}isAbsentEdge(e,t,n){if(t.x===n.x){let s=Math.min(t.y,n.y);return e.vEdges[s][t.x].type===2}else{let s=Math.min(t.x,n.x);return e.hEdges[t.y][s].type===2}}getMissedHexagons(e,t,n=[]){let s=new Set,l=new Set;for(let f=0;f<t.length;f++)l.add(`${t[f].x},${t[f].y}`),f<t.length-1&&s.add(this.getEdgeKey(t[f],t[f+1]));let o=new Set,i=new Set;for(let f=0;f<n.length;f++)i.add(`${n[f].x},${n[f].y}`),f<n.length-1&&o.add(this.getEdgeKey(n[f],n[f+1]));let u=[];for(let f=0;f<=e.rows;f++)for(let r=0;r<e.cols;r++){let h=e.hEdges[f][r].type;if(h===3||h===4||h===5){let a=this.getEdgeKey({x:r,y:f},{x:r+1,y:f}),c=!1;h===3?c=s.has(a)||o.has(a):h===4?c=s.has(a):h===5&&(c=o.has(a)),c||u.push({type:"h",r:f,c:r})}}for(let f=0;f<e.rows;f++)for(let r=0;r<=e.cols;r++){let h=e.vEdges[f][r].type;if(h===3||h===4||h===5){let a=this.getEdgeKey({x:r,y:f},{x:r,y:f+1}),c=!1;h===3?c=s.has(a)||o.has(a):h===4?c=s.has(a):h===5&&(c=o.has(a)),c||u.push({type:"v",r:f,c:r})}}let y=[];for(let f=0;f<=e.rows;f++)for(let r=0;r<=e.cols;r++){let h=e.nodes[f][r].type;if(h===3||h===4||h===5){let a=`${r},${f}`,c=!1;h===3?c=l.has(a)||i.has(a):h===4?c=l.has(a):h===5&&(c=i.has(a)),c||y.push({x:r,y:f})}}return{edges:u,nodes:y}}validateWithErasers(e,t,n,s){let l=[],o=!0;for(let a=0;a<t.length;a++){let c=t[a],d=c.filter(m=>e.cells[m.y][m.x].type===7),g=c.filter(m=>e.cells[m.y][m.x].type!==0&&e.cells[m.y][m.x].type!==7),x=[];for(let m=0;m<n.length;m++)this.isHexagonAdjacentToRegion(e,n[m],c)&&x.push(m);let p=[];for(let m=0;m<s.length;m++)this.isNodeHexagonAdjacentToRegion(e,s[m],c)&&p.push(m);let b=this.getPossibleErasures(e,c,d,g,x,p);if(b.length===0){o=!1;let m=this.getBestEffortErasures(e,c,d,g,x,p);l.push([m])}else b.sort((m,C)=>{let P=m.invalidatedCells.length+m.invalidatedHexagons.length+m.invalidatedNodeHexagons.length,E=C.invalidatedCells.length+C.invalidatedHexagons.length+C.invalidatedNodeHexagons.length;if(P!==E)return P-E;let v=m.invalidatedHexagons.length+m.invalidatedNodeHexagons.length,S=C.invalidatedHexagons.length+C.invalidatedNodeHexagons.length;return v!==S?S-v:m.invalidatedCells.length-C.invalidatedCells.length}),l.push(b)}if(o){let a=this.findGlobalAssignment(l,n.length,s.length);if(a)return{isValid:!0,invalidatedCells:a.invalidatedCells,invalidatedEdges:a.invalidatedHexIndices.map(c=>n[c]),invalidatedNodes:a.invalidatedNodeHexIndices.map(c=>s[c])}}let i=[],u=[],y=new Set,f=new Set;for(let a of l){let c=a[0];i.push(...c.errorCells),u.push(...c.invalidatedCells);for(let d of c.invalidatedHexagons)y.add(d);for(let d of c.invalidatedNodeHexagons)f.add(d)}let r=[];for(let a=0;a<n.length;a++)y.has(a)||r.push(n[a]);let h=[];for(let a=0;a<s.length;a++)f.has(a)||h.push(s[a]);return{isValid:!1,errorReason:"Constraints failed",errorCells:i,errorEdges:r,errorNodes:h,invalidatedCells:u,invalidatedEdges:Array.from(y).map(a=>n[a]),invalidatedNodes:Array.from(f).map(a=>s[a])}}isHexagonAdjacentToRegion(e,t,n){let s=new Set(n.map(l=>`${l.x},${l.y}`));if(t.type==="h"){if(t.r>0&&s.has(`${t.c},${t.r-1}`)||t.r<e.rows&&s.has(`${t.c},${t.r}`))return!0}else if(t.c>0&&s.has(`${t.c-1},${t.r}`)||t.c<e.cols&&s.has(`${t.c},${t.r}`))return!0;return!1}isNodeHexagonAdjacentToRegion(e,t,n){let s=new Set(n.map(o=>`${o.x},${o.y}`)),l=[{x:t.x-1,y:t.y-1},{x:t.x,y:t.y-1},{x:t.x-1,y:t.y},{x:t.x,y:t.y}];for(let o of l)if(o.x>=0&&o.x<e.cols&&o.y>=0&&o.y<e.rows&&s.has(`${o.x},${o.y}`))return!0;return!1}getPossibleErasures(e,t,n,s,l,o){let i=[],u=n.length;if(u===0)return this.getRegionErrors(e,t,[]).length===0&&l.length===0&&o.length===0&&i.push({invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!0,errorCells:[]}),i;let y=[...s.map(r=>({type:"cell",pos:r})),...l.map(r=>({type:"hex",index:r})),...o.map(r=>({type:"nodeHex",index:r}))],f=this.getRegionErrors(e,t,[]).length===0&&l.length===0&&o.length===0;for(let r=0;r<=u;r++){let h=this.getNCombinations(n,r);for(let a of h){let c=new Set(a.map(g=>`${g.x},${g.y}`)),d=n.filter(g=>!c.has(`${g.x},${g.y}`));for(let g=0;g<=y.length;g++){if(d.length!==r+g)continue;let x=this.getNCombinations(y,g);for(let p of x){let b=p.filter(v=>v.type==="cell").map(v=>v.pos),m=p.filter(v=>v.type==="hex").map(v=>v.index),C=p.filter(v=>v.type==="nodeHex").map(v=>v.index);if(this.getRegionErrors(e,t,[...b,...a]).length===0){let v=!0;if(f)g>0&&(v=!1);else for(let S=0;S<p.length;S++){let T=[...p.slice(0,S),...p.slice(S+1)],M=T.filter(z=>z.type==="cell").map(z=>z.pos),R=new Set(T.filter(z=>z.type==="hex").map(z=>z.index)),I=new Set(T.filter(z=>z.type==="nodeHex").map(z=>z.index)),B=l.every(z=>R.has(z)),A=o.every(z=>I.has(z));if(this.getRegionErrors(e,t,M).length===0&&B&&A){v=!1;break}}v&&i.push({invalidatedCells:[...b,...a],invalidatedHexagons:m,invalidatedNodeHexagons:C,isValid:!0,errorCells:[]})}}}}}return i}getBestEffortErasures(e,t,n,s,l,o){let i=this.getRegionErrors(e,t,[]);if(i.length===0&&l.length===0&&o.length===0)return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:[...n]};if(n.length>0){let f=[...s.map(c=>({type:"cell",pos:c})),...l.map(c=>({type:"hex",index:c})),...o.map(c=>({type:"nodeHex",index:c}))],r=null,h=1/0,a=c=>{let d=[],g=[],x=[],p=0;for(let T of c)p<n.length&&(T.type==="cell"?d.push(T.pos):T.type==="hex"?g.push(T.index):x.push(T.index),p++);let b=n.length-p,m=Math.floor(b/2),C=n.slice(p,p+m);p+=m*2;let P=this.getRegionErrors(e,t,[...d,...C]);for(let T=p;T<n.length;T++)P.push(n[T]);let E=Math.max(0,l.length-g.length),v=Math.max(0,o.length-x.length),S=P.length+E+v;S<h&&(h=S,r={invalidatedCells:[...d,...C],invalidatedHexagons:g,invalidatedNodeHexagons:x,isValid:!1,errorCells:P})};a([...i.map(c=>({type:"cell",pos:c})),...l.map(c=>({type:"hex",index:c})),...o.map(c=>({type:"nodeHex",index:c}))]),a(f);for(let c of i)a([{type:"cell",pos:c}]);if(r)return r}let y=[...i,...n];return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:y}}getNCombinations(e,t){let n=[],s=(l,o)=>{if(o.length===t){n.push([...o]);return}for(let i=l;i<e.length;i++)o.push(e[i]),s(i+1,o),o.pop()};return s(0,[]),n}checkRegionValid(e,t,n){return this.getRegionErrors(e,t,n).length===0}getRegionErrors(e,t,n){let s=new Set(n.map(h=>`${h.x},${h.y}`)),l=new Map,o=new Map,i=new Set,u=new Set,y=[],f=[];for(let h of t){if(s.has(`${h.x},${h.y}`))continue;let a=e.cells[h.y][h.x];if(a.type===0)continue;let c=a.color;c!==W.None&&(l.set(c,(l.get(c)||0)+1),o.has(c)||o.set(c,[]),o.get(c).push(h)),a.type===1?u.add(c):a.type===2?i.add(c):a.type===3||a.type===4?a.shape&&y.push({shape:a.shape,rotatable:a.type===4,pos:h}):(a.type===5||a.type===6)&&a.shape&&f.push({shape:a.shape,rotatable:a.type===6,pos:h})}let r=[];if(u.size>1)for(let h of t)s.has(`${h.x},${h.y}`)||e.cells[h.y][h.x].type===1&&r.push(h);for(let h of i)if(l.get(h)!==2){let a=o.get(h)||[];for(let c of a)e.cells[c.y][c.x].type===2&&r.push(c)}if((y.length>0||f.length>0)&&!this.checkTetrisConstraint(e,t,y.map(h=>({shape:h.shape,rotatable:h.rotatable})),f.map(h=>({shape:h.shape,rotatable:h.rotatable})))){for(let h of y)r.push(h.pos);for(let h of f)r.push(h.pos)}return r}findGlobalAssignment(e,t,n){let s=e.length,l=new Array(t).fill(0),o=new Array(n).fill(0),i=[],u=[],y=[],f=r=>{if(r===s)return l.every(h=>h===1)&&o.every(h=>h===1);for(let h of e[r]){let a=!0;for(let c of h.invalidatedHexagons)if(l[c]>0){a=!1;break}if(a){for(let c of h.invalidatedNodeHexagons)if(o[c]>0){a=!1;break}}if(a){for(let c of h.invalidatedHexagons)l[c]++,u.push(c);for(let c of h.invalidatedNodeHexagons)o[c]++,y.push(c);if(i.push(...h.invalidatedCells),f(r+1))return!0;for(let c of h.invalidatedHexagons)l[c]--,u.pop();for(let c of h.invalidatedNodeHexagons)o[c]--,y.pop();for(let c=0;c<h.invalidatedCells.length;c++)i.pop()}}return!1};return f(0)?{invalidatedCells:i,invalidatedHexIndices:u,invalidatedNodeHexIndices:y}:null}checkTetrisConstraint(e,t,n,s=[]){let l=n.reduce((v,S)=>v+this.getShapeArea(S.shape),0),o=s.reduce((v,S)=>v+this.getShapeArea(S.shape),0),i=l-o;if(i<0||i!==0&&i!==t.length)return!1;let u=e.rows,y=e.cols;this.tetrisCache.size>1e4&&this.tetrisCache.clear();let f=new Uint8Array(u*y);for(let v of t)f[v.y*y+v.x]=1;let r=(v,S)=>`${this.getShapeKey(v.shape)}-${v.rotatable}-${S}`,h=[...n.map(v=>r(v,1)),...s.map(v=>r(v,-1))].sort().join("|"),a=`${u}x${y}:${f.join("")}:${h}`;if(this.tetrisCache.has(a))return this.tetrisCache.get(a);let c=new Int8Array(u*y);if(i>0)for(let v=0;v<f.length;v++)c[v]=f[v];let d=new Int8Array(u*y),g=[],x=[...n.map(v=>({...v,sign:1})),...s.map(v=>({...v,sign:-1}))];for(let v of x){let S=v.rotatable?this.getAllRotations(v.shape):[v.shape],T=this.getShapeKey(S[0]),M=g.find(R=>R.sign===v.sign&&(v.rotatable?R.rotations.length>1:R.rotations.length===1)&&this.getShapeKey(R.rotations[0].shape)===T);M?M.count++:g.push({rotations:S.map(R=>({shape:R,h:R.length,w:R[0].length})),sign:v.sign,area:this.getShapeArea(v.shape),count:1})}g.sort((v,S)=>S.sign-v.sign||S.area-v.area);let p=i>0?t.length:0,b=0,m=l,C=o,P=(v,S,T)=>{if(p>m||b>C)return!1;if(v===g.length)return p===0&&b===0;let M=g[v],R=S+1,I=R===M.count;M.sign===1?m-=M.area:C-=M.area;for(let B of M.rotations){let A=B.h,z=B.w,w=S===0?0:T;for(let N=w;N<=u*y-(A>0?(A-1)*y+z:0);N++){let H=Math.floor(N/y),K=N%y;if(H>u-A||K>y-z)continue;let F=!0,Q=[];for(let $=0;$<A;$++){for(let U=0;U<z;U++)if(B.shape[$][U]){let G=(H+$)*y+(K+U);M.sign===1?d[G]<c[G]?p--:b++:d[G]<=c[G]?p++:b--,d[G]+=M.sign,Q.push(G),d[G]<0&&(F=!1),M.sign===1&&d[G]>1+o&&(F=!1)}if(!F)break}if(F){if(I){if(P(v+1,0,0)){for(let $ of Q)d[$]-=M.sign,M.sign===1?d[$]<c[$]?p++:b--:d[$]<=c[$]?p--:b++;return M.sign===1?m+=M.area:C+=M.area,!0}}else if(P(v,R,N)){for(let $ of Q)d[$]-=M.sign,M.sign===1?d[$]<c[$]?p++:b--:d[$]<=c[$]?p--:b++;return M.sign===1?m+=M.area:C+=M.area,!0}}for(let $ of Q)d[$]-=M.sign,M.sign===1?d[$]<c[$]?p++:b--:d[$]<=c[$]?p--:b++}}return M.sign===1?m+=M.area:C+=M.area,!1},E=P(0,0,0);return this.tetrisCache.set(a,E),E}getShapeArea(e){let t=0;for(let n of e)for(let s of n)s&&t++;return t}getShapeKey(e){return JSON.stringify(e)}getAllRotations(e){let t=[],n=new Set,s=e;for(let l=0;l<4;l++){let o=this.getShapeKey(s);n.has(o)||(t.push(s),n.add(o)),s=this.rotate90(s)}return t}rotate90(e){let t=e.length,n=e[0].length,s=Array.from({length:n},()=>Array(t).fill(0));for(let l=0;l<t;l++)for(let o=0;o<n;o++)s[o][t-1-l]=e[l][o];return s}calculateRegions(e,t,n=[],s){let l=[],o=e.rows,i=e.cols,u=new Uint8Array(o*i),y=new Uint8Array((o+1)*i),f=new Uint8Array(o*(i+1)),r=(a,c)=>{a.x===c.x?f[Math.min(a.y,c.y)*(i+1)+a.x]=1:y[a.y*i+Math.min(a.x,c.x)]=1};for(let a=0;a<t.length-1;a++)r(t[a],t[a+1]);for(let a=0;a<n.length-1;a++)r(n[a],n[a+1]);for(let a=0;a<=o;a++)for(let c=0;c<i;c++)e.hEdges[a][c].type===2&&(y[a*i+c]=1);for(let a=0;a<o;a++)for(let c=0;c<=i;c++)e.vEdges[a][c].type===2&&(f[a*(i+1)+c]=1);let h=s||this.getExternalCells(e);for(let a=0;a<o;a++)for(let c=0;c<i;c++){let d=a*i+c;if(u[d]||h&&h.has(`${c},${a}`))continue;let g=[],x=[d];u[d]=1;let p=0;for(;p<x.length;){let b=x[p++],m=b%i,C=Math.floor(b/i);if(g.push({x:m,y:C}),C>0&&!y[C*i+m]){let P=(C-1)*i+m;!u[P]&&(!h||!h.has(`${m},${C-1}`))&&(u[P]=1,x.push(P))}if(C<o-1&&!y[(C+1)*i+m]){let P=(C+1)*i+m;!u[P]&&(!h||!h.has(`${m},${C+1}`))&&(u[P]=1,x.push(P))}if(m>0&&!f[C*(i+1)+m]){let P=C*i+(m-1);!u[P]&&(!h||!h.has(`${m-1},${C}`))&&(u[P]=1,x.push(P))}if(m<i-1&&!f[C*(i+1)+(m+1)]){let P=C*i+(m+1);!u[P]&&(!h||!h.has(`${m+1},${C}`))&&(u[P]=1,x.push(P))}}l.push(g)}return l}getExternalCells(e){let t=new Set,n=[];for(let s=0;s<e.cols;s++)e.hEdges[0][s].type===2&&(t.has(`${s},0`)||(t.add(`${s},0`),n.push({x:s,y:0}))),e.hEdges[e.rows][s].type===2&&(t.has(`${s},${e.rows-1}`)||(t.add(`${s},${e.rows-1}`),n.push({x:s,y:e.rows-1})));for(let s=0;s<e.rows;s++)e.vEdges[s][0].type===2&&(t.has(`0,${s}`)||(t.add(`0,${s}`),n.push({x:0,y:s}))),e.vEdges[s][e.cols].type===2&&(t.has(`${e.cols-1},${s}`)||(t.add(`${e.cols-1},${s}`),n.push({x:e.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),l=[{nx:s.x,ny:s.y-1,edge:e.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:e.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:e.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:e.vEdges[s.y][s.x+1]}];for(let o of l)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return t}getSymmetricalPoint(e,t){let n=e.symmetry||0;return n===1?{x:e.cols-t.x,y:t.y}:n===2?{x:t.x,y:e.rows-t.y}:n===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getSymmetricalPointIndex(e,t){let n=e.cols+1,s=Math.floor(t/n),l=t%n,o=e.symmetry||0,i=s,u=l;return o===1?u=e.cols-l:o===2?i=e.rows-s:o===3&&(u=e.cols-l,i=e.rows-s),i*n+u}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}calculateDifficulty(e){let t=e.rows,n=e.cols,s=n+1,l=(t+1)*s,o=Array.from({length:l},()=>[]),i=[],u=[],y=new Map,f=0,r=new Set,h=new Set;for(let w=0;w<=t;w++)for(let N=0;N<=n;N++){let H=w*s+N;if(e.nodes[w][N].type===1&&i.push(H),e.nodes[w][N].type===2&&u.push(H),(e.nodes[w][N].type===3||e.nodes[w][N].type===4||e.nodes[w][N].type===5)&&(y.set(`n${N},${w}`,f++),h.add(H)),N<n){let K=H+1,F=e.hEdges[w][N].type,Q=F===3||F===4||F===5,$=F===1||F===2;o[H].push({next:K,hexType:F,isBroken:$}),o[K].push({next:H,hexType:F,isBroken:$}),Q&&(y.set(`eh${N},${w}`,f++),r.add(this.getEdgeKey({x:N,y:w},{x:N+1,y:w})))}if(w<t){let K=H+s,F=e.vEdges[w][N].type,Q=F===3||F===4||F===5,$=F===1||F===2;o[H].push({next:K,hexType:F,isBroken:$}),o[K].push({next:H,hexType:F,isBroken:$}),Q&&(y.set(`ev${N},${w}`,f++),r.add(this.getEdgeKey({x:N,y:w},{x:N,y:w+1})))}}let a={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},c=f,d=new Set,g=Math.max(1e3,t*n*200),x=this.getExternalCells(e),p=!1;for(let w=0;w<t;w++){for(let N=0;N<n;N++)if(e.cells[w][N].type!==0){p=!0;break}if(p)break}this.tetrisCache.clear();for(let w of i){let N=e.cols+1,H=Math.floor(w/N),K=w%N,F=0n,Q=e.nodes[H][K].type;(Q===3||Q===4)&&(F|=1n<<BigInt(y.get(`n${K},${H}`)));let $=e.symmetry||0;if($!==0){let G=this.getSymmetricalPointIndex(e,w),O=Math.floor(G/N),L=G%N,X=e.nodes[O][L].type;(X===3||X===5)&&(F|=1n<<BigInt(y.get(`n${L},${O}`)))}let U=1n<<BigInt(w);if($!==0){let G=this.getSymmetricalPointIndex(e,w);if(G===w)continue;U|=1n<<BigInt(G)}this.exploreSearchSpace(e,w,U,[w],F,c,o,u,d,a,g,x,p,y)}if(a.solutions===0)return 0;let b=r.size+h.size,m=new Set;r.size>0&&m.add(999);let C=0,P=0;for(let w=0;w<t;w++)for(let N=0;N<n;N++){let H=e.cells[w][N];H.type!==0&&(b++,m.add(H.type),H.type===3?C++:H.type===4&&(C++,P++))}let E=a.branchingPoints/(a.totalNodesVisited||1),v=Math.log10(a.totalNodesVisited+1),S=(E*10+v*1.5)/(Math.log2(a.solutions+1)*.5+1);S-=r.size*.05,S+=h.size*.12,C>0&&(S+=(C-P)*.5,S+=P*.2);let T=0,M=0;for(let w=0;w<t;w++)for(let N=0;N<n;N++){let H=e.cells[w][N];H.type===5?T++:H.type===6&&(T++,M++)}T>0&&(S+=(T-M)*.6,S+=M*.3);let R=t*n,I=b/R,B=I<.25?Math.pow(I/.25,4):1,A=m.size<=1?.5:1;S*=B*A;let z=Math.log2(R)/5;return S*=z,Math.max(.01,Math.min(1,S/4))}exploreSearchSpace(e,t,n,s,l,o,i,u,y,f,r,h,a=!0,c){if(f.totalNodesVisited++,f.maxDepth=Math.max(f.maxDepth,s.length),f.totalNodesVisited>r)return;let d=e.symmetry||0;if(u.includes(t)){let p=0,b=l;for(;b>0n;)b&1n&&p++,b>>=1n;if(p===o){let m=s.map(E=>({x:E%(e.cols+1),y:Math.floor(E/(e.cols+1))})),C={points:m};if(d!==0){let E=this.getSymmetricalPointIndex(e,t),v=e.cols+1;if(e.nodes[Math.floor(E/v)][E%v].type!==2)return}let P=d!==0?m.map(E=>this.getSymmetricalPoint(e,E)):[];if(a){let E=this.validateFast(e,m,P,h);if(E.isValid){let v=this.getFingerprint(e,m,P,E.regions,h);y.has(v)||(y.add(v),f.solutions++)}}else{let E=this.getFingerprint(e,m,P,void 0,h);y.has(E)||(y.add(E),f.solutions++)}}return}if(!this.canReachEndOptimized(t,n,i,u)){f.backtracks++;return}let g=[];for(let p of i[t]){if(p.isBroken||n&1n<<BigInt(p.next))continue;if(d!==0){let m=this.getSymmetricalPointIndex(e,t),C=this.getSymmetricalPointIndex(e,p.next);if(p.next===C||t===C&&p.next===m)continue}let b=!0;for(let m of i[t])if(m.hexType===3||m.hexType===4){let P=s.length>=2&&m.next===s[s.length-2],E=m.next===p.next;if(!P&&!E){b=!1;break}}if(b){if(d!==0){let m=this.getSymmetricalPointIndex(e,t),C=this.getSymmetricalPointIndex(e,p.next);for(let P of i[m])if(P.hexType===3||P.hexType===5){let v=s.length>=2?this.getSymmetricalPointIndex(e,s[s.length-2]):-1,S=P.next===v,T=P.next===C;if(!S&&!T){b=!1;break}}}b&&g.push(p)}}if(g.length>1&&f.branchingPoints++,e.rows*e.cols>30)for(let p=g.length-1;p>0;p--){let b=this.rng?this.rng.next():Math.random(),m=Math.floor(b*(p+1));[g[p],g[m]]=[g[m],g[p]]}let x=e.cols+1;for(let p of g){let b=l,m=Math.floor(p.next/x),C=p.next%x,P=e.nodes[m][C].type;(P===3||P===4)&&(b|=1n<<BigInt(c.get(`n${C},${m}`)));let E=s[s.length-1],v=Math.floor(E/x),S=E%x;if(v===m){let M=Math.min(S,C);(p.hexType===3||p.hexType===4)&&(b|=1n<<BigInt(c.get(`eh${M},${m}`)))}else{let M=Math.min(v,m);(p.hexType===3||p.hexType===4)&&(b|=1n<<BigInt(c.get(`ev${C},${M}`)))}if(d!==0){let M=this.getSymmetricalPointIndex(e,p.next),R=Math.floor(M/x),I=M%x,B=e.nodes[R][I].type;(B===3||B===5)&&(b|=1n<<BigInt(c.get(`n${I},${R}`)));let A=this.getSymmetricalPointIndex(e,E),z=Math.floor(A/x),w=A%x;if(z===R){let N=Math.min(w,I),H=e.hEdges[R][N].type;(H===3||H===5)&&(b|=1n<<BigInt(c.get(`eh${N},${R}`)))}else{let N=Math.min(z,R),H=e.vEdges[N][I].type;(H===3||H===5)&&(b|=1n<<BigInt(c.get(`ev${I},${N}`)))}}s.push(p.next);let T=n|1n<<BigInt(p.next);if(d!==0){let M=this.getSymmetricalPointIndex(e,p.next);T|=1n<<BigInt(M)}if(this.exploreSearchSpace(e,p.next,T,s,b,o,i,u,y,f,r,h,a,c),s.pop(),f.totalNodesVisited>r)return}}countSolutions(e,t=100){let n=e.rows,s=e.cols,l=s+1,o=(n+1)*l,i=Array.from({length:o},()=>[]),u=[],y=[],f=new Map,r=0;for(let g=0;g<=n;g++)for(let x=0;x<=s;x++){let p=g*l+x;if(e.nodes[g][x].type===1&&u.push(p),e.nodes[g][x].type===2&&y.push(p),(e.nodes[g][x].type===3||e.nodes[g][x].type===4||e.nodes[g][x].type===5)&&f.set(`n${x},${g}`,r++),x<s){let b=p+1,m=e.hEdges[g][x].type,C=m===3||m===4||m===5,P=m===1||m===2;i[p].push({next:b,hexType:m,isBroken:P}),i[b].push({next:p,hexType:m,isBroken:P}),C&&f.set(`eh${x},${g}`,r++)}if(g<n){let b=p+l,m=e.vEdges[g][x].type,C=m===3||m===4||m===5,P=m===1||m===2;i[p].push({next:b,hexType:m,isBroken:P}),i[b].push({next:p,hexType:m,isBroken:P}),C&&f.set(`ev${x},${g}`,r++)}}let h=new Set,a=r,c=this.getExternalCells(e),d=!1;for(let g=0;g<n;g++){for(let x=0;x<s;x++)if(e.cells[g][x].type!==0){d=!0;break}if(d)break}this.tetrisCache.clear();for(let g of u){let x=e.cols+1,p=Math.floor(g/x),b=g%x,m=0n,C=e.nodes[p][b].type;(C===3||C===4)&&(m|=1n<<BigInt(f.get(`n${b},${p}`)));let P=e.symmetry||0;if(P!==0){let v=this.getSymmetricalPointIndex(e,g),S=Math.floor(v/x),T=v%x,M=e.nodes[S][T].type;(M===3||M===5)&&(m|=1n<<BigInt(f.get(`n${T},${S}`)))}let E=1n<<BigInt(g);if(P!==0){let v=this.getSymmetricalPointIndex(e,g);if(v===g)continue;E|=1n<<BigInt(v)}this.findPathsOptimized(e,g,E,[g],m,a,i,y,h,t,c,d,f)}return h.size}findPathsOptimized(e,t,n,s,l,o,i,u,y,f,r,h=!0,a){if(y.size>=f)return;let c=e.symmetry||0;if(u.includes(t)){let d=0,g=l;for(;g>0n;)g&1n&&d++,g>>=1n;if(d===o){let x=s.map(b=>({x:b%(e.cols+1),y:Math.floor(b/(e.cols+1))}));if(c!==0){let b=this.getSymmetricalPointIndex(e,t),m=e.cols+1;if(e.nodes[Math.floor(b/m)][b%m].type!==2)return}let p=c!==0?x.map(b=>this.getSymmetricalPoint(e,b)):[];if(!h)y.add(this.getFingerprint(e,x,p,void 0,r));else{let b=this.validateFast(e,x,p,r);b.isValid&&y.add(this.getFingerprint(e,x,p,b.regions,r))}}return}if(this.canReachEndOptimized(t,n,i,u))for(let d of i[t]){if(d.isBroken||n&1n<<BigInt(d.next))continue;if(c!==0){let S=this.getSymmetricalPointIndex(e,t),T=this.getSymmetricalPointIndex(e,d.next);if(d.next===T||t===T&&d.next===S)continue}let g=!0;for(let S of i[t])if(S.hexType===3||S.hexType===4){let M=s.length>=2&&S.next===s[s.length-2],R=S.next===d.next;if(!M&&!R){g=!1;break}}if(!g)continue;if(c!==0){let S=this.getSymmetricalPointIndex(e,t),T=this.getSymmetricalPointIndex(e,d.next);for(let M of i[S])if(M.hexType===3||M.hexType===5){let I=s.length>=2?this.getSymmetricalPointIndex(e,s[s.length-2]):-1,B=M.next===I,A=M.next===T;if(!B&&!A){g=!1;break}}}if(!g)continue;let x=e.cols+1,p=l,b=Math.floor(d.next/x),m=d.next%x,C=e.nodes[b][m].type;(C===3||C===4)&&(p|=1n<<BigInt(a.get(`n${m},${b}`)));let P=Math.floor(t/x),E=t%x;if(P===b){let S=Math.min(E,m);(d.hexType===3||d.hexType===4)&&(p|=1n<<BigInt(a.get(`eh${S},${b}`)))}else{let S=Math.min(P,b);(d.hexType===3||d.hexType===4)&&(p|=1n<<BigInt(a.get(`ev${m},${S}`)))}if(c!==0){let S=this.getSymmetricalPointIndex(e,d.next),T=Math.floor(S/x),M=S%x,R=e.nodes[T][M].type;(R===3||R===5)&&(p|=1n<<BigInt(a.get(`n${M},${T}`)));let I=this.getSymmetricalPointIndex(e,t),B=Math.floor(I/x),A=I%x;if(B===T){let z=Math.min(A,M),w=e.hEdges[T][z].type;(w===3||w===5)&&(p|=1n<<BigInt(a.get(`eh${z},${T}`)))}else{let z=Math.min(B,T),w=e.vEdges[z][M].type;(w===3||w===5)&&(p|=1n<<BigInt(a.get(`ev${M},${z}`)))}}s.push(d.next);let v=n|1n<<BigInt(d.next);if(c!==0){let S=this.getSymmetricalPointIndex(e,d.next);v|=1n<<BigInt(S)}if(this.findPathsOptimized(e,d.next,v,s,p,o,i,u,y,f,r,h,a),s.pop(),y.size>=f)return}}canReachEndOptimized(e,t,n,s){let l=[e],o=t,i=0;for(;i<l.length;){let u=l[i++];if(s.includes(u))return!0;for(let y of n[u])!y.isBroken&&!(o&1n<<BigInt(y.next))&&(o|=1n<<BigInt(y.next),l.push(y.next))}return!1}getFingerprint(e,t,n,s,l){let i=(s||this.calculateRegions(e,t,n,l)).map(y=>{let f="",r=[];for(let h of y){let a=e.cells[h.y][h.x];a.type!==0&&r.push(a.type<<8|a.color)}r.sort((h,a)=>h-a);for(let h of r)f+=h.toString(36)+",";return f}).sort(),u="";for(let y of i)y.length>0&&(u+=y+"|");return u||"empty"}};var ae=class{isWorker;TETRIS_SHAPES_WITH_ROTATIONS=[];rng=null;constructor(){this.isWorker=typeof self<"u"&&"postMessage"in self&&!("document"in self);for(let e of this.TETRIS_SHAPES)this.TETRIS_SHAPES_WITH_ROTATIONS.push(this.getAllRotations(e))}stringToSeed(e){try{if(/^[0-9a-fA-F]+$/.test(e))return BigInt("0x"+e)}catch{}let t=0n;for(let n=0;n<e.length;n++)t=(t<<5n)-t+BigInt(e.charCodeAt(n));return t}generate(e,t,n={}){let s=n.rngType??0,l=n.seed;l||(l=Math.floor(Math.random()*4294967295).toString(16));let o=l,i=this.stringToSeed(l),u=n.difficulty??.5,y=new se,f=null,r=-1,h=e*t<=16,a=this.isWorker?e*t>30?120:h?250:150:e*t>30?80:h?200:100,c=this.isWorker?8:h?12:6,d=n.symmetry||0,g={x:0,y:e},x={x:t,y:0};d===1?x={x:0,y:0}:d===2?x={x:t,y:e}:d===3&&(x={x:t,y:e});let p=null,b=null,m=null;for(let C=0;C<a;C++){let P=(i^0x5deece66dn)+0xbn;if(this.rng=ce(s,i^0x5deece66dn),y.setRng(this.rng),C%c===0){p=this.generateRandomPath(new te(e,t),g,x,n.pathLength,d);let M=new te(e,t),R=d!==0?p.map(I=>this.getSymmetricalPoint(M,I,d)):[];b=this.calculateRegions(M,p,R),m=b.map(I=>this.getRegionBoundaryEdges(M,I,p,R))}let E=this.generateFromPath(e,t,p,n,b,m);if(!y.validate(E,{points:p}).isValid){i=P;continue}if(!this.checkAllRequestedConstraintsPresent(E,n)){i=P;continue}let S=y.calculateDifficulty(E);if(S===0){i=P;continue}let T=Math.abs(S-u);if((f===null||T<Math.abs(r-u))&&(r=S,f=E,f.seed=o),u>.8&&S>.8){f.seed=o;break}if(T<.01){f.seed=o;break}i=P}if(!f){for(let E=0;E<50;E++){this.rng=ce(s,i),y.setRng(this.rng);let v=this.generateRandomPath(new te(e,t),g,x,n.pathLength,d),S=this.generateFromPath(e,t,v,n);if(y.validate(S,{points:v}).isValid)return S.seed=o,S;i=(i^0x5deece66dn)+0xbn}this.rng=ce(s,i),y.setRng(this.rng);let C=this.generateRandomPath(new te(e,t),g,x,n.pathLength,d),P=this.generateFromPath(e,t,C,n);return P.seed=o,P}return f}generateFromPath(e,t,n,s,l,o){let i=new te(e,t),u=s.symmetry||0;i.symmetry=u;let y={x:0,y:e},f={x:t,y:0};if(u===1?f={x:0,y:0}:u===2?f={x:t,y:e}:u===3&&(f={x:t,y:e}),i.nodes[y.y][y.x].type=1,i.nodes[f.y][f.x].type=2,u!==0){let h=this.getSymmetricalPoint(i,y,u),a=this.getSymmetricalPoint(i,f,u);i.nodes[h.y][h.x].type=1,i.nodes[a.y][a.x].type=2}let r=u!==0?n.map(h=>this.getSymmetricalPoint(i,h,u)):[];return this.applyConstraintsBasedOnPath(i,n,s,r,l,o),s.useBrokenEdges&&this.applyBrokenEdges(i,n,s),this.cleanGrid(i),i}generateRandomPath(e,t,n,s,l=0){if(s===void 0)return this.generateSingleRandomPath(e,t,n,void 0,l);let o=e.rows+e.cols,i=(e.rows+1)*(e.cols+1)-1,u=o+s*(i-o),y=[],f=1/0,r=e.rows*e.cols>30?30:50;for(let h=0;h<r;h++){let a=this.generateSingleRandomPath(e,t,n,s,l);if(a.length===0)continue;let c=a.length-1,d=Math.abs(c-u);if(d<f&&(f=d,y=a),f<=2)break}return y}generateSingleRandomPath(e,t,n,s,l=0){let o=new Set,i=[],u=0,y=e.rows*e.cols*200,f=r=>{if(u++,u>y)return!1;o.add(`${r.x},${r.y}`);let h=this.getSymmetricalPoint(e,r,l);if(o.add(`${h.x},${h.y}`),i.push(r),r.x===n.x&&r.y===n.y)return!0;let a=this.getValidNeighbors(e,r,o);l!==0&&(a=a.filter(c=>{let d=this.getSymmetricalPoint(e,c,l);if(d.x<0||d.x>e.cols||d.y<0||d.y>e.rows||o.has(`${d.x},${d.y}`)||c.x===d.x&&c.y===d.y)return!1;let g=this.getEdgeKey(r,c),x=this.getEdgeKey(h,d);return g!==x})),s!==void 0?a.sort((c,d)=>{let g=Math.abs(c.x-n.x)+Math.abs(c.y-n.y),x=Math.abs(d.x-n.x)+Math.abs(d.y-n.y);return(g-x)*(1-s*2)+(this.rng.next()-.5)*1.5}):this.shuffleArray(a);for(let c of a)if(f(c))return!0;return i.pop(),o.delete(`${r.x},${r.y}`),o.delete(`${h.x},${h.y}`),!1};return f(t),i}getValidNeighbors(e,t,n){let s=[],l=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of l){let i=t.x+o.x,u=t.y+o.y;i>=0&&i<=e.cols&&u>=0&&u<=e.rows&&(n.has(`${i},${u}`)||s.push({x:i,y:u}))}return s}applyBrokenEdges(e,t,n){let s=n.complexity??.5,l=n.symmetry??0,o=new Set;for(let r=0;r<t.length-1;r++)if(o.add(this.getEdgeKey(t[r],t[r+1])),l!==0){let h=this.getSymmetricalPoint(e,t[r],l),a=this.getSymmetricalPoint(e,t[r+1],l);o.add(this.getEdgeKey(h,a))}let i=[];for(let r=0;r<=e.rows;r++)for(let h=0;h<e.cols;h++){let a={x:h,y:r},c={x:h+1,y:r};o.has(this.getEdgeKey(a,c))||i.push({type:"h",r,c:h,p1:a,p2:c})}for(let r=0;r<e.rows;r++)for(let h=0;h<=e.cols;h++){let a={x:h,y:r},c={x:h,y:r+1};o.has(this.getEdgeKey(a,c))||i.push({type:"v",r,c:h,p1:a,p2:c})}this.shuffleArray(i);let u=Math.max(1,Math.floor(s*(e.rows*e.cols)/4)),y=0;for(let r of i){if(y>=u)break;r.type==="h"?e.hEdges[r.r][r.c].type=1:e.vEdges[r.r][r.c].type=1,y++}let f=!0;for(;f;){f=!1;for(let r=0;r<=e.rows;r++)for(let h=0;h<e.cols;h++)e.hEdges[r][h].type===1&&this.canBecomeAbsent(e,{type:"h",r,c:h})&&(e.hEdges[r][h].type=2,f=!0);for(let r=0;r<e.rows;r++)for(let h=0;h<=e.cols;h++)e.vEdges[r][h].type===1&&this.canBecomeAbsent(e,{type:"v",r,c:h})&&(e.vEdges[r][h].type=2,f=!0)}for(let r=0;r<=e.rows;r++)for(let h=0;h<=e.cols;h++){let a=[];if(h>0&&a.push({e:e.hEdges[r][h-1],type:"h",r,c:h-1}),h<e.cols&&a.push({e:e.hEdges[r][h],type:"h",r,c:h}),r>0&&a.push({e:e.vEdges[r-1][h],type:"v",r:r-1,c:h}),r<e.rows&&a.push({e:e.vEdges[r][h],type:"v",r,c:h}),a.length>0&&a.every(c=>c.e.type===1||c.e.type===2)&&a.every(c=>!this.isAdjacentToMark(e,c)))for(let c of a)c.e.type=2}}canBecomeAbsent(e,t){if(this.isAdjacentToMark(e,t))return!1;if(t.type==="h"){if(t.r===0||t.r===e.rows)return!0}else if(t.c===0||t.c===e.cols)return!0;let n=t.type==="h"?[{x:t.c,y:t.r},{x:t.c+1,y:t.r}]:[{x:t.c,y:t.r},{x:t.c,y:t.r+1}];for(let s of n){let l=[{type:"h",r:s.y,c:s.x-1},{type:"h",r:s.y,c:s.x},{type:"v",r:s.y-1,c:s.x},{type:"v",r:s.y,c:s.x}];for(let o of l)if(o.c>=0&&o.c<=e.cols&&o.r>=0&&o.r<=e.rows){if(o.type==="h"&&o.c<e.cols){if(e.hEdges[o.r][o.c].type===2)return!0}else if(o.type==="v"&&o.r<e.rows&&e.vEdges[o.r][o.c].type===2)return!0}}return!1}cleanGrid(e){let t=[];for(let o=0;o<=e.rows;o++)for(let i=0;i<=e.cols;i++)e.nodes[o][i].type===1&&t.push({x:i,y:o});let n=new Set,s=[...t];for(let o of t)n.add(`${o.x},${o.y}`);for(;s.length>0;){let o=s.shift(),i=[{nx:o.x,ny:o.y-1,edge:e.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:e.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:e.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:e.hEdges[o.y]?.[o.x]}];for(let u of i)u.edge&&u.edge.type!==2&&(n.has(`${u.nx},${u.ny}`)||(n.add(`${u.nx},${u.ny}`),s.push({x:u.nx,y:u.ny})))}for(let o=0;o<=e.rows;o++)for(let i=0;i<e.cols;i++)(!n.has(`${i},${o}`)||!n.has(`${i+1},${o}`))&&(e.hEdges[o][i].type=2);for(let o=0;o<e.rows;o++)for(let i=0;i<=e.cols;i++)(!n.has(`${i},${o}`)||!n.has(`${i},${o+1}`))&&(e.vEdges[o][i].type=2);let l=this.getExternalCells(e);for(let o of l){let[i,u]=o.split(",").map(Number);e.cells[u][i].type=0}}getExternalCells(e){let t=new Set,n=[];for(let s=0;s<e.cols;s++)e.hEdges[0][s].type===2&&(t.has(`${s},0`)||(t.add(`${s},0`),n.push({x:s,y:0}))),e.hEdges[e.rows][s].type===2&&(t.has(`${s},${e.rows-1}`)||(t.add(`${s},${e.rows-1}`),n.push({x:s,y:e.rows-1})));for(let s=0;s<e.rows;s++)e.vEdges[s][0].type===2&&(t.has(`0,${s}`)||(t.add(`0,${s}`),n.push({x:0,y:s}))),e.vEdges[s][e.cols].type===2&&(t.has(`${e.cols-1},${s}`)||(t.add(`${e.cols-1},${s}`),n.push({x:e.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),l=[{nx:s.x,ny:s.y-1,edge:e.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:e.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:e.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:e.vEdges[s.y][s.x+1]}];for(let o of l)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return t}isAdjacentToMark(e,t){if(t.type==="h"){if(t.r>0&&e.cells[t.r-1][t.c].type!==0||t.r<e.rows&&e.cells[t.r][t.c].type!==0)return!0}else if(t.c>0&&e.cells[t.r][t.c-1].type!==0||t.c<e.cols&&e.cells[t.r][t.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let t=0;t<e.rows;t++)for(let n=0;n<e.cols;n++){if(e.cells[t][n].type===0)continue;if([e.hEdges[t][n],e.hEdges[t+1][n],e.vEdges[t][n],e.vEdges[t][n+1]].every(l=>l.type===1||l.type===2))return!0}return!1}getSymmetricalPoint(e,t,n){return n===1?{x:e.cols-t.x,y:t.y}:n===2?{x:t.x,y:e.rows-t.y}:n===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,t,n,s=[],l,o){let i=n.complexity??.5,u=n.useHexagons??!0,y=n.useSquares??!0,f=n.useStars??!0,r=n.useTetris??!1,h=n.useTetrisNegative??!1,a=n.useEraser??!1,c=0,d=0,g=0,x=0,p=0,b=0,m=Math.floor(e.rows*e.cols*.6);if(u){let C=n.difficulty??.5,P=n.symmetry||0;for(let E=0;E<t.length-1;E++){let S=this.getValidNeighbors(e,t[E],new Set).length>2,T=i*(C<.4?.6:.3);if(S&&(T=C<.4?T*1:T*.5),this.rng.next()<T){let M=3,R=t[E],I=t[E+1];if(P!==0){let B=this.rng.next();B<.3?M=4:B<.6&&(M=5,R=this.getSymmetricalPoint(e,t[E],P),I=this.getSymmetricalPoint(e,t[E+1],P))}this.setEdgeHexagon(e,R,I,M),c++}}for(let E=0;E<t.length;E++){let v=t[E];if(e.nodes[v.y][v.x].type!==0||this.hasIncidentHexagonEdge(e,v))continue;let S=i*(C>.6?.15:.05);if(this.rng.next()<S){let T=3,M=v;if(P!==0){let R=this.rng.next();R<.3?T=4:R<.6&&(T=5,M=this.getSymmetricalPoint(e,v,P))}e.nodes[M.y][M.x].type=T,c++}}if(c===0&&t.length>=2){let E=Math.floor(this.rng.next()*(t.length-1)),v=n.symmetry||0,S=3,T=t[E],M=t[E+1];if(v!==0){let R=this.rng.next();R<.3?S=4:R<.6&&(S=5,T=this.getSymmetricalPoint(e,t[E],v),M=this.getSymmetricalPoint(e,t[E+1],v))}this.setEdgeHexagon(e,T,M,S)}}if(y||f||r||a){let C=l||this.calculateRegions(e,t,s),P=n.availableColors??[W.Black,W.White,W.Red,W.Blue],E=n.defaultColors??{},v=(I,B)=>{if(E[I]!==void 0)return E[I];let A=oe[I];return A&&E[A]!==void 0?E[A]:B},S=Array.from({length:C.length},(I,B)=>B);this.shuffleArray(S);let T=new Set,M={square:y,star:f,tetris:r,tetrisNegative:h,eraser:a},R=0;for(let I=0;I<S.length;I++){let B=S[I],A=C[B],z=S.length-I,w=M.square&&d===0||M.star&&g===0||M.tetris&&x===0||M.tetrisNegative&&R===0||M.eraser&&p===0,N=.2+i*.6;if(w&&z<=3?N=1:w&&z<=6&&(N=.7),this.rng.next()>N)continue;let H=[...A];this.shuffleArray(H);let K=new Set,F=P[Math.floor(this.rng.next()*P.length)];if(y&&T.size<2){let $=P.filter(U=>!T.has(U));$.length>0&&(F=$[Math.floor(this.rng.next()*$.length)])}let Q=y&&this.rng.next()<.5+i*.3;if(y&&d===0&&z<=2&&(Q=!0),y&&!f&&z<=2&&T.size<2&&d>0&&(Q=!0),Q&&H.length>0){let $=Math.min(H.length,Math.max(4,Math.floor(A.length/4))),U=Math.floor(this.rng.next()*($/2))+Math.ceil($/2);for(let G=0;G<U&&H.length!==0;G++){let O=H.pop();e.cells[O.y][O.x].type=1,e.cells[O.y][O.x].color=F,d++,T.add(F),K.add(F)}}if(r||h){let $=this.rng.next()<.1+i*.4;x===0&&z<=3&&($=!0),h&&R===0&&z<=2&&($=!0);let U=x===0&&z<=2?6:4,G=b+A.length<=m||w&&r&&x===0&&A.length<=30||w&&h&&R===0&&A.length<=30;if($&&H.length>0&&G){let O=A.length<=25?this.generateTiling(A,U,n):null;if(O){let L=[],X=.2+i*.3;if(h&&R===0&&z<=3&&(X=.9),h&&this.rng.next()<X){let k=n.difficulty??.5;if(this.rng.next()<.1&&H.length>=2){let _=!1;if(H.length>=3&&this.rng.next()<.8){let ee=this.rng.next()<.5,Z=1+Math.floor(this.rng.next()*2),J=this.TETRIS_SHAPES.filter(ne=>this.getShapeArea(ne)===Z),Y=J[Math.floor(this.rng.next()*J.length)],V=this.findStandardTriple(Y);V&&(ee?(O.push({shape:Y,displayShape:Y,isRotated:!this.isRotationallyInvariant(Y)&&this.rng.next()<k*.7,isNegative:!1}),O.push({shape:V.n,displayShape:V.n,isRotated:!this.isRotationallyInvariant(V.n)&&this.rng.next()<k*.7,isNegative:!1}),L.push({shape:V.p,displayShape:V.p,isRotated:!this.isRotationallyInvariant(V.p)&&this.rng.next()<k*.7,isNegative:!0})):(O.push({shape:V.p,displayShape:V.p,isRotated:!this.isRotationallyInvariant(V.p)&&this.rng.next()<k*.7,isNegative:!1}),L.push({shape:Y,displayShape:Y,isRotated:!this.isRotationallyInvariant(Y)&&this.rng.next()<k*.7,isNegative:!0}),L.push({shape:V.n,displayShape:V.n,isRotated:!this.isRotationallyInvariant(V.n)&&this.rng.next()<k*.7,isNegative:!0})),_=!0)}if(!_){let ee=3+Math.floor(this.rng.next()*2),Z=this.TETRIS_SHAPES.filter(J=>this.getShapeArea(J)===ee);if(this.shuffleArray(Z),Z.length>0){let J=Z[0],Y=Z[0];O.push({shape:J,displayShape:J,isRotated:!this.isRotationallyInvariant(J)&&this.rng.next()<k*.7,isNegative:!1}),L.push({shape:Y,displayShape:Y,isRotated:!this.isRotationallyInvariant(Y)&&this.rng.next()<k*.7,isNegative:!0})}}}else if(O.length>0){let _=this.rng.next()<.3?2:1;for(let ee=0;ee<_&&!(H.length<1);ee++){let Z=Math.floor(this.rng.next()*O.length),J=O[Z];if(J.isNegative)continue;let Y=!1;if(H.length>=2&&this.rng.next()<.2){let V=this.findStandardTriple(J.shape);if(V){let ne=this.findStandardTriple(V.p);ne&&(O[Z]={shape:ne.p,displayShape:ne.p,isRotated:!this.isRotationallyInvariant(ne.p)&&this.rng.next()<k*.7,isNegative:!1},L.push({shape:V.n,displayShape:V.n,isRotated:!this.isRotationallyInvariant(V.n)&&this.rng.next()<k*.7,isNegative:!0}),L.push({shape:ne.n,displayShape:ne.n,isRotated:!this.isRotationallyInvariant(ne.n)&&this.rng.next()<k*.7,isNegative:!0}),Y=!0)}}if(!Y){let V=this.findStandardTriple(J.shape);V&&(O.some(me=>!me.isNegative&&this.isSameShape(me.shape,V.n))||(O[Z]={shape:V.p,displayShape:V.p,isRotated:!this.isRotationallyInvariant(V.p)&&this.rng.next()<k*.7,isNegative:!1},L.push({shape:V.n,displayShape:V.n,isRotated:!this.isRotationallyInvariant(V.n)&&this.rng.next()<k*.7,isNegative:!0})))}}}}let D=[...O,...L];if(D.length>H.length)continue;for(let k of D){if(H.length===0)break;let q=H.pop();if(k.isNegative)e.cells[q.y][q.x].type=k.isRotated?6:5,e.cells[q.y][q.x].color=v(5,W.Cyan),R++;else{e.cells[q.y][q.x].type=k.isRotated?4:3;let ee=v(3,W.None),Z=ee;if(f&&this.rng.next()<.3){let J=P.filter(Y=>Y!==ee&&!K.has(Y));J.length>0&&(Z=J[Math.floor(this.rng.next()*J.length)],K.add(Z))}e.cells[q.y][q.x].color=Z}e.cells[q.y][q.x].shape=k.isRotated?k.displayShape:k.shape,x++}b+=A.length}}}if(a&&p<1){let $=.05+i*.2,U=this.rng.next()<$;if(z<=2&&(U=!0),U&&H.length>=1){let G=[];f&&G.push("star"),y&&G.push("square");let O=[];u&&(O=o?o[B]:this.getRegionBoundaryEdges(e,A,t,s),O.length>0&&G.push("hexagon")),r&&G.push("tetris"),h&&G.push("tetrisNegative"),this.shuffleArray(G),H.length>=2&&G.push("eraser");let L=!1;for(let X of G){if(L)break;if(X==="hexagon"){let D=O.filter(k=>!this.isEdgeAdjacentToHexagonNode(e,k));if(D.length>0){let k=D[Math.floor(this.rng.next()*D.length)];k.type==="h"?e.hEdges[k.r][k.c].type=3:e.vEdges[k.r][k.c].type=3,c++,L=!0}}else if(X==="square"&&H.length>=2){let D=H.pop();e.cells[D.y][D.x].type=1;let k=A.find(_=>e.cells[_.y][_.x].type===1),q=k?e.cells[k.y][k.x].color:void 0;e.cells[D.y][D.x].color=P.find(_=>_!==q)||W.Red,d++,L=!0}else if(X==="star"&&H.length>=2){let D=H.pop();e.cells[D.y][D.x].type=2,e.cells[D.y][D.x].color=P[Math.floor(this.rng.next()*P.length)],g++,L=!0}else if(X==="tetris"&&H.length>=2){let D=this.generateTiling(A,4,n),k=[];if(D&&D.length>0){let q=0;for(let _ of D){let ee=this.getShapeArea(_.shape);if(q+ee<A.length)k.push(_),q+=ee;else break}}if(k.length===0&&A.length>1&&(k=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),k.length>0){for(let q of k){if(H.length<2)break;let _=H.pop();e.cells[_.y][_.x].type=q.isRotated?4:3,e.cells[_.y][_.x].shape=q.isRotated?q.displayShape:q.shape,e.cells[_.y][_.x].color=W.None,x++}L=!0}}else if(X==="tetrisNegative"&&this.canPlaceGeneratedTetrisNegative(e,A,H)){if(!this.hasRegionTetrisSymbol(e,A)){let k=H.pop();e.cells[k.y][k.x].type=3,e.cells[k.y][k.x].shape=[[1]],e.cells[k.y][k.x].color=v(3,W.None),x++}let D=H.pop();e.cells[D.y][D.x].type=5,e.cells[D.y][D.x].shape=[[1]],e.cells[D.y][D.x].color=v(5,W.Cyan),R++}else if(X==="eraser"&&this.canPlaceGeneratedEraser(e,A,H)){let D=H.pop();e.cells[D.y][D.x].type=7,e.cells[D.y][D.x].color=v(7,W.White),p++,L=!0}}if(L&&this.canPlaceGeneratedEraser(e,A,H)){let X=H.pop();e.cells[X.y][X.x].type=7;let D=v(7,W.White),k=D;if(f&&this.rng.next()<.3){let q=P.filter(_=>_!==D&&!K.has(_));q.length>0&&(k=q[Math.floor(this.rng.next()*q.length)],K.add(k))}e.cells[X.y][X.x].color=k,p++}}}if(f){for(let U of P){if(H.length<1)break;if(A.filter(O=>e.cells[O.y][O.x].color===U).length===1&&(U!==W.White||K.has(U))){let O=H.pop();e.cells[O.y][O.x].type=2,e.cells[O.y][O.x].color=U,g++}}let $=Math.max(1,Math.floor(A.length/8));for(let U=0;U<$&&!(H.length<2);U++)for(let G of P){if(H.length<2)break;if(this.rng.next()>.3+i*.4)continue;if(A.filter(L=>e.cells[L.y][L.x].color===G).length===0)for(let L=0;L<2;L++){let X=H.pop();e.cells[X.y][X.x].type=2,e.cells[X.y][X.x].color=G,g++}}}}if(y&&T.size<2){let I=T.values().next().value;if(!(I!==void 0&&g>0&&Array.from({length:e.rows*e.cols}).some((A,z)=>{let w=Math.floor(z/e.cols),N=z%e.cols;return e.cells[w][N].type===2&&e.cells[w][N].color===I}))){for(let A of C){if(T.size>=2)break;if(A.some(w=>e.cells[w.y][w.x].type===1))continue;let z=A.filter(w=>e.cells[w.y][w.x].type===0);if(z.length>0){let w=P.find(H=>!T.has(H))||W.White,N=z[Math.floor(this.rng.next()*z.length)];e.cells[N.y][N.x].type=1,e.cells[N.y][N.x].color=w,T.add(w),d++}}if(T.size<2&&f&&I!==void 0)for(let A of C){let z=A.filter(w=>e.cells[w.y][w.x].type===0);if(z.length>0){let w=z[Math.floor(this.rng.next()*z.length)];e.cells[w.y][w.x].type=2,e.cells[w.y][w.x].color=I,g++;break}}}}}}calculateRegions(e,t,n=[]){let s=[],l=e.rows,o=e.cols,i=new Uint8Array(l*o),u=new Uint8Array((l+1)*o),y=new Uint8Array(l*(o+1)),f=(r,h)=>{r.x===h.x?y[Math.min(r.y,h.y)*(o+1)+r.x]=1:u[r.y*o+Math.min(r.x,h.x)]=1};for(let r=0;r<t.length-1;r++)f(t[r],t[r+1]);for(let r=0;r<n.length-1;r++)f(n[r],n[r+1]);for(let r=0;r<=l;r++)for(let h=0;h<o;h++)e.hEdges[r][h].type===2&&(u[r*o+h]=1);for(let r=0;r<l;r++)for(let h=0;h<=o;h++)e.vEdges[r][h].type===2&&(y[r*(o+1)+h]=1);for(let r=0;r<l;r++)for(let h=0;h<o;h++){let a=r*o+h;if(i[a])continue;let c=[],d=[a];i[a]=1;let g=0;for(;g<d.length;){let x=d[g++],p=x%o,b=Math.floor(x/o);if(c.push({x:p,y:b}),b>0&&!u[b*o+p]){let m=(b-1)*o+p;i[m]||(i[m]=1,d.push(m))}if(b<l-1&&!u[(b+1)*o+p]){let m=(b+1)*o+p;i[m]||(i[m]=1,d.push(m))}if(p>0&&!y[b*(o+1)+p]){let m=b*o+(p-1);i[m]||(i[m]=1,d.push(m))}if(p<o-1&&!y[b*(o+1)+(p+1)]){let m=b*o+(p+1);i[m]||(i[m]=1,d.push(m))}}s.push(c)}return s}isAbsentEdge(e,t,n){if(t.x===n.x){let s=Math.min(t.y,n.y);return e.vEdges[s][t.x].type===2}else{let s=Math.min(t.x,n.x);return e.hEdges[t.y][s].type===2}}getRegionBoundaryEdges(e,t,n,s=[]){let l=new Set;for(let u=0;u<n.length-1;u++)l.add(this.getEdgeKey(n[u],n[u+1]));for(let u=0;u<s.length-1;u++)l.add(this.getEdgeKey(s[u],s[u+1]));let o=[];for(let u of t){let y=[{type:"h",r:u.y,c:u.x},{type:"h",r:u.y+1,c:u.x},{type:"v",r:u.y,c:u.x},{type:"v",r:u.y,c:u.x+1}];for(let f of y){let r=f.type==="h"?{x:f.c,y:f.r}:{x:f.c,y:f.r},h=f.type==="h"?{x:f.c+1,y:f.r}:{x:f.c,y:f.r+1},a=this.getEdgeKey(r,h);!l.has(a)&&!this.isAbsentEdge(e,r,h)&&o.push(f)}}let i=new Map;for(let u of o)i.set(`${u.type},${u.r},${u.c}`,u);return Array.from(i.values())}setEdgeHexagon(e,t,n,s=3){t.x===n.x?e.vEdges[Math.min(t.y,n.y)][t.x].type=s:e.hEdges[t.y][Math.min(t.x,n.x)].type=s}hasIncidentHexagonEdge(e,t){let n=s=>s===3||s===4||s===5;return!!(t.x>0&&n(e.hEdges[t.y][t.x-1].type)||t.x<e.cols&&n(e.hEdges[t.y][t.x].type)||t.y>0&&n(e.vEdges[t.y-1][t.x].type)||t.y<e.rows&&n(e.vEdges[t.y][t.x].type))}isEdgeAdjacentToHexagonNode(e,t){let n=s=>s===3||s===4||s===5;return t.type==="h"?n(e.nodes[t.r][t.c].type)||n(e.nodes[t.r][t.c+1].type):n(e.nodes[t.r][t.c].type)||n(e.nodes[t.r+1][t.c].type)}checkAllRequestedConstraintsPresent(e,t){let n=t.useHexagons??!0,s=t.useSquares??!0,l=t.useStars??!0,o=t.useTetris??!1,i=t.useTetrisNegative??!1,u=t.useEraser??!1;if(t.useBrokenEdges??!1){let f=!1;for(let r=0;r<=e.rows;r++)for(let h=0;h<e.cols;h++)if(e.hEdges[r][h].type===1||e.hEdges[r][h].type===2){f=!0;break}if(!f){for(let r=0;r<e.rows;r++)for(let h=0;h<=e.cols;h++)if(e.vEdges[r][h].type===1||e.vEdges[r][h].type===2){f=!0;break}}if(!f)return!1}if(n){let f=!1,r=a=>a===3||a===4||a===5,h=a=>a===3||a===4||a===5;for(let a=0;a<=e.rows;a++)for(let c=0;c<e.cols;c++)if(r(e.hEdges[a][c].type)){f=!0;break}if(!f){for(let a=0;a<e.rows;a++)for(let c=0;c<=e.cols;c++)if(r(e.vEdges[a][c].type)){f=!0;break}}if(!f){for(let a=0;a<=e.rows;a++)for(let c=0;c<=e.cols;c++)if(h(e.nodes[a][c].type)){f=!0;break}}if(!f)return!1}if(s||l||o||u){let f=!1,r=!1,h=!1,a=!1,c=!1,d=new Set,g=new Set;for(let x=0;x<e.rows;x++)for(let p=0;p<e.cols;p++){let b=e.cells[x][p].type;b===1&&(f=!0,d.add(e.cells[x][p].color)),b===2&&(r=!0,g.add(e.cells[x][p].color)),(b===3||b===4)&&(h=!0),(b===5||b===6)&&(a=!0),b===7&&(c=!0)}if(s&&!f||l&&!r||o&&!h||i&&!a||u&&!c)return!1;if(s&&f&&d.size<2){let x=d.values().next().value;if(x===void 0||!g.has(x))return!1}}return!this.hasIsolatedMark(e)}generateTiling(e,t,n){let s=Math.min(...e.map(r=>r.x)),l=Math.min(...e.map(r=>r.y)),o=Math.max(...e.map(r=>r.x)),i=Math.max(...e.map(r=>r.y)),u=o-s+1,y=i-l+1,f=Array.from({length:y},()=>Array(u).fill(!1));for(let r of e)f[r.y-l][r.x-s]=!0;return this.tilingDfs(f,[],t,n)}tilingDfs(e,t,n,s){let l=-1,o=-1;for(let y=0;y<e.length;y++){for(let f=0;f<e[0].length;f++)if(e[y][f]){l=y,o=f;break}if(l!==-1)break}if(l===-1)return t;if(t.length>=n)return null;let i=s.difficulty??.5,u=Array.from({length:this.TETRIS_SHAPES.length},(y,f)=>f);this.shuffleArray(u),i>.6&&u.sort((y,f)=>this.getShapeArea(this.TETRIS_SHAPES[f])-this.getShapeArea(this.TETRIS_SHAPES[y]));for(let y of u){let f=this.TETRIS_SHAPES[y],r=this.TETRIS_SHAPES_WITH_ROTATIONS[y],h=Array.from({length:r.length},(a,c)=>c);this.shuffleArray(h);for(let a of h){let c=r[a],d=[];for(let g=0;g<c.length;g++)for(let x=0;x<c[0].length;x++)c[g][x]&&d.push({r:g,c:x});for(let g of d){let x=l-g.r,p=o-g.c;if(this.canPlace(e,c,x,p)){this.placePiece(e,c,x,p,!1);let b=r.length>1&&this.rng.next()<.3+i*.6,m=this.tilingDfs(e,[...t,{shape:c,displayShape:f,isRotated:b}],n,s);if(m)return m;this.placePiece(e,c,x,p,!0)}}}}return null}getShapeArea(e){let t=0;for(let n of e)for(let s of n)s&&t++;return t}isRotationallyInvariant(e){return this.getAllRotations(e).length===1}getAllRotations(e){let t=[],n=new Set,s=e;for(let l=0;l<4;l++){let o=JSON.stringify(s);n.has(o)||(t.push(s),n.add(o)),s=this.rotate90(s)}return t}rotate90(e){let t=e.length,n=e[0].length,s=Array.from({length:n},()=>Array(t).fill(0));for(let l=0;l<t;l++)for(let o=0;o<n;o++)s[o][t-1-l]=e[l][o];return s}canPlace(e,t,n,s){for(let l=0;l<t.length;l++)for(let o=0;o<t[0].length;o++)if(t[l][o]){let i=n+l,u=s+o;if(i<0||i>=e.length||u<0||u>=e[0].length||!e[i][u])return!1}return!0}placePiece(e,t,n,s,l){for(let o=0;o<t.length;o++)for(let i=0;i<t[0].length;i++)t[o][i]&&(e[n+o][s+i]=l)}isSameShape(e,t){let n=this.getAllRotations(e),s=JSON.stringify(t);return n.some(l=>JSON.stringify(l)===s)}countRegionNonEraserSymbols(e,t){let n=0;for(let s of t){let l=e.cells[s.y][s.x].type;l!==0&&l!==7&&n++}return n}hasRegionTetrisSymbol(e,t){for(let n of t){let s=e.cells[n.y][n.x].type;if(s===3||s===4)return!0}return!1}canPlaceGeneratedTetrisNegative(e,t,n){return n.length<1?!1:this.hasRegionTetrisSymbol(e,t)?!0:n.length>=2}canPlaceGeneratedEraser(e,t,n){return n.length<1?!1:this.countRegionNonEraserSymbols(e,t)>0?!0:n.length>=2}canTilePieceWith(e,t,n){let s=this.getShapeArea(e),l=this.getShapeArea(t),o=this.getShapeArea(n);if(s!==l+o)return!1;let i=this.getAllRotations(t),u=this.getAllRotations(n),y=e.length,f=e[0].length;for(let r of i)for(let h of u){let a=r.length,c=r[0].length,d=h.length,g=h[0].length;for(let x=0;x<=y-a;x++)for(let p=0;p<=f-c;p++)for(let b=0;b<=y-d;b++)for(let m=0;m<=f-g;m++){let C=Array.from({length:y},()=>Array(f).fill(0)),P=!0;for(let E=0;E<a;E++)for(let v=0;v<c;v++)r[E][v]&&(C[x+E][p+v]=1);for(let E=0;E<d;E++){for(let v=0;v<g;v++)if(h[E][v]){if(C[b+E][m+v]){P=!1;break}C[b+E][m+v]=1}if(!P)break}if(P){let E=!0;for(let v=0;v<y;v++){for(let S=0;S<f;S++)if(C[v][S]!==e[v][S]){E=!1;break}if(!E)break}if(E)return!0}}}return!1}findStandardTriple(e){let t=this.getShapeArea(e),n=[...this.TETRIS_SHAPES];this.shuffleArray(n);for(let s of n){let l=this.getShapeArea(s),o=t+l;if(o>5)continue;let i=this.TETRIS_SHAPES.filter(u=>this.getShapeArea(u)===o);for(let u of i)if(this.canTilePieceWith(u,e,s))return{p:u,n:s}}return null}shuffleArray(e){for(let t=e.length-1;t>0;t--){let n=Math.floor(this.rng.next()*(t+1));[e[t],e[n]]=[e[n],e[t]]}}};var ye=class{bytes=[];cur=0;bit=0;write(e,t){for(let n=0;n<t;n++)e&1<<n&&(this.cur|=1<<this.bit),this.bit++,this.bit===8&&(this.bytes.push(this.cur),this.cur=0,this.bit=0)}finish(){return this.bit>0&&this.bytes.push(this.cur),new Uint8Array(this.bytes)}},de=class{constructor(e){this.buf=e}i=0;bit=0;read(e){let t=0;for(let n=0;n<e;n++)this.buf[this.i]&1<<this.bit&&(t|=1<<n),this.bit++,this.bit===8&&(this.bit=0,this.i++);return t}};function Pe(j){let e=new Map;for(let t of j)for(let n of t)if(n.shape){let s=JSON.stringify(n.shape);e.has(s)||e.set(s,n.shape)}return[...e.values()]}var pe=class{static async serialize(e,t){let n=new ye;n.write(e.rows,6),n.write(e.cols,6),n.write(e.symmetry??0,2);let s=Pe(e.cells);n.write(s.length,5);for(let f of s){n.write(f.length,4),n.write(f[0].length,4);for(let r of f)for(let h of r)n.write(h,1)}let l=new Map;s.forEach((f,r)=>l.set(JSON.stringify(f),r));for(let f of e.cells)for(let r of f)n.write(r.type,3),n.write(r.color,3),r.shape?(n.write(1,1),n.write(l.get(JSON.stringify(r.shape)),5)):n.write(0,1);for(let f=0;f<e.rows;f++)for(let r=0;r<e.cols+1;r++)n.write(e.vEdges[f][r].type,3);for(let f=0;f<e.rows+1;f++)for(let r=0;r<e.cols;r++)n.write(e.hEdges[f][r].type,3);for(let f=0;f<e.rows+1;f++)for(let r=0;r<e.cols+1;r++)n.write(e.nodes[f][r].type,3);n.write(+!!t.useHexagons,1),n.write(+!!t.useSquares,1),n.write(+!!t.useStars,1),n.write(+!!t.useTetris,1),n.write(+!!t.useTetrisNegative,1),n.write(+!!t.useEraser,1),n.write(+!!t.useBrokenEdges,1),n.write(t.symmetry??0,2),n.write(Math.round((t.complexity??0)*254),8),n.write(Math.round((t.difficulty??0)*254),8),n.write(Math.round((t.pathLength??0)*254),8);let o=n.finish(),i=new Uint8Array(await new Response(new Blob([o.buffer]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()),u=0;for(let f of i)u^=f;let y=new Uint8Array(i.length+1);return y.set(i),y[i.length]=u,btoa(String.fromCharCode(...y)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}static async deserialize(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4;)t+="=";let n=atob(t),s=Uint8Array.from(n,B=>B.charCodeAt(0)),l=0;for(let B=0;B<s.length-1;B++)l^=s[B];if(l!==s.at(-1))throw new Error("Invalid parity data");let o=new Uint8Array(await new Response(new Blob([s.slice(0,-1).buffer]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer()),i=new de(o),u=i.read(6),y=i.read(6),f=i.read(2),r=i.read(5),h=[];for(let B=0;B<r;B++){let A=i.read(4),z=i.read(4),w=[];for(let N=0;N<A;N++){let H=[];for(let K=0;K<z;K++)H.push(i.read(1));w.push(H)}h.push(w)}let a=[];for(let B=0;B<u;B++){let A=[];for(let z=0;z<y;z++){let w=i.read(3),N=i.read(3),H=i.read(1),K={type:w,color:N};H&&(K.shape=h[i.read(5)].map(F=>F.slice())),A.push(K)}a.push(A)}let c=Array.from({length:u},()=>Array.from({length:y+1},()=>({type:i.read(3)}))),d=Array.from({length:u+1},()=>Array.from({length:y},()=>({type:i.read(3)}))),g=Array.from({length:u+1},()=>Array.from({length:y+1},()=>({type:i.read(3)}))),x=()=>{let B=i.read(8);return Math.round(B/254*1e3)/1e3},p={},b=!!i.read(1),m=!!i.read(1),C=!!i.read(1),P=!!i.read(1),E=!!i.read(1),v=!!i.read(1),S=!!i.read(1),T=i.read(2);b&&(p.useHexagons=!0),m&&(p.useSquares=!0),C&&(p.useStars=!0),P&&(p.useTetris=!0),E&&(p.useTetrisNegative=!0),v&&(p.useEraser=!0),S&&(p.useBrokenEdges=!0),p.symmetry=T;let M=x(),R=x(),I=x();return M!==0&&(p.complexity=M),R!==0&&(p.difficulty=R),I!==0&&(p.pathLength=I),{puzzle:{rows:u,cols:y,cells:a,vEdges:c,hEdges:d,nodes:g,symmetry:f},options:p}}};var ge=class{canvas;ctx;puzzle=null;options;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;invalidatedCells=[];invalidatedEdges=[];invalidatedNodes=[];errorCells=[];errorEdges=[];errorNodes=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;canvasRect=null;boundMouseDown=null;boundMouseMove=null;boundMouseUp=null;boundTouchStart=null;boundTouchMove=null;boundTouchEnd=null;constructor(e,t,n={}){if(typeof e=="string"){if(typeof document>"u")throw new Error("Cannot look up canvas by ID in a non-browser environment.");let l=document.getElementById(e);if(!(l instanceof HTMLCanvasElement))throw new Error(`Element with id "${e}" is not a canvas.`);this.canvas=l}else this.canvas=e;let s=this.canvas.getContext("2d");if(!s)throw new Error("Could not get 2D context.");this.ctx=s,this.ctx.imageSmoothingEnabled=!1,this.options=this.mergeOptions(n),t&&this.setPuzzle(t),this.initEvents(),this.animate()}mergeOptions(e){let t={blinkDuration:e.animations?.blinkDuration??this.options?.animations?.blinkDuration??1e3,fadeDuration:e.animations?.fadeDuration??this.options?.animations?.fadeDuration??1e3,blinkPeriod:e.animations?.blinkPeriod??this.options?.animations?.blinkPeriod??800},n={path:e.colors?.path??this.options?.colors?.path??"#ffcc00",error:e.colors?.error??this.options?.colors?.error??"#ff4444",success:e.colors?.success??this.options?.colors?.success??"#ffcc00",symmetry:e.colors?.symmetry??this.options?.colors?.symmetry??"rgba(255, 255, 255, 0.5)",interrupted:e.colors?.interrupted??this.options?.colors?.interrupted??"#ffcc00",grid:e.colors?.grid??this.options?.colors?.grid??"#555",node:e.colors?.node??this.options?.colors?.node??"#555",hexagon:e.colors?.hexagon??this.options?.colors?.hexagon??"#000",hexagonMain:e.colors?.hexagonMain??this.options?.colors?.hexagonMain??"#00ffff",hexagonSymmetry:e.colors?.hexagonSymmetry??this.options?.colors?.hexagonSymmetry??"#ffff00",colorMap:e.colors?.colorMap??this.options?.colors?.colorMap??{[W.Black]:"#000",[W.White]:"#fff",[W.Red]:"#f00",[W.Blue]:"#00f",[W.Cyan]:"#00ffff",[W.None]:"#ffcc00"},colorList:e.colors?.colorList??this.options?.colors?.colorList};return{gridPadding:e.gridPadding??this.options?.gridPadding??60,cellSize:e.cellSize??this.options?.cellSize??80,nodeRadius:e.nodeRadius??this.options?.nodeRadius??6,startNodeRadius:e.startNodeRadius??this.options?.startNodeRadius??22,pathWidth:e.pathWidth??this.options?.pathWidth??18,exitLength:e.exitLength??this.options?.exitLength??25,autoResize:e.autoResize??this.options?.autoResize??!0,blinkMarksOnError:e.blinkMarksOnError??this.options?.blinkMarksOnError??!0,stayPathOnError:e.stayPathOnError??this.options?.stayPathOnError??!0,animations:t,colors:n,onPathComplete:e.onPathComplete??this.options?.onPathComplete??(()=>{})}}setPuzzle(e){this.puzzle=e,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw()}setOptions(e){this.options=this.mergeOptions({...this.options,...e}),this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}setValidationResult(e,t=[],n=[],s=[],l=[],o=[],i=[]){this.invalidatedCells=t,this.invalidatedEdges=n,this.invalidatedNodes=o,this.errorCells=s,this.errorEdges=l,this.errorNodes=i,this.eraserAnimationStartTime=Date.now(),e?(this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0}resizeCanvas(){!this.puzzle||!this.canvas||(this.canvas.width=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,this.canvas.height=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2)}setCanvasRect(e){this.canvasRect=e}initEvents(){typeof window>"u"||!(this.canvas instanceof HTMLCanvasElement)||(this.boundMouseDown=e=>this.handleStart(e),this.boundMouseMove=e=>this.handleMove(e),this.boundMouseUp=e=>this.handleEnd(e),this.boundTouchStart=e=>{this.handleStart(e.touches[0])&&e.cancelable&&e.preventDefault()},this.boundTouchMove=e=>{this.isDrawing&&(e.cancelable&&e.preventDefault(),this.handleMove(e.touches[0]))},this.boundTouchEnd=e=>{this.isDrawing&&(e.cancelable&&e.preventDefault(),this.handleEnd(e.changedTouches[0]))},this.canvas.addEventListener("mousedown",this.boundMouseDown),window.addEventListener("mousemove",this.boundMouseMove),window.addEventListener("mouseup",this.boundMouseUp),this.canvas.addEventListener("touchstart",this.boundTouchStart,{passive:!1}),window.addEventListener("touchmove",this.boundTouchMove,{passive:!1}),window.addEventListener("touchend",this.boundTouchEnd,{passive:!1}))}destroy(){typeof window>"u"||!(this.canvas instanceof HTMLCanvasElement)||(this.boundMouseDown&&this.canvas.removeEventListener("mousedown",this.boundMouseDown),this.boundMouseMove&&window.removeEventListener("mousemove",this.boundMouseMove),this.boundMouseUp&&window.removeEventListener("mouseup",this.boundMouseUp),this.boundTouchStart&&this.canvas.removeEventListener("touchstart",this.boundTouchStart),this.boundTouchMove&&window.removeEventListener("touchmove",this.boundTouchMove),this.boundTouchEnd&&window.removeEventListener("touchend",this.boundTouchEnd),this.boundMouseDown=null,this.boundMouseMove=null,this.boundMouseUp=null,this.boundTouchStart=null,this.boundTouchMove=null,this.boundTouchEnd=null)}getCanvasCoords(e,t){return{x:this.options.gridPadding+e*this.options.cellSize,y:this.options.gridPadding+t*this.options.cellSize}}getExitDir(e,t){return!this.puzzle||this.puzzle.nodes[t]?.[e]?.type!==2?null:e===this.puzzle.cols?{x:1,y:0}:e===0?{x:-1,y:0}:t===0?{x:0,y:-1}:t===this.puzzle.rows?{x:0,y:1}:{x:1,y:0}}handleStart(e){if(!this.puzzle)return!1;let t=this.canvasRect||(this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),n=(e.clientX-t.left)*(this.canvas.width/t.width),s=(e.clientY-t.top)*(this.canvas.height/t.height);for(let l=0;l<=this.puzzle.rows;l++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[l][o].type===1){let i=this.getCanvasCoords(o,l);if(Math.hypot(i.x-n,i.y-s)<this.options.startNodeRadius)return this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.isDrawing=!0,this.path=[{x:o,y:l}],this.currentMousePos=i,this.exitTipPos=null,this.draw(),!0}return!1}handleMove(e){if(!this.puzzle||!this.isDrawing)return;let t=this.canvasRect||(this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),n=(e.clientX-t.left)*(this.canvas.width/t.width),s=(e.clientY-t.top)*(this.canvas.height/t.height),l=this.path[this.path.length-1],o=this.getCanvasCoords(l.x,l.y),i=n-o.x,u=s-o.y,y=this.puzzle.symmetry||0,f=this.getExitDir(l.x,l.y),r=Math.abs(i)>Math.abs(u)?{x:i>0?1:-1,y:0}:{x:0,y:u>0?1:-1};if(f&&r.x===f.x&&r.y===f.y){let d=i*f.x+u*f.y,g=Math.max(0,Math.min(d,this.options.exitLength));this.currentMousePos={x:o.x+f.x*g,y:o.y+f.y*g},this.draw();return}let h=(d,g)=>{let x=this.getEdgeType(l,d);if(d.x<0||d.x>this.puzzle.cols||d.y<0||d.y>this.puzzle.rows||x===2){this.currentMousePos=o;return}let p=x===1?this.options.cellSize*.35:this.options.cellSize,b=this.getEdgeKey(l,d);if(!(this.path.length>=2&&d.x===this.path[this.path.length-2].x&&d.y===this.path[this.path.length-2].y)){for(let P=0;P<this.path.length-1;P++)if(this.getEdgeKey(this.path[P],this.path[P+1])===b){p=0;break}}if(this.path.some(P=>P.x===d.x&&P.y===d.y)&&this.path.length>=2){let P=this.path[this.path.length-2];(d.x!==P.x||d.y!==P.y)&&(p=Math.min(p,this.options.cellSize*.5-this.options.pathWidth*.5))}if(y!==0){let P=this.getSymmetricalPoint(l),E=this.getSymmetricalPoint(d),v=this.getEdgeType(P,E),S=this.getSymmetryPath(this.path),T=this.getEdgeKey(P,E);if(E.x<0||E.x>this.puzzle.cols||E.y<0||E.y>this.puzzle.rows||v===2){this.currentMousePos=o;return}v===1&&(p=Math.min(p,this.options.cellSize*.35));let M=S.some(w=>w.x===d.x&&w.y===d.y),R=this.path.some(w=>w.x===E.x&&w.y===E.y),I=d.x===E.x&&d.y===E.y,B=S.some((w,N)=>N<S.length-1&&this.getEdgeKey(S[N],S[N+1])===b),A=this.path.some((w,N)=>N<this.path.length-1&&this.getEdgeKey(this.path[N],this.path[N+1])===T);(M||R||I||B||A||b===T)&&(p=Math.min(p,this.options.cellSize*.5-this.options.pathWidth*.5))}d.x!==l.x?this.currentMousePos={x:o.x+Math.max(-p,Math.min(p,g)),y:o.y}:this.currentMousePos={x:o.x,y:o.y+Math.max(-p,Math.min(p,g))}};if(Math.abs(i)>Math.abs(u)){let d=i>0?1:-1;h({x:l.x+d,y:l.y},i)}else{let d=u>0?1:-1;h({x:l.x,y:l.y+d},u)}let a=[{x:l.x+1,y:l.y},{x:l.x-1,y:l.y},{x:l.x,y:l.y+1},{x:l.x,y:l.y-1}],c=this.getSymmetryPath(this.path);for(let d of a)if(d.x>=0&&d.x<=this.puzzle.cols&&d.y>=0&&d.y<=this.puzzle.rows){let g=this.getCanvasCoords(d.x,d.y);if(Math.hypot(g.x-this.currentMousePos.x,g.y-this.currentMousePos.y)<this.options.cellSize*.3){let p=this.path.findIndex(b=>b.x===d.x&&b.y===d.y);if(p===-1){if(y!==0){let b=this.getSymmetricalPoint(d);if(d.x===b.x&&d.y===b.y||this.path.some(P=>P.x===b.x&&P.y===b.y)||c.some(P=>P.x===d.x&&P.y===d.y))continue;let m=this.getEdgeKey(l,d),C=this.getEdgeKey(this.getSymmetricalPoint(l),b);if(m===C)continue}this.path.push(d)}else p===this.path.length-2&&this.path.pop()}}this.draw()}handleEnd(e){if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let t=this.path[this.path.length-1],n=this.getCanvasCoords(t.x,t.y),s=this.getExitDir(t.x,t.y);if(s){let l=this.currentMousePos.x-n.x,o=this.currentMousePos.y-n.y;if(l*s.x+o*s.y>0){this.exitTipPos={x:n.x+s.x*this.options.exitLength,y:n.y+s.y*this.options.exitLength},this.options.onPathComplete(this.path);return}}this.exitTipPos=s?{...this.currentMousePos}:null,this.startFade(this.options.colors.interrupted)}getEdgeType(e,t){if(!this.puzzle)return 2;if(e.x===t.x){let n=Math.min(e.y,t.y);return n<0||n>=this.puzzle.rows?2:this.puzzle.vEdges[n][e.x].type}else{let n=Math.min(e.x,t.x);return n<0||n>=this.puzzle.cols?2:this.puzzle.hEdges[e.y][n].type}}startFade(e="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=e,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){let e=Date.now();if(this.isFading){let t=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=t,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0)}this.isInvalidPath&&!this.options.stayPathOnError&&!this.isFading&&this.path.length>0&&this.startFade(this.options.colors.error),this.draw(),typeof requestAnimationFrame<"u"&&requestAnimationFrame(()=>this.animate())}draw(){if(!this.puzzle||!this.ctx)return;let e=this.ctx,t=Date.now();if(e.globalAlpha=1,e.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(e),this.drawConstraints(e),this.drawNodes(e),this.path.length===0&&!this.isDrawing&&this.drawRipples(e),this.isFading){if(this.drawPath(e,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let n=this.getSymmetryPath(this.fadingPath),s=this.options.colors.symmetry;if(this.isInvalidPath){let o=this.colorToRgba(s).a;s=this.setAlpha(this.options.colors.error,o)}let l=null;if(this.fadingTipPos){let o=(this.fadingTipPos.x-this.options.gridPadding)/this.options.cellSize,i=(this.fadingTipPos.y-this.options.gridPadding)/this.options.cellSize,u=this.getSymmetricalPoint({x:o,y:i});l={x:u.x*this.options.cellSize+this.options.gridPadding,y:u.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,n,!1,s,this.fadeOpacity,l)}}else if(this.path.length>0){let n=this.options.colors.path,s=this.colorToRgba(n).a,l=this.options.colors.error,o=this.isInvalidPath?this.setAlpha(l,s):n;this.isSuccessFading&&!this.puzzle.symmetry&&(o=this.setAlpha(this.options.colors.success,s));let i=1;if(!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let u=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),y=this.options.animations.blinkDuration;u<y&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(o=this.setAlpha(this.options.colors.error,s),this.options.stayPathOnError||(i=Math.max(0,1-u/this.options.animations.fadeDuration)))}if(this.drawPath(e,this.path,this.isDrawing,o,i,this.isDrawing?this.currentMousePos:this.exitTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let u=this.getSymmetryPath(this.path),y=this.options.colors.symmetry,f=this.colorToRgba(y).a,r=y,h=i;if(this.isInvalidPath&&(r=this.setAlpha(l,f)),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let c=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),d=this.options.animations.blinkDuration;c<d&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(r=this.setAlpha(this.options.colors.error,f))}let a=null;if(this.isDrawing||this.exitTipPos){let c=this.isDrawing?this.currentMousePos:this.exitTipPos,d=(c.x-this.options.gridPadding)/this.options.cellSize,g=(c.y-this.options.gridPadding)/this.options.cellSize,x=this.getSymmetricalPoint({x:d,y:g},!0);a={x:x.x*this.options.cellSize+this.options.gridPadding,y:x.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,u,this.isDrawing,r,h,a)}}}drawRipples(e){if(!this.puzzle)return;let t=(Date.now()-this.startTime)/500;for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)if(this.puzzle.nodes[n][s].type===2){let o=this.getCanvasCoords(s,n),i=this.getExitDir(s,n);if(!i)continue;let u={x:o.x+i.x*this.options.exitLength,y:o.y+i.y*this.options.exitLength},y=t%4,f=y*5,r=Math.max(0,1-y/3);e.beginPath(),e.arc(u.x,u.y,f,0,Math.PI*2),e.strokeStyle=`rgba(170, 170, 170, ${r*.4})`,e.lineWidth=2,e.stroke()}}drawGrid(e){if(!this.puzzle||!this.options.colors.grid)return;e.strokeStyle=this.options.colors.grid,e.lineWidth=12,e.lineCap="round";let t=(n,s,l)=>{if(l!==2)if(l===1){let i={x:n.x+(s.x-n.x)*.35,y:n.y+(s.y-n.y)*.35},u={x:n.x+(s.x-n.x)*(.5+.15),y:n.y+(s.y-n.y)*(.5+.15)};e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(i.x,i.y),e.stroke(),e.beginPath(),e.moveTo(u.x,u.y),e.lineTo(s.x,s.y),e.stroke()}else e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(s.x,s.y),e.stroke()};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<this.puzzle.cols;s++)t(this.getCanvasCoords(s,n),this.getCanvasCoords(s+1,n),this.puzzle.hEdges[n][s].type);for(let n=0;n<this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)t(this.getCanvasCoords(s,n),this.getCanvasCoords(s,n+1),this.puzzle.vEdges[n][s].type)}drawConstraints(e){if(!this.puzzle)return;let t=Date.now(),n=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;for(let o=0;o<this.puzzle.rows;o++)for(let i=0;i<this.puzzle.cols;i++){let u=this.puzzle.cells[o][i],y=this.getCanvasCoords(i+.5,o+.5),f=this.invalidatedCells.some(g=>g.x===i&&g.y===o),r=this.errorCells.some(g=>g.x===i&&g.y===o),h=1,a,c=this.getColorCode(u.color),d=this.options.colors.error;if(r&&this.options.blinkMarksOnError&&(a=this.lerpColor(c,d,n)),f){let g=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),x=this.options.animations.blinkDuration;if(g<x){if(this.options.blinkMarksOnError){let p=Math.min(1,g/200),b=g>x*.8?(x-g)/(x*.2):1,m=Math.min(p,b);a=this.lerpColor(c,d,n*m)}}else h=Math.max(.3,1-(g-x)/this.options.animations.fadeDuration)}if(h<1||a){let{canvas:g,ctx:x}=this.prepareOffscreen();this.drawConstraintItem(x,u,y,a),e.save(),e.globalAlpha=h,e.drawImage(g,0,0),e.restore()}else this.drawConstraintItem(e,u,y)}e.lineWidth=2;let s=8,l=o=>o===3||o===3?this.options.colors.hexagon:o===4||o===4?this.options.colors.hexagonMain:o===5||o===5?this.options.colors.hexagonSymmetry:this.options.colors.hexagon;for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<this.puzzle.cols;i++){let u=this.puzzle.hEdges[o][i].type;if(u===3||u===4||u===5){let y=this.getCanvasCoords(i+.5,o);e.save();let f=this.invalidatedEdges.some(a=>a.type==="h"&&a.r===o&&a.c===i),r=this.errorEdges.some(a=>a.type==="h"&&a.r===o&&a.c===i),h=l(u);if(r&&this.options.blinkMarksOnError){let a=this.lerpColor(h,this.options.colors.error,n);this.drawHexagon(e,y.x,y.y,s,a)}else if(f){let a=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),c=this.options.animations.blinkDuration;if(a<c)if(this.options.blinkMarksOnError){let d=Math.min(1,a/200),g=a>c*.8?(c-a)/(c*.2):1,x=Math.min(d,g),p=this.lerpColor(h,this.options.colors.error,n*x);this.drawHexagon(e,y.x,y.y,s,p)}else this.drawHexagon(e,y.x,y.y,s,h);else e.globalAlpha*=Math.max(.3,1-(a-c)/this.options.animations.fadeDuration),this.drawHexagon(e,y.x,y.y,s,h)}else this.drawHexagon(e,y.x,y.y,s,h);e.restore()}}for(let o=0;o<this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++){let u=this.puzzle.vEdges[o][i].type;if(u===3||u===4||u===5){let y=this.getCanvasCoords(i,o+.5);e.save();let f=this.invalidatedEdges.some(a=>a.type==="v"&&a.r===o&&a.c===i),r=this.errorEdges.some(a=>a.type==="v"&&a.r===o&&a.c===i),h=l(u);if(r&&this.options.blinkMarksOnError){let a=this.lerpColor(h,this.options.colors.error,n);this.drawHexagon(e,y.x,y.y,s,a)}else if(f){let a=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),c=this.options.animations.blinkDuration;if(a<c)if(this.options.blinkMarksOnError){let d=Math.min(1,a/200),g=a>c*.8?(c-a)/(c*.2):1,x=Math.min(d,g),p=this.lerpColor(h,this.options.colors.error,n*x);this.drawHexagon(e,y.x,y.y,s,p)}else this.drawHexagon(e,y.x,y.y,s,h);else e.globalAlpha*=Math.max(.3,1-(a-c)/this.options.animations.fadeDuration),this.drawHexagon(e,y.x,y.y,s,h)}else this.drawHexagon(e,y.x,y.y,s,h);e.restore()}}for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++){let u=this.puzzle.nodes[o][i].type;if(u===3||u===4||u===5){let y=this.getCanvasCoords(i,o);e.save();let f=this.invalidatedNodes.some(a=>a.x===i&&a.y===o),r=this.errorNodes.some(a=>a.x===i&&a.y===o),h=l(u);if(r&&this.options.blinkMarksOnError){let a=this.lerpColor(h,this.options.colors.error,n);this.drawHexagon(e,y.x,y.y,s,a)}else if(f){let a=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),c=this.options.animations.blinkDuration;if(a<c)if(this.options.blinkMarksOnError){let d=Math.min(1,a/200),g=a>c*.8?(c-a)/(c*.2):1,x=Math.min(d,g),p=this.lerpColor(h,this.options.colors.error,n*x);this.drawHexagon(e,y.x,y.y,s,p)}else this.drawHexagon(e,y.x,y.y,s,h);else e.globalAlpha*=Math.max(.3,1-(a-c)/this.options.animations.fadeDuration),this.drawHexagon(e,y.x,y.y,s,h)}else this.drawHexagon(e,y.x,y.y,s,h);e.restore()}}}drawConstraintItem(e,t,n,s){t.type===1?(e.fillStyle=s||this.getColorCode(t.color),this.drawRoundedRect(e,n.x-26/2,n.y-26/2,26,26,8)):t.type===2?this.drawStar(e,n.x,n.y,12,16,8,t.color,s):t.type===3||t.type===4?this.drawTetris(e,n.x,n.y,t.shape||[],t.type===4,t.color,!1,s):t.type===5||t.type===6?this.drawTetris(e,n.x,n.y,t.shape||[],t.type===6,t.color,!0,s):t.type===7&&this.drawEraser(e,n.x,n.y,14,3,t.color,s)}drawNodes(e){if(!this.puzzle)return;let t=(n,s)=>{let l=[];return n>0&&l.push(this.puzzle.hEdges[s][n-1].type),n<this.puzzle.cols&&l.push(this.puzzle.hEdges[s][n].type),s>0&&l.push(this.puzzle.vEdges[s-1][n].type),s<this.puzzle.rows&&l.push(this.puzzle.vEdges[s][n].type),l.length>0&&l.every(o=>o===2)};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++){if(t(s,n))continue;let l=this.puzzle.nodes[n][s];if(l.type===3||l.type===4||l.type===5)continue;let o=this.getCanvasCoords(s,n);if(l.type===1)this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill();else if(l.type===2){let i=this.getExitDir(s,n);if(!i)continue;this.options.colors.node&&(e.strokeStyle=this.options.colors.node),e.lineWidth=12,e.lineCap="round",e.beginPath(),e.moveTo(o.x,o.y),e.lineTo(o.x+i.x*this.options.exitLength,o.y+i.y*this.options.exitLength),e.stroke()}else this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.nodeRadius,0,Math.PI*2),e.fill()}}drawPath(e,t,n,s,l,o=null){if(t.length===0||!s||s==="transparent")return;let i=this.colorToRgba(s),u=`rgb(${i.r},${i.g},${i.b})`,y=l*i.a,{canvas:f,ctx:r}=this.prepareOffscreen();this.drawPathInternal(r,t,n,u,o),e.save(),e.globalAlpha=y,e.drawImage(f,0,0),e.restore()}drawPathInternal(e,t,n,s,l=null){e.save(),e.strokeStyle=s,e.fillStyle=s,e.lineWidth=this.options.pathWidth,e.lineCap="round",e.lineJoin="round",e.beginPath();let o=this.getCanvasCoords(t[0].x,t[0].y);e.moveTo(o.x,o.y);for(let u=1;u<t.length;u++){let y=this.getCanvasCoords(t[u].x,t[u].y);e.lineTo(y.x,y.y)}let i=l||this.currentMousePos;(n||l)&&e.lineTo(i.x,i.y),e.stroke(),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill(),(n||l)&&(e.beginPath(),e.arc(i.x,i.y,this.options.pathWidth/2,0,Math.PI*2),e.fill()),e.restore()}drawRoundedRect(e,t,n,s,l,o){e.beginPath(),e.moveTo(t+o,n),e.lineTo(t+s-o,n),e.quadraticCurveTo(t+s,n,t+s,n+o),e.lineTo(t+s,n+l-o),e.quadraticCurveTo(t+s,n+l,t+s-o,n+l),e.lineTo(t+o,n+l),e.quadraticCurveTo(t,n+l,t,n+l-o),e.lineTo(t,n+o),e.quadraticCurveTo(t,n,t+o,n),e.closePath(),e.fill()}drawHexagon(e,t,n,s,l){if(!(!this.options.colors.hexagon&&!l)){e.fillStyle=l||this.options.colors.hexagon,e.beginPath();for(let o=0;o<6;o++){let i=Math.PI/3*o,u=t+s*Math.cos(i),y=n+s*Math.sin(i);o===0?e.moveTo(u,y):e.lineTo(u,y)}e.closePath(),e.fill()}}drawEraser(e,t,n,s,l,o,i){e.strokeStyle=i||this.getColorCode(o),e.lineWidth=s*.5,e.lineCap="butt";let u=.5;e.beginPath();for(let y=0;y<l;y++){let f=Math.PI*2/l*y+u,r=t+s*Math.cos(f),h=n+s*Math.sin(f);e.moveTo(t,n),e.lineTo(r,h)}e.stroke()}drawStar(e,t,n,s,l,o,i,u){e.fillStyle=u||this.getColorCode(i),e.beginPath();for(let y=0;y<o*2;y++){let f=y%2===0?l:s,r=Math.PI/o*y,h=t+f*Math.cos(r),a=n+f*Math.sin(r);y===0?e.moveTo(h,a):e.lineTo(h,a)}e.closePath(),e.fill()}drawTetris(e,t,n,s,l,o,i,u){if(!s||s.length===0)return;let y=12,f=2,r=s[0].length*y+(s[0].length-1)*f,h=s.length*y+(s.length-1)*f;e.save(),e.translate(t,n),l&&e.rotate(Math.PI/8);let a=u||this.getColorCode(o,i?"#00ffff":"#ffcc00");if(i){e.strokeStyle=a,e.lineWidth=2;for(let c=0;c<s.length;c++)for(let d=0;d<s[c].length;d++)if(s[c][d]){let g=d*(y+f)-r/2,x=c*(y+f)-h/2;e.strokeRect(g+1,x+1,y-2,y-2)}}else{e.fillStyle=a;for(let c=0;c<s.length;c++)for(let d=0;d<s[c].length;d++)if(s[c][d]){let g=d*(y+f)-r/2,x=c*(y+f)-h/2;e.fillRect(g,x,y,y)}}e.restore()}getColorCode(e,t="#666"){return this.options.colors.colorList&&this.options.colors.colorList[e]!==void 0?this.options.colors.colorList[e]:this.options.colors.colorMap&&this.options.colors.colorMap[e]!==void 0?this.options.colors.colorMap[e]:t}colorToRgba(e){if(!e||e==="transparent")return{r:0,g:0,b:0,a:0};if(e.startsWith("rgba")||e.startsWith("rgb")){let n=e.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);if(n)return{r:parseInt(n[1]),g:parseInt(n[2]),b:parseInt(n[3]),a:n[4]?parseFloat(n[4]):1}}let t=e.startsWith("#")?e.slice(1):e;if((t.length===3||t.length===4)&&(t=t.split("").map(n=>n+n).join("")),t.length===6){let n=parseInt(t,16);return{r:n>>16&255,g:n>>8&255,b:n&255,a:1}}else if(t.length===8){let n=parseInt(t,16);return{r:n>>24&255,g:n>>16&255,b:n>>8&255,a:(n&255)/255}}return{r:0,g:0,b:0,a:1}}lerpColor(e,t,n){try{let s=this.colorToRgba(e),l=this.colorToRgba(t),o=Math.round(s.r+(l.r-s.r)*n),i=Math.round(s.g+(l.g-s.g)*n),u=Math.round(s.b+(l.b-s.b)*n),y=s.a+(l.a-s.a)*n;return`rgba(${o},${i},${u},${y})`}catch{return e}}setAlpha(e,t){let n=this.colorToRgba(e);return`rgba(${n.r},${n.g},${n.b},${t})`}getSymmetryPath(e){return!this.puzzle||!this.puzzle.symmetry?[]:e.map(t=>this.getSymmetricalPoint(t))}getSymmetricalPoint(e,t=!1){if(!this.puzzle||!this.puzzle.symmetry)return{...e};let{cols:n,rows:s,symmetry:l}=this.puzzle;return l===1?{x:n-e.x,y:e.y}:l===2?{x:e.x,y:s-e.y}:l===3?{x:n-e.x,y:s-e.y}:{...e}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}prepareOffscreen(){if(!this.offscreenCanvas){if(typeof document<"u")this.offscreenCanvas=document.createElement("canvas");else if(typeof OffscreenCanvas<"u")this.offscreenCanvas=new OffscreenCanvas(this.canvas.width,this.canvas.height);else throw new Error("Offscreen canvas not supported in this environment.");this.offscreenCtx=this.offscreenCanvas.getContext("2d")}if((this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),!this.offscreenCtx)throw new Error("Could not get offscreen 2D context.");return this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx}}};var be=class{generator;validator;constructor(){this.generator=new ae,this.validator=new se}createPuzzle(e,t,n={}){return this.generator.generate(e,t,n).export()}validateSolution(e,t){let n=te.fromData(e);return this.validator.validate(n,t)}calculateDifficulty(e){let t=te.fromData(e);return this.validator.calculateDifficulty(t)}};export{oe as CellType,W as Color,ve as Direction,ie as EdgeType,te as Grid,re as NodeType,ae as PuzzleGenerator,pe as PuzzleSerializer,se as PuzzleValidator,xe as RngType,le as SymmetryType,be as WitnessCore,ge as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
