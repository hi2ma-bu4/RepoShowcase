/*!
 * MiniWitness 1.1.1
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var Z=(t=>(t[t.Up=0]="Up",t[t.Right=1]="Right",t[t.Down=2]="Down",t[t.Left=3]="Left",t))(Z||{}),L=(n=>(n[n.None=0]="None",n[n.Square=1]="Square",n[n.Star=2]="Star",n[n.Tetris=3]="Tetris",n[n.TetrisRotated=4]="TetrisRotated",n[n.Eraser=5]="Eraser",n))(L||{}),K=(t=>(t[t.Normal=0]="Normal",t[t.Broken=1]="Broken",t[t.Absent=2]="Absent",t[t.Hexagon=3]="Hexagon",t))(K||{}),X=(o=>(o[o.Normal=0]="Normal",o[o.Start=1]="Start",o[o.End=2]="End",o))(X||{}),Y=(i=>(i[i.None=0]="None",i[i.Black=1]="Black",i[i.White=2]="White",i[i.Red=3]="Red",i[i.Blue=4]="Blue",i))(Y||{});var q=class F{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];constructor(e,s){this.rows=e,this.cols=s,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:0}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes}))}static fromData(e){let s=new F(e.rows,e.cols);return s.cells=e.cells,s.vEdges=e.vEdges,s.hEdges=e.hEdges,s.nodes=e.nodes,s}};var G=class{validate(e,s){let o=s.points;if(o.length<2)return{isValid:!1,errorReason:"Path too short"};let t=o[0],i=o[o.length-1];if(e.nodes[t.y][t.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[i.y][i.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};let n=new Set;n.add(`${t.x},${t.y}`);for(let h=0;h<o.length-1;h++){let l=o[h],a=o[h+1];if(Math.abs(l.x-a.x)+Math.abs(l.y-a.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let f=`${a.x},${a.y}`;if(n.has(f))return{isValid:!1,errorReason:"Self-intersecting path"};if(n.add(f),this.isBrokenEdge(e,l,a))return{isValid:!1,errorReason:"Passed through broken edge"}}let r=this.calculateRegions(e,o),c=this.getMissedHexagons(e,o);return this.validateWithErasers(e,r,c)}isBrokenEdge(e,s,o){let t;if(s.x===o.x){let i=Math.min(s.y,o.y);t=e.vEdges[i][s.x].type}else{let i=Math.min(s.x,o.x);t=e.hEdges[s.y][i].type}return t===1||t===2}isAbsentEdge(e,s,o){if(s.x===o.x){let t=Math.min(s.y,o.y);return e.vEdges[t][s.x].type===2}else{let t=Math.min(s.x,o.x);return e.hEdges[s.y][t].type===2}}getMissedHexagons(e,s){let o=new Set;for(let i=0;i<s.length-1;i++)o.add(this.getEdgeKey(s[i],s[i+1]));let t=[];for(let i=0;i<=e.rows;i++)for(let n=0;n<e.cols;n++)if(e.hEdges[i][n].type===3){let r=this.getEdgeKey({x:n,y:i},{x:n+1,y:i});o.has(r)||t.push({type:"h",r:i,c:n})}for(let i=0;i<e.rows;i++)for(let n=0;n<=e.cols;n++)if(e.vEdges[i][n].type===3){let r=this.getEdgeKey({x:n,y:i},{x:n,y:i+1});o.has(r)||t.push({type:"v",r:i,c:n})}return t}validateWithErasers(e,s,o){let t=[];for(let n=0;n<s.length;n++){let r=s[n],c=r.filter(u=>e.cells[u.y][u.x].type===5),h=r.filter(u=>e.cells[u.y][u.x].type!==0&&e.cells[u.y][u.x].type!==5),l=[];for(let u=0;u<o.length;u++)this.isHexagonAdjacentToRegion(e,o[u],r)&&l.push(u);let a=this.getPossibleErasures(e,r,c,h,l);if(a.length===0)return{isValid:!1,errorReason:`Constraints failed in region ${n}`};a.sort((u,f)=>{let d=u.invalidatedCells.length+u.invalidatedHexagons.length,p=f.invalidatedCells.length+f.invalidatedHexagons.length;return d-p}),t.push(a)}let i=this.findGlobalAssignment(t,o.length);return i?{isValid:!0,invalidatedCells:i.invalidatedCells,invalidatedEdges:i.invalidatedHexIndices.map(n=>o[n])}:{isValid:!1,errorReason:"Could not satisfy all constraints with available erasers"}}isHexagonAdjacentToRegion(e,s,o){let t=new Set(o.map(i=>`${i.x},${i.y}`));if(s.type==="h"){if(s.r>0&&t.has(`${s.c},${s.r-1}`)||s.r<e.rows&&t.has(`${s.c},${s.r}`))return!0}else if(s.c>0&&t.has(`${s.c-1},${s.r}`)||s.c<e.cols&&t.has(`${s.c},${s.r}`))return!0;return!1}getPossibleErasures(e,s,o,t,i){let n=[],r=o.length;if(r===0)return this.checkRegionValid(e,s,[],[])&&n.push({invalidatedCells:[],invalidatedHexagons:[],isValid:!0}),n;let c=[...t.map(l=>({type:"cell",pos:l})),...i.map(l=>({type:"hex",index:l}))],h=this.checkRegionValid(e,s,[],[])&&i.length===0;for(let l=0;l<=r;l++){let a=this.getNCombinations(o,l);for(let u of a){let f=new Set(u.map(p=>`${p.x},${p.y}`)),d=o.filter(p=>!f.has(`${p.x},${p.y}`));for(let p=0;p<=c.length;p++){if(d.length!==l+p)continue;let v=this.getNCombinations(c,p);for(let b of v){let x=b.filter(C=>C.type==="cell").map(C=>C.pos),k=b.filter(C=>C.type==="hex").map(C=>C.index);if(this.checkRegionValid(e,s,[...x,...u],d)){let C=!0;if(h)p>0&&(C=!1);else for(let M=0;M<b.length;M++){let H=[...b.slice(0,M),...b.slice(M+1)],z=H.filter(m=>m.type==="cell").map(m=>m.pos),N=new Set(H.filter(m=>m.type==="hex").map(m=>m.index)),P=i.every(m=>N.has(m));if(this.checkRegionValid(e,s,z,d)&&P){C=!1;break}}C&&n.push({invalidatedCells:[...x,...u],invalidatedHexagons:k,isValid:!0})}}}}}return n}getNCombinations(e,s){let o=[],t=(i,n)=>{if(n.length===s){o.push([...n]);return}for(let r=i;r<e.length;r++)n.push(e[r]),t(r+1,n),n.pop()};return t(0,[]),o}checkRegionValid(e,s,o,t){let i=new Set(o.map(a=>`${a.x},${a.y}`)),n=new Set(t.map(a=>`${a.x},${a.y}`)),r=new Map,c=new Set,h=new Set,l=[];for(let a of s){if(i.has(`${a.x},${a.y}`))continue;let u=e.cells[a.y][a.x];if(u.type===0)continue;let f=u.type===5&&n.has(`${a.x},${a.y}`),d=u.type!==5;if(!f&&!d)continue;let p=u.color;p!==0&&r.set(p,(r.get(p)||0)+1),u.type===1?h.add(p):u.type===2?c.add(p):(u.type===3||u.type===4)&&u.shape&&l.push({shape:u.shape,rotatable:u.type===4})}if(h.size>1)return!1;for(let a of c)if(r.get(a)!==2)return!1;return!(l.length>0&&!this.checkTetrisConstraint(s,l))}findGlobalAssignment(e,s){let o=e.length,t=new Array(s).fill(0),i=[],n=[],r=c=>{if(c===o)return t.every(h=>h===1);for(let h of e[c]){let l=!0;for(let a of h.invalidatedHexagons)if(t[a]>0){l=!1;break}if(l){for(let a of h.invalidatedHexagons)t[a]++,n.push(a);if(i.push(...h.invalidatedCells),r(c+1))return!0;for(let a of h.invalidatedHexagons)t[a]--,n.pop();for(let a=0;a<h.invalidatedCells.length;a++)i.pop()}}return!1};return r(0)?{invalidatedCells:i,invalidatedHexIndices:n}:null}checkTetrisConstraint(e,s){if(s.reduce((a,u)=>a+this.getShapeArea(u.shape),0)!==e.length)return!1;let t=Math.min(...e.map(a=>a.x)),i=Math.min(...e.map(a=>a.y)),n=Math.max(...e.map(a=>a.x)),r=Math.max(...e.map(a=>a.y)),c=n-t+1,h=r-i+1,l=Array.from({length:h},()=>Array(c).fill(!1));for(let a of e)l[a.y-i][a.x-t]=!0;return this.canTile(l,s)}getShapeArea(e){let s=0;for(let o of e)for(let t of o)t&&s++;return s}canTile(e,s){let o=-1,t=-1;for(let i=0;i<e.length;i++){for(let n=0;n<e[0].length;n++)if(e[i][n]){o=i,t=n;break}if(o!==-1)break}if(o===-1)return s.length===0;if(s.length===0)return!1;for(let i=0;i<s.length;i++){let n=s[i],r=[...s.slice(0,i),...s.slice(i+1)],c=n.rotatable?this.getAllRotations(n.shape):[n.shape];for(let h of c){let l=[];for(let a=0;a<h.length;a++)for(let u=0;u<h[0].length;u++)h[a][u]&&l.push({r:a,c:u});for(let a of l){let u=o-a.r,f=t-a.c;if(this.canPlace(e,h,u,f)){if(this.placePiece(e,h,u,f,!1),this.canTile(e,r))return!0;this.placePiece(e,h,u,f,!0)}}}}return!1}canPlace(e,s,o,t){for(let i=0;i<s.length;i++)for(let n=0;n<s[0].length;n++)if(s[i][n]){let r=o+i,c=t+n;if(r<0||r>=e.length||c<0||c>=e[0].length||!e[r][c])return!1}return!0}placePiece(e,s,o,t,i){for(let n=0;n<s.length;n++)for(let r=0;r<s[0].length;r++)s[n][r]&&(e[o+n][t+r]=i)}getAllRotations(e){let s=[],o=new Set,t=e;for(let i=0;i<4;i++){let n=JSON.stringify(t);o.has(n)||(s.push(t),o.add(n)),t=this.rotate90(t)}return s}rotate90(e){let s=e.length,o=e[0].length,t=Array.from({length:o},()=>Array(s).fill(0));for(let i=0;i<s;i++)for(let n=0;n<o;n++)t[n][s-1-i]=e[i][n];return t}calculateRegions(e,s){let o=[],t=new Set,i=new Set;for(let r=0;r<s.length-1;r++)i.add(this.getEdgeKey(s[r],s[r+1]));let n=this.getExternalCells(e);for(let r=0;r<e.rows;r++)for(let c=0;c<e.cols;c++){if(t.has(`${c},${r}`)||n.has(`${c},${r}`))continue;let h=[],l=[{x:c,y:r}];for(t.add(`${c},${r}`);l.length>0;){let a=l.shift();h.push(a);let u=[{nx:a.x,ny:a.y-1,p1:{x:a.x,y:a.y},p2:{x:a.x+1,y:a.y}},{nx:a.x,ny:a.y+1,p1:{x:a.x,y:a.y+1},p2:{x:a.x+1,y:a.y+1}},{nx:a.x-1,ny:a.y,p1:{x:a.x,y:a.y},p2:{x:a.x,y:a.y+1}},{nx:a.x+1,ny:a.y,p1:{x:a.x+1,y:a.y},p2:{x:a.x+1,y:a.y+1}}];for(let f of u)if(f.nx>=0&&f.nx<e.cols&&f.ny>=0&&f.ny<e.rows){let d=`${f.nx},${f.ny}`;if(!t.has(d)&&!n.has(d)){let p=this.getEdgeKey(f.p1,f.p2);!i.has(p)&&!this.isAbsentEdge(e,f.p1,f.p2)&&(t.add(d),l.push({x:f.nx,y:f.ny}))}}}o.push(h)}return o}getExternalCells(e){let s=new Set,o=[];for(let t=0;t<e.cols;t++)e.hEdges[0][t].type===2&&(s.has(`${t},0`)||(s.add(`${t},0`),o.push({x:t,y:0}))),e.hEdges[e.rows][t].type===2&&(s.has(`${t},${e.rows-1}`)||(s.add(`${t},${e.rows-1}`),o.push({x:t,y:e.rows-1})));for(let t=0;t<e.rows;t++)e.vEdges[t][0].type===2&&(s.has(`0,${t}`)||(s.add(`0,${t}`),o.push({x:0,y:t}))),e.vEdges[t][e.cols].type===2&&(s.has(`${e.cols-1},${t}`)||(s.add(`${e.cols-1},${t}`),o.push({x:e.cols-1,y:t})));for(;o.length>0;){let t=o.shift(),i=[{nx:t.x,ny:t.y-1,edge:e.hEdges[t.y][t.x]},{nx:t.x,ny:t.y+1,edge:e.hEdges[t.y+1][t.x]},{nx:t.x-1,ny:t.y,edge:e.vEdges[t.y][t.x]},{nx:t.x+1,ny:t.y,edge:e.vEdges[t.y][t.x+1]}];for(let n of i)n.nx>=0&&n.nx<e.cols&&n.ny>=0&&n.ny<e.rows&&!s.has(`${n.nx},${n.ny}`)&&n.edge.type===2&&(s.add(`${n.nx},${n.ny}`),o.push({x:n.nx,y:n.ny}))}return s}getEdgeKey(e,s){return e.x<s.x||e.x===s.x&&e.y<s.y?`${e.x},${e.y}-${s.x},${s.y}`:`${s.x},${s.y}-${e.x},${e.y}`}calculateDifficulty(e){let s=e.rows,o=e.cols,t=o+1,i=(s+1)*t,n=Array.from({length:i},()=>[]),r=[],c=[],h=new Set;for(let P=0;P<=s;P++)for(let m=0;m<=o;m++){let y=P*t+m;if(e.nodes[P][m].type===1&&r.push(y),e.nodes[P][m].type===2&&c.push(y),m<o){let O=y+1,I=e.hEdges[P][m].type,w=I===3,S=I===1||I===2;n[y].push({next:O,isHexagon:w,isBroken:S}),n[O].push({next:y,isHexagon:w,isBroken:S}),w&&h.add(this.getEdgeKey({x:m,y:P},{x:m+1,y:P}))}if(P<s){let O=y+t,I=e.vEdges[P][m].type,w=I===3,S=I===1||I===2;n[y].push({next:O,isHexagon:w,isBroken:S}),n[O].push({next:y,isHexagon:w,isBroken:S}),w&&h.add(this.getEdgeKey({x:m,y:P},{x:m,y:P+1}))}}let l={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},a=h.size,u=new Set,f=Math.max(1e3,s*o*200);for(let P of r)this.exploreSearchSpace(e,P,1n<<BigInt(P),[P],0,a,n,c,u,l,f);if(l.solutions===0)return 0;let d=h.size,p=new Set;h.size>0&&p.add(999);let v=0,b=0;for(let P=0;P<s;P++)for(let m=0;m<o;m++){let y=e.cells[P][m];y.type!==0&&(d++,p.add(y.type),y.type===3?v++:y.type===4&&(v++,b++))}let x=l.branchingPoints/(l.totalNodesVisited||1),k=Math.log10(l.totalNodesVisited+1),A=(x*10+k*1.5)/(Math.log2(l.solutions+1)*.5+1);v>0&&(A+=b*.5,A+=(v-b)*.2);let C=s*o,M=d/C,H=M<.25?Math.pow(M/.25,4):1,z=p.size<=1?.5:1;A*=H*z;let N=Math.log2(C)/5;return A*=N,Math.max(.01,Math.min(1,A/4))}exploreSearchSpace(e,s,o,t,i,n,r,c,h,l,a){if(l.totalNodesVisited++,l.maxDepth=Math.max(l.maxDepth,t.length),l.totalNodesVisited>a)return;if(c.includes(s)){if(i===n){let f={points:t.map(d=>({x:d%(e.cols+1),y:Math.floor(d/(e.cols+1))}))};if(this.validate(e,f).isValid){let d=this.getFingerprint(e,f.points);h.has(d)||(h.add(d),l.solutions++)}}return}if(!this.canReachEndOptimized(s,o,r,c)){l.backtracks++;return}let u=[];for(let f of r[s]){if(f.isBroken||o&1n<<BigInt(f.next))continue;let d=!0;for(let p of r[s])if(p.isHexagon){let v=t.length>=2&&p.next===t[t.length-2],b=p.next===f.next;if(!v&&!b){d=!1;break}}d&&u.push(f)}if(u.length>1&&l.branchingPoints++,e.rows*e.cols>30)for(let f=u.length-1;f>0;f--){let d=Math.floor(Math.random()*(f+1));[u[f],u[d]]=[u[d],u[f]]}for(let f of u)if(t.push(f.next),this.exploreSearchSpace(e,f.next,o|1n<<BigInt(f.next),t,i+(f.isHexagon?1:0),n,r,c,h,l,a),t.pop(),l.totalNodesVisited>a)return}countSolutions(e,s=100){let o=e.rows,t=e.cols,i=t+1,n=(o+1)*i,r=Array.from({length:n},()=>[]),c=[],h=[],l=new Set;for(let f=0;f<=o;f++)for(let d=0;d<=t;d++){let p=f*i+d;if(e.nodes[f][d].type===1&&c.push(p),e.nodes[f][d].type===2&&h.push(p),d<t){let v=p+1,b=e.hEdges[f][d].type,x=b===3,k=b===1||b===2;r[p].push({next:v,isHexagon:x,isBroken:k}),r[v].push({next:p,isHexagon:x,isBroken:k}),x&&l.add(this.getEdgeKey({x:d,y:f},{x:d+1,y:f}))}if(f<o){let v=p+i,b=e.vEdges[f][d].type,x=b===3,k=b===1||b===2;r[p].push({next:v,isHexagon:x,isBroken:k}),r[v].push({next:p,isHexagon:x,isBroken:k}),x&&l.add(this.getEdgeKey({x:d,y:f},{x:d,y:f+1}))}}let a=new Set,u=l.size;for(let f of c)this.findPathsOptimized(e,f,1n<<BigInt(f),[f],0,u,r,h,a,s);return a.size}findPathsOptimized(e,s,o,t,i,n,r,c,h,l){if(!(h.size>=l)){if(c.includes(s)){if(i===n){let a={points:t.map(u=>({x:u%(e.cols+1),y:Math.floor(u/(e.cols+1))}))};this.validate(e,a).isValid&&h.add(this.getFingerprint(e,a.points))}return}if(this.canReachEndOptimized(s,o,r,c))for(let a of r[s]){if(a.isBroken||o&1n<<BigInt(a.next))continue;let u=!0;for(let f of r[s])if(f.isHexagon){let d=t.length>=2&&f.next===t[t.length-2],p=f.next===a.next;if(!d&&!p){u=!1;break}}if(u&&(t.push(a.next),this.findPathsOptimized(e,a.next,o|1n<<BigInt(a.next),t,i+(a.isHexagon?1:0),n,r,c,h,l),t.pop(),h.size>=l))return}}}canReachEndOptimized(e,s,o,t){let i=[e],n=s,r=0;for(;r<i.length;){let c=i[r++];if(t.includes(c))return!0;for(let h of o[c])!h.isBroken&&!(n&1n<<BigInt(h.next))&&(n|=1n<<BigInt(h.next),i.push(h.next))}return!1}getFingerprint(e,s){return this.calculateRegions(e,s).map(i=>i.map(r=>e.cells[r.y][r.x]).filter(r=>r.type!==0).map(r=>`${r.type}:${r.color}`).sort().join(",")).sort().filter(i=>i.length>0).join("|")||"empty"}};var j=class{generate(e,s,o={}){let t=o.difficulty??.5,i=new G,n=null,r=-1,c=e*s>30?50:80;for(let h=0;h<c;h++){let l=this.generateOnce(e,s,o);if(!this.checkAllRequestedConstraintsPresent(l,o))continue;let a=i.calculateDifficulty(l);if(a===0)continue;let u=Math.abs(a-t);if((n===null||u<Math.abs(r-t))&&(r=a,n=l),t>.8&&a>.8||u<.05)break}return n||this.generateOnce(e,s,o)}generateOnce(e,s,o){let t=new q(e,s),i={x:0,y:e},n={x:s,y:0};t.nodes[i.y][i.x].type=1,t.nodes[n.y][n.x].type=2;let r=this.generateRandomPath(t,i,n);return this.applyConstraintsBasedOnPath(t,r,o),o.useBrokenEdges&&this.applyBrokenEdges(t,r,o),this.cleanGrid(t),t}generateRandomPath(e,s,o){let t=new Set,i=[],n=r=>{if(t.add(`${r.x},${r.y}`),i.push(r),r.x===o.x&&r.y===o.y)return!0;let c=this.getValidNeighbors(e,r,t);this.shuffleArray(c);for(let h of c)if(n(h))return!0;return i.pop(),!1};return n(s),i}getValidNeighbors(e,s,o){let t=[],i=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let n of i){let r=s.x+n.x,c=s.y+n.y;r>=0&&r<=e.cols&&c>=0&&c<=e.rows&&(o.has(`${r},${c}`)||t.push({x:r,y:c}))}return t}applyBrokenEdges(e,s,o){let t=o.complexity??.5,i=new Set;for(let h=0;h<s.length-1;h++)i.add(this.getEdgeKey(s[h],s[h+1]));let n=[];for(let h=0;h<=e.rows;h++)for(let l=0;l<e.cols;l++){let a={x:l,y:h},u={x:l+1,y:h};i.has(this.getEdgeKey(a,u))||n.push({type:"h",r:h,c:l,p1:a,p2:u})}for(let h=0;h<e.rows;h++)for(let l=0;l<=e.cols;l++){let a={x:l,y:h},u={x:l,y:h+1};i.has(this.getEdgeKey(a,u))||n.push({type:"v",r:h,c:l,p1:a,p2:u})}this.shuffleArray(n);let r=Math.max(1,Math.floor(t*(e.rows*e.cols)/4)),c=0;for(let h of n){if(c>=r)break;let l=Math.random()<.8?1:2;l===2&&this.isAdjacentToMark(e,h)&&(l=1),h.type==="h"?e.hEdges[h.r][h.c].type=l:e.vEdges[h.r][h.c].type=l,c++}for(let h=0;h<=e.rows;h++)for(let l=0;l<=e.cols;l++){let a=[];if(l>0&&a.push({e:e.hEdges[h][l-1],type:"h",r:h,c:l-1}),l<e.cols&&a.push({e:e.hEdges[h][l],type:"h",r:h,c:l}),h>0&&a.push({e:e.vEdges[h-1][l],type:"v",r:h-1,c:l}),h<e.rows&&a.push({e:e.vEdges[h][l],type:"v",r:h,c:l}),a.every(u=>u.e.type===1||u.e.type===2)&&a.every(u=>!this.isAdjacentToMark(e,u)))for(let u of a)u.e.type=2}}cleanGrid(e){let s=[];for(let n=0;n<=e.rows;n++)for(let r=0;r<=e.cols;r++)e.nodes[n][r].type===1&&s.push({x:r,y:n});let o=new Set,t=[...s];for(let n of s)o.add(`${n.x},${n.y}`);for(;t.length>0;){let n=t.shift(),r=[{nx:n.x,ny:n.y-1,edge:e.vEdges[n.y-1]?.[n.x]},{nx:n.x,ny:n.y+1,edge:e.vEdges[n.y]?.[n.x]},{nx:n.x-1,ny:n.y,edge:e.hEdges[n.y]?.[n.x-1]},{nx:n.x+1,ny:n.y,edge:e.hEdges[n.y]?.[n.x]}];for(let c of r)c.edge&&c.edge.type!==2&&(o.has(`${c.nx},${c.ny}`)||(o.add(`${c.nx},${c.ny}`),t.push({x:c.nx,y:c.ny})))}for(let n=0;n<=e.rows;n++)for(let r=0;r<e.cols;r++)(!o.has(`${r},${n}`)||!o.has(`${r+1},${n}`))&&(e.hEdges[n][r].type=2);for(let n=0;n<e.rows;n++)for(let r=0;r<=e.cols;r++)(!o.has(`${r},${n}`)||!o.has(`${r},${n+1}`))&&(e.vEdges[n][r].type=2);let i=this.getExternalCells(e);for(let n of i){let[r,c]=n.split(",").map(Number);e.cells[c][r].type=0}}getExternalCells(e){let s=new Set,o=[];for(let t=0;t<e.cols;t++)e.hEdges[0][t].type===2&&(s.has(`${t},0`)||(s.add(`${t},0`),o.push({x:t,y:0}))),e.hEdges[e.rows][t].type===2&&(s.has(`${t},${e.rows-1}`)||(s.add(`${t},${e.rows-1}`),o.push({x:t,y:e.rows-1})));for(let t=0;t<e.rows;t++)e.vEdges[t][0].type===2&&(s.has(`0,${t}`)||(s.add(`0,${t}`),o.push({x:0,y:t}))),e.vEdges[t][e.cols].type===2&&(s.has(`${e.cols-1},${t}`)||(s.add(`${e.cols-1},${t}`),o.push({x:e.cols-1,y:t})));for(;o.length>0;){let t=o.shift(),i=[{nx:t.x,ny:t.y-1,edge:e.hEdges[t.y][t.x]},{nx:t.x,ny:t.y+1,edge:e.hEdges[t.y+1][t.x]},{nx:t.x-1,ny:t.y,edge:e.vEdges[t.y][t.x]},{nx:t.x+1,ny:t.y,edge:e.vEdges[t.y][t.x+1]}];for(let n of i)n.nx>=0&&n.nx<e.cols&&n.ny>=0&&n.ny<e.rows&&!s.has(`${n.nx},${n.ny}`)&&n.edge.type===2&&(s.add(`${n.nx},${n.ny}`),o.push({x:n.nx,y:n.ny}))}return s}isAdjacentToMark(e,s){if(s.type==="h"){if(s.r>0&&e.cells[s.r-1][s.c].type!==0||s.r<e.rows&&e.cells[s.r][s.c].type!==0)return!0}else if(s.c>0&&e.cells[s.r][s.c-1].type!==0||s.c<e.cols&&e.cells[s.r][s.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let s=0;s<e.rows;s++)for(let o=0;o<e.cols;o++){if(e.cells[s][o].type===0)continue;if([e.hEdges[s][o],e.hEdges[s+1][o],e.vEdges[s][o],e.vEdges[s][o+1]].every(i=>i.type===1||i.type===2))return!0}return!1}getEdgeKey(e,s){return e.x<s.x||e.x===s.x&&e.y<s.y?`${e.x},${e.y}-${s.x},${s.y}`:`${s.x},${s.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,s,o){let t=o.complexity??.5,i=o.useHexagons??!0,n=o.useSquares??!0,r=o.useStars??!0,c=o.useTetris??!1,h=o.useEraser??!1,l=0,a=0,u=0,f=0,d=0,p=0,v=Math.floor(e.rows*e.cols*.45);if(i){let b=o.difficulty??.5;for(let x=0;x<s.length-1;x++){let A=this.getValidNeighbors(e,s[x],new Set).length>2,C=t*.4;A&&(C=b<.4?C*1:C*.5),Math.random()<C&&(this.setEdgeHexagon(e,s[x],s[x+1]),l++)}if(l===0&&s.length>=2){let x=Math.floor(Math.random()*(s.length-1));this.setEdgeHexagon(e,s[x],s[x+1])}}if(n||r||c||h){let b=this.calculateRegions(e,s),x=[1,2,3,4],k=Array.from({length:b.length},(M,H)=>H);this.shuffleArray(k);let A=new Set,C={square:n,star:r,tetris:c,eraser:h};for(let M=0;M<k.length;M++){let H=k[M],z=b[H],N=k.length-M,P=C.square&&a===0||C.star&&u===0||C.tetris&&f===0||C.eraser&&d===0,m=.2+t*.6;if(P&&N<=3?m=1:P&&N<=6&&(m=.7),Math.random()>m)continue;let y=[...z];this.shuffleArray(y);let O=x[Math.floor(Math.random()*x.length)];if(n&&!r&&N<=2&&A.size===1){let w=x.filter(S=>!A.has(S));w.length>0&&(O=w[Math.floor(Math.random()*w.length)])}let I=n&&Math.random()<.5+t*.3;if(n&&a===0&&N<=2&&(I=!0),n&&!r&&N<=2&&A.size<2&&a>0&&(I=!0),I&&y.length>0){let w=Math.min(y.length,Math.max(4,Math.floor(z.length/4))),S=Math.floor(Math.random()*(w/2))+Math.ceil(w/2);for(let R=0;R<S&&y.length!==0;R++){let $=y.pop();e.cells[$.y][$.x].type=1,e.cells[$.y][$.x].color=O,a++,A.add(O)}}if(c&&p<v){let w=Math.random()<.1+t*.4;f===0&&N<=2&&(w=!0);let S=f===0&&N<=2?6:4;if(w&&y.length>0&&z.length<=S*4&&p+z.length<=v){let R=this.generateTiling(z,S,o);if(R){for(let $ of R){if(y.length===0)break;let E=y.pop();e.cells[E.y][E.x].type=$.isRotated?4:3,e.cells[E.y][E.x].shape=$.isRotated?$.displayShape:$.shape;let T=0;if(r&&Math.random()<.5){let g=x.filter(B=>B!==4);T=g[Math.floor(Math.random()*g.length)]}e.cells[E.y][E.x].color=T,f++}p+=z.length}}}if(h&&d<1){let w=.05+t*.2,S=Math.random()<w;if(N<=2&&(S=!0),S&&y.length>=1){let R=[];r&&R.push("star"),n&&R.push("square");let $=[];i&&($=this.getRegionBoundaryEdges(e,z,s),$.length>0&&R.push("hexagon")),c&&R.push("tetris");let E=R.length>0?R[Math.floor(Math.random()*R.length)]:null;y.length>=2&&(!E||Math.random()<.01)&&(E="eraser");let T=!1;if(E==="hexagon"){let g=$[Math.floor(Math.random()*$.length)];g.type==="h"?e.hEdges[g.r][g.c].type=3:e.vEdges[g.r][g.c].type=3,l++,T=!0}else if(E==="square"&&y.length>=2){let g=y.pop();e.cells[g.y][g.x].type=1;let B=z.find(D=>e.cells[D.y][D.x].type===1),V=B?e.cells[B.y][B.x].color:void 0;e.cells[g.y][g.x].color=x.find(D=>D!==V)||3,a++,T=!0}else if(E==="star"&&y.length>=2){let g=y.pop();e.cells[g.y][g.x].type=2,e.cells[g.y][g.x].color=x[Math.floor(Math.random()*x.length)],u++,T=!0}else if(E==="tetris"&&y.length>=2){let g=this.generateTiling(z,4,o),B=[];if(g&&g.length>0){let V=0;for(let D of g){let W=this.getShapeArea(D.shape);if(V+W<z.length)B.push(D),V+=W;else break}}if(B.length===0&&z.length>1&&(B=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),B.length>0){for(let V of B){if(y.length<2)break;let D=y.pop();e.cells[D.y][D.x].type=V.isRotated?4:3,e.cells[D.y][D.x].shape=V.isRotated?V.displayShape:V.shape;let W=0;if(r&&Math.random()<.3){let J=x.filter(Q=>Q!==4);W=J[Math.floor(Math.random()*J.length)]}e.cells[D.y][D.x].color=W,f++}T=!0}}else if(E==="eraser"&&y.length>=2){let g=y.pop();e.cells[g.y][g.x].type=5,e.cells[g.y][g.x].color=2,d++,T=!0}if(!T&&y.length>=2){let g=y.pop();e.cells[g.y][g.x].type=5,e.cells[g.y][g.x].color=2,d++,T=!0}if(T){let g=y.pop();e.cells[g.y][g.x].type=5;let B=2;r&&Math.random()<.4&&(B=x[Math.floor(Math.random()*x.length)]),e.cells[g.y][g.x].color=B,d++}}}if(r){let w=Math.max(1,Math.floor(z.length/8));for(let S=0;S<w;S++)for(let R of x){if(y.length<1)break;if(Math.random()>.3+t*.4)continue;let $=z.filter(E=>e.cells[E.y][E.x].color===R).length;if($===1){let E=y.pop();e.cells[E.y][E.x].type=2,e.cells[E.y][E.x].color=R,u++}else if($===0&&y.length>=2)for(let E=0;E<2;E++){let T=y.pop();e.cells[T.y][T.x].type=2,e.cells[T.y][T.x].color=R,u++}}}}if(n&&!r&&A.size<2){for(let M of b)if(M.every(H=>e.cells[H.y][H.x].type===0)){let H=x.find(N=>!A.has(N))||2,z=M[Math.floor(Math.random()*M.length)];e.cells[z.y][z.x].type=1,e.cells[z.y][z.x].color=H,A.add(H),a++;break}}}}calculateRegions(e,s){let o=[],t=new Set,i=new Set;for(let n=0;n<s.length-1;n++)i.add(this.getEdgeKey(s[n],s[n+1]));for(let n=0;n<e.rows;n++)for(let r=0;r<e.cols;r++){if(t.has(`${r},${n}`))continue;let c=[],h=[{x:r,y:n}];for(t.add(`${r},${n}`);h.length>0;){let l=h.shift();c.push(l);let a=[{dx:0,dy:-1,p1:{x:l.x,y:l.y},p2:{x:l.x+1,y:l.y}},{dx:0,dy:1,p1:{x:l.x,y:l.y+1},p2:{x:l.x+1,y:l.y+1}},{dx:-1,dy:0,p1:{x:l.x,y:l.y},p2:{x:l.x,y:l.y+1}},{dx:1,dy:0,p1:{x:l.x+1,y:l.y},p2:{x:l.x+1,y:l.y+1}}];for(let u of a){let f=l.x+u.dx,d=l.y+u.dy;f>=0&&f<e.cols&&d>=0&&d<e.rows&&!t.has(`${f},${d}`)&&!i.has(this.getEdgeKey(u.p1,u.p2))&&!this.isAbsentEdge(e,u.p1,u.p2)&&(t.add(`${f},${d}`),h.push({x:f,y:d}))}}o.push(c)}return o}isAbsentEdge(e,s,o){if(s.x===o.x){let t=Math.min(s.y,o.y);return e.vEdges[t][s.x].type===2}else{let t=Math.min(s.x,o.x);return e.hEdges[s.y][t].type===2}}getRegionBoundaryEdges(e,s,o){let t=new Set;for(let r=0;r<o.length-1;r++)t.add(this.getEdgeKey(o[r],o[r+1]));let i=[];for(let r of s){let c=[{type:"h",r:r.y,c:r.x},{type:"h",r:r.y+1,c:r.x},{type:"v",r:r.y,c:r.x},{type:"v",r:r.y,c:r.x+1}];for(let h of c){let l=h.type==="h"?{x:h.c,y:h.r}:{x:h.c,y:h.r},a=h.type==="h"?{x:h.c+1,y:h.r}:{x:h.c,y:h.r+1},u=this.getEdgeKey(l,a);!t.has(u)&&!this.isAbsentEdge(e,l,a)&&i.push(h)}}let n=new Map;for(let r of i)n.set(`${r.type},${r.r},${r.c}`,r);return Array.from(n.values())}setEdgeHexagon(e,s,o){s.x===o.x?e.vEdges[Math.min(s.y,o.y)][s.x].type=3:e.hEdges[s.y][Math.min(s.x,o.x)].type=3}checkAllRequestedConstraintsPresent(e,s){let o=s.useHexagons??!0,t=s.useSquares??!0,i=s.useStars??!0,n=s.useTetris??!1,r=s.useEraser??!1;if(s.useBrokenEdges??!1){let h=!1;for(let l=0;l<=e.rows;l++)for(let a=0;a<e.cols;a++)if(e.hEdges[l][a].type===1||e.hEdges[l][a].type===2){h=!0;break}if(!h){for(let l=0;l<e.rows;l++)for(let a=0;a<=e.cols;a++)if(e.vEdges[l][a].type===1||e.vEdges[l][a].type===2){h=!0;break}}if(!h)return!1}if(o){let h=!1;for(let l=0;l<=e.rows;l++)for(let a=0;a<e.cols;a++)if(e.hEdges[l][a].type===3){h=!0;break}if(!h){for(let l=0;l<e.rows;l++)for(let a=0;a<=e.cols;a++)if(e.vEdges[l][a].type===3){h=!0;break}}if(!h)return!1}if(t||i||n||r){let h=!1,l=!1,a=!1,u=!1,f=new Set;for(let d=0;d<e.rows;d++)for(let p=0;p<e.cols;p++){let v=e.cells[d][p].type;v===1&&(h=!0,f.add(e.cells[d][p].color)),v===2&&(l=!0),(v===3||v===4)&&(a=!0),v===5&&(u=!0)}if(t&&!h||i&&!l||n&&!a||r&&!u||t&&h&&!l&&f.size<2)return!1}return!this.hasIsolatedMark(e)}generateTiling(e,s,o){let t=Math.min(...e.map(a=>a.x)),i=Math.min(...e.map(a=>a.y)),n=Math.max(...e.map(a=>a.x)),r=Math.max(...e.map(a=>a.y)),c=n-t+1,h=r-i+1,l=Array.from({length:h},()=>Array(c).fill(!1));for(let a of e)l[a.y-i][a.x-t]=!0;return this.tilingDfs(l,[],s,o)}tilingDfs(e,s,o,t){let i=-1,n=-1;for(let h=0;h<e.length;h++){for(let l=0;l<e[0].length;l++)if(e[h][l]){i=h,n=l;break}if(i!==-1)break}if(i===-1)return s;if(s.length>=o)return null;let r=t.difficulty??.5,c=[...this.TETRIS_SHAPES];this.shuffleArray(c),r>.6&&c.sort((h,l)=>this.getShapeArea(l)-this.getShapeArea(h));for(let h of c){let l=this.isRotationallyInvariant(h),a=l?[h]:this.getAllRotations(h);this.shuffleArray(a);for(let u of a){let f=[];for(let d=0;d<u.length;d++)for(let p=0;p<u[0].length;p++)u[d][p]&&f.push({r:d,c:p});for(let d of f){let p=i-d.r,v=n-d.c;if(this.canPlace(e,u,p,v)){this.placePiece(e,u,p,v,!1);let b=this.tilingDfs(e,[...s,{shape:u,displayShape:h,isRotated:!l&&Math.random()<.3+r*.6}],o,t);if(b)return b;this.placePiece(e,u,p,v,!0)}}}}return null}getShapeArea(e){let s=0;for(let o of e)for(let t of o)t&&s++;return s}isRotationallyInvariant(e){let s=this.getShapeArea(e);return s===1||s===4&&e.length===2&&e[0].length===2}getAllRotations(e){let s=[],o=new Set,t=e;for(let i=0;i<4;i++){let n=JSON.stringify(t);o.has(n)||(s.push(t),o.add(n)),t=this.rotate90(t)}return s}rotate90(e){let s=e.length,o=e[0].length,t=Array.from({length:o},()=>Array(s).fill(0));for(let i=0;i<s;i++)for(let n=0;n<o;n++)t[n][s-1-i]=e[i][n];return t}canPlace(e,s,o,t){for(let i=0;i<s.length;i++)for(let n=0;n<s[0].length;n++)if(s[i][n]){let r=o+i,c=t+n;if(r<0||r>=e.length||c<0||c>=e[0].length||!e[r][c])return!1}return!0}placePiece(e,s,o,t,i){for(let n=0;n<s.length;n++)for(let r=0;r<s[0].length;r++)s[n][r]&&(e[o+n][t+r]=i)}shuffleArray(e){for(let s=e.length-1;s>0;s--){let o=Math.floor(Math.random()*(s+1));[e[s],e[o]]=[e[o],e[s]]}}};var U=class{canvas;ctx;puzzle=null;options;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;invalidatedCells=[];invalidatedEdges=[];isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;constructor(e,s,o={}){if(typeof window>"u"){this.canvas={},this.ctx={},this.options=this.mergeOptions(o);return}if(typeof e=="string"){let i=document.getElementById(e);if(!(i instanceof HTMLCanvasElement))throw new Error(`Element with id "${e}" is not a canvas.`);this.canvas=i}else this.canvas=e;let t=this.canvas.getContext("2d");if(!t)throw new Error("Could not get 2D context.");this.ctx=t,this.ctx.imageSmoothingEnabled=!1,this.options=this.mergeOptions(o),s&&this.setPuzzle(s),this.initEvents(),this.animate()}mergeOptions(e){return{gridPadding:e.gridPadding??60,cellSize:e.cellSize??80,nodeRadius:e.nodeRadius??6,startNodeRadius:e.startNodeRadius??22,pathWidth:e.pathWidth??18,exitLength:e.exitLength??25,autoResize:e.autoResize??!0,colors:{path:e.colors?.path??"#ffcc00",grid:e.colors?.grid??"#555",node:e.colors?.node??"#555",hexagon:e.colors?.hexagon??"#ffcc00",colorMap:e.colors?.colorMap??{1:"#000",2:"#fff",3:"#f00",4:"#00f",0:"#f0f"}},onPathComplete:e.onPathComplete??(()=>{})}}setPuzzle(e){this.puzzle=e,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.invalidatedCells=[],this.invalidatedEdges=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw()}setOptions(e){this.options=this.mergeOptions({...this.options,...e}),this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}setValidationResult(e,s=[],o=[]){this.invalidatedCells=s,this.invalidatedEdges=o,e?(this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.startFade("#ff4444")}resizeCanvas(){!this.puzzle||!this.canvas||(this.canvas.width=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,this.canvas.height=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2)}initEvents(){typeof window>"u"||(this.canvas.addEventListener("mousedown",e=>this.handleStart(e)),window.addEventListener("mousemove",e=>this.handleMove(e)),window.addEventListener("mouseup",e=>this.handleEnd(e)),this.canvas.addEventListener("touchstart",e=>{e.preventDefault(),this.handleStart(e.touches[0])},{passive:!1}),window.addEventListener("touchmove",e=>{this.handleMove(e.touches[0])},{passive:!1}),window.addEventListener("touchend",e=>{this.handleEnd(e.changedTouches[0])},{passive:!1}))}getCanvasCoords(e,s){return{x:this.options.gridPadding+e*this.options.cellSize,y:this.options.gridPadding+s*this.options.cellSize}}getExitDir(e,s){return!this.puzzle||this.puzzle.nodes[s][e].type!==2?null:e===this.puzzle.cols?{x:1,y:0}:e===0?{x:-1,y:0}:s===0?{x:0,y:-1}:s===this.puzzle.rows?{x:0,y:1}:{x:1,y:0}}handleStart(e){if(!this.puzzle)return;this.cancelFade(),this.isSuccessFading=!1,this.invalidatedCells=[],this.invalidatedEdges=[];let s=this.canvas.getBoundingClientRect(),o=e.clientX-s.left,t=e.clientY-s.top;for(let i=0;i<=this.puzzle.rows;i++)for(let n=0;n<=this.puzzle.cols;n++)if(this.puzzle.nodes[i][n].type===1){let r=this.getCanvasCoords(n,i);if(Math.hypot(r.x-o,r.y-t)<this.options.startNodeRadius){this.isDrawing=!0,this.path=[{x:n,y:i}],this.currentMousePos=r,this.exitTipPos=null,this.draw();return}}}handleMove(e){if(!this.puzzle||!this.isDrawing)return;let s=this.canvas.getBoundingClientRect(),o=e.clientX-s.left,t=e.clientY-s.top,i=this.path[this.path.length-1],n=this.getCanvasCoords(i.x,i.y),r=o-n.x,c=t-n.y,h=this.getExitDir(i.x,i.y);if(h){let a=r*h.x+c*h.y;if(a>0){let u=Math.min(a,this.options.exitLength);this.currentMousePos={x:n.x+h.x*u,y:n.y+h.y*u},this.draw();return}}if(Math.abs(r)>Math.abs(c)){let a=r>0?1:-1,u={x:i.x+a,y:i.y},f=this.getEdgeType(i,u);if(u.x>=0&&u.x<=this.puzzle.cols&&f!==2){let d=f===1?this.options.cellSize*.35:this.options.cellSize;this.currentMousePos={x:n.x+Math.max(-d,Math.min(d,r)),y:n.y}}else this.currentMousePos=n}else{let a=c>0?1:-1,u={x:i.x,y:i.y+a},f=this.getEdgeType(i,u);if(u.y>=0&&u.y<=this.puzzle.rows&&f!==2){let d=f===1?this.options.cellSize*.35:this.options.cellSize;this.currentMousePos={x:n.x,y:n.y+Math.max(-d,Math.min(d,c))}}else this.currentMousePos=n}let l=[{x:i.x+1,y:i.y},{x:i.x-1,y:i.y},{x:i.x,y:i.y+1},{x:i.x,y:i.y-1}];for(let a of l)if(a.x>=0&&a.x<=this.puzzle.cols&&a.y>=0&&a.y<=this.puzzle.rows){let u=this.getCanvasCoords(a.x,a.y);if(Math.hypot(u.x-this.currentMousePos.x,u.y-this.currentMousePos.y)<this.options.cellSize*.3){let d=this.path.findIndex(p=>p.x===a.x&&p.y===a.y);d===-1?this.path.push(a):d===this.path.length-2&&this.path.pop()}}this.draw()}handleEnd(e){if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let s=this.path[this.path.length-1],o=this.getCanvasCoords(s.x,s.y),t=this.getExitDir(s.x,s.y);if(t&&Math.hypot(this.currentMousePos.x-o.x,this.currentMousePos.y-o.y)>this.options.exitLength*.1){this.exitTipPos={...this.currentMousePos},this.options.onPathComplete(this.path);return}this.exitTipPos=t?{...this.currentMousePos}:null,this.startFade("#ffcc00")}getEdgeType(e,s){if(!this.puzzle)return 2;if(e.x===s.x){let o=Math.min(e.y,s.y);return o<0||o>=this.puzzle.rows?2:this.puzzle.vEdges[o][e.x].type}else{let o=Math.min(e.x,s.x);return o<0||o>=this.puzzle.cols?2:this.puzzle.hEdges[e.y][o].type}}startFade(e="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=e,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){typeof window>"u"||(this.draw(),this.isFading&&(this.fadeOpacity-=.015,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0)),requestAnimationFrame(()=>this.animate()))}draw(){if(!this.puzzle||!this.ctx)return;let e=this.ctx;e.globalAlpha=1,e.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(e),this.drawConstraints(e),this.drawNodes(e),this.path.length===0&&!this.isDrawing&&this.drawRipples(e),this.isFading?this.drawPath(e,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos):this.path.length>0&&this.drawPath(e,this.path,this.isDrawing,this.options.colors.path,1,this.isDrawing?this.currentMousePos:this.exitTipPos)}drawRipples(e){if(!this.puzzle)return;let s=(Date.now()-this.startTime)/500;for(let o=0;o<=this.puzzle.rows;o++)for(let t=0;t<=this.puzzle.cols;t++)if(this.puzzle.nodes[o][t].type===2){let n=this.getCanvasCoords(t,o),r=this.getExitDir(t,o);if(!r)continue;let c={x:n.x+r.x*this.options.exitLength,y:n.y+r.y*this.options.exitLength},h=s%4,l=h*5,a=Math.max(0,1-h/3);e.beginPath(),e.arc(c.x,c.y,l,0,Math.PI*2),e.strokeStyle=`rgba(170, 170, 170, ${a*.4})`,e.lineWidth=2,e.stroke()}}drawGrid(e){if(!this.puzzle||!this.options.colors.grid)return;e.strokeStyle=this.options.colors.grid,e.lineWidth=12,e.lineCap="round";let s=(o,t,i)=>{if(i!==2)if(i===1){let r={x:o.x+(t.x-o.x)*.35,y:o.y+(t.y-o.y)*.35},c={x:o.x+(t.x-o.x)*(.5+.15),y:o.y+(t.y-o.y)*(.5+.15)};e.beginPath(),e.moveTo(o.x,o.y),e.lineTo(r.x,r.y),e.stroke(),e.beginPath(),e.moveTo(c.x,c.y),e.lineTo(t.x,t.y),e.stroke()}else e.beginPath(),e.moveTo(o.x,o.y),e.lineTo(t.x,t.y),e.stroke()};for(let o=0;o<=this.puzzle.rows;o++)for(let t=0;t<this.puzzle.cols;t++)s(this.getCanvasCoords(t,o),this.getCanvasCoords(t+1,o),this.puzzle.hEdges[o][t].type);for(let o=0;o<this.puzzle.rows;o++)for(let t=0;t<=this.puzzle.cols;t++)s(this.getCanvasCoords(t,o),this.getCanvasCoords(t,o+1),this.puzzle.vEdges[o][t].type)}drawConstraints(e){if(!this.puzzle)return;let s=Date.now();for(let t=0;t<this.puzzle.rows;t++)for(let i=0;i<this.puzzle.cols;i++){let n=this.puzzle.cells[t][i],r=this.getCanvasCoords(i+.5,t+.5),c=this.invalidatedCells.some(l=>l.x===i&&l.y===t),h=1;if(c){if(this.isFading)h=this.fadeOpacity;else if(this.isSuccessFading){let l=s-this.successFadeStartTime;h=Math.max(.3,1-l/1e3)}}if(h<1){let{canvas:l,ctx:a}=this.prepareOffscreen();this.drawConstraintItem(a,n,r),e.save(),e.globalAlpha=h,e.drawImage(l,0,0),e.restore()}else this.drawConstraintItem(e,n,r)}e.lineWidth=2;let o=8;for(let t=0;t<=this.puzzle.rows;t++)for(let i=0;i<this.puzzle.cols;i++)if(this.puzzle.hEdges[t][i].type===3){let n=this.getCanvasCoords(i+.5,t);if(e.save(),this.invalidatedEdges.some(c=>c.type==="h"&&c.r===t&&c.c===i)){if(this.isFading)e.globalAlpha*=this.fadeOpacity;else if(this.isSuccessFading){let c=s-this.successFadeStartTime;e.globalAlpha*=Math.max(.3,1-c/1e3)}}this.drawHexagon(e,n.x,n.y,o),e.restore()}for(let t=0;t<this.puzzle.rows;t++)for(let i=0;i<=this.puzzle.cols;i++)if(this.puzzle.vEdges[t][i].type===3){let n=this.getCanvasCoords(i,t+.5);if(e.save(),this.invalidatedEdges.some(c=>c.type==="v"&&c.r===t&&c.c===i)){if(this.isFading)e.globalAlpha*=this.fadeOpacity;else if(this.isSuccessFading){let c=s-this.successFadeStartTime;e.globalAlpha*=Math.max(.3,1-c/1e3)}}this.drawHexagon(e,n.x,n.y,o),e.restore()}}drawConstraintItem(e,s,o){s.type===1?(e.fillStyle=this.getColorCode(s.color),this.drawRoundedRect(e,o.x-26/2,o.y-26/2,26,26,8)):s.type===2?this.drawStar(e,o.x,o.y,12,16,8,s.color):s.type===3||s.type===4?this.drawTetris(e,o.x,o.y,s.shape||[],s.type===4,s.color):s.type===5&&this.drawEraser(e,o.x,o.y,14,3,s.color)}drawNodes(e){if(!this.puzzle)return;let s=(o,t)=>{let i=[];return o>0&&i.push(this.puzzle.hEdges[t][o-1].type),o<this.puzzle.cols&&i.push(this.puzzle.hEdges[t][o].type),t>0&&i.push(this.puzzle.vEdges[t-1][o].type),t<this.puzzle.rows&&i.push(this.puzzle.vEdges[t][o].type),i.length>0&&i.every(n=>n===2)};for(let o=0;o<=this.puzzle.rows;o++)for(let t=0;t<=this.puzzle.cols;t++){if(s(t,o))continue;let i=this.puzzle.nodes[o][t],n=this.getCanvasCoords(t,o);if(i.type===1)this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(n.x,n.y,this.options.startNodeRadius,0,Math.PI*2),e.fill();else if(i.type===2){let r=this.getExitDir(t,o);if(!r)continue;this.options.colors.node&&(e.strokeStyle=this.options.colors.node),e.lineWidth=12,e.lineCap="round",e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(n.x+r.x*this.options.exitLength,n.y+r.y*this.options.exitLength),e.stroke()}else this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(n.x,n.y,this.options.nodeRadius,0,Math.PI*2),e.fill()}}drawPath(e,s,o,t,i,n=null){if(!(s.length===0||!t))if(i<1){let{canvas:r,ctx:c}=this.prepareOffscreen();this.drawPathInternal(c,s,o,t,n),e.save(),e.globalAlpha=i,e.drawImage(r,0,0),e.restore()}else this.drawPathInternal(e,s,o,t,n)}drawPathInternal(e,s,o,t,i=null){e.save(),e.strokeStyle=t,e.fillStyle=t,e.lineWidth=this.options.pathWidth,e.lineCap="round",e.lineJoin="round",e.beginPath();let n=this.getCanvasCoords(s[0].x,s[0].y);e.moveTo(n.x,n.y);for(let r=1;r<s.length;r++){let c=this.getCanvasCoords(s[r].x,s[r].y);e.lineTo(c.x,c.y)}if(o||i){let r=i||this.currentMousePos;e.lineTo(r.x,r.y)}e.stroke(),e.beginPath(),e.arc(n.x,n.y,this.options.startNodeRadius,0,Math.PI*2),e.fill(),o&&(e.beginPath(),e.arc(this.currentMousePos.x,this.currentMousePos.y,this.options.pathWidth/2,0,Math.PI*2),e.fill()),e.restore()}drawRoundedRect(e,s,o,t,i,n){e.beginPath(),e.moveTo(s+n,o),e.lineTo(s+t-n,o),e.quadraticCurveTo(s+t,o,s+t,o+n),e.lineTo(s+t,o+i-n),e.quadraticCurveTo(s+t,o+i,s+t-n,o+i),e.lineTo(s+n,o+i),e.quadraticCurveTo(s,o+i,s,o+i-n),e.lineTo(s,o+n),e.quadraticCurveTo(s,o,s+n,o),e.closePath(),e.fill()}drawHexagon(e,s,o,t){if(this.options.colors.hexagon){e.fillStyle=this.options.colors.hexagon,e.beginPath();for(let i=0;i<6;i++){let n=Math.PI/3*i,r=s+t*Math.cos(n),c=o+t*Math.sin(n);i===0?e.moveTo(r,c):e.lineTo(r,c)}e.closePath(),e.fill()}}drawEraser(e,s,o,t,i,n){e.strokeStyle=this.getColorCode(n),e.lineWidth=t*.5,e.lineCap="butt";let r=.5;e.beginPath();for(let c=0;c<i;c++){let h=Math.PI*2/i*c+r,l=s+t*Math.cos(h),a=o+t*Math.sin(h);e.moveTo(s,o),e.lineTo(l,a)}e.stroke()}drawStar(e,s,o,t,i,n,r){e.fillStyle=this.getColorCode(r),e.beginPath();for(let c=0;c<n*2;c++){let h=c%2===0?i:t,l=Math.PI/n*c,a=s+h*Math.cos(l),u=o+h*Math.sin(l);c===0?e.moveTo(a,u):e.lineTo(a,u)}e.closePath(),e.fill()}drawTetris(e,s,o,t,i,n){if(!t||t.length===0)return;let r=12,c=2,h=t[0].length*r+(t[0].length-1)*c,l=t.length*r+(t.length-1)*c;e.save(),e.translate(s,o),i&&e.rotate(Math.PI/8),e.fillStyle=n===0?"#ffcc00":this.getColorCode(n);for(let a=0;a<t.length;a++)for(let u=0;u<t[a].length;u++)if(t[a][u]){let f=u*(r+c)-h/2,d=a*(r+c)-l/2;e.fillRect(f,d,r,r)}e.restore()}getColorCode(e){return this.options.colors.colorMap&&this.options.colors.colorMap[e]||"#666"}prepareOffscreen(){return typeof document>"u"?{canvas:{},ctx:{}}:(this.offscreenCanvas||(this.offscreenCanvas=document.createElement("canvas"),this.offscreenCtx=this.offscreenCanvas.getContext("2d")),(this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx})}};var _=class{generator;validator;constructor(){this.generator=new j,this.validator=new G}createPuzzle(e,s,o={}){return this.generator.generate(e,s,o).export()}validateSolution(e,s){let o=q.fromData(e);return this.validator.validate(o,s)}calculateDifficulty(e){let s=q.fromData(e);return this.validator.calculateDifficulty(s)}};export{L as CellType,Y as Color,Z as Direction,K as EdgeType,q as Grid,X as NodeType,j as PuzzleGenerator,G as PuzzleValidator,_ as WitnessCore,U as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
