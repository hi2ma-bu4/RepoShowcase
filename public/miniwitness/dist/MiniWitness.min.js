/*!
 * MiniWitness 1.1.3
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var te=(t=>(t[t.Up=0]="Up",t[t.Right=1]="Right",t[t.Down=2]="Down",t[t.Left=3]="Left",t))(te||{}),K=(o=>(o[o.None=0]="None",o[o.Square=1]="Square",o[o.Star=2]="Star",o[o.Tetris=3]="Tetris",o[o.TetrisRotated=4]="TetrisRotated",o[o.Eraser=5]="Eraser",o))(K||{}),U=(t=>(t[t.Normal=0]="Normal",t[t.Broken=1]="Broken",t[t.Absent=2]="Absent",t[t.Hexagon=3]="Hexagon",t))(U||{}),j=(n=>(n[n.Normal=0]="Normal",n[n.Start=1]="Start",n[n.End=2]="End",n))(j||{}),z={None:0,Black:1,White:2,Red:3,Blue:4};var G=class X{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];constructor(e,s){this.rows=e,this.cols=s,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:z.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes}))}static fromData(e){let s=new X(e.rows,e.cols);return s.cells=e.cells,s.vEdges=e.vEdges,s.hEdges=e.hEdges,s.nodes=e.nodes,s}};var W=class{validate(e,s){let n=s.points;if(n.length<2)return{isValid:!1,errorReason:"Path too short"};let t=n[0],i=n[n.length-1];if(e.nodes[t.y][t.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[i.y][i.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};let o=new Set;o.add(`${t.x},${t.y}`);for(let h=0;h<n.length-1;h++){let a=n[h],l=n[h+1];if(Math.abs(a.x-l.x)+Math.abs(a.y-l.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let c=`${l.x},${l.y}`;if(o.has(c))return{isValid:!1,errorReason:"Self-intersecting path"};if(o.add(c),this.isBrokenEdge(e,a,l))return{isValid:!1,errorReason:"Passed through broken edge"}}let r=this.calculateRegions(e,n),u=this.getMissedHexagons(e,n);return this.validateWithErasers(e,r,u)}isBrokenEdge(e,s,n){let t;if(s.x===n.x){let i=Math.min(s.y,n.y);t=e.vEdges[i][s.x].type}else{let i=Math.min(s.x,n.x);t=e.hEdges[s.y][i].type}return t===1||t===2}isAbsentEdge(e,s,n){if(s.x===n.x){let t=Math.min(s.y,n.y);return e.vEdges[t][s.x].type===2}else{let t=Math.min(s.x,n.x);return e.hEdges[s.y][t].type===2}}getMissedHexagons(e,s){let n=new Set;for(let i=0;i<s.length-1;i++)n.add(this.getEdgeKey(s[i],s[i+1]));let t=[];for(let i=0;i<=e.rows;i++)for(let o=0;o<e.cols;o++)if(e.hEdges[i][o].type===3){let r=this.getEdgeKey({x:o,y:i},{x:o+1,y:i});n.has(r)||t.push({type:"h",r:i,c:o})}for(let i=0;i<e.rows;i++)for(let o=0;o<=e.cols;o++)if(e.vEdges[i][o].type===3){let r=this.getEdgeKey({x:o,y:i},{x:o,y:i+1});n.has(r)||t.push({type:"v",r:i,c:o})}return t}validateWithErasers(e,s,n){let t=[],i=!0;for(let a=0;a<s.length;a++){let l=s[a],f=l.filter(y=>e.cells[y.y][y.x].type===5),c=l.filter(y=>e.cells[y.y][y.x].type!==0&&e.cells[y.y][y.x].type!==5),d=[];for(let y=0;y<n.length;y++)this.isHexagonAdjacentToRegion(e,n[y],l)&&d.push(y);let p=this.getPossibleErasures(e,l,f,c,d);if(p.length===0){i=!1;let y=this.getBestEffortErasures(e,l,f,c,d);t.push([y])}else p.sort((y,m)=>{let b=y.invalidatedCells.length+y.invalidatedHexagons.length,S=m.invalidatedCells.length+m.invalidatedHexagons.length;return b-S}),t.push(p)}if(i){let a=this.findGlobalAssignment(t,n.length);if(a)return{isValid:!0,invalidatedCells:a.invalidatedCells,invalidatedEdges:a.invalidatedHexIndices.map(l=>n[l])}}let o=[],r=[],u=new Set;for(let a of t){let l=a[0];o.push(...l.errorCells),r.push(...l.invalidatedCells);for(let f of l.invalidatedHexagons)u.add(f)}let h=[];for(let a=0;a<n.length;a++)u.has(a)||h.push(n[a]);return{isValid:!1,errorReason:"Constraints failed",errorCells:o,errorEdges:h,invalidatedCells:r,invalidatedEdges:Array.from(u).map(a=>n[a])}}isHexagonAdjacentToRegion(e,s,n){let t=new Set(n.map(i=>`${i.x},${i.y}`));if(s.type==="h"){if(s.r>0&&t.has(`${s.c},${s.r-1}`)||s.r<e.rows&&t.has(`${s.c},${s.r}`))return!0}else if(s.c>0&&t.has(`${s.c-1},${s.r}`)||s.c<e.cols&&t.has(`${s.c},${s.r}`))return!0;return!1}getPossibleErasures(e,s,n,t,i){let o=[],r=n.length;if(r===0)return this.getRegionErrors(e,s,[],[]).length===0&&i.length===0&&o.push({invalidatedCells:[],invalidatedHexagons:[],isValid:!0,errorCells:[]}),o;let u=[...t.map(a=>({type:"cell",pos:a})),...i.map(a=>({type:"hex",index:a}))],h=this.getRegionErrors(e,s,[],[]).length===0&&i.length===0;for(let a=0;a<=r;a++){let l=this.getNCombinations(n,a);for(let f of l){let c=new Set(f.map(p=>`${p.x},${p.y}`)),d=n.filter(p=>!c.has(`${p.x},${p.y}`));for(let p=0;p<=u.length;p++){if(d.length!==a+p)continue;let y=this.getNCombinations(u,p);for(let m of y){let b=m.filter(w=>w.type==="cell").map(w=>w.pos),S=m.filter(w=>w.type==="hex").map(w=>w.index);if(this.getRegionErrors(e,s,[...b,...f],d).length===0){let w=!0;if(h)p>0&&(w=!1);else for(let V=0;V<m.length;V++){let M=[...m.slice(0,V),...m.slice(V+1)],D=M.filter(C=>C.type==="cell").map(C=>C.pos),g=new Set(M.filter(C=>C.type==="hex").map(C=>C.index)),P=i.every(C=>g.has(C));if(this.getRegionErrors(e,s,D,d).length===0&&P){w=!1;break}}w&&o.push({invalidatedCells:[...b,...f],invalidatedHexagons:S,isValid:!0,errorCells:[]})}}}}}return o}getBestEffortErasures(e,s,n,t,i){let o=[...t.map(a=>({type:"cell",pos:a})),...i.map(a=>({type:"hex",index:a}))],r=this.getRegionErrors(e,s,[],[]);if(r.length===0&&i.length===0)return{invalidatedCells:[],invalidatedHexagons:[],isValid:!1,errorCells:[...n]};if(n.length>0&&o.length>0){let a=o[0];if(r.length>0){let d=r[0],p=o.find(y=>y.type==="cell"&&y.pos.x===d.x&&y.pos.y===d.y);p&&(a=p)}else if(i.length>0){let d=o.find(p=>p.type==="hex"&&p.index===i[0]);d&&(a=d)}let l=a.type==="cell"?[a.pos]:[],f=a.type==="hex"?[a.index]:[],c=this.getRegionErrors(e,s,l,[]);for(let d of n)c.push(d);return{invalidatedCells:l,invalidatedHexagons:f,isValid:!1,errorCells:c}}let h=[...r,...n];return{invalidatedCells:[],invalidatedHexagons:[],isValid:!1,errorCells:h}}getNCombinations(e,s){let n=[],t=(i,o)=>{if(o.length===s){n.push([...o]);return}for(let r=i;r<e.length;r++)o.push(e[r]),t(r+1,o),o.pop()};return t(0,[]),n}checkRegionValid(e,s,n,t){return this.getRegionErrors(e,s,n,t).length===0}getRegionErrors(e,s,n,t){let i=new Set(n.map(c=>`${c.x},${c.y}`)),o=new Set(t.map(c=>`${c.x},${c.y}`)),r=new Map,u=new Map,h=new Set,a=new Set,l=[];for(let c of s){if(i.has(`${c.x},${c.y}`))continue;let d=e.cells[c.y][c.x];if(d.type===0)continue;let p=d.type===5&&o.has(`${c.x},${c.y}`),y=d.type!==5;if(!p&&!y)continue;let m=d.color;m!==z.None&&(r.set(m,(r.get(m)||0)+1),u.has(m)||u.set(m,[]),u.get(m).push(c)),d.type===1?a.add(m):d.type===2?h.add(m):(d.type===3||d.type===4)&&d.shape&&l.push({shape:d.shape,rotatable:d.type===4,pos:c})}let f=[];if(a.size>1)for(let c of s)i.has(`${c.x},${c.y}`)||e.cells[c.y][c.x].type===1&&f.push(c);for(let c of h)if(r.get(c)!==2){let d=u.get(c)||[];for(let p of d)(e.cells[p.y][p.x].type===2||o.has(`${p.x},${p.y}`))&&f.push(p)}if(l.length>0&&!this.checkTetrisConstraint(s,l.map(c=>({shape:c.shape,rotatable:c.rotatable}))))for(let c of l)f.push(c.pos);return f}findGlobalAssignment(e,s){let n=e.length,t=new Array(s).fill(0),i=[],o=[],r=u=>{if(u===n)return t.every(h=>h===1);for(let h of e[u]){let a=!0;for(let l of h.invalidatedHexagons)if(t[l]>0){a=!1;break}if(a){for(let l of h.invalidatedHexagons)t[l]++,o.push(l);if(i.push(...h.invalidatedCells),r(u+1))return!0;for(let l of h.invalidatedHexagons)t[l]--,o.pop();for(let l=0;l<h.invalidatedCells.length;l++)i.pop()}}return!1};return r(0)?{invalidatedCells:i,invalidatedHexIndices:o}:null}checkTetrisConstraint(e,s){if(s.reduce((l,f)=>l+this.getShapeArea(f.shape),0)!==e.length)return!1;let t=Math.min(...e.map(l=>l.x)),i=Math.min(...e.map(l=>l.y)),o=Math.max(...e.map(l=>l.x)),r=Math.max(...e.map(l=>l.y)),u=o-t+1,h=r-i+1,a=Array.from({length:h},()=>Array(u).fill(!1));for(let l of e)a[l.y-i][l.x-t]=!0;return this.canTile(a,s)}getShapeArea(e){let s=0;for(let n of e)for(let t of n)t&&s++;return s}canTile(e,s){let n=-1,t=-1;for(let i=0;i<e.length;i++){for(let o=0;o<e[0].length;o++)if(e[i][o]){n=i,t=o;break}if(n!==-1)break}if(n===-1)return s.length===0;if(s.length===0)return!1;for(let i=0;i<s.length;i++){let o=s[i],r=[...s.slice(0,i),...s.slice(i+1)],u=o.rotatable?this.getAllRotations(o.shape):[o.shape];for(let h of u){let a=[];for(let l=0;l<h.length;l++)for(let f=0;f<h[0].length;f++)h[l][f]&&a.push({r:l,c:f});for(let l of a){let f=n-l.r,c=t-l.c;if(this.canPlace(e,h,f,c)){if(this.placePiece(e,h,f,c,!1),this.canTile(e,r))return!0;this.placePiece(e,h,f,c,!0)}}}}return!1}canPlace(e,s,n,t){for(let i=0;i<s.length;i++)for(let o=0;o<s[0].length;o++)if(s[i][o]){let r=n+i,u=t+o;if(r<0||r>=e.length||u<0||u>=e[0].length||!e[r][u])return!1}return!0}placePiece(e,s,n,t,i){for(let o=0;o<s.length;o++)for(let r=0;r<s[0].length;r++)s[o][r]&&(e[n+o][t+r]=i)}getAllRotations(e){let s=[],n=new Set,t=e;for(let i=0;i<4;i++){let o=JSON.stringify(t);n.has(o)||(s.push(t),n.add(o)),t=this.rotate90(t)}return s}rotate90(e){let s=e.length,n=e[0].length,t=Array.from({length:n},()=>Array(s).fill(0));for(let i=0;i<s;i++)for(let o=0;o<n;o++)t[o][s-1-i]=e[i][o];return t}calculateRegions(e,s){let n=[],t=new Set,i=new Set;for(let r=0;r<s.length-1;r++)i.add(this.getEdgeKey(s[r],s[r+1]));let o=this.getExternalCells(e);for(let r=0;r<e.rows;r++)for(let u=0;u<e.cols;u++){if(t.has(`${u},${r}`)||o.has(`${u},${r}`))continue;let h=[],a=[{x:u,y:r}];for(t.add(`${u},${r}`);a.length>0;){let l=a.shift();h.push(l);let f=[{nx:l.x,ny:l.y-1,p1:{x:l.x,y:l.y},p2:{x:l.x+1,y:l.y}},{nx:l.x,ny:l.y+1,p1:{x:l.x,y:l.y+1},p2:{x:l.x+1,y:l.y+1}},{nx:l.x-1,ny:l.y,p1:{x:l.x,y:l.y},p2:{x:l.x,y:l.y+1}},{nx:l.x+1,ny:l.y,p1:{x:l.x+1,y:l.y},p2:{x:l.x+1,y:l.y+1}}];for(let c of f)if(c.nx>=0&&c.nx<e.cols&&c.ny>=0&&c.ny<e.rows){let d=`${c.nx},${c.ny}`;if(!t.has(d)&&!o.has(d)){let p=this.getEdgeKey(c.p1,c.p2);!i.has(p)&&!this.isAbsentEdge(e,c.p1,c.p2)&&(t.add(d),a.push({x:c.nx,y:c.ny}))}}}n.push(h)}return n}getExternalCells(e){let s=new Set,n=[];for(let t=0;t<e.cols;t++)e.hEdges[0][t].type===2&&(s.has(`${t},0`)||(s.add(`${t},0`),n.push({x:t,y:0}))),e.hEdges[e.rows][t].type===2&&(s.has(`${t},${e.rows-1}`)||(s.add(`${t},${e.rows-1}`),n.push({x:t,y:e.rows-1})));for(let t=0;t<e.rows;t++)e.vEdges[t][0].type===2&&(s.has(`0,${t}`)||(s.add(`0,${t}`),n.push({x:0,y:t}))),e.vEdges[t][e.cols].type===2&&(s.has(`${e.cols-1},${t}`)||(s.add(`${e.cols-1},${t}`),n.push({x:e.cols-1,y:t})));for(;n.length>0;){let t=n.shift(),i=[{nx:t.x,ny:t.y-1,edge:e.hEdges[t.y][t.x]},{nx:t.x,ny:t.y+1,edge:e.hEdges[t.y+1][t.x]},{nx:t.x-1,ny:t.y,edge:e.vEdges[t.y][t.x]},{nx:t.x+1,ny:t.y,edge:e.vEdges[t.y][t.x+1]}];for(let o of i)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!s.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(s.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return s}getEdgeKey(e,s){return e.x<s.x||e.x===s.x&&e.y<s.y?`${e.x},${e.y}-${s.x},${s.y}`:`${s.x},${s.y}-${e.x},${e.y}`}calculateDifficulty(e){let s=e.rows,n=e.cols,t=n+1,i=(s+1)*t,o=Array.from({length:i},()=>[]),r=[],u=[],h=new Set;for(let g=0;g<=s;g++)for(let P=0;P<=n;P++){let C=g*t+P;if(e.nodes[g][P].type===1&&r.push(C),e.nodes[g][P].type===2&&u.push(C),P<n){let F=C+1,v=e.hEdges[g][P].type,q=v===3,L=v===1||v===2;o[C].push({next:F,isHexagon:q,isBroken:L}),o[F].push({next:C,isHexagon:q,isBroken:L}),q&&h.add(this.getEdgeKey({x:P,y:g},{x:P+1,y:g}))}if(g<s){let F=C+t,v=e.vEdges[g][P].type,q=v===3,L=v===1||v===2;o[C].push({next:F,isHexagon:q,isBroken:L}),o[F].push({next:C,isHexagon:q,isBroken:L}),q&&h.add(this.getEdgeKey({x:P,y:g},{x:P,y:g+1}))}}let a={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},l=h.size,f=new Set,c=Math.max(1e3,s*n*200);for(let g of r)this.exploreSearchSpace(e,g,1n<<BigInt(g),[g],0,l,o,u,f,a,c);if(a.solutions===0)return 0;let d=h.size,p=new Set;h.size>0&&p.add(999);let y=0,m=0;for(let g=0;g<s;g++)for(let P=0;P<n;P++){let C=e.cells[g][P];C.type!==0&&(d++,p.add(C.type),C.type===3?y++:C.type===4&&(y++,m++))}let b=a.branchingPoints/(a.totalNodesVisited||1),S=Math.log10(a.totalNodesVisited+1),H=(b*10+S*1.5)/(Math.log2(a.solutions+1)*.5+1);y>0&&(H+=m*.5,H+=(y-m)*.2);let N=s*n,w=d/N,V=w<.25?Math.pow(w/.25,4):1,M=p.size<=1?.5:1;H*=V*M;let D=Math.log2(N)/5;return H*=D,Math.max(.01,Math.min(1,H/4))}exploreSearchSpace(e,s,n,t,i,o,r,u,h,a,l){if(a.totalNodesVisited++,a.maxDepth=Math.max(a.maxDepth,t.length),a.totalNodesVisited>l)return;if(u.includes(s)){if(i===o){let c={points:t.map(d=>({x:d%(e.cols+1),y:Math.floor(d/(e.cols+1))}))};if(this.validate(e,c).isValid){let d=this.getFingerprint(e,c.points);h.has(d)||(h.add(d),a.solutions++)}}return}if(!this.canReachEndOptimized(s,n,r,u)){a.backtracks++;return}let f=[];for(let c of r[s]){if(c.isBroken||n&1n<<BigInt(c.next))continue;let d=!0;for(let p of r[s])if(p.isHexagon){let y=t.length>=2&&p.next===t[t.length-2],m=p.next===c.next;if(!y&&!m){d=!1;break}}d&&f.push(c)}if(f.length>1&&a.branchingPoints++,e.rows*e.cols>30)for(let c=f.length-1;c>0;c--){let d=Math.floor(Math.random()*(c+1));[f[c],f[d]]=[f[d],f[c]]}for(let c of f)if(t.push(c.next),this.exploreSearchSpace(e,c.next,n|1n<<BigInt(c.next),t,i+(c.isHexagon?1:0),o,r,u,h,a,l),t.pop(),a.totalNodesVisited>l)return}countSolutions(e,s=100){let n=e.rows,t=e.cols,i=t+1,o=(n+1)*i,r=Array.from({length:o},()=>[]),u=[],h=[],a=new Set;for(let c=0;c<=n;c++)for(let d=0;d<=t;d++){let p=c*i+d;if(e.nodes[c][d].type===1&&u.push(p),e.nodes[c][d].type===2&&h.push(p),d<t){let y=p+1,m=e.hEdges[c][d].type,b=m===3,S=m===1||m===2;r[p].push({next:y,isHexagon:b,isBroken:S}),r[y].push({next:p,isHexagon:b,isBroken:S}),b&&a.add(this.getEdgeKey({x:d,y:c},{x:d+1,y:c}))}if(c<n){let y=p+i,m=e.vEdges[c][d].type,b=m===3,S=m===1||m===2;r[p].push({next:y,isHexagon:b,isBroken:S}),r[y].push({next:p,isHexagon:b,isBroken:S}),b&&a.add(this.getEdgeKey({x:d,y:c},{x:d,y:c+1}))}}let l=new Set,f=a.size;for(let c of u)this.findPathsOptimized(e,c,1n<<BigInt(c),[c],0,f,r,h,l,s);return l.size}findPathsOptimized(e,s,n,t,i,o,r,u,h,a){if(!(h.size>=a)){if(u.includes(s)){if(i===o){let l={points:t.map(f=>({x:f%(e.cols+1),y:Math.floor(f/(e.cols+1))}))};this.validate(e,l).isValid&&h.add(this.getFingerprint(e,l.points))}return}if(this.canReachEndOptimized(s,n,r,u))for(let l of r[s]){if(l.isBroken||n&1n<<BigInt(l.next))continue;let f=!0;for(let c of r[s])if(c.isHexagon){let d=t.length>=2&&c.next===t[t.length-2],p=c.next===l.next;if(!d&&!p){f=!1;break}}if(f&&(t.push(l.next),this.findPathsOptimized(e,l.next,n|1n<<BigInt(l.next),t,i+(l.isHexagon?1:0),o,r,u,h,a),t.pop(),h.size>=a))return}}}canReachEndOptimized(e,s,n,t){let i=[e],o=s,r=0;for(;r<i.length;){let u=i[r++];if(t.includes(u))return!0;for(let h of n[u])!h.isBroken&&!(o&1n<<BigInt(h.next))&&(o|=1n<<BigInt(h.next),i.push(h.next))}return!1}getFingerprint(e,s){return this.calculateRegions(e,s).map(i=>i.map(r=>e.cells[r.y][r.x]).filter(r=>r.type!==0).map(r=>`${r.type}:${r.color}`).sort().join(",")).sort().filter(i=>i.length>0).join("|")||"empty"}};var J=class{generate(e,s,n={}){let t=n.difficulty??.5,i=new W,o=null,r=-1,u=e*s>30?50:80,h=5,a={x:0,y:e},l={x:s,y:0},f=null;for(let c=0;c<u;c++){c%h===0&&(f=this.generateRandomPath(new G(e,s),a,l,n.pathLength));let d=this.generateFromPath(e,s,f,n);if(!this.checkAllRequestedConstraintsPresent(d,n))continue;let p=i.calculateDifficulty(d);if(p===0)continue;let y=Math.abs(p-t);if((o===null||y<Math.abs(r-t))&&(r=p,o=d),t>.8&&p>.8||y<.05)break}if(!o){let c=this.generateRandomPath(new G(e,s),a,l,n.pathLength);return this.generateFromPath(e,s,c,n)}return o}generateFromPath(e,s,n,t){let i=new G(e,s),o={x:0,y:e},r={x:s,y:0};return i.nodes[o.y][o.x].type=1,i.nodes[r.y][r.x].type=2,this.applyConstraintsBasedOnPath(i,n,t),t.useBrokenEdges&&this.applyBrokenEdges(i,n,t),this.cleanGrid(i),i}generateRandomPath(e,s,n,t){if(t===void 0)return this.generateSingleRandomPath(e,s,n);let i=e.rows+e.cols,o=(e.rows+1)*(e.cols+1)-1,r=i+t*(o-i),u=[],h=1/0,a=50;for(let l=0;l<a;l++){let f=this.generateSingleRandomPath(e,s,n,t),c=f.length-1,d=Math.abs(c-r);if(d<h&&(h=d,u=f),h<=1)break}return u}generateSingleRandomPath(e,s,n,t){let i=new Set,o=[],r=u=>{if(i.add(`${u.x},${u.y}`),o.push(u),u.x===n.x&&u.y===n.y)return!0;let h=this.getValidNeighbors(e,u,i);t!==void 0?h.sort((a,l)=>{let f=Math.abs(a.x-n.x)+Math.abs(a.y-n.y),c=Math.abs(l.x-n.x)+Math.abs(l.y-n.y);return(f-c)*(1-t*2)+(Math.random()-.5)*1.5}):this.shuffleArray(h);for(let a of h)if(r(a))return!0;return o.pop(),!1};return r(s),o}getValidNeighbors(e,s,n){let t=[],i=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of i){let r=s.x+o.x,u=s.y+o.y;r>=0&&r<=e.cols&&u>=0&&u<=e.rows&&(n.has(`${r},${u}`)||t.push({x:r,y:u}))}return t}applyBrokenEdges(e,s,n){let t=n.complexity??.5,i=new Set;for(let h=0;h<s.length-1;h++)i.add(this.getEdgeKey(s[h],s[h+1]));let o=[];for(let h=0;h<=e.rows;h++)for(let a=0;a<e.cols;a++){let l={x:a,y:h},f={x:a+1,y:h};i.has(this.getEdgeKey(l,f))||o.push({type:"h",r:h,c:a,p1:l,p2:f})}for(let h=0;h<e.rows;h++)for(let a=0;a<=e.cols;a++){let l={x:a,y:h},f={x:a,y:h+1};i.has(this.getEdgeKey(l,f))||o.push({type:"v",r:h,c:a,p1:l,p2:f})}this.shuffleArray(o);let r=Math.max(1,Math.floor(t*(e.rows*e.cols)/4)),u=0;for(let h of o){if(u>=r)break;let a=Math.random()<.8?1:2;a===2&&this.isAdjacentToMark(e,h)&&(a=1),h.type==="h"?e.hEdges[h.r][h.c].type=a:e.vEdges[h.r][h.c].type=a,u++}for(let h=0;h<=e.rows;h++)for(let a=0;a<=e.cols;a++){let l=[];if(a>0&&l.push({e:e.hEdges[h][a-1],type:"h",r:h,c:a-1}),a<e.cols&&l.push({e:e.hEdges[h][a],type:"h",r:h,c:a}),h>0&&l.push({e:e.vEdges[h-1][a],type:"v",r:h-1,c:a}),h<e.rows&&l.push({e:e.vEdges[h][a],type:"v",r:h,c:a}),l.every(f=>f.e.type===1||f.e.type===2)&&l.every(f=>!this.isAdjacentToMark(e,f)))for(let f of l)f.e.type=2}}cleanGrid(e){let s=[];for(let o=0;o<=e.rows;o++)for(let r=0;r<=e.cols;r++)e.nodes[o][r].type===1&&s.push({x:r,y:o});let n=new Set,t=[...s];for(let o of s)n.add(`${o.x},${o.y}`);for(;t.length>0;){let o=t.shift(),r=[{nx:o.x,ny:o.y-1,edge:e.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:e.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:e.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:e.hEdges[o.y]?.[o.x]}];for(let u of r)u.edge&&u.edge.type!==2&&(n.has(`${u.nx},${u.ny}`)||(n.add(`${u.nx},${u.ny}`),t.push({x:u.nx,y:u.ny})))}for(let o=0;o<=e.rows;o++)for(let r=0;r<e.cols;r++)(!n.has(`${r},${o}`)||!n.has(`${r+1},${o}`))&&(e.hEdges[o][r].type=2);for(let o=0;o<e.rows;o++)for(let r=0;r<=e.cols;r++)(!n.has(`${r},${o}`)||!n.has(`${r},${o+1}`))&&(e.vEdges[o][r].type=2);let i=this.getExternalCells(e);for(let o of i){let[r,u]=o.split(",").map(Number);e.cells[u][r].type=0}}getExternalCells(e){let s=new Set,n=[];for(let t=0;t<e.cols;t++)e.hEdges[0][t].type===2&&(s.has(`${t},0`)||(s.add(`${t},0`),n.push({x:t,y:0}))),e.hEdges[e.rows][t].type===2&&(s.has(`${t},${e.rows-1}`)||(s.add(`${t},${e.rows-1}`),n.push({x:t,y:e.rows-1})));for(let t=0;t<e.rows;t++)e.vEdges[t][0].type===2&&(s.has(`0,${t}`)||(s.add(`0,${t}`),n.push({x:0,y:t}))),e.vEdges[t][e.cols].type===2&&(s.has(`${e.cols-1},${t}`)||(s.add(`${e.cols-1},${t}`),n.push({x:e.cols-1,y:t})));for(;n.length>0;){let t=n.shift(),i=[{nx:t.x,ny:t.y-1,edge:e.hEdges[t.y][t.x]},{nx:t.x,ny:t.y+1,edge:e.hEdges[t.y+1][t.x]},{nx:t.x-1,ny:t.y,edge:e.vEdges[t.y][t.x]},{nx:t.x+1,ny:t.y,edge:e.vEdges[t.y][t.x+1]}];for(let o of i)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!s.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(s.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return s}isAdjacentToMark(e,s){if(s.type==="h"){if(s.r>0&&e.cells[s.r-1][s.c].type!==0||s.r<e.rows&&e.cells[s.r][s.c].type!==0)return!0}else if(s.c>0&&e.cells[s.r][s.c-1].type!==0||s.c<e.cols&&e.cells[s.r][s.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let s=0;s<e.rows;s++)for(let n=0;n<e.cols;n++){if(e.cells[s][n].type===0)continue;if([e.hEdges[s][n],e.hEdges[s+1][n],e.vEdges[s][n],e.vEdges[s][n+1]].every(i=>i.type===1||i.type===2))return!0}return!1}getEdgeKey(e,s){return e.x<s.x||e.x===s.x&&e.y<s.y?`${e.x},${e.y}-${s.x},${s.y}`:`${s.x},${s.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,s,n){let t=n.complexity??.5,i=n.useHexagons??!0,o=n.useSquares??!0,r=n.useStars??!0,u=n.useTetris??!1,h=n.useEraser??!1,a=0,l=0,f=0,c=0,d=0,p=0,y=Math.floor(e.rows*e.cols*.45);if(i){let m=n.difficulty??.5;for(let b=0;b<s.length-1;b++){let H=this.getValidNeighbors(e,s[b],new Set).length>2,N=t*.4;H&&(N=m<.4?N*1:N*.5),Math.random()<N&&(this.setEdgeHexagon(e,s[b],s[b+1]),a++)}if(a===0&&s.length>=2){let b=Math.floor(Math.random()*(s.length-1));this.setEdgeHexagon(e,s[b],s[b+1])}}if(o||r||u||h){let m=this.calculateRegions(e,s),b=n.availableColors??[z.Black,z.White,z.Red,z.Blue],S=n.defaultColors??{},H=(M,D)=>{if(S[M]!==void 0)return S[M];let g=K[M];return g&&S[g]!==void 0?S[g]:D},N=Array.from({length:m.length},(M,D)=>D);this.shuffleArray(N);let w=new Set,V={square:o,star:r,tetris:u,eraser:h};for(let M=0;M<N.length;M++){let D=N[M],g=m[D],P=N.length-M,C=V.square&&l===0||V.star&&f===0||V.tetris&&c===0||V.eraser&&d===0,F=.2+t*.6;if(C&&P<=3?F=1:C&&P<=6&&(F=.7),Math.random()>F)continue;let v=[...g];this.shuffleArray(v);let q=b[Math.floor(Math.random()*b.length)];if(o&&!r&&P<=2&&w.size===1){let I=b.filter(O=>!w.has(O));I.length>0&&(q=I[Math.floor(Math.random()*I.length)])}let L=o&&Math.random()<.5+t*.3;if(o&&l===0&&P<=2&&(L=!0),o&&!r&&P<=2&&w.size<2&&l>0&&(L=!0),L&&v.length>0){let I=Math.min(v.length,Math.max(4,Math.floor(g.length/4))),O=Math.floor(Math.random()*(I/2))+Math.ceil(I/2);for(let R=0;R<O&&v.length!==0;R++){let T=v.pop();e.cells[T.y][T.x].type=1,e.cells[T.y][T.x].color=q,l++,w.add(q)}}if(u&&p<y){let I=Math.random()<.1+t*.4;c===0&&P<=2&&(I=!0);let O=c===0&&P<=2?6:4;if(I&&v.length>0&&g.length<=O*4&&p+g.length<=y){let R=this.generateTiling(g,O,n);if(R){for(let T of R){if(v.length===0)break;let E=v.pop();e.cells[E.y][E.x].type=T.isRotated?4:3,e.cells[E.y][E.x].shape=T.isRotated?T.displayShape:T.shape;let k=H(3,z.None);if(r&&Math.random()<.5){let x=b.filter(A=>A!==z.Blue&&A!==k);x.length>0&&(k=x[Math.floor(Math.random()*x.length)])}e.cells[E.y][E.x].color=k,c++}p+=g.length}}}if(h&&d<1){let I=.05+t*.2,O=Math.random()<I;if(P<=2&&(O=!0),O&&v.length>=1){let R=[];r&&R.push("star"),o&&R.push("square");let T=[];i&&(T=this.getRegionBoundaryEdges(e,g,s),T.length>0&&R.push("hexagon")),u&&R.push("tetris");let E=R.length>0?R[Math.floor(Math.random()*R.length)]:null;v.length>=2&&(!E||Math.random()<.01)&&(E="eraser");let k=!1;if(E==="hexagon"){let x=T[Math.floor(Math.random()*T.length)];x.type==="h"?e.hEdges[x.r][x.c].type=3:e.vEdges[x.r][x.c].type=3,a++,k=!0}else if(E==="square"&&v.length>=2){let x=v.pop();e.cells[x.y][x.x].type=1;let A=g.find($=>e.cells[$.y][$.x].type===1),B=A?e.cells[A.y][A.x].color:void 0;e.cells[x.y][x.x].color=b.find($=>$!==B)||z.Red,l++,k=!0}else if(E==="star"&&v.length>=2){let x=v.pop();e.cells[x.y][x.x].type=2,e.cells[x.y][x.x].color=b[Math.floor(Math.random()*b.length)],f++,k=!0}else if(E==="tetris"&&v.length>=2){let x=this.generateTiling(g,4,n),A=[];if(x&&x.length>0){let B=0;for(let $ of x){let Y=this.getShapeArea($.shape);if(B+Y<g.length)A.push($),B+=Y;else break}}if(A.length===0&&g.length>1&&(A=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),A.length>0){for(let B of A){if(v.length<2)break;let $=v.pop();e.cells[$.y][$.x].type=B.isRotated?4:3,e.cells[$.y][$.x].shape=B.isRotated?B.displayShape:B.shape;let Y=z.None;if(r&&Math.random()<.3){let Q=b.filter(ee=>ee!==z.Blue);Y=Q[Math.floor(Math.random()*Q.length)]}e.cells[$.y][$.x].color=Y,c++}k=!0}}else if(E==="eraser"&&v.length>=2){let x=v.pop();e.cells[x.y][x.x].type=5,e.cells[x.y][x.x].color=H(5,z.White),d++,k=!0}if(!k&&v.length>=2){let x=v.pop();e.cells[x.y][x.x].type=5,e.cells[x.y][x.x].color=H(5,z.White),d++,k=!0}if(k){let x=v.pop();e.cells[x.y][x.x].type=5;let A=H(5,z.White);if(r&&Math.random()<.4){let B=b.filter($=>$!==A);B.length>0&&(A=B[Math.floor(Math.random()*B.length)])}e.cells[x.y][x.x].color=A,d++}}}if(r){let I=Math.max(1,Math.floor(g.length/8));for(let O=0;O<I;O++)for(let R of b){if(v.length<1)break;if(Math.random()>.3+t*.4)continue;let T=g.filter(E=>e.cells[E.y][E.x].color===R).length;if(T===1){let E=v.pop();e.cells[E.y][E.x].type=2,e.cells[E.y][E.x].color=R,f++}else if(T===0&&v.length>=2)for(let E=0;E<2;E++){let k=v.pop();e.cells[k.y][k.x].type=2,e.cells[k.y][k.x].color=R,f++}}}}if(o&&!r&&w.size<2){for(let M of m)if(M.every(D=>e.cells[D.y][D.x].type===0)){let D=b.find(P=>!w.has(P))||z.White,g=M[Math.floor(Math.random()*M.length)];e.cells[g.y][g.x].type=1,e.cells[g.y][g.x].color=D,w.add(D),l++;break}}}}calculateRegions(e,s){let n=[],t=new Set,i=new Set;for(let o=0;o<s.length-1;o++)i.add(this.getEdgeKey(s[o],s[o+1]));for(let o=0;o<e.rows;o++)for(let r=0;r<e.cols;r++){if(t.has(`${r},${o}`))continue;let u=[],h=[{x:r,y:o}];for(t.add(`${r},${o}`);h.length>0;){let a=h.shift();u.push(a);let l=[{dx:0,dy:-1,p1:{x:a.x,y:a.y},p2:{x:a.x+1,y:a.y}},{dx:0,dy:1,p1:{x:a.x,y:a.y+1},p2:{x:a.x+1,y:a.y+1}},{dx:-1,dy:0,p1:{x:a.x,y:a.y},p2:{x:a.x,y:a.y+1}},{dx:1,dy:0,p1:{x:a.x+1,y:a.y},p2:{x:a.x+1,y:a.y+1}}];for(let f of l){let c=a.x+f.dx,d=a.y+f.dy;c>=0&&c<e.cols&&d>=0&&d<e.rows&&!t.has(`${c},${d}`)&&!i.has(this.getEdgeKey(f.p1,f.p2))&&!this.isAbsentEdge(e,f.p1,f.p2)&&(t.add(`${c},${d}`),h.push({x:c,y:d}))}}n.push(u)}return n}isAbsentEdge(e,s,n){if(s.x===n.x){let t=Math.min(s.y,n.y);return e.vEdges[t][s.x].type===2}else{let t=Math.min(s.x,n.x);return e.hEdges[s.y][t].type===2}}getRegionBoundaryEdges(e,s,n){let t=new Set;for(let r=0;r<n.length-1;r++)t.add(this.getEdgeKey(n[r],n[r+1]));let i=[];for(let r of s){let u=[{type:"h",r:r.y,c:r.x},{type:"h",r:r.y+1,c:r.x},{type:"v",r:r.y,c:r.x},{type:"v",r:r.y,c:r.x+1}];for(let h of u){let a=h.type==="h"?{x:h.c,y:h.r}:{x:h.c,y:h.r},l=h.type==="h"?{x:h.c+1,y:h.r}:{x:h.c,y:h.r+1},f=this.getEdgeKey(a,l);!t.has(f)&&!this.isAbsentEdge(e,a,l)&&i.push(h)}}let o=new Map;for(let r of i)o.set(`${r.type},${r.r},${r.c}`,r);return Array.from(o.values())}setEdgeHexagon(e,s,n){s.x===n.x?e.vEdges[Math.min(s.y,n.y)][s.x].type=3:e.hEdges[s.y][Math.min(s.x,n.x)].type=3}checkAllRequestedConstraintsPresent(e,s){let n=s.useHexagons??!0,t=s.useSquares??!0,i=s.useStars??!0,o=s.useTetris??!1,r=s.useEraser??!1;if(s.useBrokenEdges??!1){let h=!1;for(let a=0;a<=e.rows;a++)for(let l=0;l<e.cols;l++)if(e.hEdges[a][l].type===1||e.hEdges[a][l].type===2){h=!0;break}if(!h){for(let a=0;a<e.rows;a++)for(let l=0;l<=e.cols;l++)if(e.vEdges[a][l].type===1||e.vEdges[a][l].type===2){h=!0;break}}if(!h)return!1}if(n){let h=!1;for(let a=0;a<=e.rows;a++)for(let l=0;l<e.cols;l++)if(e.hEdges[a][l].type===3){h=!0;break}if(!h){for(let a=0;a<e.rows;a++)for(let l=0;l<=e.cols;l++)if(e.vEdges[a][l].type===3){h=!0;break}}if(!h)return!1}if(t||i||o||r){let h=!1,a=!1,l=!1,f=!1,c=new Set;for(let d=0;d<e.rows;d++)for(let p=0;p<e.cols;p++){let y=e.cells[d][p].type;y===1&&(h=!0,c.add(e.cells[d][p].color)),y===2&&(a=!0),(y===3||y===4)&&(l=!0),y===5&&(f=!0)}if(t&&!h||i&&!a||o&&!l||r&&!f||t&&h&&!a&&c.size<2)return!1}return!this.hasIsolatedMark(e)}generateTiling(e,s,n){let t=Math.min(...e.map(l=>l.x)),i=Math.min(...e.map(l=>l.y)),o=Math.max(...e.map(l=>l.x)),r=Math.max(...e.map(l=>l.y)),u=o-t+1,h=r-i+1,a=Array.from({length:h},()=>Array(u).fill(!1));for(let l of e)a[l.y-i][l.x-t]=!0;return this.tilingDfs(a,[],s,n)}tilingDfs(e,s,n,t){let i=-1,o=-1;for(let h=0;h<e.length;h++){for(let a=0;a<e[0].length;a++)if(e[h][a]){i=h,o=a;break}if(i!==-1)break}if(i===-1)return s;if(s.length>=n)return null;let r=t.difficulty??.5,u=[...this.TETRIS_SHAPES];this.shuffleArray(u),r>.6&&u.sort((h,a)=>this.getShapeArea(a)-this.getShapeArea(h));for(let h of u){let a=this.isRotationallyInvariant(h),l=a?[h]:this.getAllRotations(h);this.shuffleArray(l);for(let f of l){let c=[];for(let d=0;d<f.length;d++)for(let p=0;p<f[0].length;p++)f[d][p]&&c.push({r:d,c:p});for(let d of c){let p=i-d.r,y=o-d.c;if(this.canPlace(e,f,p,y)){this.placePiece(e,f,p,y,!1);let m=this.tilingDfs(e,[...s,{shape:f,displayShape:h,isRotated:!a&&Math.random()<.3+r*.6}],n,t);if(m)return m;this.placePiece(e,f,p,y,!0)}}}}return null}getShapeArea(e){let s=0;for(let n of e)for(let t of n)t&&s++;return s}isRotationallyInvariant(e){let s=this.getShapeArea(e);return s===1||s===4&&e.length===2&&e[0].length===2}getAllRotations(e){let s=[],n=new Set,t=e;for(let i=0;i<4;i++){let o=JSON.stringify(t);n.has(o)||(s.push(t),n.add(o)),t=this.rotate90(t)}return s}rotate90(e){let s=e.length,n=e[0].length,t=Array.from({length:n},()=>Array(s).fill(0));for(let i=0;i<s;i++)for(let o=0;o<n;o++)t[o][s-1-i]=e[i][o];return t}canPlace(e,s,n,t){for(let i=0;i<s.length;i++)for(let o=0;o<s[0].length;o++)if(s[i][o]){let r=n+i,u=t+o;if(r<0||r>=e.length||u<0||u>=e[0].length||!e[r][u])return!1}return!0}placePiece(e,s,n,t,i){for(let o=0;o<s.length;o++)for(let r=0;r<s[0].length;r++)s[o][r]&&(e[n+o][t+r]=i)}shuffleArray(e){for(let s=e.length-1;s>0;s--){let n=Math.floor(Math.random()*(s+1));[e[s],e[n]]=[e[n],e[s]]}}};var _=class{canvas;ctx;puzzle=null;options;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;invalidatedCells=[];invalidatedEdges=[];errorCells=[];errorEdges=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;constructor(e,s,n={}){if(typeof window>"u"){this.canvas={},this.ctx={},this.options=this.mergeOptions(n);return}if(typeof e=="string"){let i=document.getElementById(e);if(!(i instanceof HTMLCanvasElement))throw new Error(`Element with id "${e}" is not a canvas.`);this.canvas=i}else this.canvas=e;let t=this.canvas.getContext("2d");if(!t)throw new Error("Could not get 2D context.");this.ctx=t,this.ctx.imageSmoothingEnabled=!1,this.options=this.mergeOptions(n),s&&this.setPuzzle(s),this.initEvents(),this.animate()}mergeOptions(e){return{gridPadding:e.gridPadding??60,cellSize:e.cellSize??80,nodeRadius:e.nodeRadius??6,startNodeRadius:e.startNodeRadius??22,pathWidth:e.pathWidth??18,exitLength:e.exitLength??25,autoResize:e.autoResize??!0,animations:{blinkDuration:e.animations?.blinkDuration??1e3,fadeDuration:e.animations?.fadeDuration??1e3,blinkPeriod:e.animations?.blinkPeriod??800},colors:{path:e.colors?.path??"#ffcc00",error:e.colors?.error??"#ff4444",success:e.colors?.success??"#ffcc00",interrupted:e.colors?.interrupted??"#ffcc00",grid:e.colors?.grid??"#555",node:e.colors?.node??"#555",hexagon:e.colors?.hexagon??"#ffcc00",colorMap:e.colors?.colorMap??{[z.Black]:"#000",[z.White]:"#fff",[z.Red]:"#f00",[z.Blue]:"#00f",[z.None]:"#ffcc00"},colorList:e.colors?.colorList},onPathComplete:e.onPathComplete??(()=>{})}}setPuzzle(e){this.puzzle=e,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.invalidatedCells=[],this.invalidatedEdges=[],this.errorCells=[],this.errorEdges=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw()}setOptions(e){this.options=this.mergeOptions({...this.options,...e}),this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}setValidationResult(e,s=[],n=[],t=[],i=[]){this.invalidatedCells=s,this.invalidatedEdges=n,this.errorCells=t,this.errorEdges=i,this.eraserAnimationStartTime=Date.now(),e?(this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0}resizeCanvas(){!this.puzzle||!this.canvas||(this.canvas.width=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,this.canvas.height=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2)}initEvents(){typeof window>"u"||(this.canvas.addEventListener("mousedown",e=>this.handleStart(e)),window.addEventListener("mousemove",e=>this.handleMove(e)),window.addEventListener("mouseup",e=>this.handleEnd(e)),this.canvas.addEventListener("touchstart",e=>{e.preventDefault(),this.handleStart(e.touches[0])},{passive:!1}),window.addEventListener("touchmove",e=>{this.handleMove(e.touches[0])},{passive:!1}),window.addEventListener("touchend",e=>{this.handleEnd(e.changedTouches[0])},{passive:!1}))}getCanvasCoords(e,s){return{x:this.options.gridPadding+e*this.options.cellSize,y:this.options.gridPadding+s*this.options.cellSize}}getExitDir(e,s){return!this.puzzle||this.puzzle.nodes[s][e].type!==2?null:e===this.puzzle.cols?{x:1,y:0}:e===0?{x:-1,y:0}:s===0?{x:0,y:-1}:s===this.puzzle.rows?{x:0,y:1}:{x:1,y:0}}handleStart(e){if(!this.puzzle)return;let s=this.canvas.getBoundingClientRect(),n=e.clientX-s.left,t=e.clientY-s.top;for(let i=0;i<=this.puzzle.rows;i++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[i][o].type===1){let r=this.getCanvasCoords(o,i);if(Math.hypot(r.x-n,r.y-t)<this.options.startNodeRadius){this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.errorCells=[],this.errorEdges=[],this.isDrawing=!0,this.path=[{x:o,y:i}],this.currentMousePos=r,this.exitTipPos=null,this.draw();return}}}handleMove(e){if(!this.puzzle||!this.isDrawing)return;let s=this.canvas.getBoundingClientRect(),n=e.clientX-s.left,t=e.clientY-s.top,i=this.path[this.path.length-1],o=this.getCanvasCoords(i.x,i.y),r=n-o.x,u=t-o.y,h=this.getExitDir(i.x,i.y);if(h){let l=r*h.x+u*h.y;if(l>0){let f=Math.min(l,this.options.exitLength);this.currentMousePos={x:o.x+h.x*f,y:o.y+h.y*f},this.draw();return}}if(Math.abs(r)>Math.abs(u)){let l=r>0?1:-1,f={x:i.x+l,y:i.y},c=this.getEdgeType(i,f);if(f.x>=0&&f.x<=this.puzzle.cols&&c!==2){let d=c===1?this.options.cellSize*.35:this.options.cellSize;this.currentMousePos={x:o.x+Math.max(-d,Math.min(d,r)),y:o.y}}else this.currentMousePos=o}else{let l=u>0?1:-1,f={x:i.x,y:i.y+l},c=this.getEdgeType(i,f);if(f.y>=0&&f.y<=this.puzzle.rows&&c!==2){let d=c===1?this.options.cellSize*.35:this.options.cellSize;this.currentMousePos={x:o.x,y:o.y+Math.max(-d,Math.min(d,u))}}else this.currentMousePos=o}let a=[{x:i.x+1,y:i.y},{x:i.x-1,y:i.y},{x:i.x,y:i.y+1},{x:i.x,y:i.y-1}];for(let l of a)if(l.x>=0&&l.x<=this.puzzle.cols&&l.y>=0&&l.y<=this.puzzle.rows){let f=this.getCanvasCoords(l.x,l.y);if(Math.hypot(f.x-this.currentMousePos.x,f.y-this.currentMousePos.y)<this.options.cellSize*.3){let d=this.path.findIndex(p=>p.x===l.x&&p.y===l.y);d===-1?this.path.push(l):d===this.path.length-2&&this.path.pop()}}this.draw()}handleEnd(e){if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let s=this.path[this.path.length-1],n=this.getCanvasCoords(s.x,s.y),t=this.getExitDir(s.x,s.y);if(t&&Math.hypot(this.currentMousePos.x-n.x,this.currentMousePos.y-n.y)>this.options.exitLength*.1){this.exitTipPos={...this.currentMousePos},this.options.onPathComplete(this.path);return}this.exitTipPos=t?{...this.currentMousePos}:null,this.startFade(this.options.colors.interrupted)}getEdgeType(e,s){if(!this.puzzle)return 2;if(e.x===s.x){let n=Math.min(e.y,s.y);return n<0||n>=this.puzzle.rows?2:this.puzzle.vEdges[n][e.x].type}else{let n=Math.min(e.x,s.x);return n<0||n>=this.puzzle.cols?2:this.puzzle.hEdges[e.y][n].type}}startFade(e="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=e,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){if(!(typeof window>"u")){if(this.draw(),this.isFading){let e=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=e,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0)}requestAnimationFrame(()=>this.animate())}}draw(){if(!this.puzzle||!this.ctx)return;let e=this.ctx,s=Date.now();if(e.globalAlpha=1,e.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(e),this.drawConstraints(e),this.drawNodes(e),this.path.length===0&&!this.isDrawing&&this.drawRipples(e),this.isFading)this.drawPath(e,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos);else if(this.path.length>0){let n=this.isInvalidPath?this.options.colors.error:this.options.colors.path;if(!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let t=s-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),i=this.options.animations.blinkDuration;if(t<i){let o=Math.min(1,t/200),r=t>i*.8?(i-t)/(i*.2):1,u=Math.min(o,r);if(this.isSuccessFading)n=this.lerpColor(this.options.colors.path,this.options.colors.error,u);else{let h=(Math.sin(s*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;n=this.lerpColor(this.options.colors.path,this.options.colors.error,h*u)}}}this.drawPath(e,this.path,this.isDrawing,n,1,this.isDrawing?this.currentMousePos:this.exitTipPos)}}drawRipples(e){if(!this.puzzle)return;let s=(Date.now()-this.startTime)/500;for(let n=0;n<=this.puzzle.rows;n++)for(let t=0;t<=this.puzzle.cols;t++)if(this.puzzle.nodes[n][t].type===2){let o=this.getCanvasCoords(t,n),r=this.getExitDir(t,n);if(!r)continue;let u={x:o.x+r.x*this.options.exitLength,y:o.y+r.y*this.options.exitLength},h=s%4,a=h*5,l=Math.max(0,1-h/3);e.beginPath(),e.arc(u.x,u.y,a,0,Math.PI*2),e.strokeStyle=`rgba(170, 170, 170, ${l*.4})`,e.lineWidth=2,e.stroke()}}drawGrid(e){if(!this.puzzle||!this.options.colors.grid)return;e.strokeStyle=this.options.colors.grid,e.lineWidth=12,e.lineCap="round";let s=(n,t,i)=>{if(i!==2)if(i===1){let r={x:n.x+(t.x-n.x)*.35,y:n.y+(t.y-n.y)*.35},u={x:n.x+(t.x-n.x)*(.5+.15),y:n.y+(t.y-n.y)*(.5+.15)};e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(r.x,r.y),e.stroke(),e.beginPath(),e.moveTo(u.x,u.y),e.lineTo(t.x,t.y),e.stroke()}else e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(t.x,t.y),e.stroke()};for(let n=0;n<=this.puzzle.rows;n++)for(let t=0;t<this.puzzle.cols;t++)s(this.getCanvasCoords(t,n),this.getCanvasCoords(t+1,n),this.puzzle.hEdges[n][t].type);for(let n=0;n<this.puzzle.rows;n++)for(let t=0;t<=this.puzzle.cols;t++)s(this.getCanvasCoords(t,n),this.getCanvasCoords(t,n+1),this.puzzle.vEdges[n][t].type)}drawConstraints(e){if(!this.puzzle)return;let s=Date.now(),n=(Math.sin(s*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;for(let i=0;i<this.puzzle.rows;i++)for(let o=0;o<this.puzzle.cols;o++){let r=this.puzzle.cells[i][o],u=this.getCanvasCoords(o+.5,i+.5),h=this.invalidatedCells.some(p=>p.x===o&&p.y===i),a=this.errorCells.some(p=>p.x===o&&p.y===i),l=1,f,c=this.getColorCode(r.color),d=this.options.colors.error;if(a&&(f=this.lerpColor(c,d,n)),h){let p=s-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),y=this.options.animations.blinkDuration;if(this.isFading)l=this.fadeOpacity;else if(p<y){let m=Math.min(1,p/200),b=p>y*.8?(y-p)/(y*.2):1,S=Math.min(m,b);f=this.lerpColor(c,d,n*S)}else l=Math.max(.3,1-(p-y)/this.options.animations.fadeDuration)}if(l<1||f){let{canvas:p,ctx:y}=this.prepareOffscreen();this.drawConstraintItem(y,r,u,f),e.save(),e.globalAlpha=l,e.drawImage(p,0,0),e.restore()}else this.drawConstraintItem(e,r,u)}e.lineWidth=2;let t=8;for(let i=0;i<=this.puzzle.rows;i++)for(let o=0;o<this.puzzle.cols;o++)if(this.puzzle.hEdges[i][o].type===3){let r=this.getCanvasCoords(o+.5,i);e.save();let u=this.invalidatedEdges.some(a=>a.type==="h"&&a.r===i&&a.c===o);if(this.errorEdges.some(a=>a.type==="h"&&a.r===i&&a.c===o)){let a=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(e,r.x,r.y,t,a)}else if(u){let a=s-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),l=this.options.animations.blinkDuration;if(this.isFading)e.globalAlpha*=this.fadeOpacity;else if(a<l){let f=Math.min(1,a/200),c=a>l*.8?(l-a)/(l*.2):1,d=Math.min(f,c),p=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*d);this.drawHexagon(e,r.x,r.y,t,p)}else e.globalAlpha*=Math.max(.3,1-(a-l)/this.options.animations.fadeDuration),this.drawHexagon(e,r.x,r.y,t)}else this.drawHexagon(e,r.x,r.y,t);e.restore()}for(let i=0;i<this.puzzle.rows;i++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.vEdges[i][o].type===3){let r=this.getCanvasCoords(o,i+.5);e.save();let u=this.invalidatedEdges.some(a=>a.type==="v"&&a.r===i&&a.c===o);if(this.errorEdges.some(a=>a.type==="v"&&a.r===i&&a.c===o)){let a=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(e,r.x,r.y,t,a)}else if(u){let a=s-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),l=this.options.animations.blinkDuration;if(this.isFading)e.globalAlpha*=this.fadeOpacity;else if(a<l){let f=Math.min(1,a/200),c=a>l*.8?(l-a)/(l*.2):1,d=Math.min(f,c),p=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*d);this.drawHexagon(e,r.x,r.y,t,p)}else e.globalAlpha*=Math.max(.3,1-(a-l)/this.options.animations.fadeDuration),this.drawHexagon(e,r.x,r.y,t)}else this.drawHexagon(e,r.x,r.y,t);e.restore()}}drawConstraintItem(e,s,n,t){s.type===1?(e.fillStyle=t||this.getColorCode(s.color),this.drawRoundedRect(e,n.x-26/2,n.y-26/2,26,26,8)):s.type===2?this.drawStar(e,n.x,n.y,12,16,8,s.color,t):s.type===3||s.type===4?this.drawTetris(e,n.x,n.y,s.shape||[],s.type===4,s.color,t):s.type===5&&this.drawEraser(e,n.x,n.y,14,3,s.color,t)}drawNodes(e){if(!this.puzzle)return;let s=(n,t)=>{let i=[];return n>0&&i.push(this.puzzle.hEdges[t][n-1].type),n<this.puzzle.cols&&i.push(this.puzzle.hEdges[t][n].type),t>0&&i.push(this.puzzle.vEdges[t-1][n].type),t<this.puzzle.rows&&i.push(this.puzzle.vEdges[t][n].type),i.length>0&&i.every(o=>o===2)};for(let n=0;n<=this.puzzle.rows;n++)for(let t=0;t<=this.puzzle.cols;t++){if(s(t,n))continue;let i=this.puzzle.nodes[n][t],o=this.getCanvasCoords(t,n);if(i.type===1)this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill();else if(i.type===2){let r=this.getExitDir(t,n);if(!r)continue;this.options.colors.node&&(e.strokeStyle=this.options.colors.node),e.lineWidth=12,e.lineCap="round",e.beginPath(),e.moveTo(o.x,o.y),e.lineTo(o.x+r.x*this.options.exitLength,o.y+r.y*this.options.exitLength),e.stroke()}else this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.nodeRadius,0,Math.PI*2),e.fill()}}drawPath(e,s,n,t,i,o=null){if(!(s.length===0||!t))if(i<1){let{canvas:r,ctx:u}=this.prepareOffscreen();this.drawPathInternal(u,s,n,t,o),e.save(),e.globalAlpha=i,e.drawImage(r,0,0),e.restore()}else this.drawPathInternal(e,s,n,t,o)}drawPathInternal(e,s,n,t,i=null){e.save(),e.strokeStyle=t,e.fillStyle=t,e.lineWidth=this.options.pathWidth,e.lineCap="round",e.lineJoin="round",e.beginPath();let o=this.getCanvasCoords(s[0].x,s[0].y);e.moveTo(o.x,o.y);for(let r=1;r<s.length;r++){let u=this.getCanvasCoords(s[r].x,s[r].y);e.lineTo(u.x,u.y)}if(n||i){let r=i||this.currentMousePos;e.lineTo(r.x,r.y)}e.stroke(),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill(),n&&(e.beginPath(),e.arc(this.currentMousePos.x,this.currentMousePos.y,this.options.pathWidth/2,0,Math.PI*2),e.fill()),e.restore()}drawRoundedRect(e,s,n,t,i,o){e.beginPath(),e.moveTo(s+o,n),e.lineTo(s+t-o,n),e.quadraticCurveTo(s+t,n,s+t,n+o),e.lineTo(s+t,n+i-o),e.quadraticCurveTo(s+t,n+i,s+t-o,n+i),e.lineTo(s+o,n+i),e.quadraticCurveTo(s,n+i,s,n+i-o),e.lineTo(s,n+o),e.quadraticCurveTo(s,n,s+o,n),e.closePath(),e.fill()}drawHexagon(e,s,n,t,i){if(!(!this.options.colors.hexagon&&!i)){e.fillStyle=i||this.options.colors.hexagon,e.beginPath();for(let o=0;o<6;o++){let r=Math.PI/3*o,u=s+t*Math.cos(r),h=n+t*Math.sin(r);o===0?e.moveTo(u,h):e.lineTo(u,h)}e.closePath(),e.fill()}}drawEraser(e,s,n,t,i,o,r){e.strokeStyle=r||this.getColorCode(o),e.lineWidth=t*.5,e.lineCap="butt";let u=.5;e.beginPath();for(let h=0;h<i;h++){let a=Math.PI*2/i*h+u,l=s+t*Math.cos(a),f=n+t*Math.sin(a);e.moveTo(s,n),e.lineTo(l,f)}e.stroke()}drawStar(e,s,n,t,i,o,r,u){e.fillStyle=u||this.getColorCode(r),e.beginPath();for(let h=0;h<o*2;h++){let a=h%2===0?i:t,l=Math.PI/o*h,f=s+a*Math.cos(l),c=n+a*Math.sin(l);h===0?e.moveTo(f,c):e.lineTo(f,c)}e.closePath(),e.fill()}drawTetris(e,s,n,t,i,o,r){if(!t||t.length===0)return;let u=12,h=2,a=t[0].length*u+(t[0].length-1)*h,l=t.length*u+(t.length-1)*h;e.save(),e.translate(s,n),i&&e.rotate(Math.PI/8),e.fillStyle=r||this.getColorCode(o,"#ffcc00");for(let f=0;f<t.length;f++)for(let c=0;c<t[f].length;c++)if(t[f][c]){let d=c*(u+h)-a/2,p=f*(u+h)-l/2;e.fillRect(d,p,u,u)}e.restore()}getColorCode(e,s="#666"){return this.options.colors.colorList&&this.options.colors.colorList[e]!==void 0?this.options.colors.colorList[e]:this.options.colors.colorMap&&this.options.colors.colorMap[e]!==void 0?this.options.colors.colorMap[e]:s}hexToRgb(e){let s=e.startsWith("#")?e.slice(1):e;s.length===3&&(s=s.split("").map(t=>t+t).join(""));let n=parseInt(s,16);return{r:n>>16&255,g:n>>8&255,b:n&255}}rgbToHex(e,s,n){return"#"+((1<<24)+(e<<16)+(s<<8)+n).toString(16).slice(1)}lerpColor(e,s,n){try{let t=this.hexToRgb(e),i=this.hexToRgb(s);return this.rgbToHex(Math.round(t.r+(i.r-t.r)*n),Math.round(t.g+(i.g-t.g)*n),Math.round(t.b+(i.b-t.b)*n))}catch{return e}}prepareOffscreen(){return typeof document>"u"?{canvas:{},ctx:{}}:(this.offscreenCanvas||(this.offscreenCanvas=document.createElement("canvas"),this.offscreenCtx=this.offscreenCanvas.getContext("2d")),(this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx})}};var Z=class{generator;validator;constructor(){this.generator=new J,this.validator=new W}createPuzzle(e,s,n={}){return this.generator.generate(e,s,n).export()}validateSolution(e,s){let n=G.fromData(e);return this.validator.validate(n,s)}calculateDifficulty(e){let s=G.fromData(e);return this.validator.calculateDifficulty(s)}};export{K as CellType,z as Color,te as Direction,U as EdgeType,G as Grid,j as NodeType,J as PuzzleGenerator,W as PuzzleValidator,Z as WitnessCore,_ as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
