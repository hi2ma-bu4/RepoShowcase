/*!
 * MiniWitness 1.1.5
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var oe=(s=>(s[s.Up=0]="Up",s[s.Right=1]="Right",s[s.Down=2]="Down",s[s.Left=3]="Left",s))(oe||{}),U=(o=>(o[o.None=0]="None",o[o.Square=1]="Square",o[o.Star=2]="Star",o[o.Tetris=3]="Tetris",o[o.TetrisRotated=4]="TetrisRotated",o[o.Eraser=5]="Eraser",o))(U||{}),Y=(s=>(s[s.Normal=0]="Normal",s[s.Broken=1]="Broken",s[s.Absent=2]="Absent",s[s.Hexagon=3]="Hexagon",s))(Y||{}),j=(n=>(n[n.Normal=0]="Normal",n[n.Start=1]="Start",n[n.End=2]="End",n))(j||{}),z={None:0,Black:1,White:2,Red:3,Blue:4};var W=class L{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:z.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes}))}static fromData(e){let t=new L(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t}};var K=class{validate(e,t){let n=t.points;if(n.length<2)return{isValid:!1,errorReason:"Path too short"};let s=n[0],i=n[n.length-1];if(e.nodes[s.y][s.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[i.y][i.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};let o=new Set;o.add(`${s.x},${s.y}`);for(let h=0;h<n.length-1;h++){let a=n[h],r=n[h+1];if(Math.abs(a.x-r.x)+Math.abs(a.y-r.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let c=`${r.x},${r.y}`;if(o.has(c))return{isValid:!1,errorReason:"Self-intersecting path"};if(o.add(c),this.isBrokenEdge(e,a,r))return{isValid:!1,errorReason:"Passed through broken edge"}}let l=this.calculateRegions(e,n),u=this.getMissedHexagons(e,n);return this.validateWithErasers(e,l,u)}isBrokenEdge(e,t,n){let s;if(t.x===n.x){let i=Math.min(t.y,n.y);s=e.vEdges[i][t.x].type}else{let i=Math.min(t.x,n.x);s=e.hEdges[t.y][i].type}return s===1||s===2}isAbsentEdge(e,t,n){if(t.x===n.x){let s=Math.min(t.y,n.y);return e.vEdges[s][t.x].type===2}else{let s=Math.min(t.x,n.x);return e.hEdges[t.y][s].type===2}}getMissedHexagons(e,t){let n=new Set;for(let i=0;i<t.length-1;i++)n.add(this.getEdgeKey(t[i],t[i+1]));let s=[];for(let i=0;i<=e.rows;i++)for(let o=0;o<e.cols;o++)if(e.hEdges[i][o].type===3){let l=this.getEdgeKey({x:o,y:i},{x:o+1,y:i});n.has(l)||s.push({type:"h",r:i,c:o})}for(let i=0;i<e.rows;i++)for(let o=0;o<=e.cols;o++)if(e.vEdges[i][o].type===3){let l=this.getEdgeKey({x:o,y:i},{x:o,y:i+1});n.has(l)||s.push({type:"v",r:i,c:o})}return s}validateWithErasers(e,t,n){let s=[],i=!0;for(let a=0;a<t.length;a++){let r=t[a],f=r.filter(y=>e.cells[y.y][y.x].type===5),c=r.filter(y=>e.cells[y.y][y.x].type!==0&&e.cells[y.y][y.x].type!==5),p=[];for(let y=0;y<n.length;y++)this.isHexagonAdjacentToRegion(e,n[y],r)&&p.push(y);let d=this.getPossibleErasures(e,r,f,c,p);if(d.length===0){i=!1;let y=this.getBestEffortErasures(e,r,f,c,p);s.push([y])}else d.sort((y,m)=>{let x=y.invalidatedCells.length+y.invalidatedHexagons.length,S=m.invalidatedCells.length+m.invalidatedHexagons.length;return x-S}),s.push(d)}if(i){let a=this.findGlobalAssignment(s,n.length);if(a)return{isValid:!0,invalidatedCells:a.invalidatedCells,invalidatedEdges:a.invalidatedHexIndices.map(r=>n[r])}}let o=[],l=[],u=new Set;for(let a of s){let r=a[0];o.push(...r.errorCells),l.push(...r.invalidatedCells);for(let f of r.invalidatedHexagons)u.add(f)}let h=[];for(let a=0;a<n.length;a++)u.has(a)||h.push(n[a]);return{isValid:!1,errorReason:"Constraints failed",errorCells:o,errorEdges:h,invalidatedCells:l,invalidatedEdges:Array.from(u).map(a=>n[a])}}isHexagonAdjacentToRegion(e,t,n){let s=new Set(n.map(i=>`${i.x},${i.y}`));if(t.type==="h"){if(t.r>0&&s.has(`${t.c},${t.r-1}`)||t.r<e.rows&&s.has(`${t.c},${t.r}`))return!0}else if(t.c>0&&s.has(`${t.c-1},${t.r}`)||t.c<e.cols&&s.has(`${t.c},${t.r}`))return!0;return!1}getPossibleErasures(e,t,n,s,i){let o=[],l=n.length;if(l===0)return this.getRegionErrors(e,t,[]).length===0&&i.length===0&&o.push({invalidatedCells:[],invalidatedHexagons:[],isValid:!0,errorCells:[]}),o;let u=[...s.map(a=>({type:"cell",pos:a})),...i.map(a=>({type:"hex",index:a}))],h=this.getRegionErrors(e,t,[]).length===0&&i.length===0;for(let a=0;a<=l;a++){let r=this.getNCombinations(n,a);for(let f of r){let c=new Set(f.map(d=>`${d.x},${d.y}`)),p=n.filter(d=>!c.has(`${d.x},${d.y}`));for(let d=0;d<=u.length;d++){if(p.length!==a+d)continue;let y=this.getNCombinations(u,d);for(let m of y){let x=m.filter(P=>P.type==="cell").map(P=>P.pos),S=m.filter(P=>P.type==="hex").map(P=>P.index);if(this.getRegionErrors(e,t,[...x,...f]).length===0){let P=!0;if(h)d>0&&(P=!1);else for(let V=0;V<m.length;V++){let M=[...m.slice(0,V),...m.slice(V+1)],k=M.filter(E=>E.type==="cell").map(E=>E.pos),g=new Set(M.filter(E=>E.type==="hex").map(E=>E.index)),b=i.every(E=>g.has(E));if(this.getRegionErrors(e,t,k).length===0&&b){P=!1;break}}P&&o.push({invalidatedCells:[...x,...f],invalidatedHexagons:S,isValid:!0,errorCells:[]})}}}}}return o}getBestEffortErasures(e,t,n,s,i){let o=this.getRegionErrors(e,t,[]);if(o.length===0&&i.length===0)return{invalidatedCells:[],invalidatedHexagons:[],isValid:!1,errorCells:[...n]};if(n.length>0){let h=[...s.map(c=>({type:"cell",pos:c})),...i.map(c=>({type:"hex",index:c}))],a=null,r=1/0,f=c=>{let p=[],d=[],y=0;for(let P of c)y<n.length&&(P.type==="cell"?p.push(P.pos):d.push(P.index),y++);let m=n.length-y,x=Math.floor(m/2),S=n.slice(y,y+x);y+=x*2;let A=this.getRegionErrors(e,t,[...p,...S]);for(let P=y;P<n.length;P++)A.push(n[P]);let R=A.length;R<r&&(r=R,a={invalidatedCells:[...p,...S],invalidatedHexagons:d,isValid:!1,errorCells:A})};f([...o.map(c=>({type:"cell",pos:c})),...i.map(c=>({type:"hex",index:c}))]),f(h);for(let c of o)f([{type:"cell",pos:c}]);if(a)return a}let u=[...o,...n];return{invalidatedCells:[],invalidatedHexagons:[],isValid:!1,errorCells:u}}getNCombinations(e,t){let n=[],s=(i,o)=>{if(o.length===t){n.push([...o]);return}for(let l=i;l<e.length;l++)o.push(e[l]),s(l+1,o),o.pop()};return s(0,[]),n}checkRegionValid(e,t,n){return this.getRegionErrors(e,t,n).length===0}getRegionErrors(e,t,n){let s=new Set(n.map(r=>`${r.x},${r.y}`)),i=new Map,o=new Map,l=new Set,u=new Set,h=[];for(let r of t){if(s.has(`${r.x},${r.y}`))continue;let f=e.cells[r.y][r.x];if(f.type===0)continue;let c=f.color;c!==z.None&&(i.set(c,(i.get(c)||0)+1),o.has(c)||o.set(c,[]),o.get(c).push(r)),f.type===1?u.add(c):f.type===2?l.add(c):(f.type===3||f.type===4)&&f.shape&&h.push({shape:f.shape,rotatable:f.type===4,pos:r})}let a=[];if(u.size>1)for(let r of t)s.has(`${r.x},${r.y}`)||e.cells[r.y][r.x].type===1&&a.push(r);for(let r of l)if(i.get(r)!==2){let f=o.get(r)||[];for(let c of f)e.cells[c.y][c.x].type===2&&a.push(c)}if(h.length>0&&!this.checkTetrisConstraint(t,h.map(r=>({shape:r.shape,rotatable:r.rotatable}))))for(let r of h)a.push(r.pos);return a}findGlobalAssignment(e,t){let n=e.length,s=new Array(t).fill(0),i=[],o=[],l=u=>{if(u===n)return s.every(h=>h===1);for(let h of e[u]){let a=!0;for(let r of h.invalidatedHexagons)if(s[r]>0){a=!1;break}if(a){for(let r of h.invalidatedHexagons)s[r]++,o.push(r);if(i.push(...h.invalidatedCells),l(u+1))return!0;for(let r of h.invalidatedHexagons)s[r]--,o.pop();for(let r=0;r<h.invalidatedCells.length;r++)i.pop()}}return!1};return l(0)?{invalidatedCells:i,invalidatedHexIndices:o}:null}checkTetrisConstraint(e,t){if(t.reduce((r,f)=>r+this.getShapeArea(f.shape),0)!==e.length)return!1;let s=Math.min(...e.map(r=>r.x)),i=Math.min(...e.map(r=>r.y)),o=Math.max(...e.map(r=>r.x)),l=Math.max(...e.map(r=>r.y)),u=o-s+1,h=l-i+1,a=Array.from({length:h},()=>Array(u).fill(!1));for(let r of e)a[r.y-i][r.x-s]=!0;return this.canTile(a,t)}getShapeArea(e){let t=0;for(let n of e)for(let s of n)s&&t++;return t}canTile(e,t){let n=-1,s=-1;for(let i=0;i<e.length;i++){for(let o=0;o<e[0].length;o++)if(e[i][o]){n=i,s=o;break}if(n!==-1)break}if(n===-1)return t.length===0;if(t.length===0)return!1;for(let i=0;i<t.length;i++){let o=t[i],l=[...t.slice(0,i),...t.slice(i+1)],u=o.rotatable?this.getAllRotations(o.shape):[o.shape];for(let h of u){let a=[];for(let r=0;r<h.length;r++)for(let f=0;f<h[0].length;f++)h[r][f]&&a.push({r,c:f});for(let r of a){let f=n-r.r,c=s-r.c;if(this.canPlace(e,h,f,c)){if(this.placePiece(e,h,f,c,!1),this.canTile(e,l))return!0;this.placePiece(e,h,f,c,!0)}}}}return!1}canPlace(e,t,n,s){for(let i=0;i<t.length;i++)for(let o=0;o<t[0].length;o++)if(t[i][o]){let l=n+i,u=s+o;if(l<0||l>=e.length||u<0||u>=e[0].length||!e[l][u])return!1}return!0}placePiece(e,t,n,s,i){for(let o=0;o<t.length;o++)for(let l=0;l<t[0].length;l++)t[o][l]&&(e[n+o][s+l]=i)}getAllRotations(e){let t=[],n=new Set,s=e;for(let i=0;i<4;i++){let o=JSON.stringify(s);n.has(o)||(t.push(s),n.add(o)),s=this.rotate90(s)}return t}rotate90(e){let t=e.length,n=e[0].length,s=Array.from({length:n},()=>Array(t).fill(0));for(let i=0;i<t;i++)for(let o=0;o<n;o++)s[o][t-1-i]=e[i][o];return s}calculateRegions(e,t){let n=[],s=new Set,i=new Set;for(let l=0;l<t.length-1;l++)i.add(this.getEdgeKey(t[l],t[l+1]));let o=this.getExternalCells(e);for(let l=0;l<e.rows;l++)for(let u=0;u<e.cols;u++){if(s.has(`${u},${l}`)||o.has(`${u},${l}`))continue;let h=[],a=[{x:u,y:l}];for(s.add(`${u},${l}`);a.length>0;){let r=a.shift();h.push(r);let f=[{nx:r.x,ny:r.y-1,p1:{x:r.x,y:r.y},p2:{x:r.x+1,y:r.y}},{nx:r.x,ny:r.y+1,p1:{x:r.x,y:r.y+1},p2:{x:r.x+1,y:r.y+1}},{nx:r.x-1,ny:r.y,p1:{x:r.x,y:r.y},p2:{x:r.x,y:r.y+1}},{nx:r.x+1,ny:r.y,p1:{x:r.x+1,y:r.y},p2:{x:r.x+1,y:r.y+1}}];for(let c of f)if(c.nx>=0&&c.nx<e.cols&&c.ny>=0&&c.ny<e.rows){let p=`${c.nx},${c.ny}`;if(!s.has(p)&&!o.has(p)){let d=this.getEdgeKey(c.p1,c.p2);!i.has(d)&&!this.isAbsentEdge(e,c.p1,c.p2)&&(s.add(p),a.push({x:c.nx,y:c.ny}))}}}n.push(h)}return n}getExternalCells(e){let t=new Set,n=[];for(let s=0;s<e.cols;s++)e.hEdges[0][s].type===2&&(t.has(`${s},0`)||(t.add(`${s},0`),n.push({x:s,y:0}))),e.hEdges[e.rows][s].type===2&&(t.has(`${s},${e.rows-1}`)||(t.add(`${s},${e.rows-1}`),n.push({x:s,y:e.rows-1})));for(let s=0;s<e.rows;s++)e.vEdges[s][0].type===2&&(t.has(`0,${s}`)||(t.add(`0,${s}`),n.push({x:0,y:s}))),e.vEdges[s][e.cols].type===2&&(t.has(`${e.cols-1},${s}`)||(t.add(`${e.cols-1},${s}`),n.push({x:e.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),i=[{nx:s.x,ny:s.y-1,edge:e.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:e.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:e.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:e.vEdges[s.y][s.x+1]}];for(let o of i)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return t}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}calculateDifficulty(e){let t=e.rows,n=e.cols,s=n+1,i=(t+1)*s,o=Array.from({length:i},()=>[]),l=[],u=[],h=new Set;for(let g=0;g<=t;g++)for(let b=0;b<=n;b++){let E=g*s+b;if(e.nodes[g][b].type===1&&l.push(E),e.nodes[g][b].type===2&&u.push(E),b<n){let O=E+1,v=e.hEdges[g][b].type,B=v===3,G=v===1||v===2;o[E].push({next:O,isHexagon:B,isBroken:G}),o[O].push({next:E,isHexagon:B,isBroken:G}),B&&h.add(this.getEdgeKey({x:b,y:g},{x:b+1,y:g}))}if(g<t){let O=E+s,v=e.vEdges[g][b].type,B=v===3,G=v===1||v===2;o[E].push({next:O,isHexagon:B,isBroken:G}),o[O].push({next:E,isHexagon:B,isBroken:G}),B&&h.add(this.getEdgeKey({x:b,y:g},{x:b,y:g+1}))}}let a={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},r=h.size,f=new Set,c=Math.max(1e3,t*n*200);for(let g of l)this.exploreSearchSpace(e,g,1n<<BigInt(g),[g],0,r,o,u,f,a,c);if(a.solutions===0)return 0;let p=h.size,d=new Set;h.size>0&&d.add(999);let y=0,m=0;for(let g=0;g<t;g++)for(let b=0;b<n;b++){let E=e.cells[g][b];E.type!==0&&(p++,d.add(E.type),E.type===3?y++:E.type===4&&(y++,m++))}let x=a.branchingPoints/(a.totalNodesVisited||1),S=Math.log10(a.totalNodesVisited+1),A=(x*10+S*1.5)/(Math.log2(a.solutions+1)*.5+1);y>0&&(A+=m*.5,A+=(y-m)*.2);let R=t*n,P=p/R,V=P<.25?Math.pow(P/.25,4):1,M=d.size<=1?.5:1;A*=V*M;let k=Math.log2(R)/5;return A*=k,Math.max(.01,Math.min(1,A/4))}exploreSearchSpace(e,t,n,s,i,o,l,u,h,a,r){if(a.totalNodesVisited++,a.maxDepth=Math.max(a.maxDepth,s.length),a.totalNodesVisited>r)return;if(u.includes(t)){if(i===o){let c={points:s.map(p=>({x:p%(e.cols+1),y:Math.floor(p/(e.cols+1))}))};if(this.validate(e,c).isValid){let p=this.getFingerprint(e,c.points);h.has(p)||(h.add(p),a.solutions++)}}return}if(!this.canReachEndOptimized(t,n,l,u)){a.backtracks++;return}let f=[];for(let c of l[t]){if(c.isBroken||n&1n<<BigInt(c.next))continue;let p=!0;for(let d of l[t])if(d.isHexagon){let y=s.length>=2&&d.next===s[s.length-2],m=d.next===c.next;if(!y&&!m){p=!1;break}}p&&f.push(c)}if(f.length>1&&a.branchingPoints++,e.rows*e.cols>30)for(let c=f.length-1;c>0;c--){let p=Math.floor(Math.random()*(c+1));[f[c],f[p]]=[f[p],f[c]]}for(let c of f)if(s.push(c.next),this.exploreSearchSpace(e,c.next,n|1n<<BigInt(c.next),s,i+(c.isHexagon?1:0),o,l,u,h,a,r),s.pop(),a.totalNodesVisited>r)return}countSolutions(e,t=100){let n=e.rows,s=e.cols,i=s+1,o=(n+1)*i,l=Array.from({length:o},()=>[]),u=[],h=[],a=new Set;for(let c=0;c<=n;c++)for(let p=0;p<=s;p++){let d=c*i+p;if(e.nodes[c][p].type===1&&u.push(d),e.nodes[c][p].type===2&&h.push(d),p<s){let y=d+1,m=e.hEdges[c][p].type,x=m===3,S=m===1||m===2;l[d].push({next:y,isHexagon:x,isBroken:S}),l[y].push({next:d,isHexagon:x,isBroken:S}),x&&a.add(this.getEdgeKey({x:p,y:c},{x:p+1,y:c}))}if(c<n){let y=d+i,m=e.vEdges[c][p].type,x=m===3,S=m===1||m===2;l[d].push({next:y,isHexagon:x,isBroken:S}),l[y].push({next:d,isHexagon:x,isBroken:S}),x&&a.add(this.getEdgeKey({x:p,y:c},{x:p,y:c+1}))}}let r=new Set,f=a.size;for(let c of u)this.findPathsOptimized(e,c,1n<<BigInt(c),[c],0,f,l,h,r,t);return r.size}findPathsOptimized(e,t,n,s,i,o,l,u,h,a){if(!(h.size>=a)){if(u.includes(t)){if(i===o){let r={points:s.map(f=>({x:f%(e.cols+1),y:Math.floor(f/(e.cols+1))}))};this.validate(e,r).isValid&&h.add(this.getFingerprint(e,r.points))}return}if(this.canReachEndOptimized(t,n,l,u))for(let r of l[t]){if(r.isBroken||n&1n<<BigInt(r.next))continue;let f=!0;for(let c of l[t])if(c.isHexagon){let p=s.length>=2&&c.next===s[s.length-2],d=c.next===r.next;if(!p&&!d){f=!1;break}}if(f&&(s.push(r.next),this.findPathsOptimized(e,r.next,n|1n<<BigInt(r.next),s,i+(r.isHexagon?1:0),o,l,u,h,a),s.pop(),h.size>=a))return}}}canReachEndOptimized(e,t,n,s){let i=[e],o=t,l=0;for(;l<i.length;){let u=i[l++];if(s.includes(u))return!0;for(let h of n[u])!h.isBroken&&!(o&1n<<BigInt(h.next))&&(o|=1n<<BigInt(h.next),i.push(h.next))}return!1}getFingerprint(e,t){return this.calculateRegions(e,t).map(i=>i.map(l=>e.cells[l.y][l.x]).filter(l=>l.type!==0).map(l=>`${l.type}:${l.color}`).sort().join(",")).sort().filter(i=>i.length>0).join("|")||"empty"}};var J=class{generate(e,t,n={}){let s=n.difficulty??.5,i=new K,o=null,l=-1,u=e*t>30?50:80,h=5,a={x:0,y:e},r={x:t,y:0},f=null;for(let c=0;c<u;c++){c%h===0&&(f=this.generateRandomPath(new W(e,t),a,r,n.pathLength));let p=this.generateFromPath(e,t,f,n);if(!this.checkAllRequestedConstraintsPresent(p,n))continue;let d=i.calculateDifficulty(p);if(d===0)continue;let y=Math.abs(d-s);if((o===null||y<Math.abs(l-s))&&(l=d,o=p),s>.8&&d>.8||y<.05)break}if(!o){let c=this.generateRandomPath(new W(e,t),a,r,n.pathLength);return this.generateFromPath(e,t,c,n)}return o}generateFromPath(e,t,n,s){let i=new W(e,t),o={x:0,y:e},l={x:t,y:0};return i.nodes[o.y][o.x].type=1,i.nodes[l.y][l.x].type=2,this.applyConstraintsBasedOnPath(i,n,s),s.useBrokenEdges&&this.applyBrokenEdges(i,n,s),this.cleanGrid(i),i}generateRandomPath(e,t,n,s){if(s===void 0)return this.generateSingleRandomPath(e,t,n);let i=e.rows+e.cols,o=(e.rows+1)*(e.cols+1)-1,l=i+s*(o-i),u=[],h=1/0,a=50;for(let r=0;r<a;r++){let f=this.generateSingleRandomPath(e,t,n,s),c=f.length-1,p=Math.abs(c-l);if(p<h&&(h=p,u=f),h<=1)break}return u}generateSingleRandomPath(e,t,n,s){let i=new Set,o=[],l=u=>{if(i.add(`${u.x},${u.y}`),o.push(u),u.x===n.x&&u.y===n.y)return!0;let h=this.getValidNeighbors(e,u,i);s!==void 0?h.sort((a,r)=>{let f=Math.abs(a.x-n.x)+Math.abs(a.y-n.y),c=Math.abs(r.x-n.x)+Math.abs(r.y-n.y);return(f-c)*(1-s*2)+(Math.random()-.5)*1.5}):this.shuffleArray(h);for(let a of h)if(l(a))return!0;return o.pop(),!1};return l(t),o}getValidNeighbors(e,t,n){let s=[],i=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of i){let l=t.x+o.x,u=t.y+o.y;l>=0&&l<=e.cols&&u>=0&&u<=e.rows&&(n.has(`${l},${u}`)||s.push({x:l,y:u}))}return s}applyBrokenEdges(e,t,n){let s=n.complexity??.5,i=new Set;for(let a=0;a<t.length-1;a++)i.add(this.getEdgeKey(t[a],t[a+1]));let o=[];for(let a=0;a<=e.rows;a++)for(let r=0;r<e.cols;r++){let f={x:r,y:a},c={x:r+1,y:a};i.has(this.getEdgeKey(f,c))||o.push({type:"h",r:a,c:r,p1:f,p2:c})}for(let a=0;a<e.rows;a++)for(let r=0;r<=e.cols;r++){let f={x:r,y:a},c={x:r,y:a+1};i.has(this.getEdgeKey(f,c))||o.push({type:"v",r:a,c:r,p1:f,p2:c})}this.shuffleArray(o);let l=Math.max(1,Math.floor(s*(e.rows*e.cols)/4)),u=0;for(let a of o){if(u>=l)break;a.type==="h"?e.hEdges[a.r][a.c].type=1:e.vEdges[a.r][a.c].type=1,u++}let h=!0;for(;h;){h=!1;for(let a=0;a<=e.rows;a++)for(let r=0;r<e.cols;r++)e.hEdges[a][r].type===1&&this.canBecomeAbsent(e,{type:"h",r:a,c:r})&&(e.hEdges[a][r].type=2,h=!0);for(let a=0;a<e.rows;a++)for(let r=0;r<=e.cols;r++)e.vEdges[a][r].type===1&&this.canBecomeAbsent(e,{type:"v",r:a,c:r})&&(e.vEdges[a][r].type=2,h=!0)}for(let a=0;a<=e.rows;a++)for(let r=0;r<=e.cols;r++){let f=[];if(r>0&&f.push({e:e.hEdges[a][r-1],type:"h",r:a,c:r-1}),r<e.cols&&f.push({e:e.hEdges[a][r],type:"h",r:a,c:r}),a>0&&f.push({e:e.vEdges[a-1][r],type:"v",r:a-1,c:r}),a<e.rows&&f.push({e:e.vEdges[a][r],type:"v",r:a,c:r}),f.length>0&&f.every(c=>c.e.type===1||c.e.type===2)&&f.every(c=>!this.isAdjacentToMark(e,c)))for(let c of f)c.e.type=2}}canBecomeAbsent(e,t){if(this.isAdjacentToMark(e,t))return!1;if(t.type==="h"){if(t.r===0||t.r===e.rows)return!0}else if(t.c===0||t.c===e.cols)return!0;let n=t.type==="h"?[{x:t.c,y:t.r},{x:t.c+1,y:t.r}]:[{x:t.c,y:t.r},{x:t.c,y:t.r+1}];for(let s of n){let i=[{type:"h",r:s.y,c:s.x-1},{type:"h",r:s.y,c:s.x},{type:"v",r:s.y-1,c:s.x},{type:"v",r:s.y,c:s.x}];for(let o of i)if(o.c>=0&&o.c<=e.cols&&o.r>=0&&o.r<=e.rows){if(o.type==="h"&&o.c<e.cols){if(e.hEdges[o.r][o.c].type===2)return!0}else if(o.type==="v"&&o.r<e.rows&&e.vEdges[o.r][o.c].type===2)return!0}}return!1}cleanGrid(e){let t=[];for(let o=0;o<=e.rows;o++)for(let l=0;l<=e.cols;l++)e.nodes[o][l].type===1&&t.push({x:l,y:o});let n=new Set,s=[...t];for(let o of t)n.add(`${o.x},${o.y}`);for(;s.length>0;){let o=s.shift(),l=[{nx:o.x,ny:o.y-1,edge:e.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:e.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:e.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:e.hEdges[o.y]?.[o.x]}];for(let u of l)u.edge&&u.edge.type!==2&&(n.has(`${u.nx},${u.ny}`)||(n.add(`${u.nx},${u.ny}`),s.push({x:u.nx,y:u.ny})))}for(let o=0;o<=e.rows;o++)for(let l=0;l<e.cols;l++)(!n.has(`${l},${o}`)||!n.has(`${l+1},${o}`))&&(e.hEdges[o][l].type=2);for(let o=0;o<e.rows;o++)for(let l=0;l<=e.cols;l++)(!n.has(`${l},${o}`)||!n.has(`${l},${o+1}`))&&(e.vEdges[o][l].type=2);let i=this.getExternalCells(e);for(let o of i){let[l,u]=o.split(",").map(Number);e.cells[u][l].type=0}}getExternalCells(e){let t=new Set,n=[];for(let s=0;s<e.cols;s++)e.hEdges[0][s].type===2&&(t.has(`${s},0`)||(t.add(`${s},0`),n.push({x:s,y:0}))),e.hEdges[e.rows][s].type===2&&(t.has(`${s},${e.rows-1}`)||(t.add(`${s},${e.rows-1}`),n.push({x:s,y:e.rows-1})));for(let s=0;s<e.rows;s++)e.vEdges[s][0].type===2&&(t.has(`0,${s}`)||(t.add(`0,${s}`),n.push({x:0,y:s}))),e.vEdges[s][e.cols].type===2&&(t.has(`${e.cols-1},${s}`)||(t.add(`${e.cols-1},${s}`),n.push({x:e.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),i=[{nx:s.x,ny:s.y-1,edge:e.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:e.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:e.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:e.vEdges[s.y][s.x+1]}];for(let o of i)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return t}isAdjacentToMark(e,t){if(t.type==="h"){if(t.r>0&&e.cells[t.r-1][t.c].type!==0||t.r<e.rows&&e.cells[t.r][t.c].type!==0)return!0}else if(t.c>0&&e.cells[t.r][t.c-1].type!==0||t.c<e.cols&&e.cells[t.r][t.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let t=0;t<e.rows;t++)for(let n=0;n<e.cols;n++){if(e.cells[t][n].type===0)continue;if([e.hEdges[t][n],e.hEdges[t+1][n],e.vEdges[t][n],e.vEdges[t][n+1]].every(i=>i.type===1||i.type===2))return!0}return!1}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,t,n){let s=n.complexity??.5,i=n.useHexagons??!0,o=n.useSquares??!0,l=n.useStars??!0,u=n.useTetris??!1,h=n.useEraser??!1,a=0,r=0,f=0,c=0,p=0,d=0,y=Math.floor(e.rows*e.cols*.45);if(i){let m=n.difficulty??.5;for(let x=0;x<t.length-1;x++){let A=this.getValidNeighbors(e,t[x],new Set).length>2,R=s*.4;A&&(R=m<.4?R*1:R*.5),Math.random()<R&&(this.setEdgeHexagon(e,t[x],t[x+1]),a++)}if(a===0&&t.length>=2){let x=Math.floor(Math.random()*(t.length-1));this.setEdgeHexagon(e,t[x],t[x+1])}}if(o||l||u||h){let m=this.calculateRegions(e,t),x=n.availableColors??[z.Black,z.White,z.Red,z.Blue],S=n.defaultColors??{},A=(M,k)=>{if(S[M]!==void 0)return S[M];let g=U[M];return g&&S[g]!==void 0?S[g]:k},R=Array.from({length:m.length},(M,k)=>k);this.shuffleArray(R);let P=new Set,V={square:o,star:l,tetris:u,eraser:h};for(let M=0;M<R.length;M++){let k=R[M],g=m[k],b=R.length-M,E=V.square&&r===0||V.star&&f===0||V.tetris&&c===0||V.eraser&&p===0,O=.2+s*.6;if(E&&b<=3?O=1:E&&b<=6&&(O=.7),Math.random()>O)continue;let v=[...g];this.shuffleArray(v);let B=x[Math.floor(Math.random()*x.length)];if(o&&!l&&b<=2&&P.size===1){let T=x.filter(q=>!P.has(q));T.length>0&&(B=T[Math.floor(Math.random()*T.length)])}let G=o&&Math.random()<.5+s*.3;if(o&&r===0&&b<=2&&(G=!0),o&&!l&&b<=2&&P.size<2&&r>0&&(G=!0),G&&v.length>0){let T=Math.min(v.length,Math.max(4,Math.floor(g.length/4))),q=Math.floor(Math.random()*(T/2))+Math.ceil(T/2);for(let $=0;$<q&&v.length!==0;$++){let D=v.pop();e.cells[D.y][D.x].type=1,e.cells[D.y][D.x].color=B,r++,P.add(B)}}if(u&&d<y){let T=Math.random()<.1+s*.4;c===0&&b<=2&&(T=!0);let q=c===0&&b<=2?6:4;if(T&&v.length>0&&g.length<=q*4&&d+g.length<=y){let $=this.generateTiling(g,q,n);if($){for(let D of $){if(v.length===0)break;let w=v.pop();e.cells[w.y][w.x].type=D.isRotated?4:3,e.cells[w.y][w.x].shape=D.isRotated?D.displayShape:D.shape;let H=A(3,z.None);if(l&&Math.random()<.5){let C=x.filter(N=>N!==z.Blue&&N!==H);C.length>0&&(H=C[Math.floor(Math.random()*C.length)])}e.cells[w.y][w.x].color=H,c++}d+=g.length}}}if(h&&p<1){let T=.05+s*.2,q=Math.random()<T;if(b<=2&&(q=!0),q&&v.length>=1){let $=[];l&&$.push("star"),o&&$.push("square");let D=[];i&&(D=this.getRegionBoundaryEdges(e,g,t),D.length>0&&$.push("hexagon")),u&&$.push("tetris");let w=$.length>0?$[Math.floor(Math.random()*$.length)]:null;v.length>=2&&(!w||Math.random()<.01)&&(w="eraser");let H=!1;if(w==="hexagon"){let C=D[Math.floor(Math.random()*D.length)];C.type==="h"?e.hEdges[C.r][C.c].type=3:e.vEdges[C.r][C.c].type=3,a++,H=!0}else if(w==="square"&&v.length>=2){let C=v.pop();e.cells[C.y][C.x].type=1;let N=g.find(I=>e.cells[I.y][I.x].type===1),F=N?e.cells[N.y][N.x].color:void 0;e.cells[C.y][C.x].color=x.find(I=>I!==F)||z.Red,r++,H=!0}else if(w==="star"&&v.length>=2){let C=v.pop();e.cells[C.y][C.x].type=2,e.cells[C.y][C.x].color=x[Math.floor(Math.random()*x.length)],f++,H=!0}else if(w==="tetris"&&v.length>=2){let C=this.generateTiling(g,4,n),N=[];if(C&&C.length>0){let F=0;for(let I of C){let X=this.getShapeArea(I.shape);if(F+X<g.length)N.push(I),F+=X;else break}}if(N.length===0&&g.length>1&&(N=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),N.length>0){for(let F of N){if(v.length<2)break;let I=v.pop();e.cells[I.y][I.x].type=F.isRotated?4:3,e.cells[I.y][I.x].shape=F.isRotated?F.displayShape:F.shape;let X=z.None;if(l&&Math.random()<.3){let te=x.filter(ne=>ne!==z.Blue);X=te[Math.floor(Math.random()*te.length)]}e.cells[I.y][I.x].color=X,c++}H=!0}}else if(w==="eraser"&&v.length>=2){let C=v.pop();e.cells[C.y][C.x].type=5,e.cells[C.y][C.x].color=A(5,z.White),p++,H=!0}if(!H&&v.length>=2){let C=v.pop();e.cells[C.y][C.x].type=5,e.cells[C.y][C.x].color=A(5,z.White),p++,H=!0}if(H){let C=v.pop();e.cells[C.y][C.x].type=5;let N=A(5,z.White);if(l&&Math.random()<.4){let F=x.filter(I=>I!==N);F.length>0&&(N=F[Math.floor(Math.random()*F.length)])}e.cells[C.y][C.x].color=N,p++}}}if(l){let T=Math.max(1,Math.floor(g.length/8));for(let q=0;q<T;q++)for(let $ of x){if(v.length<1)break;if(Math.random()>.3+s*.4)continue;let D=g.filter(w=>e.cells[w.y][w.x].color===$).length;if(D===1){let w=v.pop();e.cells[w.y][w.x].type=2,e.cells[w.y][w.x].color=$,f++}else if(D===0&&v.length>=2)for(let w=0;w<2;w++){let H=v.pop();e.cells[H.y][H.x].type=2,e.cells[H.y][H.x].color=$,f++}}}}if(o&&!l&&P.size<2){for(let M of m)if(M.every(k=>e.cells[k.y][k.x].type===0)){let k=x.find(b=>!P.has(b))||z.White,g=M[Math.floor(Math.random()*M.length)];e.cells[g.y][g.x].type=1,e.cells[g.y][g.x].color=k,P.add(k),r++;break}}}}calculateRegions(e,t){let n=[],s=new Set,i=new Set;for(let o=0;o<t.length-1;o++)i.add(this.getEdgeKey(t[o],t[o+1]));for(let o=0;o<e.rows;o++)for(let l=0;l<e.cols;l++){if(s.has(`${l},${o}`))continue;let u=[],h=[{x:l,y:o}];for(s.add(`${l},${o}`);h.length>0;){let a=h.shift();u.push(a);let r=[{dx:0,dy:-1,p1:{x:a.x,y:a.y},p2:{x:a.x+1,y:a.y}},{dx:0,dy:1,p1:{x:a.x,y:a.y+1},p2:{x:a.x+1,y:a.y+1}},{dx:-1,dy:0,p1:{x:a.x,y:a.y},p2:{x:a.x,y:a.y+1}},{dx:1,dy:0,p1:{x:a.x+1,y:a.y},p2:{x:a.x+1,y:a.y+1}}];for(let f of r){let c=a.x+f.dx,p=a.y+f.dy;c>=0&&c<e.cols&&p>=0&&p<e.rows&&!s.has(`${c},${p}`)&&!i.has(this.getEdgeKey(f.p1,f.p2))&&!this.isAbsentEdge(e,f.p1,f.p2)&&(s.add(`${c},${p}`),h.push({x:c,y:p}))}}n.push(u)}return n}isAbsentEdge(e,t,n){if(t.x===n.x){let s=Math.min(t.y,n.y);return e.vEdges[s][t.x].type===2}else{let s=Math.min(t.x,n.x);return e.hEdges[t.y][s].type===2}}getRegionBoundaryEdges(e,t,n){let s=new Set;for(let l=0;l<n.length-1;l++)s.add(this.getEdgeKey(n[l],n[l+1]));let i=[];for(let l of t){let u=[{type:"h",r:l.y,c:l.x},{type:"h",r:l.y+1,c:l.x},{type:"v",r:l.y,c:l.x},{type:"v",r:l.y,c:l.x+1}];for(let h of u){let a=h.type==="h"?{x:h.c,y:h.r}:{x:h.c,y:h.r},r=h.type==="h"?{x:h.c+1,y:h.r}:{x:h.c,y:h.r+1},f=this.getEdgeKey(a,r);!s.has(f)&&!this.isAbsentEdge(e,a,r)&&i.push(h)}}let o=new Map;for(let l of i)o.set(`${l.type},${l.r},${l.c}`,l);return Array.from(o.values())}setEdgeHexagon(e,t,n){t.x===n.x?e.vEdges[Math.min(t.y,n.y)][t.x].type=3:e.hEdges[t.y][Math.min(t.x,n.x)].type=3}checkAllRequestedConstraintsPresent(e,t){let n=t.useHexagons??!0,s=t.useSquares??!0,i=t.useStars??!0,o=t.useTetris??!1,l=t.useEraser??!1;if(t.useBrokenEdges??!1){let h=!1;for(let a=0;a<=e.rows;a++)for(let r=0;r<e.cols;r++)if(e.hEdges[a][r].type===1||e.hEdges[a][r].type===2){h=!0;break}if(!h){for(let a=0;a<e.rows;a++)for(let r=0;r<=e.cols;r++)if(e.vEdges[a][r].type===1||e.vEdges[a][r].type===2){h=!0;break}}if(!h)return!1}if(n){let h=!1;for(let a=0;a<=e.rows;a++)for(let r=0;r<e.cols;r++)if(e.hEdges[a][r].type===3){h=!0;break}if(!h){for(let a=0;a<e.rows;a++)for(let r=0;r<=e.cols;r++)if(e.vEdges[a][r].type===3){h=!0;break}}if(!h)return!1}if(s||i||o||l){let h=!1,a=!1,r=!1,f=!1,c=new Set;for(let p=0;p<e.rows;p++)for(let d=0;d<e.cols;d++){let y=e.cells[p][d].type;y===1&&(h=!0,c.add(e.cells[p][d].color)),y===2&&(a=!0),(y===3||y===4)&&(r=!0),y===5&&(f=!0)}if(s&&!h||i&&!a||o&&!r||l&&!f||s&&h&&!a&&c.size<2)return!1}return!this.hasIsolatedMark(e)}generateTiling(e,t,n){let s=Math.min(...e.map(r=>r.x)),i=Math.min(...e.map(r=>r.y)),o=Math.max(...e.map(r=>r.x)),l=Math.max(...e.map(r=>r.y)),u=o-s+1,h=l-i+1,a=Array.from({length:h},()=>Array(u).fill(!1));for(let r of e)a[r.y-i][r.x-s]=!0;return this.tilingDfs(a,[],t,n)}tilingDfs(e,t,n,s){let i=-1,o=-1;for(let h=0;h<e.length;h++){for(let a=0;a<e[0].length;a++)if(e[h][a]){i=h,o=a;break}if(i!==-1)break}if(i===-1)return t;if(t.length>=n)return null;let l=s.difficulty??.5,u=[...this.TETRIS_SHAPES];this.shuffleArray(u),l>.6&&u.sort((h,a)=>this.getShapeArea(a)-this.getShapeArea(h));for(let h of u){let a=this.isRotationallyInvariant(h),r=a?[h]:this.getAllRotations(h);this.shuffleArray(r);for(let f of r){let c=[];for(let p=0;p<f.length;p++)for(let d=0;d<f[0].length;d++)f[p][d]&&c.push({r:p,c:d});for(let p of c){let d=i-p.r,y=o-p.c;if(this.canPlace(e,f,d,y)){this.placePiece(e,f,d,y,!1);let m=this.tilingDfs(e,[...t,{shape:f,displayShape:h,isRotated:!a&&Math.random()<.3+l*.6}],n,s);if(m)return m;this.placePiece(e,f,d,y,!0)}}}}return null}getShapeArea(e){let t=0;for(let n of e)for(let s of n)s&&t++;return t}isRotationallyInvariant(e){let t=this.getShapeArea(e);return t===1||t===4&&e.length===2&&e[0].length===2}getAllRotations(e){let t=[],n=new Set,s=e;for(let i=0;i<4;i++){let o=JSON.stringify(s);n.has(o)||(t.push(s),n.add(o)),s=this.rotate90(s)}return t}rotate90(e){let t=e.length,n=e[0].length,s=Array.from({length:n},()=>Array(t).fill(0));for(let i=0;i<t;i++)for(let o=0;o<n;o++)s[o][t-1-i]=e[i][o];return s}canPlace(e,t,n,s){for(let i=0;i<t.length;i++)for(let o=0;o<t[0].length;o++)if(t[i][o]){let l=n+i,u=s+o;if(l<0||l>=e.length||u<0||u>=e[0].length||!e[l][u])return!1}return!0}placePiece(e,t,n,s,i){for(let o=0;o<t.length;o++)for(let l=0;l<t[0].length;l++)t[o][l]&&(e[n+o][s+l]=i)}shuffleArray(e){for(let t=e.length-1;t>0;t--){let n=Math.floor(Math.random()*(t+1));[e[t],e[n]]=[e[n],e[t]]}}};var _=class{bytes=[];cur=0;bit=0;write(e,t){for(let n=0;n<t;n++)e&1<<n&&(this.cur|=1<<this.bit),this.bit++,this.bit===8&&(this.bytes.push(this.cur),this.cur=0,this.bit=0)}finish(){return this.bit>0&&this.bytes.push(this.cur),new Uint8Array(this.bytes)}},Q=class{constructor(e){this.buf=e}i=0;bit=0;read(e){let t=0;for(let n=0;n<e;n++)this.buf[this.i]&1<<this.bit&&(t|=1<<n),this.bit++,this.bit===8&&(this.bit=0,this.i++);return t}};function re(L){let e=new Map;for(let t of L)for(let n of t)if(n.shape){let s=JSON.stringify(n.shape);e.has(s)||e.set(s,n.shape)}return[...e.values()]}var Z=class{static async serialize(e,t){let n=new _;n.write(e.rows,6),n.write(e.cols,6);let s=re(e.cells);n.write(s.length,5);for(let a of s){n.write(a.length,4),n.write(a[0].length,4);for(let r of a)for(let f of r)n.write(f,1)}let i=new Map;s.forEach((a,r)=>i.set(JSON.stringify(a),r));for(let a of e.cells)for(let r of a)n.write(r.type,3),n.write(r.color,3),r.shape?(n.write(1,1),n.write(i.get(JSON.stringify(r.shape)),5)):n.write(0,1);for(let a=0;a<e.rows;a++)for(let r=0;r<e.cols+1;r++)n.write(e.vEdges[a][r].type,2);for(let a=0;a<e.rows+1;a++)for(let r=0;r<e.cols;r++)n.write(e.hEdges[a][r].type,2);for(let a=0;a<e.rows+1;a++)for(let r=0;r<e.cols+1;r++)n.write(e.nodes[a][r].type,2);n.write(+!!t.useHexagons,1),n.write(+!!t.useSquares,1),n.write(+!!t.useStars,1),n.write(+!!t.useTetris,1),n.write(+!!t.useEraser,1),n.write(+!!t.useBrokenEdges,1),n.write(Math.round((t.complexity??0)*254),8),n.write(Math.round((t.difficulty??0)*254),8),n.write(Math.round((t.pathLength??0)*254),8);let o=n.finish(),l=new Uint8Array(await new Response(new Blob([o.buffer]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()),u=0;for(let a of l)u^=a;let h=new Uint8Array(l.length+1);return h.set(l),h[l.length]=u,btoa(String.fromCharCode(...h)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}static async deserialize(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4;)t+="=";let n=atob(t),s=Uint8Array.from(n,b=>b.charCodeAt(0)),i=0;for(let b=0;b<s.length-1;b++)i^=s[b];if(i!==s.at(-1))throw new Error("Invalid parity data");let o=new Uint8Array(await new Response(new Blob([s.slice(0,-1).buffer]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer()),l=new Q(o),u=l.read(6),h=l.read(6),a=l.read(5),r=[];for(let b=0;b<a;b++){let E=l.read(4),O=l.read(4),v=[];for(let B=0;B<E;B++){let G=[];for(let T=0;T<O;T++)G.push(l.read(1));v.push(G)}r.push(v)}let f=[];for(let b=0;b<u;b++){let E=[];for(let O=0;O<h;O++){let v=l.read(3),B=l.read(3),G=l.read(1),T={type:v,color:B};G&&(T.shape=r[l.read(5)].map(q=>q.slice())),E.push(T)}f.push(E)}let c=Array.from({length:u},()=>Array.from({length:h+1},()=>({type:l.read(2)}))),p=Array.from({length:u+1},()=>Array.from({length:h},()=>({type:l.read(2)}))),d=Array.from({length:u+1},()=>Array.from({length:h+1},()=>({type:l.read(2)}))),y=()=>{let b=l.read(8);return Math.round(b/254*1e3)/1e3},m={},x=!!l.read(1),S=!!l.read(1),A=!!l.read(1),R=!!l.read(1),P=!!l.read(1),V=!!l.read(1);x&&(m.useHexagons=!0),S&&(m.useSquares=!0),A&&(m.useStars=!0),R&&(m.useTetris=!0),P&&(m.useEraser=!0),V&&(m.useBrokenEdges=!0);let M=y(),k=y(),g=y();return M!==0&&(m.complexity=M),k!==0&&(m.difficulty=k),g!==0&&(m.pathLength=g),{puzzle:{rows:u,cols:h,cells:f,vEdges:c,hEdges:p,nodes:d},options:m}}};var ee=class{canvas;ctx;puzzle=null;options;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;invalidatedCells=[];invalidatedEdges=[];errorCells=[];errorEdges=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;constructor(e,t,n={}){if(typeof window>"u"){this.canvas={},this.ctx={},this.options=this.mergeOptions(n);return}if(typeof e=="string"){let i=document.getElementById(e);if(!(i instanceof HTMLCanvasElement))throw new Error(`Element with id "${e}" is not a canvas.`);this.canvas=i}else this.canvas=e;let s=this.canvas.getContext("2d");if(!s)throw new Error("Could not get 2D context.");this.ctx=s,this.ctx.imageSmoothingEnabled=!1,this.options=this.mergeOptions(n),t&&this.setPuzzle(t),this.initEvents(),this.animate()}mergeOptions(e){return{gridPadding:e.gridPadding??60,cellSize:e.cellSize??80,nodeRadius:e.nodeRadius??6,startNodeRadius:e.startNodeRadius??22,pathWidth:e.pathWidth??18,exitLength:e.exitLength??25,autoResize:e.autoResize??!0,animations:{blinkDuration:e.animations?.blinkDuration??1e3,fadeDuration:e.animations?.fadeDuration??1e3,blinkPeriod:e.animations?.blinkPeriod??800},colors:{path:e.colors?.path??"#ffcc00",error:e.colors?.error??"#ff4444",success:e.colors?.success??"#ffcc00",interrupted:e.colors?.interrupted??"#ffcc00",grid:e.colors?.grid??"#555",node:e.colors?.node??"#555",hexagon:e.colors?.hexagon??"#ffcc00",colorMap:e.colors?.colorMap??{[z.Black]:"#000",[z.White]:"#fff",[z.Red]:"#f00",[z.Blue]:"#00f",[z.None]:"#ffcc00"},colorList:e.colors?.colorList},onPathComplete:e.onPathComplete??(()=>{})}}setPuzzle(e){this.puzzle=e,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.invalidatedCells=[],this.invalidatedEdges=[],this.errorCells=[],this.errorEdges=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw()}setOptions(e){this.options=this.mergeOptions({...this.options,...e}),this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}setValidationResult(e,t=[],n=[],s=[],i=[]){this.invalidatedCells=t,this.invalidatedEdges=n,this.errorCells=s,this.errorEdges=i,this.eraserAnimationStartTime=Date.now(),e?(this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0}resizeCanvas(){!this.puzzle||!this.canvas||(this.canvas.width=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,this.canvas.height=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2)}initEvents(){typeof window>"u"||(this.canvas.addEventListener("mousedown",e=>this.handleStart(e)),window.addEventListener("mousemove",e=>this.handleMove(e)),window.addEventListener("mouseup",e=>this.handleEnd(e)),this.canvas.addEventListener("touchstart",e=>{this.handleStart(e.touches[0])&&e.preventDefault()},{passive:!1}),window.addEventListener("touchmove",e=>{this.isDrawing&&e.preventDefault(),this.handleMove(e.touches[0])},{passive:!1}),window.addEventListener("touchend",e=>{this.isDrawing&&e.preventDefault(),this.handleEnd(e.changedTouches[0])},{passive:!1}))}getCanvasCoords(e,t){return{x:this.options.gridPadding+e*this.options.cellSize,y:this.options.gridPadding+t*this.options.cellSize}}getExitDir(e,t){return!this.puzzle||this.puzzle.nodes[t][e].type!==2?null:e===this.puzzle.cols?{x:1,y:0}:e===0?{x:-1,y:0}:t===0?{x:0,y:-1}:t===this.puzzle.rows?{x:0,y:1}:{x:1,y:0}}handleStart(e){if(!this.puzzle)return!1;let t=this.canvas.getBoundingClientRect(),n=(e.clientX-t.left)*(this.canvas.width/t.width),s=(e.clientY-t.top)*(this.canvas.height/t.height);for(let i=0;i<=this.puzzle.rows;i++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[i][o].type===1){let l=this.getCanvasCoords(o,i);if(Math.hypot(l.x-n,l.y-s)<this.options.startNodeRadius)return this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.errorCells=[],this.errorEdges=[],this.isDrawing=!0,this.path=[{x:o,y:i}],this.currentMousePos=l,this.exitTipPos=null,this.draw(),!0}return!1}handleMove(e){if(!this.puzzle||!this.isDrawing)return;let t=this.canvas.getBoundingClientRect(),n=(e.clientX-t.left)*(this.canvas.width/t.width),s=(e.clientY-t.top)*(this.canvas.height/t.height),i=this.path[this.path.length-1],o=this.getCanvasCoords(i.x,i.y),l=n-o.x,u=s-o.y,h=this.getExitDir(i.x,i.y);if(h){let r=l*h.x+u*h.y;if(r>0){let f=Math.min(r,this.options.exitLength);this.currentMousePos={x:o.x+h.x*f,y:o.y+h.y*f},this.draw();return}}if(Math.abs(l)>Math.abs(u)){let r=l>0?1:-1,f={x:i.x+r,y:i.y},c=this.getEdgeType(i,f);if(f.x>=0&&f.x<=this.puzzle.cols&&c!==2){let p=c===1?this.options.cellSize*.35:this.options.cellSize;this.currentMousePos={x:o.x+Math.max(-p,Math.min(p,l)),y:o.y}}else this.currentMousePos=o}else{let r=u>0?1:-1,f={x:i.x,y:i.y+r},c=this.getEdgeType(i,f);if(f.y>=0&&f.y<=this.puzzle.rows&&c!==2){let p=c===1?this.options.cellSize*.35:this.options.cellSize;this.currentMousePos={x:o.x,y:o.y+Math.max(-p,Math.min(p,u))}}else this.currentMousePos=o}let a=[{x:i.x+1,y:i.y},{x:i.x-1,y:i.y},{x:i.x,y:i.y+1},{x:i.x,y:i.y-1}];for(let r of a)if(r.x>=0&&r.x<=this.puzzle.cols&&r.y>=0&&r.y<=this.puzzle.rows){let f=this.getCanvasCoords(r.x,r.y);if(Math.hypot(f.x-this.currentMousePos.x,f.y-this.currentMousePos.y)<this.options.cellSize*.3){let p=this.path.findIndex(d=>d.x===r.x&&d.y===r.y);p===-1?this.path.push(r):p===this.path.length-2&&this.path.pop()}}this.draw()}handleEnd(e){if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let t=this.path[this.path.length-1],n=this.getCanvasCoords(t.x,t.y),s=this.getExitDir(t.x,t.y);if(s&&Math.hypot(this.currentMousePos.x-n.x,this.currentMousePos.y-n.y)>this.options.exitLength*.1){this.exitTipPos={...this.currentMousePos},this.options.onPathComplete(this.path);return}this.exitTipPos=s?{...this.currentMousePos}:null,this.startFade(this.options.colors.interrupted)}getEdgeType(e,t){if(!this.puzzle)return 2;if(e.x===t.x){let n=Math.min(e.y,t.y);return n<0||n>=this.puzzle.rows?2:this.puzzle.vEdges[n][e.x].type}else{let n=Math.min(e.x,t.x);return n<0||n>=this.puzzle.cols?2:this.puzzle.hEdges[e.y][n].type}}startFade(e="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=e,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){if(!(typeof window>"u")){if(this.draw(),this.isFading){let e=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=e,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0)}requestAnimationFrame(()=>this.animate())}}draw(){if(!this.puzzle||!this.ctx)return;let e=this.ctx,t=Date.now();if(e.globalAlpha=1,e.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(e),this.drawConstraints(e),this.drawNodes(e),this.path.length===0&&!this.isDrawing&&this.drawRipples(e),this.isFading)this.drawPath(e,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos);else if(this.path.length>0){let n=this.isInvalidPath?this.options.colors.error:this.options.colors.path;if(this.isSuccessFading&&(n=this.options.colors.success),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let s=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),i=this.options.animations.blinkDuration;if(s<i)if(this.isSuccessFading)(this.invalidatedCells.length>0||this.invalidatedEdges.length>0)&&(n=this.options.colors.error);else{let o=Math.min(1,s/200),l=s>i*.8?(i-s)/(i*.2):1,u=Math.min(o,l),h=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;n=this.lerpColor(this.options.colors.path,this.options.colors.error,h*u)}}this.drawPath(e,this.path,this.isDrawing,n,1,this.isDrawing?this.currentMousePos:this.exitTipPos)}}drawRipples(e){if(!this.puzzle)return;let t=(Date.now()-this.startTime)/500;for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)if(this.puzzle.nodes[n][s].type===2){let o=this.getCanvasCoords(s,n),l=this.getExitDir(s,n);if(!l)continue;let u={x:o.x+l.x*this.options.exitLength,y:o.y+l.y*this.options.exitLength},h=t%4,a=h*5,r=Math.max(0,1-h/3);e.beginPath(),e.arc(u.x,u.y,a,0,Math.PI*2),e.strokeStyle=`rgba(170, 170, 170, ${r*.4})`,e.lineWidth=2,e.stroke()}}drawGrid(e){if(!this.puzzle||!this.options.colors.grid)return;e.strokeStyle=this.options.colors.grid,e.lineWidth=12,e.lineCap="round";let t=(n,s,i)=>{if(i!==2)if(i===1){let l={x:n.x+(s.x-n.x)*.35,y:n.y+(s.y-n.y)*.35},u={x:n.x+(s.x-n.x)*(.5+.15),y:n.y+(s.y-n.y)*(.5+.15)};e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(l.x,l.y),e.stroke(),e.beginPath(),e.moveTo(u.x,u.y),e.lineTo(s.x,s.y),e.stroke()}else e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(s.x,s.y),e.stroke()};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<this.puzzle.cols;s++)t(this.getCanvasCoords(s,n),this.getCanvasCoords(s+1,n),this.puzzle.hEdges[n][s].type);for(let n=0;n<this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)t(this.getCanvasCoords(s,n),this.getCanvasCoords(s,n+1),this.puzzle.vEdges[n][s].type)}drawConstraints(e){if(!this.puzzle)return;let t=Date.now(),n=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;for(let i=0;i<this.puzzle.rows;i++)for(let o=0;o<this.puzzle.cols;o++){let l=this.puzzle.cells[i][o],u=this.getCanvasCoords(o+.5,i+.5),h=this.invalidatedCells.some(d=>d.x===o&&d.y===i),a=this.errorCells.some(d=>d.x===o&&d.y===i),r=1,f,c=this.getColorCode(l.color),p=this.options.colors.error;if(a&&(f=this.lerpColor(c,p,n)),h){let d=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),y=this.options.animations.blinkDuration;if(this.isFading)r=this.fadeOpacity;else if(d<y){let m=Math.min(1,d/200),x=d>y*.8?(y-d)/(y*.2):1,S=Math.min(m,x);f=this.lerpColor(c,p,n*S)}else r=Math.max(.3,1-(d-y)/this.options.animations.fadeDuration)}if(r<1||f){let{canvas:d,ctx:y}=this.prepareOffscreen();this.drawConstraintItem(y,l,u,f),e.save(),e.globalAlpha=r,e.drawImage(d,0,0),e.restore()}else this.drawConstraintItem(e,l,u)}e.lineWidth=2;let s=8;for(let i=0;i<=this.puzzle.rows;i++)for(let o=0;o<this.puzzle.cols;o++)if(this.puzzle.hEdges[i][o].type===3){let l=this.getCanvasCoords(o+.5,i);e.save();let u=this.invalidatedEdges.some(a=>a.type==="h"&&a.r===i&&a.c===o);if(this.errorEdges.some(a=>a.type==="h"&&a.r===i&&a.c===o)){let a=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(e,l.x,l.y,s,a)}else if(u){let a=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),r=this.options.animations.blinkDuration;if(this.isFading)e.globalAlpha*=this.fadeOpacity;else if(a<r){let f=Math.min(1,a/200),c=a>r*.8?(r-a)/(r*.2):1,p=Math.min(f,c),d=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*p);this.drawHexagon(e,l.x,l.y,s,d)}else e.globalAlpha*=Math.max(.3,1-(a-r)/this.options.animations.fadeDuration),this.drawHexagon(e,l.x,l.y,s)}else this.drawHexagon(e,l.x,l.y,s);e.restore()}for(let i=0;i<this.puzzle.rows;i++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.vEdges[i][o].type===3){let l=this.getCanvasCoords(o,i+.5);e.save();let u=this.invalidatedEdges.some(a=>a.type==="v"&&a.r===i&&a.c===o);if(this.errorEdges.some(a=>a.type==="v"&&a.r===i&&a.c===o)){let a=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(e,l.x,l.y,s,a)}else if(u){let a=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),r=this.options.animations.blinkDuration;if(this.isFading)e.globalAlpha*=this.fadeOpacity;else if(a<r){let f=Math.min(1,a/200),c=a>r*.8?(r-a)/(r*.2):1,p=Math.min(f,c),d=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*p);this.drawHexagon(e,l.x,l.y,s,d)}else e.globalAlpha*=Math.max(.3,1-(a-r)/this.options.animations.fadeDuration),this.drawHexagon(e,l.x,l.y,s)}else this.drawHexagon(e,l.x,l.y,s);e.restore()}}drawConstraintItem(e,t,n,s){t.type===1?(e.fillStyle=s||this.getColorCode(t.color),this.drawRoundedRect(e,n.x-26/2,n.y-26/2,26,26,8)):t.type===2?this.drawStar(e,n.x,n.y,12,16,8,t.color,s):t.type===3||t.type===4?this.drawTetris(e,n.x,n.y,t.shape||[],t.type===4,t.color,s):t.type===5&&this.drawEraser(e,n.x,n.y,14,3,t.color,s)}drawNodes(e){if(!this.puzzle)return;let t=(n,s)=>{let i=[];return n>0&&i.push(this.puzzle.hEdges[s][n-1].type),n<this.puzzle.cols&&i.push(this.puzzle.hEdges[s][n].type),s>0&&i.push(this.puzzle.vEdges[s-1][n].type),s<this.puzzle.rows&&i.push(this.puzzle.vEdges[s][n].type),i.length>0&&i.every(o=>o===2)};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++){if(t(s,n))continue;let i=this.puzzle.nodes[n][s],o=this.getCanvasCoords(s,n);if(i.type===1)this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill();else if(i.type===2){let l=this.getExitDir(s,n);if(!l)continue;this.options.colors.node&&(e.strokeStyle=this.options.colors.node),e.lineWidth=12,e.lineCap="round",e.beginPath(),e.moveTo(o.x,o.y),e.lineTo(o.x+l.x*this.options.exitLength,o.y+l.y*this.options.exitLength),e.stroke()}else this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.nodeRadius,0,Math.PI*2),e.fill()}}drawPath(e,t,n,s,i,o=null){if(!(t.length===0||!s))if(i<1){let{canvas:l,ctx:u}=this.prepareOffscreen();this.drawPathInternal(u,t,n,s,o),e.save(),e.globalAlpha=i,e.drawImage(l,0,0),e.restore()}else this.drawPathInternal(e,t,n,s,o)}drawPathInternal(e,t,n,s,i=null){e.save(),e.strokeStyle=s,e.fillStyle=s,e.lineWidth=this.options.pathWidth,e.lineCap="round",e.lineJoin="round",e.beginPath();let o=this.getCanvasCoords(t[0].x,t[0].y);e.moveTo(o.x,o.y);for(let l=1;l<t.length;l++){let u=this.getCanvasCoords(t[l].x,t[l].y);e.lineTo(u.x,u.y)}if(n||i){let l=i||this.currentMousePos;e.lineTo(l.x,l.y)}e.stroke(),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill(),n&&(e.beginPath(),e.arc(this.currentMousePos.x,this.currentMousePos.y,this.options.pathWidth/2,0,Math.PI*2),e.fill()),e.restore()}drawRoundedRect(e,t,n,s,i,o){e.beginPath(),e.moveTo(t+o,n),e.lineTo(t+s-o,n),e.quadraticCurveTo(t+s,n,t+s,n+o),e.lineTo(t+s,n+i-o),e.quadraticCurveTo(t+s,n+i,t+s-o,n+i),e.lineTo(t+o,n+i),e.quadraticCurveTo(t,n+i,t,n+i-o),e.lineTo(t,n+o),e.quadraticCurveTo(t,n,t+o,n),e.closePath(),e.fill()}drawHexagon(e,t,n,s,i){if(!(!this.options.colors.hexagon&&!i)){e.fillStyle=i||this.options.colors.hexagon,e.beginPath();for(let o=0;o<6;o++){let l=Math.PI/3*o,u=t+s*Math.cos(l),h=n+s*Math.sin(l);o===0?e.moveTo(u,h):e.lineTo(u,h)}e.closePath(),e.fill()}}drawEraser(e,t,n,s,i,o,l){e.strokeStyle=l||this.getColorCode(o),e.lineWidth=s*.5,e.lineCap="butt";let u=.5;e.beginPath();for(let h=0;h<i;h++){let a=Math.PI*2/i*h+u,r=t+s*Math.cos(a),f=n+s*Math.sin(a);e.moveTo(t,n),e.lineTo(r,f)}e.stroke()}drawStar(e,t,n,s,i,o,l,u){e.fillStyle=u||this.getColorCode(l),e.beginPath();for(let h=0;h<o*2;h++){let a=h%2===0?i:s,r=Math.PI/o*h,f=t+a*Math.cos(r),c=n+a*Math.sin(r);h===0?e.moveTo(f,c):e.lineTo(f,c)}e.closePath(),e.fill()}drawTetris(e,t,n,s,i,o,l){if(!s||s.length===0)return;let u=12,h=2,a=s[0].length*u+(s[0].length-1)*h,r=s.length*u+(s.length-1)*h;e.save(),e.translate(t,n),i&&e.rotate(Math.PI/8),e.fillStyle=l||this.getColorCode(o,"#ffcc00");for(let f=0;f<s.length;f++)for(let c=0;c<s[f].length;c++)if(s[f][c]){let p=c*(u+h)-a/2,d=f*(u+h)-r/2;e.fillRect(p,d,u,u)}e.restore()}getColorCode(e,t="#666"){return this.options.colors.colorList&&this.options.colors.colorList[e]!==void 0?this.options.colors.colorList[e]:this.options.colors.colorMap&&this.options.colors.colorMap[e]!==void 0?this.options.colors.colorMap[e]:t}hexToRgb(e){let t=e.startsWith("#")?e.slice(1):e;t.length===3&&(t=t.split("").map(s=>s+s).join(""));let n=parseInt(t,16);return{r:n>>16&255,g:n>>8&255,b:n&255}}rgbToHex(e,t,n){return"#"+((1<<24)+(e<<16)+(t<<8)+n).toString(16).slice(1)}lerpColor(e,t,n){try{let s=this.hexToRgb(e),i=this.hexToRgb(t);return this.rgbToHex(Math.round(s.r+(i.r-s.r)*n),Math.round(s.g+(i.g-s.g)*n),Math.round(s.b+(i.b-s.b)*n))}catch{return e}}prepareOffscreen(){return typeof document>"u"?{canvas:{},ctx:{}}:(this.offscreenCanvas||(this.offscreenCanvas=document.createElement("canvas"),this.offscreenCtx=this.offscreenCanvas.getContext("2d")),(this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx})}};var se=class{generator;validator;constructor(){this.generator=new J,this.validator=new K}createPuzzle(e,t,n={}){return this.generator.generate(e,t,n).export()}validateSolution(e,t){let n=W.fromData(e);return this.validator.validate(n,t)}calculateDifficulty(e){let t=W.fromData(e);return this.validator.calculateDifficulty(t)}};export{U as CellType,z as Color,oe as Direction,Y as EdgeType,W as Grid,j as NodeType,J as PuzzleGenerator,Z as PuzzleSerializer,K as PuzzleValidator,se as WitnessCore,ee as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
