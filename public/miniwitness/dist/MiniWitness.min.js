/*!
 * MiniWitness 1.2.1
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var lt=(s=>(s[s.Up=0]="Up",s[s.Right=1]="Right",s[s.Down=2]="Down",s[s.Left=3]="Left",s))(lt||{}),j=(o=>(o[o.None=0]="None",o[o.Square=1]="Square",o[o.Star=2]="Star",o[o.Tetris=3]="Tetris",o[o.TetrisRotated=4]="TetrisRotated",o[o.Eraser=5]="Eraser",o))(j||{}),_=(s=>(s[s.Normal=0]="Normal",s[s.Broken=1]="Broken",s[s.Absent=2]="Absent",s[s.Hexagon=3]="Hexagon",s))(_||{}),Q=(s=>(s[s.Normal=0]="Normal",s[s.Start=1]="Start",s[s.End=2]="End",s[s.Hexagon=3]="Hexagon",s))(Q||{}),tt=(s=>(s[s.None=0]="None",s[s.Horizontal=1]="Horizontal",s[s.Vertical=2]="Vertical",s[s.Rotational=3]="Rotational",s))(tt||{}),H={None:0,Black:1,White:2,Red:3,Blue:4};var U=class X{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];symmetry=0;constructor(t,e){this.rows=t,this.cols=e,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:H.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes,symmetry:this.symmetry}))}static fromData(t){let e=new X(t.rows,t.cols);return e.cells=t.cells,e.vEdges=t.vEdges,e.hEdges=t.hEdges,e.nodes=t.nodes,e.symmetry=t.symmetry||0,e}};var Y=class{validate(t,e,n){let s=e.points;if(s.length<2)return{isValid:!1,errorReason:"Path too short"};let a=t.symmetry||0,o=[];if(a!==0)for(let u of s)o.push(this.getSymmetricalPoint(t,u));let r=s[0],h=s[s.length-1];if(t.nodes[r.y][r.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(t.nodes[h.y][h.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};if(a!==0){let u=o[0],y=o[o.length-1];if(t.nodes[u.y][u.x].type!==1)return{isValid:!1,errorReason:"Symmetrical path must start at Start Node"};if(t.nodes[y.y][y.x].type!==2)return{isValid:!1,errorReason:"Symmetrical path must end at End Node"}}let f=new Set,l=new Set;if(f.add(`${r.x},${r.y}`),a!==0){let u=o[0];if(f.has(`${u.x},${u.y}`))return{isValid:!1,errorReason:"Paths collide at start"};f.add(`${u.x},${u.y}`)}for(let u=0;u<s.length-1;u++){let y=s[u],m=s[u+1];if(Math.abs(y.x-m.x)+Math.abs(y.y-m.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let g=`${m.x},${m.y}`;if(f.has(g))return{isValid:!1,errorReason:"Self-intersecting path or path collision"};if(f.add(g),this.isBrokenEdge(t,y,m))return{isValid:!1,errorReason:"Passed through broken edge"};if(l.add(this.getEdgeKey(y,m)),a!==0){let b=o[u],p=o[u+1],v=`${p.x},${p.y}`;if(f.has(v))return{isValid:!1,errorReason:"Path collision"};if(f.add(v),this.isBrokenEdge(t,b,p))return{isValid:!1,errorReason:"Symmetrical path passed through broken edge"};let P=this.getEdgeKey(b,p);if(l.has(P))return{isValid:!1,errorReason:"Paths cross the same edge"};l.add(P)}}let i=this.calculateRegions(t,s,o,n),c=this.getMissedHexagons(t,s,o),d=this.validateWithErasers(t,i,c.edges,c.nodes);return d.regions=i,d}validateFast(t,e,n,s){let a=this.calculateRegions(t,e,n,s),o=this.getMissedHexagons(t,e,n);return this.validateWithErasers(t,a,o.edges,o.nodes)}isBrokenEdge(t,e,n){let s;if(e.x===n.x){let a=Math.min(e.y,n.y);s=t.vEdges[a][e.x].type}else{let a=Math.min(e.x,n.x);s=t.hEdges[e.y][a].type}return s===1||s===2}isAbsentEdge(t,e,n){if(e.x===n.x){let s=Math.min(e.y,n.y);return t.vEdges[s][e.x].type===2}else{let s=Math.min(e.x,n.x);return t.hEdges[e.y][s].type===2}}getMissedHexagons(t,e,n=[]){let s=new Set,a=new Set;for(let h=0;h<e.length;h++)a.add(`${e[h].x},${e[h].y}`),h<e.length-1&&s.add(this.getEdgeKey(e[h],e[h+1]));for(let h=0;h<n.length;h++)a.add(`${n[h].x},${n[h].y}`),h<n.length-1&&s.add(this.getEdgeKey(n[h],n[h+1]));let o=[];for(let h=0;h<=t.rows;h++)for(let f=0;f<t.cols;f++)if(t.hEdges[h][f].type===3){let l=this.getEdgeKey({x:f,y:h},{x:f+1,y:h});s.has(l)||o.push({type:"h",r:h,c:f})}for(let h=0;h<t.rows;h++)for(let f=0;f<=t.cols;f++)if(t.vEdges[h][f].type===3){let l=this.getEdgeKey({x:f,y:h},{x:f,y:h+1});s.has(l)||o.push({type:"v",r:h,c:f})}let r=[];for(let h=0;h<=t.rows;h++)for(let f=0;f<=t.cols;f++)t.nodes[h][f].type===3&&(a.has(`${f},${h}`)||r.push({x:f,y:h}));return{edges:o,nodes:r}}validateWithErasers(t,e,n,s){let a=[],o=!0;for(let d=0;d<e.length;d++){let u=e[d],y=u.filter(p=>t.cells[p.y][p.x].type===5),m=u.filter(p=>t.cells[p.y][p.x].type!==0&&t.cells[p.y][p.x].type!==5),x=[];for(let p=0;p<n.length;p++)this.isHexagonAdjacentToRegion(t,n[p],u)&&x.push(p);let g=[];for(let p=0;p<s.length;p++)this.isNodeHexagonAdjacentToRegion(t,s[p],u)&&g.push(p);let b=this.getPossibleErasures(t,u,y,m,x,g);if(b.length===0){o=!1;let p=this.getBestEffortErasures(t,u,y,m,x,g);a.push([p])}else b.sort((p,v)=>{let P=p.invalidatedCells.length+p.invalidatedHexagons.length+p.invalidatedNodeHexagons.length,M=v.invalidatedCells.length+v.invalidatedHexagons.length+v.invalidatedNodeHexagons.length;return P-M}),a.push(b)}if(o){let d=this.findGlobalAssignment(a,n.length,s.length);if(d)return{isValid:!0,invalidatedCells:d.invalidatedCells,invalidatedEdges:d.invalidatedHexIndices.map(u=>n[u]),invalidatedNodes:d.invalidatedNodeHexIndices.map(u=>s[u])}}let r=[],h=[],f=new Set,l=new Set;for(let d of a){let u=d[0];r.push(...u.errorCells),h.push(...u.invalidatedCells);for(let y of u.invalidatedHexagons)f.add(y);for(let y of u.invalidatedNodeHexagons)l.add(y)}let i=[];for(let d=0;d<n.length;d++)f.has(d)||i.push(n[d]);let c=[];for(let d=0;d<s.length;d++)l.has(d)||c.push(s[d]);return{isValid:!1,errorReason:"Constraints failed",errorCells:r,errorEdges:i,errorNodes:c,invalidatedCells:h,invalidatedEdges:Array.from(f).map(d=>n[d]),invalidatedNodes:Array.from(l).map(d=>s[d])}}isHexagonAdjacentToRegion(t,e,n){let s=new Set(n.map(a=>`${a.x},${a.y}`));if(e.type==="h"){if(e.r>0&&s.has(`${e.c},${e.r-1}`)||e.r<t.rows&&s.has(`${e.c},${e.r}`))return!0}else if(e.c>0&&s.has(`${e.c-1},${e.r}`)||e.c<t.cols&&s.has(`${e.c},${e.r}`))return!0;return!1}isNodeHexagonAdjacentToRegion(t,e,n){let s=new Set(n.map(o=>`${o.x},${o.y}`)),a=[{x:e.x-1,y:e.y-1},{x:e.x,y:e.y-1},{x:e.x-1,y:e.y},{x:e.x,y:e.y}];for(let o of a)if(o.x>=0&&o.x<t.cols&&o.y>=0&&o.y<t.rows&&s.has(`${o.x},${o.y}`))return!0;return!1}getPossibleErasures(t,e,n,s,a,o){let r=[],h=n.length;if(h===0)return this.getRegionErrors(t,e,[]).length===0&&a.length===0&&o.length===0&&r.push({invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!0,errorCells:[]}),r;let f=[...s.map(i=>({type:"cell",pos:i})),...a.map(i=>({type:"hex",index:i})),...o.map(i=>({type:"nodeHex",index:i}))],l=this.getRegionErrors(t,e,[]).length===0&&a.length===0&&o.length===0;for(let i=0;i<=h;i++){let c=this.getNCombinations(n,i);for(let d of c){let u=new Set(d.map(m=>`${m.x},${m.y}`)),y=n.filter(m=>!u.has(`${m.x},${m.y}`));for(let m=0;m<=f.length;m++){if(y.length!==i+m)continue;let x=this.getNCombinations(f,m);for(let g of x){let b=g.filter(w=>w.type==="cell").map(w=>w.pos),p=g.filter(w=>w.type==="hex").map(w=>w.index),v=g.filter(w=>w.type==="nodeHex").map(w=>w.index);if(this.getRegionErrors(t,e,[...b,...d]).length===0){let w=!0;if(l)m>0&&(w=!1);else for(let $=0;$<g.length;$++){let V=[...g.slice(0,$),...g.slice($+1)],I=V.filter(k=>k.type==="cell").map(k=>k.pos),D=new Set(V.filter(k=>k.type==="hex").map(k=>k.index)),E=new Set(V.filter(k=>k.type==="nodeHex").map(k=>k.index)),S=a.every(k=>D.has(k)),N=o.every(k=>E.has(k));if(this.getRegionErrors(t,e,I).length===0&&S&&N){w=!1;break}}w&&r.push({invalidatedCells:[...b,...d],invalidatedHexagons:p,invalidatedNodeHexagons:v,isValid:!0,errorCells:[]})}}}}}return r}getBestEffortErasures(t,e,n,s,a,o){let r=this.getRegionErrors(t,e,[]);if(r.length===0&&a.length===0&&o.length===0)return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:[...n]};if(n.length>0){let l=[...s.map(u=>({type:"cell",pos:u})),...a.map(u=>({type:"hex",index:u})),...o.map(u=>({type:"nodeHex",index:u}))],i=null,c=1/0,d=u=>{let y=[],m=[],x=[],g=0;for(let w of u)g<n.length&&(w.type==="cell"?y.push(w.pos):w.type==="hex"?m.push(w.index):x.push(w.index),g++);let b=n.length-g,p=Math.floor(b/2),v=n.slice(g,g+p);g+=p*2;let P=this.getRegionErrors(t,e,[...y,...v]);for(let w=g;w<n.length;w++)P.push(n[w]);let M=P.length;M<c&&(c=M,i={invalidatedCells:[...y,...v],invalidatedHexagons:m,invalidatedNodeHexagons:x,isValid:!1,errorCells:P})};d([...r.map(u=>({type:"cell",pos:u})),...a.map(u=>({type:"hex",index:u})),...o.map(u=>({type:"nodeHex",index:u}))]),d(l);for(let u of r)d([{type:"cell",pos:u}]);if(i)return i}let f=[...r,...n];return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:f}}getNCombinations(t,e){let n=[],s=(a,o)=>{if(o.length===e){n.push([...o]);return}for(let r=a;r<t.length;r++)o.push(t[r]),s(r+1,o),o.pop()};return s(0,[]),n}checkRegionValid(t,e,n){return this.getRegionErrors(t,e,n).length===0}getRegionErrors(t,e,n){let s=new Set(n.map(i=>`${i.x},${i.y}`)),a=new Map,o=new Map,r=new Set,h=new Set,f=[];for(let i of e){if(s.has(`${i.x},${i.y}`))continue;let c=t.cells[i.y][i.x];if(c.type===0)continue;let d=c.color;d!==H.None&&(a.set(d,(a.get(d)||0)+1),o.has(d)||o.set(d,[]),o.get(d).push(i)),c.type===1?h.add(d):c.type===2?r.add(d):(c.type===3||c.type===4)&&c.shape&&f.push({shape:c.shape,rotatable:c.type===4,pos:i})}let l=[];if(h.size>1)for(let i of e)s.has(`${i.x},${i.y}`)||t.cells[i.y][i.x].type===1&&l.push(i);for(let i of r)if(a.get(i)!==2){let c=o.get(i)||[];for(let d of c)t.cells[d.y][d.x].type===2&&l.push(d)}if(f.length>0&&!this.checkTetrisConstraint(e,f.map(i=>({shape:i.shape,rotatable:i.rotatable}))))for(let i of f)l.push(i.pos);return l}findGlobalAssignment(t,e,n){let s=t.length,a=new Array(e).fill(0),o=new Array(n).fill(0),r=[],h=[],f=[],l=i=>{if(i===s)return a.every(c=>c===1)&&o.every(c=>c===1);for(let c of t[i]){let d=!0;for(let u of c.invalidatedHexagons)if(a[u]>0){d=!1;break}if(d){for(let u of c.invalidatedNodeHexagons)if(o[u]>0){d=!1;break}}if(d){for(let u of c.invalidatedHexagons)a[u]++,h.push(u);for(let u of c.invalidatedNodeHexagons)o[u]++,f.push(u);if(r.push(...c.invalidatedCells),l(i+1))return!0;for(let u of c.invalidatedHexagons)a[u]--,h.pop();for(let u of c.invalidatedNodeHexagons)o[u]--,f.pop();for(let u=0;u<c.invalidatedCells.length;u++)r.pop()}}return!1};return l(0)?{invalidatedCells:r,invalidatedHexIndices:h,invalidatedNodeHexIndices:f}:null}checkTetrisConstraint(t,e){if(e.reduce((i,c)=>i+this.getShapeArea(c.shape),0)!==t.length)return!1;let s=Math.min(...t.map(i=>i.x)),a=Math.min(...t.map(i=>i.y)),o=Math.max(...t.map(i=>i.x)),r=Math.max(...t.map(i=>i.y)),h=o-s+1,f=r-a+1,l=Array.from({length:f},()=>Array(h).fill(!1));for(let i of t)l[i.y-a][i.x-s]=!0;return this.canTile(l,e)}getShapeArea(t){let e=0;for(let n of t)for(let s of n)s&&e++;return e}canTile(t,e){let n=-1,s=-1;for(let a=0;a<t.length;a++){for(let o=0;o<t[0].length;o++)if(t[a][o]){n=a,s=o;break}if(n!==-1)break}if(n===-1)return e.length===0;if(e.length===0)return!1;for(let a=0;a<e.length;a++){let o=e[a],r=[...e.slice(0,a),...e.slice(a+1)],h=o.rotatable?this.getAllRotations(o.shape):[o.shape];for(let f of h){let l=[];for(let i=0;i<f.length;i++)for(let c=0;c<f[0].length;c++)f[i][c]&&l.push({r:i,c});for(let i of l){let c=n-i.r,d=s-i.c;if(this.canPlace(t,f,c,d)){if(this.placePiece(t,f,c,d,!1),this.canTile(t,r))return!0;this.placePiece(t,f,c,d,!0)}}}}return!1}canPlace(t,e,n,s){for(let a=0;a<e.length;a++)for(let o=0;o<e[0].length;o++)if(e[a][o]){let r=n+a,h=s+o;if(r<0||r>=t.length||h<0||h>=t[0].length||!t[r][h])return!1}return!0}placePiece(t,e,n,s,a){for(let o=0;o<e.length;o++)for(let r=0;r<e[0].length;r++)e[o][r]&&(t[n+o][s+r]=a)}getAllRotations(t){let e=[],n=new Set,s=t;for(let a=0;a<4;a++){let o=JSON.stringify(s);n.has(o)||(e.push(s),n.add(o)),s=this.rotate90(s)}return e}rotate90(t){let e=t.length,n=t[0].length,s=Array.from({length:n},()=>Array(e).fill(0));for(let a=0;a<e;a++)for(let o=0;o<n;o++)s[o][e-1-a]=t[a][o];return s}calculateRegions(t,e,n=[],s){let a=[],o=t.rows,r=t.cols,h=new Uint8Array(o*r),f=new Uint8Array((o+1)*r),l=new Uint8Array(o*(r+1)),i=(d,u)=>{d.x===u.x?l[Math.min(d.y,u.y)*(r+1)+d.x]=1:f[d.y*r+Math.min(d.x,u.x)]=1};for(let d=0;d<e.length-1;d++)i(e[d],e[d+1]);for(let d=0;d<n.length-1;d++)i(n[d],n[d+1]);for(let d=0;d<=o;d++)for(let u=0;u<r;u++)t.hEdges[d][u].type===2&&(f[d*r+u]=1);for(let d=0;d<o;d++)for(let u=0;u<=r;u++)t.vEdges[d][u].type===2&&(l[d*(r+1)+u]=1);let c=s||this.getExternalCells(t);for(let d=0;d<o;d++)for(let u=0;u<r;u++){let y=d*r+u;if(h[y]||c&&c.has(`${u},${d}`))continue;let m=[],x=[y];h[y]=1;let g=0;for(;g<x.length;){let b=x[g++],p=b%r,v=Math.floor(b/r);if(m.push({x:p,y:v}),v>0&&!f[v*r+p]){let P=(v-1)*r+p;!h[P]&&(!c||!c.has(`${p},${v-1}`))&&(h[P]=1,x.push(P))}if(v<o-1&&!f[(v+1)*r+p]){let P=(v+1)*r+p;!h[P]&&(!c||!c.has(`${p},${v+1}`))&&(h[P]=1,x.push(P))}if(p>0&&!l[v*(r+1)+p]){let P=v*r+(p-1);!h[P]&&(!c||!c.has(`${p-1},${v}`))&&(h[P]=1,x.push(P))}if(p<r-1&&!l[v*(r+1)+(p+1)]){let P=v*r+(p+1);!h[P]&&(!c||!c.has(`${p+1},${v}`))&&(h[P]=1,x.push(P))}}a.push(m)}return a}getExternalCells(t){let e=new Set,n=[];for(let s=0;s<t.cols;s++)t.hEdges[0][s].type===2&&(e.has(`${s},0`)||(e.add(`${s},0`),n.push({x:s,y:0}))),t.hEdges[t.rows][s].type===2&&(e.has(`${s},${t.rows-1}`)||(e.add(`${s},${t.rows-1}`),n.push({x:s,y:t.rows-1})));for(let s=0;s<t.rows;s++)t.vEdges[s][0].type===2&&(e.has(`0,${s}`)||(e.add(`0,${s}`),n.push({x:0,y:s}))),t.vEdges[s][t.cols].type===2&&(e.has(`${t.cols-1},${s}`)||(e.add(`${t.cols-1},${s}`),n.push({x:t.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),a=[{nx:s.x,ny:s.y-1,edge:t.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:t.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:t.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:t.vEdges[s.y][s.x+1]}];for(let o of a)o.nx>=0&&o.nx<t.cols&&o.ny>=0&&o.ny<t.rows&&!e.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(e.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return e}getSymmetricalPoint(t,e){let n=t.symmetry||0;return n===1?{x:t.cols-e.x,y:e.y}:n===2?{x:e.x,y:t.rows-e.y}:n===3?{x:t.cols-e.x,y:t.rows-e.y}:{...e}}getSymmetricalPointIndex(t,e){let n=t.cols+1,s=Math.floor(e/n),a=e%n,o=t.symmetry||0,r=s,h=a;return o===1?h=t.cols-a:o===2?r=t.rows-s:o===3&&(h=t.cols-a,r=t.rows-s),r*n+h}getEdgeKey(t,e){return t.x<e.x||t.x===e.x&&t.y<e.y?`${t.x},${t.y}-${e.x},${e.y}`:`${e.x},${e.y}-${t.x},${t.y}`}calculateDifficulty(t){let e=t.rows,n=t.cols,s=n+1,a=(e+1)*s,o=Array.from({length:a},()=>[]),r=[],h=[],f=new Set,l=new Set;for(let E=0;E<=e;E++)for(let S=0;S<=n;S++){let N=E*s+S;if(t.nodes[E][S].type===1&&r.push(N),t.nodes[E][S].type===2&&h.push(N),t.nodes[E][S].type===3&&l.add(N),S<n){let k=N+1,C=t.hEdges[E][S].type,A=C===3,W=C===1||C===2;o[N].push({next:k,isHexagon:A,isBroken:W}),o[k].push({next:N,isHexagon:A,isBroken:W}),A&&f.add(this.getEdgeKey({x:S,y:E},{x:S+1,y:E}))}if(E<e){let k=N+s,C=t.vEdges[E][S].type,A=C===3,W=C===1||C===2;o[N].push({next:k,isHexagon:A,isBroken:W}),o[k].push({next:N,isHexagon:A,isBroken:W}),A&&f.add(this.getEdgeKey({x:S,y:E},{x:S,y:E+1}))}}let i={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},c=f.size+l.size,d=new Set,u=Math.max(1e3,e*n*200),y=this.getExternalCells(t),m=!1;for(let E=0;E<e;E++){for(let S=0;S<n;S++)if(t.cells[E][S].type!==0){m=!0;break}if(m)break}for(let E of r){let S=l.has(E)?1:0,N=t.symmetry||0,k=1n<<BigInt(E);if(N!==0){let C=this.getSymmetricalPointIndex(t,E);if(C===E)continue;k|=1n<<BigInt(C)}this.exploreSearchSpace(t,E,k,[E],S,c,o,h,d,i,u,y,m)}if(i.solutions===0)return 0;let x=f.size+l.size,g=new Set;f.size>0&&g.add(999);let b=0,p=0;for(let E=0;E<e;E++)for(let S=0;S<n;S++){let N=t.cells[E][S];N.type!==0&&(x++,g.add(N.type),N.type===3?b++:N.type===4&&(b++,p++))}let v=i.branchingPoints/(i.totalNodesVisited||1),P=Math.log10(i.totalNodesVisited+1),M=(v*10+P*1.5)/(Math.log2(i.solutions+1)*.5+1);M-=f.size*.05,M+=l.size*.12,b>0&&(M+=p*.5,M+=(b-p)*.2);let w=e*n,$=x/w,V=$<.25?Math.pow($/.25,4):1,I=g.size<=1?.5:1;M*=V*I;let D=Math.log2(w)/5;return M*=D,Math.max(.01,Math.min(1,M/4))}exploreSearchSpace(t,e,n,s,a,o,r,h,f,l,i,c,d=!0){if(l.totalNodesVisited++,l.maxDepth=Math.max(l.maxDepth,s.length),l.totalNodesVisited>i)return;let u=t.symmetry||0;if(h.includes(e)){if(a===o){let x=s.map(p=>({x:p%(t.cols+1),y:Math.floor(p/(t.cols+1))})),g={points:x};if(u!==0){let p=this.getSymmetricalPointIndex(t,e),v=t.cols+1;if(t.nodes[Math.floor(p/v)][p%v].type!==2)return}let b=u!==0?x.map(p=>this.getSymmetricalPoint(t,p)):[];if(d){let p=this.validateFast(t,x,b,c);if(p.isValid){let v=this.getFingerprint(t,x,b,p.regions,c);f.has(v)||(f.add(v),l.solutions++)}}else{let p=this.getFingerprint(t,x,b,void 0,c);f.has(p)||(f.add(p),l.solutions++)}}return}if(!this.canReachEndOptimized(e,n,r,h)){l.backtracks++;return}let y=[];for(let x of r[e]){if(x.isBroken||n&1n<<BigInt(x.next))continue;if(u!==0){let b=this.getSymmetricalPointIndex(t,e),p=this.getSymmetricalPointIndex(t,x.next);if(x.next===p||e===p&&x.next===b)continue}let g=!0;for(let b of r[e])if(b.isHexagon){let p=s.length>=2&&b.next===s[s.length-2],v=b.next===x.next;if(!p&&!v){g=!1;break}}g&&y.push(x)}if(y.length>1&&l.branchingPoints++,t.rows*t.cols>30)for(let x=y.length-1;x>0;x--){let g=Math.floor(Math.random()*(x+1));[y[x],y[g]]=[y[g],y[x]]}let m=t.cols+1;for(let x of y){let g=t.nodes[Math.floor(x.next/m)][x.next%m].type===3?1:0;s.push(x.next);let b=n|1n<<BigInt(x.next);if(u!==0){let p=this.getSymmetricalPointIndex(t,x.next);b|=1n<<BigInt(p)}if(this.exploreSearchSpace(t,x.next,b,s,a+(x.isHexagon?1:0)+g,o,r,h,f,l,i,c,d),s.pop(),l.totalNodesVisited>i)return}}countSolutions(t,e=100){let n=t.rows,s=t.cols,a=s+1,o=(n+1)*a,r=Array.from({length:o},()=>[]),h=[],f=[],l=new Set,i=new Set;for(let m=0;m<=n;m++)for(let x=0;x<=s;x++){let g=m*a+x;if(t.nodes[m][x].type===1&&h.push(g),t.nodes[m][x].type===2&&f.push(g),t.nodes[m][x].type===3&&i.add(g),x<s){let b=g+1,p=t.hEdges[m][x].type,v=p===3,P=p===1||p===2;r[g].push({next:b,isHexagon:v,isBroken:P}),r[b].push({next:g,isHexagon:v,isBroken:P}),v&&l.add(this.getEdgeKey({x,y:m},{x:x+1,y:m}))}if(m<n){let b=g+a,p=t.vEdges[m][x].type,v=p===3,P=p===1||p===2;r[g].push({next:b,isHexagon:v,isBroken:P}),r[b].push({next:g,isHexagon:v,isBroken:P}),v&&l.add(this.getEdgeKey({x,y:m},{x,y:m+1}))}}let c=new Set,d=l.size+i.size,u=this.getExternalCells(t),y=!1;for(let m=0;m<n;m++){for(let x=0;x<s;x++)if(t.cells[m][x].type!==0){y=!0;break}if(y)break}for(let m of h){let x=i.has(m)?1:0,g=t.symmetry||0,b=1n<<BigInt(m);if(g!==0){let p=this.getSymmetricalPointIndex(t,m);if(p===m)continue;b|=1n<<BigInt(p)}this.findPathsOptimized(t,m,b,[m],x,d,r,f,c,e,u,y)}return c.size}findPathsOptimized(t,e,n,s,a,o,r,h,f,l,i,c=!0){if(f.size>=l)return;let d=t.symmetry||0;if(h.includes(e)){if(a===o){let u=s.map(m=>({x:m%(t.cols+1),y:Math.floor(m/(t.cols+1))}));if(d!==0){let m=this.getSymmetricalPointIndex(t,e),x=t.cols+1;if(t.nodes[Math.floor(m/x)][m%x].type!==2)return}let y=d!==0?u.map(m=>this.getSymmetricalPoint(t,m)):[];if(!c)f.add(this.getFingerprint(t,u,y,void 0,i));else{let m=this.validateFast(t,u,y,i);m.isValid&&f.add(this.getFingerprint(t,u,y,m.regions,i))}}return}if(this.canReachEndOptimized(e,n,r,h))for(let u of r[e]){if(u.isBroken||n&1n<<BigInt(u.next))continue;if(d!==0){let b=this.getSymmetricalPointIndex(t,e),p=this.getSymmetricalPointIndex(t,u.next);if(u.next===p||e===p&&u.next===b)continue}let y=!0;for(let b of r[e])if(b.isHexagon){let p=s.length>=2&&b.next===s[s.length-2],v=b.next===u.next;if(!p&&!v){y=!1;break}}if(!y)continue;let m=t.cols+1,x=t.nodes[Math.floor(u.next/m)][u.next%m].type===3?1:0;s.push(u.next);let g=n|1n<<BigInt(u.next);if(d!==0){let b=this.getSymmetricalPointIndex(t,u.next);g|=1n<<BigInt(b)}if(this.findPathsOptimized(t,u.next,g,s,a+(u.isHexagon?1:0)+x,o,r,h,f,l,i,c),s.pop(),f.size>=l)return}}canReachEndOptimized(t,e,n,s){let a=[t],o=e,r=0;for(;r<a.length;){let h=a[r++];if(s.includes(h))return!0;for(let f of n[h])!f.isBroken&&!(o&1n<<BigInt(f.next))&&(o|=1n<<BigInt(f.next),a.push(f.next))}return!1}getFingerprint(t,e,n,s,a){let r=(s||this.calculateRegions(t,e,n,a)).map(f=>{let l="",i=[];for(let c of f){let d=t.cells[c.y][c.x];d.type!==0&&i.push(d.type<<8|d.color)}i.sort((c,d)=>c-d);for(let c of i)l+=c.toString(36)+",";return l}).sort(),h="";for(let f of r)f.length>0&&(h+=f+"|");return h||"empty"}};var Z=class{isWorker;constructor(){this.isWorker=typeof self<"u"&&"postMessage"in self&&!("document"in self)}generate(t,e,n={}){let s=n.difficulty??.5,a=new Y,o=null,r=-1,h=this.isWorker?t*e>30?150:120:t*e>30?100:80,f=this.isWorker?8:5,l=n.symmetry||0,i={x:0,y:t},c={x:e,y:0};l===1?c={x:0,y:0}:l===2?c={x:e,y:t}:l===3&&(c={x:e,y:t});let d=null,u=null,y=null;for(let m=0;m<h;m++){if(m%f===0){d=this.generateRandomPath(new U(t,e),i,c,n.pathLength,l);let p=new U(t,e),v=l!==0?d.map(P=>this.getSymmetricalPoint(p,P,l)):[];u=this.calculateRegions(p,d,v),y=u.map(P=>this.getRegionBoundaryEdges(p,P,d,v))}let x=this.generateFromPath(t,e,d,n,u,y);if(!this.checkAllRequestedConstraintsPresent(x,n))continue;let g=a.calculateDifficulty(x);if(g===0)continue;let b=Math.abs(g-s);if((o===null||b<Math.abs(r-s))&&(r=g,o=x),s>.8&&g>.8||b<.01)break}if(!o){let m=this.generateRandomPath(new U(t,e),i,c,n.pathLength,l);return this.generateFromPath(t,e,m,n)}return o}generateFromPath(t,e,n,s,a,o){let r=new U(t,e),h=s.symmetry||0;r.symmetry=h;let f={x:0,y:t},l={x:e,y:0};if(h===1?l={x:0,y:0}:h===2?l={x:e,y:t}:h===3&&(l={x:e,y:t}),r.nodes[f.y][f.x].type=1,r.nodes[l.y][l.x].type=2,h!==0){let c=this.getSymmetricalPoint(r,f,h),d=this.getSymmetricalPoint(r,l,h);r.nodes[c.y][c.x].type=1,r.nodes[d.y][d.x].type=2}let i=h!==0?n.map(c=>this.getSymmetricalPoint(r,c,h)):[];return this.applyConstraintsBasedOnPath(r,n,s,i,a,o),s.useBrokenEdges&&this.applyBrokenEdges(r,n,s),this.cleanGrid(r),r}generateRandomPath(t,e,n,s,a=0){if(s===void 0)return this.generateSingleRandomPath(t,e,n,void 0,a);let o=t.rows+t.cols,r=(t.rows+1)*(t.cols+1)-1,h=o+s*(r-o),f=[],l=1/0,i=t.rows*t.cols>30?30:50;for(let c=0;c<i;c++){let d=this.generateSingleRandomPath(t,e,n,s,a);if(d.length===0)continue;let u=d.length-1,y=Math.abs(u-h);if(y<l&&(l=y,f=d),l<=2)break}return f}generateSingleRandomPath(t,e,n,s,a=0){let o=new Set,r=[],h=0,f=t.rows*t.cols*20,l=i=>{if(h++,h>f)return!1;o.add(`${i.x},${i.y}`);let c=this.getSymmetricalPoint(t,i,a);if(o.add(`${c.x},${c.y}`),r.push(i),i.x===n.x&&i.y===n.y)return!0;let d=this.getValidNeighbors(t,i,o);a!==0&&(d=d.filter(u=>{let y=this.getSymmetricalPoint(t,u,a);if(y.x<0||y.x>t.cols||y.y<0||y.y>t.rows||o.has(`${y.x},${y.y}`)||u.x===y.x&&u.y===y.y)return!1;let m=this.getEdgeKey(i,u),x=this.getEdgeKey(c,y);return m!==x})),s!==void 0?d.sort((u,y)=>{let m=Math.abs(u.x-n.x)+Math.abs(u.y-n.y),x=Math.abs(y.x-n.x)+Math.abs(y.y-n.y);return(m-x)*(1-s*2)+(Math.random()-.5)*1.5}):this.shuffleArray(d);for(let u of d)if(l(u))return!0;return r.pop(),o.delete(`${i.x},${i.y}`),o.delete(`${c.x},${c.y}`),!1};return l(e),r}getValidNeighbors(t,e,n){let s=[],a=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of a){let r=e.x+o.x,h=e.y+o.y;r>=0&&r<=t.cols&&h>=0&&h<=t.rows&&(n.has(`${r},${h}`)||s.push({x:r,y:h}))}return s}applyBrokenEdges(t,e,n){let s=n.complexity??.5,a=n.symmetry??0,o=new Set;for(let i=0;i<e.length-1;i++)if(o.add(this.getEdgeKey(e[i],e[i+1])),a!==0){let c=this.getSymmetricalPoint(t,e[i],a),d=this.getSymmetricalPoint(t,e[i+1],a);o.add(this.getEdgeKey(c,d))}let r=[];for(let i=0;i<=t.rows;i++)for(let c=0;c<t.cols;c++){let d={x:c,y:i},u={x:c+1,y:i};o.has(this.getEdgeKey(d,u))||r.push({type:"h",r:i,c,p1:d,p2:u})}for(let i=0;i<t.rows;i++)for(let c=0;c<=t.cols;c++){let d={x:c,y:i},u={x:c,y:i+1};o.has(this.getEdgeKey(d,u))||r.push({type:"v",r:i,c,p1:d,p2:u})}this.shuffleArray(r);let h=Math.max(1,Math.floor(s*(t.rows*t.cols)/4)),f=0;for(let i of r){if(f>=h)break;i.type==="h"?t.hEdges[i.r][i.c].type=1:t.vEdges[i.r][i.c].type=1,f++}let l=!0;for(;l;){l=!1;for(let i=0;i<=t.rows;i++)for(let c=0;c<t.cols;c++)t.hEdges[i][c].type===1&&this.canBecomeAbsent(t,{type:"h",r:i,c})&&(t.hEdges[i][c].type=2,l=!0);for(let i=0;i<t.rows;i++)for(let c=0;c<=t.cols;c++)t.vEdges[i][c].type===1&&this.canBecomeAbsent(t,{type:"v",r:i,c})&&(t.vEdges[i][c].type=2,l=!0)}for(let i=0;i<=t.rows;i++)for(let c=0;c<=t.cols;c++){let d=[];if(c>0&&d.push({e:t.hEdges[i][c-1],type:"h",r:i,c:c-1}),c<t.cols&&d.push({e:t.hEdges[i][c],type:"h",r:i,c}),i>0&&d.push({e:t.vEdges[i-1][c],type:"v",r:i-1,c}),i<t.rows&&d.push({e:t.vEdges[i][c],type:"v",r:i,c}),d.length>0&&d.every(u=>u.e.type===1||u.e.type===2)&&d.every(u=>!this.isAdjacentToMark(t,u)))for(let u of d)u.e.type=2}}canBecomeAbsent(t,e){if(this.isAdjacentToMark(t,e))return!1;if(e.type==="h"){if(e.r===0||e.r===t.rows)return!0}else if(e.c===0||e.c===t.cols)return!0;let n=e.type==="h"?[{x:e.c,y:e.r},{x:e.c+1,y:e.r}]:[{x:e.c,y:e.r},{x:e.c,y:e.r+1}];for(let s of n){let a=[{type:"h",r:s.y,c:s.x-1},{type:"h",r:s.y,c:s.x},{type:"v",r:s.y-1,c:s.x},{type:"v",r:s.y,c:s.x}];for(let o of a)if(o.c>=0&&o.c<=t.cols&&o.r>=0&&o.r<=t.rows){if(o.type==="h"&&o.c<t.cols){if(t.hEdges[o.r][o.c].type===2)return!0}else if(o.type==="v"&&o.r<t.rows&&t.vEdges[o.r][o.c].type===2)return!0}}return!1}cleanGrid(t){let e=[];for(let o=0;o<=t.rows;o++)for(let r=0;r<=t.cols;r++)t.nodes[o][r].type===1&&e.push({x:r,y:o});let n=new Set,s=[...e];for(let o of e)n.add(`${o.x},${o.y}`);for(;s.length>0;){let o=s.shift(),r=[{nx:o.x,ny:o.y-1,edge:t.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:t.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:t.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:t.hEdges[o.y]?.[o.x]}];for(let h of r)h.edge&&h.edge.type!==2&&(n.has(`${h.nx},${h.ny}`)||(n.add(`${h.nx},${h.ny}`),s.push({x:h.nx,y:h.ny})))}for(let o=0;o<=t.rows;o++)for(let r=0;r<t.cols;r++)(!n.has(`${r},${o}`)||!n.has(`${r+1},${o}`))&&(t.hEdges[o][r].type=2);for(let o=0;o<t.rows;o++)for(let r=0;r<=t.cols;r++)(!n.has(`${r},${o}`)||!n.has(`${r},${o+1}`))&&(t.vEdges[o][r].type=2);let a=this.getExternalCells(t);for(let o of a){let[r,h]=o.split(",").map(Number);t.cells[h][r].type=0}}getExternalCells(t){let e=new Set,n=[];for(let s=0;s<t.cols;s++)t.hEdges[0][s].type===2&&(e.has(`${s},0`)||(e.add(`${s},0`),n.push({x:s,y:0}))),t.hEdges[t.rows][s].type===2&&(e.has(`${s},${t.rows-1}`)||(e.add(`${s},${t.rows-1}`),n.push({x:s,y:t.rows-1})));for(let s=0;s<t.rows;s++)t.vEdges[s][0].type===2&&(e.has(`0,${s}`)||(e.add(`0,${s}`),n.push({x:0,y:s}))),t.vEdges[s][t.cols].type===2&&(e.has(`${t.cols-1},${s}`)||(e.add(`${t.cols-1},${s}`),n.push({x:t.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),a=[{nx:s.x,ny:s.y-1,edge:t.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:t.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:t.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:t.vEdges[s.y][s.x+1]}];for(let o of a)o.nx>=0&&o.nx<t.cols&&o.ny>=0&&o.ny<t.rows&&!e.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(e.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return e}isAdjacentToMark(t,e){if(e.type==="h"){if(e.r>0&&t.cells[e.r-1][e.c].type!==0||e.r<t.rows&&t.cells[e.r][e.c].type!==0)return!0}else if(e.c>0&&t.cells[e.r][e.c-1].type!==0||e.c<t.cols&&t.cells[e.r][e.c].type!==0)return!0;return!1}hasIsolatedMark(t){for(let e=0;e<t.rows;e++)for(let n=0;n<t.cols;n++){if(t.cells[e][n].type===0)continue;if([t.hEdges[e][n],t.hEdges[e+1][n],t.vEdges[e][n],t.vEdges[e][n+1]].every(a=>a.type===1||a.type===2))return!0}return!1}getSymmetricalPoint(t,e,n){return n===1?{x:t.cols-e.x,y:e.y}:n===2?{x:e.x,y:t.rows-e.y}:n===3?{x:t.cols-e.x,y:t.rows-e.y}:{...e}}getEdgeKey(t,e){return t.x<e.x||t.x===e.x&&t.y<e.y?`${t.x},${t.y}-${e.x},${e.y}`:`${e.x},${e.y}-${t.x},${t.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(t,e,n,s=[],a,o){let r=n.complexity??.5,h=n.useHexagons??!0,f=n.useSquares??!0,l=n.useStars??!0,i=n.useTetris??!1,c=n.useEraser??!1,d=0,u=0,y=0,m=0,x=0,g=0,b=Math.floor(t.rows*t.cols*.45);if(h){let p=n.difficulty??.5;for(let v=0;v<e.length-1;v++){let M=this.getValidNeighbors(t,e[v],new Set).length>2,w=r*(p<.4?.6:.3);M&&(w=p<.4?w*1:w*.5),Math.random()<w&&(this.setEdgeHexagon(t,e[v],e[v+1]),d++)}for(let v=0;v<e.length;v++){let P=e[v];if(t.nodes[P.y][P.x].type!==0||this.hasIncidentHexagonEdge(t,P))continue;let M=r*(p>.6?.15:.05);Math.random()<M&&(t.nodes[P.y][P.x].type=3,d++)}if(d===0&&e.length>=2){let v=Math.floor(Math.random()*(e.length-1));this.setEdgeHexagon(t,e[v],e[v+1])}}if(f||l||i||c){let p=a||this.calculateRegions(t,e,s),v=n.availableColors??[H.Black,H.White,H.Red,H.Blue],P=n.defaultColors??{},M=(I,D)=>{if(P[I]!==void 0)return P[I];let E=j[I];return E&&P[E]!==void 0?P[E]:D},w=Array.from({length:p.length},(I,D)=>D);this.shuffleArray(w);let $=new Set,V={square:f,star:l,tetris:i,eraser:c};for(let I=0;I<w.length;I++){let D=w[I],E=p[D],S=w.length-I,N=V.square&&u===0||V.star&&y===0||V.tetris&&m===0||V.eraser&&x===0,k=.2+r*.6;if(N&&S<=3?k=1:N&&S<=6&&(k=.7),Math.random()>k)continue;let C=[...E];this.shuffleArray(C);let A=v[Math.floor(Math.random()*v.length)];if(f&&!l&&S<=2&&$.size===1){let q=v.filter(K=>!$.has(K));q.length>0&&(A=q[Math.floor(Math.random()*q.length)])}let W=f&&Math.random()<.5+r*.3;if(f&&u===0&&S<=2&&(W=!0),f&&!l&&S<=2&&$.size<2&&u>0&&(W=!0),W&&C.length>0){let q=Math.min(C.length,Math.max(4,Math.floor(E.length/4))),K=Math.floor(Math.random()*(q/2))+Math.ceil(q/2);for(let B=0;B<K&&C.length!==0;B++){let F=C.pop();t.cells[F.y][F.x].type=1,t.cells[F.y][F.x].color=A,u++,$.add(A)}}if(i&&g<b){let q=Math.random()<.1+r*.4;m===0&&S<=2&&(q=!0);let K=m===0&&S<=2?6:4;if(q&&C.length>0&&E.length<=K*4&&g+E.length<=b){let B=this.generateTiling(E,K,n);if(B){for(let F of B){if(C.length===0)break;let T=C.pop();t.cells[T.y][T.x].type=F.isRotated?4:3,t.cells[T.y][T.x].shape=F.isRotated?F.displayShape:F.shape;let O=M(3,H.None);if(l&&Math.random()<.5){let z=v.filter(R=>R!==H.Blue&&R!==O);z.length>0&&(O=z[Math.floor(Math.random()*z.length)])}t.cells[T.y][T.x].color=O,m++}g+=E.length}}}if(c&&x<1){let q=.05+r*.2,K=Math.random()<q;if(S<=2&&(K=!0),K&&C.length>=1){let B=[];l&&B.push("star"),f&&B.push("square");let F=[];h&&(F=o?o[D]:this.getRegionBoundaryEdges(t,E,e,s),F.length>0&&B.push("hexagon")),i&&B.push("tetris");let T=B.length>0?B[Math.floor(Math.random()*B.length)]:null;C.length>=2&&(!T||Math.random()<.01)&&(T="eraser");let O=!1;if(T==="hexagon"){let z=F.filter(R=>!this.isEdgeAdjacentToHexagonNode(t,R));if(z.length>0){let R=z[Math.floor(Math.random()*z.length)];R.type==="h"?t.hEdges[R.r][R.c].type=3:t.vEdges[R.r][R.c].type=3,d++,O=!0}}else if(T==="square"&&C.length>=2){let z=C.pop();t.cells[z.y][z.x].type=1;let R=E.find(G=>t.cells[G.y][G.x].type===1),L=R?t.cells[R.y][R.x].color:void 0;t.cells[z.y][z.x].color=v.find(G=>G!==L)||H.Red,u++,O=!0}else if(T==="star"&&C.length>=2){let z=C.pop();t.cells[z.y][z.x].type=2,t.cells[z.y][z.x].color=v[Math.floor(Math.random()*v.length)],y++,O=!0}else if(T==="tetris"&&C.length>=2){let z=this.generateTiling(E,4,n),R=[];if(z&&z.length>0){let L=0;for(let G of z){let J=this.getShapeArea(G.shape);if(L+J<E.length)R.push(G),L+=J;else break}}if(R.length===0&&E.length>1&&(R=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),R.length>0){for(let L of R){if(C.length<2)break;let G=C.pop();t.cells[G.y][G.x].type=L.isRotated?4:3,t.cells[G.y][G.x].shape=L.isRotated?L.displayShape:L.shape;let J=H.None;if(l&&Math.random()<.3){let it=v.filter(at=>at!==H.Blue);J=it[Math.floor(Math.random()*it.length)]}t.cells[G.y][G.x].color=J,m++}O=!0}}else if(T==="eraser"&&C.length>=2){let z=C.pop();t.cells[z.y][z.x].type=5,t.cells[z.y][z.x].color=M(5,H.White),x++,O=!0}if(!O&&C.length>=2){let z=C.pop();t.cells[z.y][z.x].type=5,t.cells[z.y][z.x].color=M(5,H.White),x++,O=!0}if(O){let z=C.pop();t.cells[z.y][z.x].type=5;let R=M(5,H.White);if(l&&Math.random()<.4){let L=v.filter(G=>G!==R);L.length>0&&(R=L[Math.floor(Math.random()*L.length)])}t.cells[z.y][z.x].color=R,x++}}}if(l){let q=Math.max(1,Math.floor(E.length/8));for(let K=0;K<q;K++)for(let B of v){if(C.length<1)break;if(Math.random()>.3+r*.4)continue;let F=E.filter(T=>t.cells[T.y][T.x].color===B).length;if(F===1){let T=C.pop();t.cells[T.y][T.x].type=2,t.cells[T.y][T.x].color=B,y++}else if(F===0&&C.length>=2)for(let T=0;T<2;T++){let O=C.pop();t.cells[O.y][O.x].type=2,t.cells[O.y][O.x].color=B,y++}}}}if(f&&!l&&$.size<2){for(let I of p)if(I.every(D=>t.cells[D.y][D.x].type===0)){let D=v.find(S=>!$.has(S))||H.White,E=I[Math.floor(Math.random()*I.length)];t.cells[E.y][E.x].type=1,t.cells[E.y][E.x].color=D,$.add(D),u++;break}}}}calculateRegions(t,e,n=[]){let s=[],a=t.rows,o=t.cols,r=new Uint8Array(a*o),h=new Uint8Array((a+1)*o),f=new Uint8Array(a*(o+1)),l=(i,c)=>{i.x===c.x?f[Math.min(i.y,c.y)*(o+1)+i.x]=1:h[i.y*o+Math.min(i.x,c.x)]=1};for(let i=0;i<e.length-1;i++)l(e[i],e[i+1]);for(let i=0;i<n.length-1;i++)l(n[i],n[i+1]);for(let i=0;i<=a;i++)for(let c=0;c<o;c++)t.hEdges[i][c].type===2&&(h[i*o+c]=1);for(let i=0;i<a;i++)for(let c=0;c<=o;c++)t.vEdges[i][c].type===2&&(f[i*(o+1)+c]=1);for(let i=0;i<a;i++)for(let c=0;c<o;c++){let d=i*o+c;if(r[d])continue;let u=[],y=[d];r[d]=1;let m=0;for(;m<y.length;){let x=y[m++],g=x%o,b=Math.floor(x/o);if(u.push({x:g,y:b}),b>0&&!h[b*o+g]){let p=(b-1)*o+g;r[p]||(r[p]=1,y.push(p))}if(b<a-1&&!h[(b+1)*o+g]){let p=(b+1)*o+g;r[p]||(r[p]=1,y.push(p))}if(g>0&&!f[b*(o+1)+g]){let p=b*o+(g-1);r[p]||(r[p]=1,y.push(p))}if(g<o-1&&!f[b*(o+1)+(g+1)]){let p=b*o+(g+1);r[p]||(r[p]=1,y.push(p))}}s.push(u)}return s}isAbsentEdge(t,e,n){if(e.x===n.x){let s=Math.min(e.y,n.y);return t.vEdges[s][e.x].type===2}else{let s=Math.min(e.x,n.x);return t.hEdges[e.y][s].type===2}}getRegionBoundaryEdges(t,e,n,s=[]){let a=new Set;for(let h=0;h<n.length-1;h++)a.add(this.getEdgeKey(n[h],n[h+1]));for(let h=0;h<s.length-1;h++)a.add(this.getEdgeKey(s[h],s[h+1]));let o=[];for(let h of e){let f=[{type:"h",r:h.y,c:h.x},{type:"h",r:h.y+1,c:h.x},{type:"v",r:h.y,c:h.x},{type:"v",r:h.y,c:h.x+1}];for(let l of f){let i=l.type==="h"?{x:l.c,y:l.r}:{x:l.c,y:l.r},c=l.type==="h"?{x:l.c+1,y:l.r}:{x:l.c,y:l.r+1},d=this.getEdgeKey(i,c);!a.has(d)&&!this.isAbsentEdge(t,i,c)&&o.push(l)}}let r=new Map;for(let h of o)r.set(`${h.type},${h.r},${h.c}`,h);return Array.from(r.values())}setEdgeHexagon(t,e,n){e.x===n.x?t.vEdges[Math.min(e.y,n.y)][e.x].type=3:t.hEdges[e.y][Math.min(e.x,n.x)].type=3}hasIncidentHexagonEdge(t,e){return e.x>0&&t.hEdges[e.y][e.x-1].type===3||e.x<t.cols&&t.hEdges[e.y][e.x].type===3||e.y>0&&t.vEdges[e.y-1][e.x].type===3||e.y<t.rows&&t.vEdges[e.y][e.x].type===3}isEdgeAdjacentToHexagonNode(t,e){return e.type==="h"?t.nodes[e.r][e.c].type===3||t.nodes[e.r][e.c+1].type===3:t.nodes[e.r][e.c].type===3||t.nodes[e.r+1][e.c].type===3}checkAllRequestedConstraintsPresent(t,e){let n=e.useHexagons??!0,s=e.useSquares??!0,a=e.useStars??!0,o=e.useTetris??!1,r=e.useEraser??!1;if(e.useBrokenEdges??!1){let f=!1;for(let l=0;l<=t.rows;l++)for(let i=0;i<t.cols;i++)if(t.hEdges[l][i].type===1||t.hEdges[l][i].type===2){f=!0;break}if(!f){for(let l=0;l<t.rows;l++)for(let i=0;i<=t.cols;i++)if(t.vEdges[l][i].type===1||t.vEdges[l][i].type===2){f=!0;break}}if(!f)return!1}if(n){let f=!1;for(let l=0;l<=t.rows;l++)for(let i=0;i<t.cols;i++)if(t.hEdges[l][i].type===3){f=!0;break}if(!f){for(let l=0;l<t.rows;l++)for(let i=0;i<=t.cols;i++)if(t.vEdges[l][i].type===3){f=!0;break}}if(!f){for(let l=0;l<=t.rows;l++)for(let i=0;i<=t.cols;i++)if(t.nodes[l][i].type===3){f=!0;break}}if(!f)return!1}if(s||a||o||r){let f=!1,l=!1,i=!1,c=!1,d=new Set;for(let u=0;u<t.rows;u++)for(let y=0;y<t.cols;y++){let m=t.cells[u][y].type;m===1&&(f=!0,d.add(t.cells[u][y].color)),m===2&&(l=!0),(m===3||m===4)&&(i=!0),m===5&&(c=!0)}if(s&&!f||a&&!l||o&&!i||r&&!c||s&&f&&!l&&d.size<2)return!1}return!this.hasIsolatedMark(t)}generateTiling(t,e,n){let s=Math.min(...t.map(i=>i.x)),a=Math.min(...t.map(i=>i.y)),o=Math.max(...t.map(i=>i.x)),r=Math.max(...t.map(i=>i.y)),h=o-s+1,f=r-a+1,l=Array.from({length:f},()=>Array(h).fill(!1));for(let i of t)l[i.y-a][i.x-s]=!0;return this.tilingDfs(l,[],e,n)}tilingDfs(t,e,n,s){let a=-1,o=-1;for(let f=0;f<t.length;f++){for(let l=0;l<t[0].length;l++)if(t[f][l]){a=f,o=l;break}if(a!==-1)break}if(a===-1)return e;if(e.length>=n)return null;let r=s.difficulty??.5,h=[...this.TETRIS_SHAPES];this.shuffleArray(h),r>.6&&h.sort((f,l)=>this.getShapeArea(l)-this.getShapeArea(f));for(let f of h){let l=this.isRotationallyInvariant(f),i=l?[f]:this.getAllRotations(f);this.shuffleArray(i);for(let c of i){let d=[];for(let u=0;u<c.length;u++)for(let y=0;y<c[0].length;y++)c[u][y]&&d.push({r:u,c:y});for(let u of d){let y=a-u.r,m=o-u.c;if(this.canPlace(t,c,y,m)){this.placePiece(t,c,y,m,!1);let x=this.tilingDfs(t,[...e,{shape:c,displayShape:f,isRotated:!l&&Math.random()<.3+r*.6}],n,s);if(x)return x;this.placePiece(t,c,y,m,!0)}}}}return null}getShapeArea(t){let e=0;for(let n of t)for(let s of n)s&&e++;return e}isRotationallyInvariant(t){let e=this.getShapeArea(t);return e===1||e===4&&t.length===2&&t[0].length===2}getAllRotations(t){let e=[],n=new Set,s=t;for(let a=0;a<4;a++){let o=JSON.stringify(s);n.has(o)||(e.push(s),n.add(o)),s=this.rotate90(s)}return e}rotate90(t){let e=t.length,n=t[0].length,s=Array.from({length:n},()=>Array(e).fill(0));for(let a=0;a<e;a++)for(let o=0;o<n;o++)s[o][e-1-a]=t[a][o];return s}canPlace(t,e,n,s){for(let a=0;a<e.length;a++)for(let o=0;o<e[0].length;o++)if(e[a][o]){let r=n+a,h=s+o;if(r<0||r>=t.length||h<0||h>=t[0].length||!t[r][h])return!1}return!0}placePiece(t,e,n,s,a){for(let o=0;o<e.length;o++)for(let r=0;r<e[0].length;r++)e[o][r]&&(t[n+o][s+r]=a)}shuffleArray(t){for(let e=t.length-1;e>0;e--){let n=Math.floor(Math.random()*(e+1));[t[e],t[n]]=[t[n],t[e]]}}};var et=class{bytes=[];cur=0;bit=0;write(t,e){for(let n=0;n<e;n++)t&1<<n&&(this.cur|=1<<this.bit),this.bit++,this.bit===8&&(this.bytes.push(this.cur),this.cur=0,this.bit=0)}finish(){return this.bit>0&&this.bytes.push(this.cur),new Uint8Array(this.bytes)}},st=class{constructor(t){this.buf=t}i=0;bit=0;read(t){let e=0;for(let n=0;n<t;n++)this.buf[this.i]&1<<this.bit&&(e|=1<<n),this.bit++,this.bit===8&&(this.bit=0,this.i++);return e}};function ht(X){let t=new Map;for(let e of X)for(let n of e)if(n.shape){let s=JSON.stringify(n.shape);t.has(s)||t.set(s,n.shape)}return[...t.values()]}var nt=class{static async serialize(t,e){let n=new et;n.write(t.rows,6),n.write(t.cols,6),n.write(t.symmetry??0,2);let s=ht(t.cells);n.write(s.length,5);for(let l of s){n.write(l.length,4),n.write(l[0].length,4);for(let i of l)for(let c of i)n.write(c,1)}let a=new Map;s.forEach((l,i)=>a.set(JSON.stringify(l),i));for(let l of t.cells)for(let i of l)n.write(i.type,3),n.write(i.color,3),i.shape?(n.write(1,1),n.write(a.get(JSON.stringify(i.shape)),5)):n.write(0,1);for(let l=0;l<t.rows;l++)for(let i=0;i<t.cols+1;i++)n.write(t.vEdges[l][i].type,2);for(let l=0;l<t.rows+1;l++)for(let i=0;i<t.cols;i++)n.write(t.hEdges[l][i].type,2);for(let l=0;l<t.rows+1;l++)for(let i=0;i<t.cols+1;i++)n.write(t.nodes[l][i].type,2);n.write(+!!e.useHexagons,1),n.write(+!!e.useSquares,1),n.write(+!!e.useStars,1),n.write(+!!e.useTetris,1),n.write(+!!e.useEraser,1),n.write(+!!e.useBrokenEdges,1),n.write(e.symmetry??0,2),n.write(Math.round((e.complexity??0)*254),8),n.write(Math.round((e.difficulty??0)*254),8),n.write(Math.round((e.pathLength??0)*254),8);let o=n.finish(),r=new Uint8Array(await new Response(new Blob([o.buffer]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()),h=0;for(let l of r)h^=l;let f=new Uint8Array(r.length+1);return f.set(r),f[r.length]=h,btoa(String.fromCharCode(...f)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}static async deserialize(t){let e=t.replace(/-/g,"+").replace(/_/g,"/");for(;e.length%4;)e+="=";let n=atob(e),s=Uint8Array.from(n,E=>E.charCodeAt(0)),a=0;for(let E=0;E<s.length-1;E++)a^=s[E];if(a!==s.at(-1))throw new Error("Invalid parity data");let o=new Uint8Array(await new Response(new Blob([s.slice(0,-1).buffer]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer()),r=new st(o),h=r.read(6),f=r.read(6),l=r.read(2),i=r.read(5),c=[];for(let E=0;E<i;E++){let S=r.read(4),N=r.read(4),k=[];for(let C=0;C<S;C++){let A=[];for(let W=0;W<N;W++)A.push(r.read(1));k.push(A)}c.push(k)}let d=[];for(let E=0;E<h;E++){let S=[];for(let N=0;N<f;N++){let k=r.read(3),C=r.read(3),A=r.read(1),W={type:k,color:C};A&&(W.shape=c[r.read(5)].map(q=>q.slice())),S.push(W)}d.push(S)}let u=Array.from({length:h},()=>Array.from({length:f+1},()=>({type:r.read(2)}))),y=Array.from({length:h+1},()=>Array.from({length:f},()=>({type:r.read(2)}))),m=Array.from({length:h+1},()=>Array.from({length:f+1},()=>({type:r.read(2)}))),x=()=>{let E=r.read(8);return Math.round(E/254*1e3)/1e3},g={},b=!!r.read(1),p=!!r.read(1),v=!!r.read(1),P=!!r.read(1),M=!!r.read(1),w=!!r.read(1),$=r.read(2);b&&(g.useHexagons=!0),p&&(g.useSquares=!0),v&&(g.useStars=!0),P&&(g.useTetris=!0),M&&(g.useEraser=!0),w&&(g.useBrokenEdges=!0),g.symmetry=$;let V=x(),I=x(),D=x();return V!==0&&(g.complexity=V),I!==0&&(g.difficulty=I),D!==0&&(g.pathLength=D),{puzzle:{rows:h,cols:f,cells:d,vEdges:u,hEdges:y,nodes:m,symmetry:l},options:g}}};var ot=class{canvas;ctx;puzzle=null;options;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;invalidatedCells=[];invalidatedEdges=[];invalidatedNodes=[];errorCells=[];errorEdges=[];errorNodes=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;canvasRect=null;constructor(t,e,n={}){if(typeof t=="string"){if(typeof document>"u")throw new Error("Cannot look up canvas by ID in a non-browser environment.");let a=document.getElementById(t);if(!(a instanceof HTMLCanvasElement))throw new Error(`Element with id "${t}" is not a canvas.`);this.canvas=a}else this.canvas=t;let s=this.canvas.getContext("2d");if(!s)throw new Error("Could not get 2D context.");this.ctx=s,this.ctx.imageSmoothingEnabled=!1,this.options=this.mergeOptions(n),e&&this.setPuzzle(e),this.initEvents(),this.animate()}mergeOptions(t){let e={blinkDuration:t.animations?.blinkDuration??this.options?.animations?.blinkDuration??1e3,fadeDuration:t.animations?.fadeDuration??this.options?.animations?.fadeDuration??1e3,blinkPeriod:t.animations?.blinkPeriod??this.options?.animations?.blinkPeriod??800},n={path:t.colors?.path??this.options?.colors?.path??"#ffcc00",error:t.colors?.error??this.options?.colors?.error??"#ff4444",success:t.colors?.success??this.options?.colors?.success??"#ffcc00",symmetry:t.colors?.symmetry??this.options?.colors?.symmetry??"rgba(255, 255, 255, 0.5)",interrupted:t.colors?.interrupted??this.options?.colors?.interrupted??"#ffcc00",grid:t.colors?.grid??this.options?.colors?.grid??"#555",node:t.colors?.node??this.options?.colors?.node??"#555",hexagon:t.colors?.hexagon??this.options?.colors?.hexagon??"#000",colorMap:t.colors?.colorMap??this.options?.colors?.colorMap??{[H.Black]:"#000",[H.White]:"#fff",[H.Red]:"#f00",[H.Blue]:"#00f",[H.None]:"#ffcc00"},colorList:t.colors?.colorList??this.options?.colors?.colorList};return{gridPadding:t.gridPadding??this.options?.gridPadding??60,cellSize:t.cellSize??this.options?.cellSize??80,nodeRadius:t.nodeRadius??this.options?.nodeRadius??6,startNodeRadius:t.startNodeRadius??this.options?.startNodeRadius??22,pathWidth:t.pathWidth??this.options?.pathWidth??18,exitLength:t.exitLength??this.options?.exitLength??25,autoResize:t.autoResize??this.options?.autoResize??!0,animations:e,colors:n,onPathComplete:t.onPathComplete??this.options?.onPathComplete??(()=>{})}}setPuzzle(t){this.puzzle=t,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw()}setOptions(t){this.options=this.mergeOptions({...this.options,...t}),this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}setValidationResult(t,e=[],n=[],s=[],a=[],o=[],r=[]){this.invalidatedCells=e,this.invalidatedEdges=n,this.invalidatedNodes=o,this.errorCells=s,this.errorEdges=a,this.errorNodes=r,this.eraserAnimationStartTime=Date.now(),t?(this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0}resizeCanvas(){!this.puzzle||!this.canvas||(this.canvas.width=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,this.canvas.height=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2)}setCanvasRect(t){this.canvasRect=t}initEvents(){typeof window>"u"||!(this.canvas instanceof HTMLCanvasElement)||(this.canvas.addEventListener("mousedown",t=>this.handleStart(t)),window.addEventListener("mousemove",t=>this.handleMove(t)),window.addEventListener("mouseup",t=>this.handleEnd(t)),this.canvas.addEventListener("touchstart",t=>{this.handleStart(t.touches[0])&&t.preventDefault()},{passive:!1}),window.addEventListener("touchmove",t=>{this.isDrawing&&t.preventDefault(),this.handleMove(t.touches[0])},{passive:!1}),window.addEventListener("touchend",t=>{this.isDrawing&&t.preventDefault(),this.handleEnd(t.changedTouches[0])},{passive:!1}))}getCanvasCoords(t,e){return{x:this.options.gridPadding+t*this.options.cellSize,y:this.options.gridPadding+e*this.options.cellSize}}getExitDir(t,e){return!this.puzzle||this.puzzle.nodes[e]?.[t]?.type!==2?null:t===this.puzzle.cols?{x:1,y:0}:t===0?{x:-1,y:0}:e===0?{x:0,y:-1}:e===this.puzzle.rows?{x:0,y:1}:{x:1,y:0}}handleStart(t){if(!this.puzzle)return!1;let e=this.canvasRect||(this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),n=(t.clientX-e.left)*(this.canvas.width/e.width),s=(t.clientY-e.top)*(this.canvas.height/e.height);for(let a=0;a<=this.puzzle.rows;a++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[a][o].type===1){let r=this.getCanvasCoords(o,a);if(Math.hypot(r.x-n,r.y-s)<this.options.startNodeRadius)return this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.isDrawing=!0,this.path=[{x:o,y:a}],this.currentMousePos=r,this.exitTipPos=null,this.draw(),!0}return!1}handleMove(t){if(!this.puzzle||!this.isDrawing)return;let e=this.canvasRect||(this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),n=(t.clientX-e.left)*(this.canvas.width/e.width),s=(t.clientY-e.top)*(this.canvas.height/e.height),a=this.path[this.path.length-1],o=this.getCanvasCoords(a.x,a.y),r=n-o.x,h=s-o.y,f=this.puzzle.symmetry||0,l=this.getExitDir(a.x,a.y),i=Math.abs(r)>Math.abs(h)?{x:r>0?1:-1,y:0}:{x:0,y:h>0?1:-1};if(l&&i.x===l.x&&i.y===l.y){let y=r*l.x+h*l.y,m=Math.max(0,Math.min(y,this.options.exitLength));this.currentMousePos={x:o.x+l.x*m,y:o.y+l.y*m},this.draw();return}let c=(y,m)=>{let x=this.getEdgeType(a,y);if(y.x<0||y.x>this.puzzle.cols||y.y<0||y.y>this.puzzle.rows||x===2){this.currentMousePos=o;return}let g=x===1?this.options.cellSize*.35:this.options.cellSize,b=this.getEdgeKey(a,y);if(!(this.path.length>=2&&y.x===this.path[this.path.length-2].x&&y.y===this.path[this.path.length-2].y)){for(let P=0;P<this.path.length-1;P++)if(this.getEdgeKey(this.path[P],this.path[P+1])===b){g=0;break}}if(this.path.some(P=>P.x===y.x&&P.y===y.y)&&this.path.length>=2){let P=this.path[this.path.length-2];(y.x!==P.x||y.y!==P.y)&&(g=Math.min(g,this.options.cellSize*.5-this.options.pathWidth*.5))}if(f!==0){let P=this.getSymmetricalPoint(a),M=this.getSymmetricalPoint(y),w=this.getEdgeType(P,M),$=this.getSymmetryPath(this.path),V=this.getEdgeKey(P,M);if(M.x<0||M.x>this.puzzle.cols||M.y<0||M.y>this.puzzle.rows||w===2){this.currentMousePos=o;return}w===1&&(g=Math.min(g,this.options.cellSize*.35));let I=$.some(C=>C.x===y.x&&C.y===y.y),D=this.path.some(C=>C.x===M.x&&C.y===M.y),E=y.x===M.x&&y.y===M.y,S=$.some((C,A)=>A<$.length-1&&this.getEdgeKey($[A],$[A+1])===b),N=this.path.some((C,A)=>A<this.path.length-1&&this.getEdgeKey(this.path[A],this.path[A+1])===V);(I||D||E||S||N||b===V)&&(g=Math.min(g,this.options.cellSize*.5-this.options.pathWidth*.5))}y.x!==a.x?this.currentMousePos={x:o.x+Math.max(-g,Math.min(g,m)),y:o.y}:this.currentMousePos={x:o.x,y:o.y+Math.max(-g,Math.min(g,m))}};if(Math.abs(r)>Math.abs(h)){let y=r>0?1:-1;c({x:a.x+y,y:a.y},r)}else{let y=h>0?1:-1;c({x:a.x,y:a.y+y},h)}let d=[{x:a.x+1,y:a.y},{x:a.x-1,y:a.y},{x:a.x,y:a.y+1},{x:a.x,y:a.y-1}],u=this.getSymmetryPath(this.path);for(let y of d)if(y.x>=0&&y.x<=this.puzzle.cols&&y.y>=0&&y.y<=this.puzzle.rows){let m=this.getCanvasCoords(y.x,y.y);if(Math.hypot(m.x-this.currentMousePos.x,m.y-this.currentMousePos.y)<this.options.cellSize*.3){let g=this.path.findIndex(b=>b.x===y.x&&b.y===y.y);if(g===-1){if(f!==0){let b=this.getSymmetricalPoint(y);if(y.x===b.x&&y.y===b.y||this.path.some(P=>P.x===b.x&&P.y===b.y)||u.some(P=>P.x===y.x&&P.y===y.y))continue;let p=this.getEdgeKey(a,y),v=this.getEdgeKey(this.getSymmetricalPoint(a),b);if(p===v)continue}this.path.push(y)}else g===this.path.length-2&&this.path.pop()}}this.draw()}handleEnd(t){if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let e=this.path[this.path.length-1],n=this.getCanvasCoords(e.x,e.y),s=this.getExitDir(e.x,e.y);if(s){let a=this.currentMousePos.x-n.x,o=this.currentMousePos.y-n.y;if(a*s.x+o*s.y>0){this.exitTipPos={x:n.x+s.x*this.options.exitLength,y:n.y+s.y*this.options.exitLength},this.options.onPathComplete(this.path);return}}this.exitTipPos=s?{...this.currentMousePos}:null,this.startFade(this.options.colors.interrupted)}getEdgeType(t,e){if(!this.puzzle)return 2;if(t.x===e.x){let n=Math.min(t.y,e.y);return n<0||n>=this.puzzle.rows?2:this.puzzle.vEdges[n][t.x].type}else{let n=Math.min(t.x,e.x);return n<0||n>=this.puzzle.cols?2:this.puzzle.hEdges[t.y][n].type}}startFade(t="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=t,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){if(typeof requestAnimationFrame>"u"){this.draw();return}if(this.draw(),this.isFading){let t=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=t,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0)}requestAnimationFrame(()=>this.animate())}draw(){if(!this.puzzle||!this.ctx)return;let t=this.ctx,e=Date.now();if(t.globalAlpha=1,t.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(t),this.drawConstraints(t),this.drawNodes(t),this.path.length===0&&!this.isDrawing&&this.drawRipples(t),this.isFading){if(this.drawPath(t,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let n=this.getSymmetryPath(this.fadingPath),s=this.options.colors.symmetry,a=null;if(this.fadingTipPos){let o=(this.fadingTipPos.x-this.options.gridPadding)/this.options.cellSize,r=(this.fadingTipPos.y-this.options.gridPadding)/this.options.cellSize,h=this.getSymmetricalPoint({x:o,y:r});a={x:h.x*this.options.cellSize+this.options.gridPadding,y:h.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(t,n,!1,s,this.fadeOpacity,a)}}else if(this.path.length>0){let n=this.isInvalidPath?this.options.colors.error:this.options.colors.path;if(this.isSuccessFading&&!this.puzzle.symmetry&&(n=this.options.colors.success),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let s=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),a=this.options.animations.blinkDuration;if(s<a)if(this.isSuccessFading)(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&(n=this.options.colors.error);else{let o=Math.min(1,s/200),r=s>a*.8?(a-s)/(a*.2):1,h=Math.min(o,r),f=(Math.sin(e*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;n=this.lerpColor(this.options.colors.path,this.options.colors.error,f*h)}}if(this.drawPath(t,this.path,this.isDrawing,n,1,this.isDrawing?this.currentMousePos:this.exitTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let s=this.getSymmetryPath(this.path),a=this.options.colors.symmetry;if(this.isInvalidPath&&(a=this.options.colors.error),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let r=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),h=this.options.animations.blinkDuration;if(r<h)if(this.isSuccessFading)(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&(a=this.options.colors.error);else{let f=Math.min(1,r/200),l=r>h*.8?(h-r)/(h*.2):1,i=Math.min(f,l),c=(Math.sin(e*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;a=this.lerpColor(this.options.colors.symmetry,this.options.colors.error,c*i)}}let o=null;if(this.isDrawing||this.exitTipPos){let r=this.isDrawing?this.currentMousePos:this.exitTipPos,h=(r.x-this.options.gridPadding)/this.options.cellSize,f=(r.y-this.options.gridPadding)/this.options.cellSize,l=this.getSymmetricalPoint({x:h,y:f},!0);o={x:l.x*this.options.cellSize+this.options.gridPadding,y:l.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(t,s,this.isDrawing,a,1,o)}}}drawRipples(t){if(!this.puzzle)return;let e=(Date.now()-this.startTime)/500;for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)if(this.puzzle.nodes[n][s].type===2){let o=this.getCanvasCoords(s,n),r=this.getExitDir(s,n);if(!r)continue;let h={x:o.x+r.x*this.options.exitLength,y:o.y+r.y*this.options.exitLength},f=e%4,l=f*5,i=Math.max(0,1-f/3);t.beginPath(),t.arc(h.x,h.y,l,0,Math.PI*2),t.strokeStyle=`rgba(170, 170, 170, ${i*.4})`,t.lineWidth=2,t.stroke()}}drawGrid(t){if(!this.puzzle||!this.options.colors.grid)return;t.strokeStyle=this.options.colors.grid,t.lineWidth=12,t.lineCap="round";let e=(n,s,a)=>{if(a!==2)if(a===1){let r={x:n.x+(s.x-n.x)*.35,y:n.y+(s.y-n.y)*.35},h={x:n.x+(s.x-n.x)*(.5+.15),y:n.y+(s.y-n.y)*(.5+.15)};t.beginPath(),t.moveTo(n.x,n.y),t.lineTo(r.x,r.y),t.stroke(),t.beginPath(),t.moveTo(h.x,h.y),t.lineTo(s.x,s.y),t.stroke()}else t.beginPath(),t.moveTo(n.x,n.y),t.lineTo(s.x,s.y),t.stroke()};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<this.puzzle.cols;s++)e(this.getCanvasCoords(s,n),this.getCanvasCoords(s+1,n),this.puzzle.hEdges[n][s].type);for(let n=0;n<this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)e(this.getCanvasCoords(s,n),this.getCanvasCoords(s,n+1),this.puzzle.vEdges[n][s].type)}drawConstraints(t){if(!this.puzzle)return;let e=Date.now(),n=(Math.sin(e*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;for(let a=0;a<this.puzzle.rows;a++)for(let o=0;o<this.puzzle.cols;o++){let r=this.puzzle.cells[a][o],h=this.getCanvasCoords(o+.5,a+.5),f=this.invalidatedCells.some(y=>y.x===o&&y.y===a),l=this.errorCells.some(y=>y.x===o&&y.y===a),i=1,c,d=this.getColorCode(r.color),u=this.options.colors.error;if(l&&(c=this.lerpColor(d,u,n)),f){let y=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),m=this.options.animations.blinkDuration;if(this.isFading)i=this.fadeOpacity;else if(y<m){let x=Math.min(1,y/200),g=y>m*.8?(m-y)/(m*.2):1,b=Math.min(x,g);c=this.lerpColor(d,u,n*b)}else i=Math.max(.3,1-(y-m)/this.options.animations.fadeDuration)}if(i<1||c){let{canvas:y,ctx:m}=this.prepareOffscreen();this.drawConstraintItem(m,r,h,c),t.save(),t.globalAlpha=i,t.drawImage(y,0,0),t.restore()}else this.drawConstraintItem(t,r,h)}t.lineWidth=2;let s=8;for(let a=0;a<=this.puzzle.rows;a++)for(let o=0;o<this.puzzle.cols;o++)if(this.puzzle.hEdges[a][o].type===3){let r=this.getCanvasCoords(o+.5,a);t.save();let h=this.invalidatedEdges.some(l=>l.type==="h"&&l.r===a&&l.c===o);if(this.errorEdges.some(l=>l.type==="h"&&l.r===a&&l.c===o)){let l=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(t,r.x,r.y,s,l)}else if(h){let l=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),i=this.options.animations.blinkDuration;if(this.isFading)t.globalAlpha*=this.fadeOpacity;else if(l<i){let c=Math.min(1,l/200),d=l>i*.8?(i-l)/(i*.2):1,u=Math.min(c,d),y=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*u);this.drawHexagon(t,r.x,r.y,s,y)}else t.globalAlpha*=Math.max(.3,1-(l-i)/this.options.animations.fadeDuration),this.drawHexagon(t,r.x,r.y,s)}else this.drawHexagon(t,r.x,r.y,s);t.restore()}for(let a=0;a<this.puzzle.rows;a++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.vEdges[a][o].type===3){let r=this.getCanvasCoords(o,a+.5);t.save();let h=this.invalidatedEdges.some(l=>l.type==="v"&&l.r===a&&l.c===o);if(this.errorEdges.some(l=>l.type==="v"&&l.r===a&&l.c===o)){let l=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(t,r.x,r.y,s,l)}else if(h){let l=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),i=this.options.animations.blinkDuration;if(this.isFading)t.globalAlpha*=this.fadeOpacity;else if(l<i){let c=Math.min(1,l/200),d=l>i*.8?(i-l)/(i*.2):1,u=Math.min(c,d),y=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*u);this.drawHexagon(t,r.x,r.y,s,y)}else t.globalAlpha*=Math.max(.3,1-(l-i)/this.options.animations.fadeDuration),this.drawHexagon(t,r.x,r.y,s)}else this.drawHexagon(t,r.x,r.y,s);t.restore()}for(let a=0;a<=this.puzzle.rows;a++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[a][o].type===3){let r=this.getCanvasCoords(o,a);t.save();let h=this.invalidatedNodes.some(l=>l.x===o&&l.y===a);if(this.errorNodes.some(l=>l.x===o&&l.y===a)){let l=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(t,r.x,r.y,s,l)}else if(h){let l=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),i=this.options.animations.blinkDuration;if(this.isFading)t.globalAlpha*=this.fadeOpacity;else if(l<i){let c=Math.min(1,l/200),d=l>i*.8?(i-l)/(i*.2):1,u=Math.min(c,d),y=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*u);this.drawHexagon(t,r.x,r.y,s,y)}else t.globalAlpha*=Math.max(.3,1-(l-i)/this.options.animations.fadeDuration),this.drawHexagon(t,r.x,r.y,s)}else this.drawHexagon(t,r.x,r.y,s);t.restore()}}drawConstraintItem(t,e,n,s){e.type===1?(t.fillStyle=s||this.getColorCode(e.color),this.drawRoundedRect(t,n.x-26/2,n.y-26/2,26,26,8)):e.type===2?this.drawStar(t,n.x,n.y,12,16,8,e.color,s):e.type===3||e.type===4?this.drawTetris(t,n.x,n.y,e.shape||[],e.type===4,e.color,s):e.type===5&&this.drawEraser(t,n.x,n.y,14,3,e.color,s)}drawNodes(t){if(!this.puzzle)return;let e=(n,s)=>{let a=[];return n>0&&a.push(this.puzzle.hEdges[s][n-1].type),n<this.puzzle.cols&&a.push(this.puzzle.hEdges[s][n].type),s>0&&a.push(this.puzzle.vEdges[s-1][n].type),s<this.puzzle.rows&&a.push(this.puzzle.vEdges[s][n].type),a.length>0&&a.every(o=>o===2)};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++){if(e(s,n))continue;let a=this.puzzle.nodes[n][s];if(a.type===3)continue;let o=this.getCanvasCoords(s,n);if(a.type===1)this.options.colors.node&&(t.fillStyle=this.options.colors.node),t.beginPath(),t.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),t.fill();else if(a.type===2){let r=this.getExitDir(s,n);if(!r)continue;this.options.colors.node&&(t.strokeStyle=this.options.colors.node),t.lineWidth=12,t.lineCap="round",t.beginPath(),t.moveTo(o.x,o.y),t.lineTo(o.x+r.x*this.options.exitLength,o.y+r.y*this.options.exitLength),t.stroke()}else this.options.colors.node&&(t.fillStyle=this.options.colors.node),t.beginPath(),t.arc(o.x,o.y,this.options.nodeRadius,0,Math.PI*2),t.fill()}}drawPath(t,e,n,s,a,o=null){if(e.length===0||!s)return;let r=a,h=s;if(s.startsWith("rgba")){let i=s.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);if(i){let c=i[1],d=i[2],u=i[3],y=i[4]?parseFloat(i[4]):1;h=`rgb(${c},${d},${u})`,r*=y}}else if(s==="transparent")return;let{canvas:f,ctx:l}=this.prepareOffscreen();this.drawPathInternal(l,e,n,h,o),t.save(),t.globalAlpha=r,t.drawImage(f,0,0),t.restore()}drawPathInternal(t,e,n,s,a=null){t.save(),t.strokeStyle=s,t.fillStyle=s,t.lineWidth=this.options.pathWidth,t.lineCap="round",t.lineJoin="round",t.beginPath();let o=this.getCanvasCoords(e[0].x,e[0].y);t.moveTo(o.x,o.y);for(let h=1;h<e.length;h++){let f=this.getCanvasCoords(e[h].x,e[h].y);t.lineTo(f.x,f.y)}let r=a||this.currentMousePos;(n||a)&&t.lineTo(r.x,r.y),t.stroke(),t.beginPath(),t.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),t.fill(),(n||a)&&(t.beginPath(),t.arc(r.x,r.y,this.options.pathWidth/2,0,Math.PI*2),t.fill()),t.restore()}drawRoundedRect(t,e,n,s,a,o){t.beginPath(),t.moveTo(e+o,n),t.lineTo(e+s-o,n),t.quadraticCurveTo(e+s,n,e+s,n+o),t.lineTo(e+s,n+a-o),t.quadraticCurveTo(e+s,n+a,e+s-o,n+a),t.lineTo(e+o,n+a),t.quadraticCurveTo(e,n+a,e,n+a-o),t.lineTo(e,n+o),t.quadraticCurveTo(e,n,e+o,n),t.closePath(),t.fill()}drawHexagon(t,e,n,s,a){if(!(!this.options.colors.hexagon&&!a)){t.fillStyle=a||this.options.colors.hexagon,t.beginPath();for(let o=0;o<6;o++){let r=Math.PI/3*o,h=e+s*Math.cos(r),f=n+s*Math.sin(r);o===0?t.moveTo(h,f):t.lineTo(h,f)}t.closePath(),t.fill()}}drawEraser(t,e,n,s,a,o,r){t.strokeStyle=r||this.getColorCode(o),t.lineWidth=s*.5,t.lineCap="butt";let h=.5;t.beginPath();for(let f=0;f<a;f++){let l=Math.PI*2/a*f+h,i=e+s*Math.cos(l),c=n+s*Math.sin(l);t.moveTo(e,n),t.lineTo(i,c)}t.stroke()}drawStar(t,e,n,s,a,o,r,h){t.fillStyle=h||this.getColorCode(r),t.beginPath();for(let f=0;f<o*2;f++){let l=f%2===0?a:s,i=Math.PI/o*f,c=e+l*Math.cos(i),d=n+l*Math.sin(i);f===0?t.moveTo(c,d):t.lineTo(c,d)}t.closePath(),t.fill()}drawTetris(t,e,n,s,a,o,r){if(!s||s.length===0)return;let h=12,f=2,l=s[0].length*h+(s[0].length-1)*f,i=s.length*h+(s.length-1)*f;t.save(),t.translate(e,n),a&&t.rotate(Math.PI/8),t.fillStyle=r||this.getColorCode(o,"#ffcc00");for(let c=0;c<s.length;c++)for(let d=0;d<s[c].length;d++)if(s[c][d]){let u=d*(h+f)-l/2,y=c*(h+f)-i/2;t.fillRect(u,y,h,h)}t.restore()}getColorCode(t,e="#666"){return this.options.colors.colorList&&this.options.colors.colorList[t]!==void 0?this.options.colors.colorList[t]:this.options.colors.colorMap&&this.options.colors.colorMap[t]!==void 0?this.options.colors.colorMap[t]:e}hexToRgb(t){let e=t.startsWith("#")?t.slice(1):t;e.length===3&&(e=e.split("").map(s=>s+s).join(""));let n=parseInt(e,16);return{r:n>>16&255,g:n>>8&255,b:n&255}}rgbToHex(t,e,n){return"#"+((1<<24)+(t<<16)+(e<<8)+n).toString(16).slice(1)}lerpColor(t,e,n){try{let s=this.hexToRgb(t),a=this.hexToRgb(e);return this.rgbToHex(Math.round(s.r+(a.r-s.r)*n),Math.round(s.g+(a.g-s.g)*n),Math.round(s.b+(a.b-s.b)*n))}catch{return t}}getSymmetryPath(t){return!this.puzzle||!this.puzzle.symmetry?[]:t.map(e=>this.getSymmetricalPoint(e))}getSymmetricalPoint(t,e=!1){if(!this.puzzle||!this.puzzle.symmetry)return{...t};let{cols:n,rows:s,symmetry:a}=this.puzzle;return a===1?{x:n-t.x,y:t.y}:a===2?{x:t.x,y:s-t.y}:a===3?{x:n-t.x,y:s-t.y}:{...t}}getEdgeKey(t,e){return t.x<e.x||t.x===e.x&&t.y<e.y?`${t.x},${t.y}-${e.x},${e.y}`:`${e.x},${e.y}-${t.x},${t.y}`}prepareOffscreen(){if(!this.offscreenCanvas){if(typeof document<"u")this.offscreenCanvas=document.createElement("canvas");else if(typeof OffscreenCanvas<"u")this.offscreenCanvas=new OffscreenCanvas(this.canvas.width,this.canvas.height);else throw new Error("Offscreen canvas not supported in this environment.");this.offscreenCtx=this.offscreenCanvas.getContext("2d")}if((this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),!this.offscreenCtx)throw new Error("Could not get offscreen 2D context.");return this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx}}};var rt=class{generator;validator;constructor(){this.generator=new Z,this.validator=new Y}createPuzzle(t,e,n={}){return this.generator.generate(t,e,n).export()}validateSolution(t,e){let n=U.fromData(t);return this.validator.validate(n,e)}calculateDifficulty(t){let e=U.fromData(t);return this.validator.calculateDifficulty(e)}};export{j as CellType,H as Color,lt as Direction,_ as EdgeType,U as Grid,Q as NodeType,Z as PuzzleGenerator,nt as PuzzleSerializer,Y as PuzzleValidator,tt as SymmetryType,rt as WitnessCore,ot as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
