/*!
 * MiniWitness 1.2.5
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var lt=(n=>(n[n.Up=0]="Up",n[n.Right=1]="Right",n[n.Down=2]="Down",n[n.Left=3]="Left",n))(lt||{}),j=(o=>(o[o.None=0]="None",o[o.Square=1]="Square",o[o.Star=2]="Star",o[o.Tetris=3]="Tetris",o[o.TetrisRotated=4]="TetrisRotated",o[o.Eraser=5]="Eraser",o))(j||{}),_=(o=>(o[o.Normal=0]="Normal",o[o.Broken=1]="Broken",o[o.Absent=2]="Absent",o[o.Hexagon=3]="Hexagon",o[o.HexagonMain=4]="HexagonMain",o[o.HexagonSymmetry=5]="HexagonSymmetry",o))(_||{}),Q=(o=>(o[o.Normal=0]="Normal",o[o.Start=1]="Start",o[o.End=2]="End",o[o.Hexagon=3]="Hexagon",o[o.HexagonMain=4]="HexagonMain",o[o.HexagonSymmetry=5]="HexagonSymmetry",o))(Q||{}),tt=(n=>(n[n.None=0]="None",n[n.Horizontal=1]="Horizontal",n[n.Vertical=2]="Vertical",n[n.Rotational=3]="Rotational",n))(tt||{}),O={None:0,Black:1,White:2,Red:3,Blue:4};var U=class X{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];symmetry=0;constructor(t,e){this.rows=t,this.cols=e,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:O.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes,symmetry:this.symmetry}))}static fromData(t){let e=new X(t.rows,t.cols);return e.cells=t.cells,e.vEdges=t.vEdges,e.hEdges=t.hEdges,e.nodes=t.nodes,e.symmetry=t.symmetry||0,e}};var Y=class{validate(t,e,s){let n=e.points;if(n.length<2)return{isValid:!1,errorReason:"Path too short"};let h=t.symmetry||0,o=[];if(h!==0)for(let y of n)o.push(this.getSymmetricalPoint(t,y));let i=n[0],f=n[n.length-1];if(t.nodes[i.y][i.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(t.nodes[f.y][f.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};if(h!==0){let y=o[0],d=o[o.length-1];if(t.nodes[y.y][y.x].type!==1)return{isValid:!1,errorReason:"Symmetrical path must start at Start Node"};if(t.nodes[d.y][d.x].type!==2)return{isValid:!1,errorReason:"Symmetrical path must end at End Node"}}let u=new Set,c=new Set;if(u.add(`${i.x},${i.y}`),h!==0){let y=o[0];if(u.has(`${y.x},${y.y}`))return{isValid:!1,errorReason:"Paths collide at start"};u.add(`${y.x},${y.y}`)}for(let y=0;y<n.length-1;y++){let d=n[y],m=n[y+1];if(Math.abs(d.x-m.x)+Math.abs(d.y-m.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let p=`${m.x},${m.y}`;if(u.has(p))return{isValid:!1,errorReason:"Self-intersecting path or path collision"};if(u.add(p),this.isBrokenEdge(t,d,m))return{isValid:!1,errorReason:"Passed through broken edge"};if(c.add(this.getEdgeKey(d,m)),h!==0){let v=o[y],g=o[y+1],P=`${g.x},${g.y}`;if(u.has(P))return{isValid:!1,errorReason:"Path collision"};if(u.add(P),this.isBrokenEdge(t,v,g))return{isValid:!1,errorReason:"Symmetrical path passed through broken edge"};let b=this.getEdgeKey(v,g);if(c.has(b))return{isValid:!1,errorReason:"Paths cross the same edge"};c.add(b)}}let r=this.calculateRegions(t,n,o,s),l=this.getMissedHexagons(t,n,o),a=this.validateWithErasers(t,r,l.edges,l.nodes);return a.regions=r,a}validateFast(t,e,s,n){let h=this.calculateRegions(t,e,s,n),o=this.getMissedHexagons(t,e,s);return this.validateWithErasers(t,h,o.edges,o.nodes)}isBrokenEdge(t,e,s){let n;if(e.x===s.x){let h=Math.min(e.y,s.y);n=t.vEdges[h][e.x].type}else{let h=Math.min(e.x,s.x);n=t.hEdges[e.y][h].type}return n===1||n===2}isAbsentEdge(t,e,s){if(e.x===s.x){let n=Math.min(e.y,s.y);return t.vEdges[n][e.x].type===2}else{let n=Math.min(e.x,s.x);return t.hEdges[e.y][n].type===2}}getMissedHexagons(t,e,s=[]){let n=new Set,h=new Set;for(let c=0;c<e.length;c++)h.add(`${e[c].x},${e[c].y}`),c<e.length-1&&n.add(this.getEdgeKey(e[c],e[c+1]));let o=new Set,i=new Set;for(let c=0;c<s.length;c++)i.add(`${s[c].x},${s[c].y}`),c<s.length-1&&o.add(this.getEdgeKey(s[c],s[c+1]));let f=[];for(let c=0;c<=t.rows;c++)for(let r=0;r<t.cols;r++){let l=t.hEdges[c][r].type;if(l===3||l===4||l===5){let a=this.getEdgeKey({x:r,y:c},{x:r+1,y:c}),y=!1;l===3?y=n.has(a)||o.has(a):l===4?y=n.has(a):l===5&&(y=o.has(a)),y||f.push({type:"h",r:c,c:r})}}for(let c=0;c<t.rows;c++)for(let r=0;r<=t.cols;r++){let l=t.vEdges[c][r].type;if(l===3||l===4||l===5){let a=this.getEdgeKey({x:r,y:c},{x:r,y:c+1}),y=!1;l===3?y=n.has(a)||o.has(a):l===4?y=n.has(a):l===5&&(y=o.has(a)),y||f.push({type:"v",r:c,c:r})}}let u=[];for(let c=0;c<=t.rows;c++)for(let r=0;r<=t.cols;r++){let l=t.nodes[c][r].type;if(l===3||l===4||l===5){let a=`${r},${c}`,y=!1;l===3?y=h.has(a)||i.has(a):l===4?y=h.has(a):l===5&&(y=i.has(a)),y||u.push({x:r,y:c})}}return{edges:f,nodes:u}}validateWithErasers(t,e,s,n){let h=[],o=!0;for(let a=0;a<e.length;a++){let y=e[a],d=y.filter(g=>t.cells[g.y][g.x].type===5),m=y.filter(g=>t.cells[g.y][g.x].type!==0&&t.cells[g.y][g.x].type!==5),x=[];for(let g=0;g<s.length;g++)this.isHexagonAdjacentToRegion(t,s[g],y)&&x.push(g);let p=[];for(let g=0;g<n.length;g++)this.isNodeHexagonAdjacentToRegion(t,n[g],y)&&p.push(g);let v=this.getPossibleErasures(t,y,d,m,x,p);if(v.length===0){o=!1;let g=this.getBestEffortErasures(t,y,d,m,x,p);h.push([g])}else v.sort((g,P)=>{let b=g.invalidatedCells.length+g.invalidatedHexagons.length+g.invalidatedNodeHexagons.length,M=P.invalidatedCells.length+P.invalidatedHexagons.length+P.invalidatedNodeHexagons.length;return b-M}),h.push(v)}if(o){let a=this.findGlobalAssignment(h,s.length,n.length);if(a)return{isValid:!0,invalidatedCells:a.invalidatedCells,invalidatedEdges:a.invalidatedHexIndices.map(y=>s[y]),invalidatedNodes:a.invalidatedNodeHexIndices.map(y=>n[y])}}let i=[],f=[],u=new Set,c=new Set;for(let a of h){let y=a[0];i.push(...y.errorCells),f.push(...y.invalidatedCells);for(let d of y.invalidatedHexagons)u.add(d);for(let d of y.invalidatedNodeHexagons)c.add(d)}let r=[];for(let a=0;a<s.length;a++)u.has(a)||r.push(s[a]);let l=[];for(let a=0;a<n.length;a++)c.has(a)||l.push(n[a]);return{isValid:!1,errorReason:"Constraints failed",errorCells:i,errorEdges:r,errorNodes:l,invalidatedCells:f,invalidatedEdges:Array.from(u).map(a=>s[a]),invalidatedNodes:Array.from(c).map(a=>n[a])}}isHexagonAdjacentToRegion(t,e,s){let n=new Set(s.map(h=>`${h.x},${h.y}`));if(e.type==="h"){if(e.r>0&&n.has(`${e.c},${e.r-1}`)||e.r<t.rows&&n.has(`${e.c},${e.r}`))return!0}else if(e.c>0&&n.has(`${e.c-1},${e.r}`)||e.c<t.cols&&n.has(`${e.c},${e.r}`))return!0;return!1}isNodeHexagonAdjacentToRegion(t,e,s){let n=new Set(s.map(o=>`${o.x},${o.y}`)),h=[{x:e.x-1,y:e.y-1},{x:e.x,y:e.y-1},{x:e.x-1,y:e.y},{x:e.x,y:e.y}];for(let o of h)if(o.x>=0&&o.x<t.cols&&o.y>=0&&o.y<t.rows&&n.has(`${o.x},${o.y}`))return!0;return!1}getPossibleErasures(t,e,s,n,h,o){let i=[],f=s.length;if(f===0)return this.getRegionErrors(t,e,[]).length===0&&h.length===0&&o.length===0&&i.push({invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!0,errorCells:[]}),i;let u=[...n.map(r=>({type:"cell",pos:r})),...h.map(r=>({type:"hex",index:r})),...o.map(r=>({type:"nodeHex",index:r}))],c=this.getRegionErrors(t,e,[]).length===0&&h.length===0&&o.length===0;for(let r=0;r<=f;r++){let l=this.getNCombinations(s,r);for(let a of l){let y=new Set(a.map(m=>`${m.x},${m.y}`)),d=s.filter(m=>!y.has(`${m.x},${m.y}`));for(let m=0;m<=u.length;m++){if(d.length!==r+m)continue;let x=this.getNCombinations(u,m);for(let p of x){let v=p.filter(C=>C.type==="cell").map(C=>C.pos),g=p.filter(C=>C.type==="hex").map(C=>C.index),P=p.filter(C=>C.type==="nodeHex").map(C=>C.index);if(this.getRegionErrors(t,e,[...v,...a]).length===0){let C=!0;if(c)m>0&&(C=!1);else for(let S=0;S<p.length;S++){let T=[...p.slice(0,S),...p.slice(S+1)],z=T.filter(E=>E.type==="cell").map(E=>E.pos),N=new Set(T.filter(E=>E.type==="hex").map(E=>E.index)),H=new Set(T.filter(E=>E.type==="nodeHex").map(E=>E.index)),I=h.every(E=>N.has(E)),k=o.every(E=>H.has(E));if(this.getRegionErrors(t,e,z).length===0&&I&&k){C=!1;break}}C&&i.push({invalidatedCells:[...v,...a],invalidatedHexagons:g,invalidatedNodeHexagons:P,isValid:!0,errorCells:[]})}}}}}return i}getBestEffortErasures(t,e,s,n,h,o){let i=this.getRegionErrors(t,e,[]);if(i.length===0&&h.length===0&&o.length===0)return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:[...s]};if(s.length>0){let c=[...n.map(y=>({type:"cell",pos:y})),...h.map(y=>({type:"hex",index:y})),...o.map(y=>({type:"nodeHex",index:y}))],r=null,l=1/0,a=y=>{let d=[],m=[],x=[],p=0;for(let C of y)p<s.length&&(C.type==="cell"?d.push(C.pos):C.type==="hex"?m.push(C.index):x.push(C.index),p++);let v=s.length-p,g=Math.floor(v/2),P=s.slice(p,p+g);p+=g*2;let b=this.getRegionErrors(t,e,[...d,...P]);for(let C=p;C<s.length;C++)b.push(s[C]);let M=b.length;M<l&&(l=M,r={invalidatedCells:[...d,...P],invalidatedHexagons:m,invalidatedNodeHexagons:x,isValid:!1,errorCells:b})};a([...i.map(y=>({type:"cell",pos:y})),...h.map(y=>({type:"hex",index:y})),...o.map(y=>({type:"nodeHex",index:y}))]),a(c);for(let y of i)a([{type:"cell",pos:y}]);if(r)return r}let u=[...i,...s];return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:u}}getNCombinations(t,e){let s=[],n=(h,o)=>{if(o.length===e){s.push([...o]);return}for(let i=h;i<t.length;i++)o.push(t[i]),n(i+1,o),o.pop()};return n(0,[]),s}checkRegionValid(t,e,s){return this.getRegionErrors(t,e,s).length===0}getRegionErrors(t,e,s){let n=new Set(s.map(r=>`${r.x},${r.y}`)),h=new Map,o=new Map,i=new Set,f=new Set,u=[];for(let r of e){if(n.has(`${r.x},${r.y}`))continue;let l=t.cells[r.y][r.x];if(l.type===0)continue;let a=l.color;a!==O.None&&(h.set(a,(h.get(a)||0)+1),o.has(a)||o.set(a,[]),o.get(a).push(r)),l.type===1?f.add(a):l.type===2?i.add(a):(l.type===3||l.type===4)&&l.shape&&u.push({shape:l.shape,rotatable:l.type===4,pos:r})}let c=[];if(f.size>1)for(let r of e)n.has(`${r.x},${r.y}`)||t.cells[r.y][r.x].type===1&&c.push(r);for(let r of i)if(h.get(r)!==2){let l=o.get(r)||[];for(let a of l)t.cells[a.y][a.x].type===2&&c.push(a)}if(u.length>0&&!this.checkTetrisConstraint(e,u.map(r=>({shape:r.shape,rotatable:r.rotatable}))))for(let r of u)c.push(r.pos);return c}findGlobalAssignment(t,e,s){let n=t.length,h=new Array(e).fill(0),o=new Array(s).fill(0),i=[],f=[],u=[],c=r=>{if(r===n)return h.every(l=>l===1)&&o.every(l=>l===1);for(let l of t[r]){let a=!0;for(let y of l.invalidatedHexagons)if(h[y]>0){a=!1;break}if(a){for(let y of l.invalidatedNodeHexagons)if(o[y]>0){a=!1;break}}if(a){for(let y of l.invalidatedHexagons)h[y]++,f.push(y);for(let y of l.invalidatedNodeHexagons)o[y]++,u.push(y);if(i.push(...l.invalidatedCells),c(r+1))return!0;for(let y of l.invalidatedHexagons)h[y]--,f.pop();for(let y of l.invalidatedNodeHexagons)o[y]--,u.pop();for(let y=0;y<l.invalidatedCells.length;y++)i.pop()}}return!1};return c(0)?{invalidatedCells:i,invalidatedHexIndices:f,invalidatedNodeHexIndices:u}:null}checkTetrisConstraint(t,e){if(e.reduce((r,l)=>r+this.getShapeArea(l.shape),0)!==t.length)return!1;let n=Math.min(...t.map(r=>r.x)),h=Math.min(...t.map(r=>r.y)),o=Math.max(...t.map(r=>r.x)),i=Math.max(...t.map(r=>r.y)),f=o-n+1,u=i-h+1,c=Array.from({length:u},()=>Array(f).fill(!1));for(let r of t)c[r.y-h][r.x-n]=!0;return this.canTile(c,e)}getShapeArea(t){let e=0;for(let s of t)for(let n of s)n&&e++;return e}canTile(t,e){let s=-1,n=-1;for(let h=0;h<t.length;h++){for(let o=0;o<t[0].length;o++)if(t[h][o]){s=h,n=o;break}if(s!==-1)break}if(s===-1)return e.length===0;if(e.length===0)return!1;for(let h=0;h<e.length;h++){let o=e[h],i=[...e.slice(0,h),...e.slice(h+1)],f=o.rotatable?this.getAllRotations(o.shape):[o.shape];for(let u of f){let c=[];for(let r=0;r<u.length;r++)for(let l=0;l<u[0].length;l++)u[r][l]&&c.push({r,c:l});for(let r of c){let l=s-r.r,a=n-r.c;if(this.canPlace(t,u,l,a)){if(this.placePiece(t,u,l,a,!1),this.canTile(t,i))return!0;this.placePiece(t,u,l,a,!0)}}}}return!1}canPlace(t,e,s,n){for(let h=0;h<e.length;h++)for(let o=0;o<e[0].length;o++)if(e[h][o]){let i=s+h,f=n+o;if(i<0||i>=t.length||f<0||f>=t[0].length||!t[i][f])return!1}return!0}placePiece(t,e,s,n,h){for(let o=0;o<e.length;o++)for(let i=0;i<e[0].length;i++)e[o][i]&&(t[s+o][n+i]=h)}getAllRotations(t){let e=[],s=new Set,n=t;for(let h=0;h<4;h++){let o=JSON.stringify(n);s.has(o)||(e.push(n),s.add(o)),n=this.rotate90(n)}return e}rotate90(t){let e=t.length,s=t[0].length,n=Array.from({length:s},()=>Array(e).fill(0));for(let h=0;h<e;h++)for(let o=0;o<s;o++)n[o][e-1-h]=t[h][o];return n}calculateRegions(t,e,s=[],n){let h=[],o=t.rows,i=t.cols,f=new Uint8Array(o*i),u=new Uint8Array((o+1)*i),c=new Uint8Array(o*(i+1)),r=(a,y)=>{a.x===y.x?c[Math.min(a.y,y.y)*(i+1)+a.x]=1:u[a.y*i+Math.min(a.x,y.x)]=1};for(let a=0;a<e.length-1;a++)r(e[a],e[a+1]);for(let a=0;a<s.length-1;a++)r(s[a],s[a+1]);for(let a=0;a<=o;a++)for(let y=0;y<i;y++)t.hEdges[a][y].type===2&&(u[a*i+y]=1);for(let a=0;a<o;a++)for(let y=0;y<=i;y++)t.vEdges[a][y].type===2&&(c[a*(i+1)+y]=1);let l=n||this.getExternalCells(t);for(let a=0;a<o;a++)for(let y=0;y<i;y++){let d=a*i+y;if(f[d]||l&&l.has(`${y},${a}`))continue;let m=[],x=[d];f[d]=1;let p=0;for(;p<x.length;){let v=x[p++],g=v%i,P=Math.floor(v/i);if(m.push({x:g,y:P}),P>0&&!u[P*i+g]){let b=(P-1)*i+g;!f[b]&&(!l||!l.has(`${g},${P-1}`))&&(f[b]=1,x.push(b))}if(P<o-1&&!u[(P+1)*i+g]){let b=(P+1)*i+g;!f[b]&&(!l||!l.has(`${g},${P+1}`))&&(f[b]=1,x.push(b))}if(g>0&&!c[P*(i+1)+g]){let b=P*i+(g-1);!f[b]&&(!l||!l.has(`${g-1},${P}`))&&(f[b]=1,x.push(b))}if(g<i-1&&!c[P*(i+1)+(g+1)]){let b=P*i+(g+1);!f[b]&&(!l||!l.has(`${g+1},${P}`))&&(f[b]=1,x.push(b))}}h.push(m)}return h}getExternalCells(t){let e=new Set,s=[];for(let n=0;n<t.cols;n++)t.hEdges[0][n].type===2&&(e.has(`${n},0`)||(e.add(`${n},0`),s.push({x:n,y:0}))),t.hEdges[t.rows][n].type===2&&(e.has(`${n},${t.rows-1}`)||(e.add(`${n},${t.rows-1}`),s.push({x:n,y:t.rows-1})));for(let n=0;n<t.rows;n++)t.vEdges[n][0].type===2&&(e.has(`0,${n}`)||(e.add(`0,${n}`),s.push({x:0,y:n}))),t.vEdges[n][t.cols].type===2&&(e.has(`${t.cols-1},${n}`)||(e.add(`${t.cols-1},${n}`),s.push({x:t.cols-1,y:n})));for(;s.length>0;){let n=s.shift(),h=[{nx:n.x,ny:n.y-1,edge:t.hEdges[n.y][n.x]},{nx:n.x,ny:n.y+1,edge:t.hEdges[n.y+1][n.x]},{nx:n.x-1,ny:n.y,edge:t.vEdges[n.y][n.x]},{nx:n.x+1,ny:n.y,edge:t.vEdges[n.y][n.x+1]}];for(let o of h)o.nx>=0&&o.nx<t.cols&&o.ny>=0&&o.ny<t.rows&&!e.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(e.add(`${o.nx},${o.ny}`),s.push({x:o.nx,y:o.ny}))}return e}getSymmetricalPoint(t,e){let s=t.symmetry||0;return s===1?{x:t.cols-e.x,y:e.y}:s===2?{x:e.x,y:t.rows-e.y}:s===3?{x:t.cols-e.x,y:t.rows-e.y}:{...e}}getSymmetricalPointIndex(t,e){let s=t.cols+1,n=Math.floor(e/s),h=e%s,o=t.symmetry||0,i=n,f=h;return o===1?f=t.cols-h:o===2?i=t.rows-n:o===3&&(f=t.cols-h,i=t.rows-n),i*s+f}getEdgeKey(t,e){return t.x<e.x||t.x===e.x&&t.y<e.y?`${t.x},${t.y}-${e.x},${e.y}`:`${e.x},${e.y}-${t.x},${t.y}`}calculateDifficulty(t){let e=t.rows,s=t.cols,n=s+1,h=(e+1)*n,o=Array.from({length:h},()=>[]),i=[],f=[],u=new Map,c=0,r=new Set,l=new Set;for(let k=0;k<=e;k++)for(let E=0;E<=s;E++){let w=k*n+E;if(t.nodes[k][E].type===1&&i.push(w),t.nodes[k][E].type===2&&f.push(w),(t.nodes[k][E].type===3||t.nodes[k][E].type===4||t.nodes[k][E].type===5)&&(u.set(`n${E},${k}`,c++),l.add(w)),E<s){let R=w+1,A=t.hEdges[k][E].type,F=A===3||A===4||A===5,G=A===1||A===2;o[w].push({next:R,hexType:A,isBroken:G}),o[R].push({next:w,hexType:A,isBroken:G}),F&&(u.set(`eh${E},${k}`,c++),r.add(this.getEdgeKey({x:E,y:k},{x:E+1,y:k})))}if(k<e){let R=w+n,A=t.vEdges[k][E].type,F=A===3||A===4||A===5,G=A===1||A===2;o[w].push({next:R,hexType:A,isBroken:G}),o[R].push({next:w,hexType:A,isBroken:G}),F&&(u.set(`ev${E},${k}`,c++),r.add(this.getEdgeKey({x:E,y:k},{x:E,y:k+1})))}}let a={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},y=c,d=new Set,m=Math.max(1e3,e*s*200),x=this.getExternalCells(t),p=!1;for(let k=0;k<e;k++){for(let E=0;E<s;E++)if(t.cells[k][E].type!==0){p=!0;break}if(p)break}for(let k of i){let E=t.cols+1,w=Math.floor(k/E),R=k%E,A=0n,F=t.nodes[w][R].type;(F===3||F===4)&&(A|=1n<<BigInt(u.get(`n${R},${w}`)));let G=t.symmetry||0;if(G!==0){let V=this.getSymmetricalPointIndex(t,k),B=Math.floor(V/E),q=V%E,$=t.nodes[B][q].type;($===3||$===5)&&(A|=1n<<BigInt(u.get(`n${q},${B}`)))}let W=1n<<BigInt(k);if(G!==0){let V=this.getSymmetricalPointIndex(t,k);if(V===k)continue;W|=1n<<BigInt(V)}this.exploreSearchSpace(t,k,W,[k],A,y,o,f,d,a,m,x,p,u)}if(a.solutions===0)return 0;let v=r.size+l.size,g=new Set;r.size>0&&g.add(999);let P=0,b=0;for(let k=0;k<e;k++)for(let E=0;E<s;E++){let w=t.cells[k][E];w.type!==0&&(v++,g.add(w.type),w.type===3?P++:w.type===4&&(P++,b++))}let M=a.branchingPoints/(a.totalNodesVisited||1),C=Math.log10(a.totalNodesVisited+1),S=(M*10+C*1.5)/(Math.log2(a.solutions+1)*.5+1);S-=r.size*.05,S+=l.size*.12,P>0&&(S+=b*.5,S+=(P-b)*.2);let T=e*s,z=v/T,N=z<.25?Math.pow(z/.25,4):1,H=g.size<=1?.5:1;S*=N*H;let I=Math.log2(T)/5;return S*=I,Math.max(.01,Math.min(1,S/4))}exploreSearchSpace(t,e,s,n,h,o,i,f,u,c,r,l,a=!0,y){if(c.totalNodesVisited++,c.maxDepth=Math.max(c.maxDepth,n.length),c.totalNodesVisited>r)return;let d=t.symmetry||0;if(f.includes(e)){let p=0,v=h;for(;v>0n;)v&1n&&p++,v>>=1n;if(p===o){let g=n.map(M=>({x:M%(t.cols+1),y:Math.floor(M/(t.cols+1))})),P={points:g};if(d!==0){let M=this.getSymmetricalPointIndex(t,e),C=t.cols+1;if(t.nodes[Math.floor(M/C)][M%C].type!==2)return}let b=d!==0?g.map(M=>this.getSymmetricalPoint(t,M)):[];if(a){let M=this.validateFast(t,g,b,l);if(M.isValid){let C=this.getFingerprint(t,g,b,M.regions,l);u.has(C)||(u.add(C),c.solutions++)}}else{let M=this.getFingerprint(t,g,b,void 0,l);u.has(M)||(u.add(M),c.solutions++)}}return}if(!this.canReachEndOptimized(e,s,i,f)){c.backtracks++;return}let m=[];for(let p of i[e]){if(p.isBroken||s&1n<<BigInt(p.next))continue;if(d!==0){let g=this.getSymmetricalPointIndex(t,e),P=this.getSymmetricalPointIndex(t,p.next);if(p.next===P||e===P&&p.next===g)continue}let v=!0;for(let g of i[e])if(g.hexType===3||g.hexType===4){let b=n.length>=2&&g.next===n[n.length-2],M=g.next===p.next;if(!b&&!M){v=!1;break}}if(v){if(d!==0){let g=this.getSymmetricalPointIndex(t,e),P=this.getSymmetricalPointIndex(t,p.next);for(let b of i[g])if(b.hexType===3||b.hexType===5){let C=n.length>=2?this.getSymmetricalPointIndex(t,n[n.length-2]):-1,S=b.next===C,T=b.next===P;if(!S&&!T){v=!1;break}}}v&&m.push(p)}}if(m.length>1&&c.branchingPoints++,t.rows*t.cols>30)for(let p=m.length-1;p>0;p--){let v=Math.floor(Math.random()*(p+1));[m[p],m[v]]=[m[v],m[p]]}let x=t.cols+1;for(let p of m){let v=h,g=Math.floor(p.next/x),P=p.next%x,b=t.nodes[g][P].type;(b===3||b===4)&&(v|=1n<<BigInt(y.get(`n${P},${g}`)));let M=n[n.length-1],C=Math.floor(M/x),S=M%x;if(C===g){let z=Math.min(S,P);(p.hexType===3||p.hexType===4)&&(v|=1n<<BigInt(y.get(`eh${z},${g}`)))}else{let z=Math.min(C,g);(p.hexType===3||p.hexType===4)&&(v|=1n<<BigInt(y.get(`ev${P},${z}`)))}if(d!==0){let z=this.getSymmetricalPointIndex(t,p.next),N=Math.floor(z/x),H=z%x,I=t.nodes[N][H].type;(I===3||I===5)&&(v|=1n<<BigInt(y.get(`n${H},${N}`)));let k=this.getSymmetricalPointIndex(t,M),E=Math.floor(k/x),w=k%x;if(E===N){let R=Math.min(w,H),A=t.hEdges[N][R].type;(A===3||A===5)&&(v|=1n<<BigInt(y.get(`eh${R},${N}`)))}else{let R=Math.min(E,N),A=t.vEdges[R][H].type;(A===3||A===5)&&(v|=1n<<BigInt(y.get(`ev${H},${R}`)))}}n.push(p.next);let T=s|1n<<BigInt(p.next);if(d!==0){let z=this.getSymmetricalPointIndex(t,p.next);T|=1n<<BigInt(z)}if(this.exploreSearchSpace(t,p.next,T,n,v,o,i,f,u,c,r,l,a,y),n.pop(),c.totalNodesVisited>r)return}}countSolutions(t,e=100){let s=t.rows,n=t.cols,h=n+1,o=(s+1)*h,i=Array.from({length:o},()=>[]),f=[],u=[],c=new Map,r=0;for(let m=0;m<=s;m++)for(let x=0;x<=n;x++){let p=m*h+x;if(t.nodes[m][x].type===1&&f.push(p),t.nodes[m][x].type===2&&u.push(p),(t.nodes[m][x].type===3||t.nodes[m][x].type===4||t.nodes[m][x].type===5)&&c.set(`n${x},${m}`,r++),x<n){let v=p+1,g=t.hEdges[m][x].type,P=g===3||g===4||g===5,b=g===1||g===2;i[p].push({next:v,hexType:g,isBroken:b}),i[v].push({next:p,hexType:g,isBroken:b}),P&&c.set(`eh${x},${m}`,r++)}if(m<s){let v=p+h,g=t.vEdges[m][x].type,P=g===3||g===4||g===5,b=g===1||g===2;i[p].push({next:v,hexType:g,isBroken:b}),i[v].push({next:p,hexType:g,isBroken:b}),P&&c.set(`ev${x},${m}`,r++)}}let l=new Set,a=r,y=this.getExternalCells(t),d=!1;for(let m=0;m<s;m++){for(let x=0;x<n;x++)if(t.cells[m][x].type!==0){d=!0;break}if(d)break}for(let m of f){let x=t.cols+1,p=Math.floor(m/x),v=m%x,g=0n,P=t.nodes[p][v].type;(P===3||P===4)&&(g|=1n<<BigInt(c.get(`n${v},${p}`)));let b=t.symmetry||0;if(b!==0){let C=this.getSymmetricalPointIndex(t,m),S=Math.floor(C/x),T=C%x,z=t.nodes[S][T].type;(z===3||z===5)&&(g|=1n<<BigInt(c.get(`n${T},${S}`)))}let M=1n<<BigInt(m);if(b!==0){let C=this.getSymmetricalPointIndex(t,m);if(C===m)continue;M|=1n<<BigInt(C)}this.findPathsOptimized(t,m,M,[m],g,a,i,u,l,e,y,d,c)}return l.size}findPathsOptimized(t,e,s,n,h,o,i,f,u,c,r,l=!0,a){if(u.size>=c)return;let y=t.symmetry||0;if(f.includes(e)){let d=0,m=h;for(;m>0n;)m&1n&&d++,m>>=1n;if(d===o){let x=n.map(v=>({x:v%(t.cols+1),y:Math.floor(v/(t.cols+1))}));if(y!==0){let v=this.getSymmetricalPointIndex(t,e),g=t.cols+1;if(t.nodes[Math.floor(v/g)][v%g].type!==2)return}let p=y!==0?x.map(v=>this.getSymmetricalPoint(t,v)):[];if(!l)u.add(this.getFingerprint(t,x,p,void 0,r));else{let v=this.validateFast(t,x,p,r);v.isValid&&u.add(this.getFingerprint(t,x,p,v.regions,r))}}return}if(this.canReachEndOptimized(e,s,i,f))for(let d of i[e]){if(d.isBroken||s&1n<<BigInt(d.next))continue;if(y!==0){let S=this.getSymmetricalPointIndex(t,e),T=this.getSymmetricalPointIndex(t,d.next);if(d.next===T||e===T&&d.next===S)continue}let m=!0;for(let S of i[e])if(S.hexType===3||S.hexType===4){let z=n.length>=2&&S.next===n[n.length-2],N=S.next===d.next;if(!z&&!N){m=!1;break}}if(!m)continue;if(y!==0){let S=this.getSymmetricalPointIndex(t,e),T=this.getSymmetricalPointIndex(t,d.next);for(let z of i[S])if(z.hexType===3||z.hexType===5){let H=n.length>=2?this.getSymmetricalPointIndex(t,n[n.length-2]):-1,I=z.next===H,k=z.next===T;if(!I&&!k){m=!1;break}}}if(!m)continue;let x=t.cols+1,p=h,v=Math.floor(d.next/x),g=d.next%x,P=t.nodes[v][g].type;(P===3||P===4)&&(p|=1n<<BigInt(a.get(`n${g},${v}`)));let b=Math.floor(e/x),M=e%x;if(b===v){let S=Math.min(M,g);(d.hexType===3||d.hexType===4)&&(p|=1n<<BigInt(a.get(`eh${S},${v}`)))}else{let S=Math.min(b,v);(d.hexType===3||d.hexType===4)&&(p|=1n<<BigInt(a.get(`ev${g},${S}`)))}if(y!==0){let S=this.getSymmetricalPointIndex(t,d.next),T=Math.floor(S/x),z=S%x,N=t.nodes[T][z].type;(N===3||N===5)&&(p|=1n<<BigInt(a.get(`n${z},${T}`)));let H=this.getSymmetricalPointIndex(t,e),I=Math.floor(H/x),k=H%x;if(I===T){let E=Math.min(k,z),w=t.hEdges[T][E].type;(w===3||w===5)&&(p|=1n<<BigInt(a.get(`eh${E},${T}`)))}else{let E=Math.min(I,T),w=t.vEdges[E][z].type;(w===3||w===5)&&(p|=1n<<BigInt(a.get(`ev${z},${E}`)))}}n.push(d.next);let C=s|1n<<BigInt(d.next);if(y!==0){let S=this.getSymmetricalPointIndex(t,d.next);C|=1n<<BigInt(S)}if(this.findPathsOptimized(t,d.next,C,n,p,o,i,f,u,c,r,l,a),n.pop(),u.size>=c)return}}canReachEndOptimized(t,e,s,n){let h=[t],o=e,i=0;for(;i<h.length;){let f=h[i++];if(n.includes(f))return!0;for(let u of s[f])!u.isBroken&&!(o&1n<<BigInt(u.next))&&(o|=1n<<BigInt(u.next),h.push(u.next))}return!1}getFingerprint(t,e,s,n,h){let i=(n||this.calculateRegions(t,e,s,h)).map(u=>{let c="",r=[];for(let l of u){let a=t.cells[l.y][l.x];a.type!==0&&r.push(a.type<<8|a.color)}r.sort((l,a)=>l-a);for(let l of r)c+=l.toString(36)+",";return c}).sort(),f="";for(let u of i)u.length>0&&(f+=u+"|");return f||"empty"}};var Z=class{isWorker;constructor(){this.isWorker=typeof self<"u"&&"postMessage"in self&&!("document"in self)}generate(t,e,s={}){let n=s.difficulty??.5,h=new Y,o=null,i=-1,f=this.isWorker?t*e>30?150:120:t*e>30?100:80,u=this.isWorker?8:5,c=s.symmetry||0,r={x:0,y:t},l={x:e,y:0};c===1?l={x:0,y:0}:c===2?l={x:e,y:t}:c===3&&(l={x:e,y:t});let a=null,y=null,d=null;for(let m=0;m<f;m++){if(m%u===0){a=this.generateRandomPath(new U(t,e),r,l,s.pathLength,c);let g=new U(t,e),P=c!==0?a.map(b=>this.getSymmetricalPoint(g,b,c)):[];y=this.calculateRegions(g,a,P),d=y.map(b=>this.getRegionBoundaryEdges(g,b,a,P))}let x=this.generateFromPath(t,e,a,s,y,d);if(!this.checkAllRequestedConstraintsPresent(x,s))continue;let p=h.calculateDifficulty(x);if(p===0)continue;let v=Math.abs(p-n);if((o===null||v<Math.abs(i-n))&&(i=p,o=x),n>.8&&p>.8||v<.01)break}if(!o){let m=this.generateRandomPath(new U(t,e),r,l,s.pathLength,c);return this.generateFromPath(t,e,m,s)}return o}generateFromPath(t,e,s,n,h,o){let i=new U(t,e),f=n.symmetry||0;i.symmetry=f;let u={x:0,y:t},c={x:e,y:0};if(f===1?c={x:0,y:0}:f===2?c={x:e,y:t}:f===3&&(c={x:e,y:t}),i.nodes[u.y][u.x].type=1,i.nodes[c.y][c.x].type=2,f!==0){let l=this.getSymmetricalPoint(i,u,f),a=this.getSymmetricalPoint(i,c,f);i.nodes[l.y][l.x].type=1,i.nodes[a.y][a.x].type=2}let r=f!==0?s.map(l=>this.getSymmetricalPoint(i,l,f)):[];return this.applyConstraintsBasedOnPath(i,s,n,r,h,o),n.useBrokenEdges&&this.applyBrokenEdges(i,s,n),this.cleanGrid(i),i}generateRandomPath(t,e,s,n,h=0){if(n===void 0)return this.generateSingleRandomPath(t,e,s,void 0,h);let o=t.rows+t.cols,i=(t.rows+1)*(t.cols+1)-1,f=o+n*(i-o),u=[],c=1/0,r=t.rows*t.cols>30?30:50;for(let l=0;l<r;l++){let a=this.generateSingleRandomPath(t,e,s,n,h);if(a.length===0)continue;let y=a.length-1,d=Math.abs(y-f);if(d<c&&(c=d,u=a),c<=2)break}return u}generateSingleRandomPath(t,e,s,n,h=0){let o=new Set,i=[],f=0,u=t.rows*t.cols*200,c=r=>{if(f++,f>u)return!1;o.add(`${r.x},${r.y}`);let l=this.getSymmetricalPoint(t,r,h);if(o.add(`${l.x},${l.y}`),i.push(r),r.x===s.x&&r.y===s.y)return!0;let a=this.getValidNeighbors(t,r,o);h!==0&&(a=a.filter(y=>{let d=this.getSymmetricalPoint(t,y,h);if(d.x<0||d.x>t.cols||d.y<0||d.y>t.rows||o.has(`${d.x},${d.y}`)||y.x===d.x&&y.y===d.y)return!1;let m=this.getEdgeKey(r,y),x=this.getEdgeKey(l,d);return m!==x})),n!==void 0?a.sort((y,d)=>{let m=Math.abs(y.x-s.x)+Math.abs(y.y-s.y),x=Math.abs(d.x-s.x)+Math.abs(d.y-s.y);return(m-x)*(1-n*2)+(Math.random()-.5)*1.5}):this.shuffleArray(a);for(let y of a)if(c(y))return!0;return i.pop(),o.delete(`${r.x},${r.y}`),o.delete(`${l.x},${l.y}`),!1};return c(e),i}getValidNeighbors(t,e,s){let n=[],h=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of h){let i=e.x+o.x,f=e.y+o.y;i>=0&&i<=t.cols&&f>=0&&f<=t.rows&&(s.has(`${i},${f}`)||n.push({x:i,y:f}))}return n}applyBrokenEdges(t,e,s){let n=s.complexity??.5,h=s.symmetry??0,o=new Set;for(let r=0;r<e.length-1;r++)if(o.add(this.getEdgeKey(e[r],e[r+1])),h!==0){let l=this.getSymmetricalPoint(t,e[r],h),a=this.getSymmetricalPoint(t,e[r+1],h);o.add(this.getEdgeKey(l,a))}let i=[];for(let r=0;r<=t.rows;r++)for(let l=0;l<t.cols;l++){let a={x:l,y:r},y={x:l+1,y:r};o.has(this.getEdgeKey(a,y))||i.push({type:"h",r,c:l,p1:a,p2:y})}for(let r=0;r<t.rows;r++)for(let l=0;l<=t.cols;l++){let a={x:l,y:r},y={x:l,y:r+1};o.has(this.getEdgeKey(a,y))||i.push({type:"v",r,c:l,p1:a,p2:y})}this.shuffleArray(i);let f=Math.max(1,Math.floor(n*(t.rows*t.cols)/4)),u=0;for(let r of i){if(u>=f)break;r.type==="h"?t.hEdges[r.r][r.c].type=1:t.vEdges[r.r][r.c].type=1,u++}let c=!0;for(;c;){c=!1;for(let r=0;r<=t.rows;r++)for(let l=0;l<t.cols;l++)t.hEdges[r][l].type===1&&this.canBecomeAbsent(t,{type:"h",r,c:l})&&(t.hEdges[r][l].type=2,c=!0);for(let r=0;r<t.rows;r++)for(let l=0;l<=t.cols;l++)t.vEdges[r][l].type===1&&this.canBecomeAbsent(t,{type:"v",r,c:l})&&(t.vEdges[r][l].type=2,c=!0)}for(let r=0;r<=t.rows;r++)for(let l=0;l<=t.cols;l++){let a=[];if(l>0&&a.push({e:t.hEdges[r][l-1],type:"h",r,c:l-1}),l<t.cols&&a.push({e:t.hEdges[r][l],type:"h",r,c:l}),r>0&&a.push({e:t.vEdges[r-1][l],type:"v",r:r-1,c:l}),r<t.rows&&a.push({e:t.vEdges[r][l],type:"v",r,c:l}),a.length>0&&a.every(y=>y.e.type===1||y.e.type===2)&&a.every(y=>!this.isAdjacentToMark(t,y)))for(let y of a)y.e.type=2}}canBecomeAbsent(t,e){if(this.isAdjacentToMark(t,e))return!1;if(e.type==="h"){if(e.r===0||e.r===t.rows)return!0}else if(e.c===0||e.c===t.cols)return!0;let s=e.type==="h"?[{x:e.c,y:e.r},{x:e.c+1,y:e.r}]:[{x:e.c,y:e.r},{x:e.c,y:e.r+1}];for(let n of s){let h=[{type:"h",r:n.y,c:n.x-1},{type:"h",r:n.y,c:n.x},{type:"v",r:n.y-1,c:n.x},{type:"v",r:n.y,c:n.x}];for(let o of h)if(o.c>=0&&o.c<=t.cols&&o.r>=0&&o.r<=t.rows){if(o.type==="h"&&o.c<t.cols){if(t.hEdges[o.r][o.c].type===2)return!0}else if(o.type==="v"&&o.r<t.rows&&t.vEdges[o.r][o.c].type===2)return!0}}return!1}cleanGrid(t){let e=[];for(let o=0;o<=t.rows;o++)for(let i=0;i<=t.cols;i++)t.nodes[o][i].type===1&&e.push({x:i,y:o});let s=new Set,n=[...e];for(let o of e)s.add(`${o.x},${o.y}`);for(;n.length>0;){let o=n.shift(),i=[{nx:o.x,ny:o.y-1,edge:t.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:t.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:t.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:t.hEdges[o.y]?.[o.x]}];for(let f of i)f.edge&&f.edge.type!==2&&(s.has(`${f.nx},${f.ny}`)||(s.add(`${f.nx},${f.ny}`),n.push({x:f.nx,y:f.ny})))}for(let o=0;o<=t.rows;o++)for(let i=0;i<t.cols;i++)(!s.has(`${i},${o}`)||!s.has(`${i+1},${o}`))&&(t.hEdges[o][i].type=2);for(let o=0;o<t.rows;o++)for(let i=0;i<=t.cols;i++)(!s.has(`${i},${o}`)||!s.has(`${i},${o+1}`))&&(t.vEdges[o][i].type=2);let h=this.getExternalCells(t);for(let o of h){let[i,f]=o.split(",").map(Number);t.cells[f][i].type=0}}getExternalCells(t){let e=new Set,s=[];for(let n=0;n<t.cols;n++)t.hEdges[0][n].type===2&&(e.has(`${n},0`)||(e.add(`${n},0`),s.push({x:n,y:0}))),t.hEdges[t.rows][n].type===2&&(e.has(`${n},${t.rows-1}`)||(e.add(`${n},${t.rows-1}`),s.push({x:n,y:t.rows-1})));for(let n=0;n<t.rows;n++)t.vEdges[n][0].type===2&&(e.has(`0,${n}`)||(e.add(`0,${n}`),s.push({x:0,y:n}))),t.vEdges[n][t.cols].type===2&&(e.has(`${t.cols-1},${n}`)||(e.add(`${t.cols-1},${n}`),s.push({x:t.cols-1,y:n})));for(;s.length>0;){let n=s.shift(),h=[{nx:n.x,ny:n.y-1,edge:t.hEdges[n.y][n.x]},{nx:n.x,ny:n.y+1,edge:t.hEdges[n.y+1][n.x]},{nx:n.x-1,ny:n.y,edge:t.vEdges[n.y][n.x]},{nx:n.x+1,ny:n.y,edge:t.vEdges[n.y][n.x+1]}];for(let o of h)o.nx>=0&&o.nx<t.cols&&o.ny>=0&&o.ny<t.rows&&!e.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(e.add(`${o.nx},${o.ny}`),s.push({x:o.nx,y:o.ny}))}return e}isAdjacentToMark(t,e){if(e.type==="h"){if(e.r>0&&t.cells[e.r-1][e.c].type!==0||e.r<t.rows&&t.cells[e.r][e.c].type!==0)return!0}else if(e.c>0&&t.cells[e.r][e.c-1].type!==0||e.c<t.cols&&t.cells[e.r][e.c].type!==0)return!0;return!1}hasIsolatedMark(t){for(let e=0;e<t.rows;e++)for(let s=0;s<t.cols;s++){if(t.cells[e][s].type===0)continue;if([t.hEdges[e][s],t.hEdges[e+1][s],t.vEdges[e][s],t.vEdges[e][s+1]].every(h=>h.type===1||h.type===2))return!0}return!1}getSymmetricalPoint(t,e,s){return s===1?{x:t.cols-e.x,y:e.y}:s===2?{x:e.x,y:t.rows-e.y}:s===3?{x:t.cols-e.x,y:t.rows-e.y}:{...e}}getEdgeKey(t,e){return t.x<e.x||t.x===e.x&&t.y<e.y?`${t.x},${t.y}-${e.x},${e.y}`:`${e.x},${e.y}-${t.x},${t.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(t,e,s,n=[],h,o){let i=s.complexity??.5,f=s.useHexagons??!0,u=s.useSquares??!0,c=s.useStars??!0,r=s.useTetris??!1,l=s.useEraser??!1,a=0,y=0,d=0,m=0,x=0,p=0,v=Math.floor(t.rows*t.cols*.45);if(f){let g=s.difficulty??.5,P=s.symmetry||0;for(let b=0;b<e.length-1;b++){let C=this.getValidNeighbors(t,e[b],new Set).length>2,S=i*(g<.4?.6:.3);if(C&&(S=g<.4?S*1:S*.5),Math.random()<S){let T=3,z=e[b],N=e[b+1];if(P!==0){let H=Math.random();H<.3?T=4:H<.6&&(T=5,z=this.getSymmetricalPoint(t,e[b],P),N=this.getSymmetricalPoint(t,e[b+1],P))}this.setEdgeHexagon(t,z,N,T),a++}}for(let b=0;b<e.length;b++){let M=e[b];if(t.nodes[M.y][M.x].type!==0||this.hasIncidentHexagonEdge(t,M))continue;let C=i*(g>.6?.15:.05);if(Math.random()<C){let S=3,T=M;if(P!==0){let z=Math.random();z<.3?S=4:z<.6&&(S=5,T=this.getSymmetricalPoint(t,M,P))}t.nodes[T.y][T.x].type=S,a++}}if(a===0&&e.length>=2){let b=Math.floor(Math.random()*(e.length-1)),M=s.symmetry||0,C=3,S=e[b],T=e[b+1];if(M!==0){let z=Math.random();z<.3?C=4:z<.6&&(C=5,S=this.getSymmetricalPoint(t,e[b],M),T=this.getSymmetricalPoint(t,e[b+1],M))}this.setEdgeHexagon(t,S,T,C)}}if(u||c||r||l){let g=h||this.calculateRegions(t,e,n),P=s.availableColors??[O.Black,O.White,O.Red,O.Blue],b=s.defaultColors??{},M=(z,N)=>{if(b[z]!==void 0)return b[z];let H=j[z];return H&&b[H]!==void 0?b[H]:N},C=Array.from({length:g.length},(z,N)=>N);this.shuffleArray(C);let S=new Set,T={square:u,star:c,tetris:r,eraser:l};for(let z=0;z<C.length;z++){let N=C[z],H=g[N],I=C.length-z,k=T.square&&y===0||T.star&&d===0||T.tetris&&m===0||T.eraser&&x===0,E=.2+i*.6;if(k&&I<=3?E=1:k&&I<=6&&(E=.7),Math.random()>E)continue;let w=[...H];this.shuffleArray(w);let R=P[Math.floor(Math.random()*P.length)];if(u&&!c&&I<=2&&S.size===1){let F=P.filter(G=>!S.has(G));F.length>0&&(R=F[Math.floor(Math.random()*F.length)])}let A=u&&Math.random()<.5+i*.3;if(u&&y===0&&I<=2&&(A=!0),u&&!c&&I<=2&&S.size<2&&y>0&&(A=!0),A&&w.length>0){let F=Math.min(w.length,Math.max(4,Math.floor(H.length/4))),G=Math.floor(Math.random()*(F/2))+Math.ceil(F/2);for(let W=0;W<G&&w.length!==0;W++){let V=w.pop();t.cells[V.y][V.x].type=1,t.cells[V.y][V.x].color=R,y++,S.add(R)}}if(r&&p<v){let F=Math.random()<.1+i*.4;m===0&&I<=2&&(F=!0);let G=m===0&&I<=2?6:4;if(F&&w.length>0&&H.length<=G*4&&p+H.length<=v){let W=this.generateTiling(H,G,s);if(W){for(let V of W){if(w.length===0)break;let B=w.pop();t.cells[B.y][B.x].type=V.isRotated?4:3,t.cells[B.y][B.x].shape=V.isRotated?V.displayShape:V.shape;let q=M(3,O.None);if(c&&Math.random()<.5){let $=P.filter(D=>D!==O.Blue&&D!==q);$.length>0&&(q=$[Math.floor(Math.random()*$.length)])}t.cells[B.y][B.x].color=q,m++}p+=H.length}}}if(l&&x<1){let F=.05+i*.2,G=Math.random()<F;if(I<=2&&(G=!0),G&&w.length>=1){let W=[];c&&W.push("star"),u&&W.push("square");let V=[];f&&(V=o?o[N]:this.getRegionBoundaryEdges(t,H,e,n),V.length>0&&W.push("hexagon")),r&&W.push("tetris");let B=W.length>0?W[Math.floor(Math.random()*W.length)]:null;w.length>=2&&(!B||Math.random()<.01)&&(B="eraser");let q=!1;if(B==="hexagon"){let $=V.filter(D=>!this.isEdgeAdjacentToHexagonNode(t,D));if($.length>0){let D=$[Math.floor(Math.random()*$.length)];D.type==="h"?t.hEdges[D.r][D.c].type=3:t.vEdges[D.r][D.c].type=3,a++,q=!0}}else if(B==="square"&&w.length>=2){let $=w.pop();t.cells[$.y][$.x].type=1;let D=H.find(L=>t.cells[L.y][L.x].type===1),K=D?t.cells[D.y][D.x].color:void 0;t.cells[$.y][$.x].color=P.find(L=>L!==K)||O.Red,y++,q=!0}else if(B==="star"&&w.length>=2){let $=w.pop();t.cells[$.y][$.x].type=2,t.cells[$.y][$.x].color=P[Math.floor(Math.random()*P.length)],d++,q=!0}else if(B==="tetris"&&w.length>=2){let $=this.generateTiling(H,4,s),D=[];if($&&$.length>0){let K=0;for(let L of $){let J=this.getShapeArea(L.shape);if(K+J<H.length)D.push(L),K+=J;else break}}if(D.length===0&&H.length>1&&(D=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),D.length>0){for(let K of D){if(w.length<2)break;let L=w.pop();t.cells[L.y][L.x].type=K.isRotated?4:3,t.cells[L.y][L.x].shape=K.isRotated?K.displayShape:K.shape;let J=O.None;if(c&&Math.random()<.3){let it=P.filter(at=>at!==O.Blue);J=it[Math.floor(Math.random()*it.length)]}t.cells[L.y][L.x].color=J,m++}q=!0}}else if(B==="eraser"&&w.length>=2){let $=w.pop();t.cells[$.y][$.x].type=5,t.cells[$.y][$.x].color=M(5,O.White),x++,q=!0}if(!q&&w.length>=2){let $=w.pop();t.cells[$.y][$.x].type=5,t.cells[$.y][$.x].color=M(5,O.White),x++,q=!0}if(q){let $=w.pop();t.cells[$.y][$.x].type=5;let D=M(5,O.White);if(c&&Math.random()<.4){let K=P.filter(L=>L!==D);K.length>0&&(D=K[Math.floor(Math.random()*K.length)])}t.cells[$.y][$.x].color=D,x++}}}if(c){let F=Math.max(1,Math.floor(H.length/8));for(let G=0;G<F;G++)for(let W of P){if(w.length<1)break;if(Math.random()>.3+i*.4)continue;let V=H.filter(B=>t.cells[B.y][B.x].color===W).length;if(V===1){let B=w.pop();t.cells[B.y][B.x].type=2,t.cells[B.y][B.x].color=W,d++}else if(V===0&&w.length>=2)for(let B=0;B<2;B++){let q=w.pop();t.cells[q.y][q.x].type=2,t.cells[q.y][q.x].color=W,d++}}}}if(u&&!c&&S.size<2){for(let z of g)if(z.every(N=>t.cells[N.y][N.x].type===0)){let N=P.find(I=>!S.has(I))||O.White,H=z[Math.floor(Math.random()*z.length)];t.cells[H.y][H.x].type=1,t.cells[H.y][H.x].color=N,S.add(N),y++;break}}}}calculateRegions(t,e,s=[]){let n=[],h=t.rows,o=t.cols,i=new Uint8Array(h*o),f=new Uint8Array((h+1)*o),u=new Uint8Array(h*(o+1)),c=(r,l)=>{r.x===l.x?u[Math.min(r.y,l.y)*(o+1)+r.x]=1:f[r.y*o+Math.min(r.x,l.x)]=1};for(let r=0;r<e.length-1;r++)c(e[r],e[r+1]);for(let r=0;r<s.length-1;r++)c(s[r],s[r+1]);for(let r=0;r<=h;r++)for(let l=0;l<o;l++)t.hEdges[r][l].type===2&&(f[r*o+l]=1);for(let r=0;r<h;r++)for(let l=0;l<=o;l++)t.vEdges[r][l].type===2&&(u[r*(o+1)+l]=1);for(let r=0;r<h;r++)for(let l=0;l<o;l++){let a=r*o+l;if(i[a])continue;let y=[],d=[a];i[a]=1;let m=0;for(;m<d.length;){let x=d[m++],p=x%o,v=Math.floor(x/o);if(y.push({x:p,y:v}),v>0&&!f[v*o+p]){let g=(v-1)*o+p;i[g]||(i[g]=1,d.push(g))}if(v<h-1&&!f[(v+1)*o+p]){let g=(v+1)*o+p;i[g]||(i[g]=1,d.push(g))}if(p>0&&!u[v*(o+1)+p]){let g=v*o+(p-1);i[g]||(i[g]=1,d.push(g))}if(p<o-1&&!u[v*(o+1)+(p+1)]){let g=v*o+(p+1);i[g]||(i[g]=1,d.push(g))}}n.push(y)}return n}isAbsentEdge(t,e,s){if(e.x===s.x){let n=Math.min(e.y,s.y);return t.vEdges[n][e.x].type===2}else{let n=Math.min(e.x,s.x);return t.hEdges[e.y][n].type===2}}getRegionBoundaryEdges(t,e,s,n=[]){let h=new Set;for(let f=0;f<s.length-1;f++)h.add(this.getEdgeKey(s[f],s[f+1]));for(let f=0;f<n.length-1;f++)h.add(this.getEdgeKey(n[f],n[f+1]));let o=[];for(let f of e){let u=[{type:"h",r:f.y,c:f.x},{type:"h",r:f.y+1,c:f.x},{type:"v",r:f.y,c:f.x},{type:"v",r:f.y,c:f.x+1}];for(let c of u){let r=c.type==="h"?{x:c.c,y:c.r}:{x:c.c,y:c.r},l=c.type==="h"?{x:c.c+1,y:c.r}:{x:c.c,y:c.r+1},a=this.getEdgeKey(r,l);!h.has(a)&&!this.isAbsentEdge(t,r,l)&&o.push(c)}}let i=new Map;for(let f of o)i.set(`${f.type},${f.r},${f.c}`,f);return Array.from(i.values())}setEdgeHexagon(t,e,s,n=3){e.x===s.x?t.vEdges[Math.min(e.y,s.y)][e.x].type=n:t.hEdges[e.y][Math.min(e.x,s.x)].type=n}hasIncidentHexagonEdge(t,e){let s=n=>n===3||n===4||n===5;return!!(e.x>0&&s(t.hEdges[e.y][e.x-1].type)||e.x<t.cols&&s(t.hEdges[e.y][e.x].type)||e.y>0&&s(t.vEdges[e.y-1][e.x].type)||e.y<t.rows&&s(t.vEdges[e.y][e.x].type))}isEdgeAdjacentToHexagonNode(t,e){let s=n=>n===3||n===4||n===5;return e.type==="h"?s(t.nodes[e.r][e.c].type)||s(t.nodes[e.r][e.c+1].type):s(t.nodes[e.r][e.c].type)||s(t.nodes[e.r+1][e.c].type)}checkAllRequestedConstraintsPresent(t,e){let s=e.useHexagons??!0,n=e.useSquares??!0,h=e.useStars??!0,o=e.useTetris??!1,i=e.useEraser??!1;if(e.useBrokenEdges??!1){let u=!1;for(let c=0;c<=t.rows;c++)for(let r=0;r<t.cols;r++)if(t.hEdges[c][r].type===1||t.hEdges[c][r].type===2){u=!0;break}if(!u){for(let c=0;c<t.rows;c++)for(let r=0;r<=t.cols;r++)if(t.vEdges[c][r].type===1||t.vEdges[c][r].type===2){u=!0;break}}if(!u)return!1}if(s){let u=!1,c=l=>l===3||l===4||l===5,r=l=>l===3||l===4||l===5;for(let l=0;l<=t.rows;l++)for(let a=0;a<t.cols;a++)if(c(t.hEdges[l][a].type)){u=!0;break}if(!u){for(let l=0;l<t.rows;l++)for(let a=0;a<=t.cols;a++)if(c(t.vEdges[l][a].type)){u=!0;break}}if(!u){for(let l=0;l<=t.rows;l++)for(let a=0;a<=t.cols;a++)if(r(t.nodes[l][a].type)){u=!0;break}}if(!u)return!1}if(n||h||o||i){let u=!1,c=!1,r=!1,l=!1,a=new Set,y=new Set;for(let d=0;d<t.rows;d++)for(let m=0;m<t.cols;m++){let x=t.cells[d][m].type;x===1&&(u=!0,a.add(t.cells[d][m].color)),x===2&&(c=!0,y.add(t.cells[d][m].color)),(x===3||x===4)&&(r=!0),x===5&&(l=!0)}if(n&&!u||h&&!c||o&&!r||i&&!l)return!1;if(n&&u&&a.size<2){let d=a.values().next().value;if(d===void 0||!y.has(d))return!1}}return!this.hasIsolatedMark(t)}generateTiling(t,e,s){let n=Math.min(...t.map(r=>r.x)),h=Math.min(...t.map(r=>r.y)),o=Math.max(...t.map(r=>r.x)),i=Math.max(...t.map(r=>r.y)),f=o-n+1,u=i-h+1,c=Array.from({length:u},()=>Array(f).fill(!1));for(let r of t)c[r.y-h][r.x-n]=!0;return this.tilingDfs(c,[],e,s)}tilingDfs(t,e,s,n){let h=-1,o=-1;for(let u=0;u<t.length;u++){for(let c=0;c<t[0].length;c++)if(t[u][c]){h=u,o=c;break}if(h!==-1)break}if(h===-1)return e;if(e.length>=s)return null;let i=n.difficulty??.5,f=[...this.TETRIS_SHAPES];this.shuffleArray(f),i>.6&&f.sort((u,c)=>this.getShapeArea(c)-this.getShapeArea(u));for(let u of f){let c=this.isRotationallyInvariant(u),r=c?[u]:this.getAllRotations(u);this.shuffleArray(r);for(let l of r){let a=[];for(let y=0;y<l.length;y++)for(let d=0;d<l[0].length;d++)l[y][d]&&a.push({r:y,c:d});for(let y of a){let d=h-y.r,m=o-y.c;if(this.canPlace(t,l,d,m)){this.placePiece(t,l,d,m,!1);let x=this.tilingDfs(t,[...e,{shape:l,displayShape:u,isRotated:!c&&Math.random()<.3+i*.6}],s,n);if(x)return x;this.placePiece(t,l,d,m,!0)}}}}return null}getShapeArea(t){let e=0;for(let s of t)for(let n of s)n&&e++;return e}isRotationallyInvariant(t){let e=this.getShapeArea(t);return e===1||e===4&&t.length===2&&t[0].length===2}getAllRotations(t){let e=[],s=new Set,n=t;for(let h=0;h<4;h++){let o=JSON.stringify(n);s.has(o)||(e.push(n),s.add(o)),n=this.rotate90(n)}return e}rotate90(t){let e=t.length,s=t[0].length,n=Array.from({length:s},()=>Array(e).fill(0));for(let h=0;h<e;h++)for(let o=0;o<s;o++)n[o][e-1-h]=t[h][o];return n}canPlace(t,e,s,n){for(let h=0;h<e.length;h++)for(let o=0;o<e[0].length;o++)if(e[h][o]){let i=s+h,f=n+o;if(i<0||i>=t.length||f<0||f>=t[0].length||!t[i][f])return!1}return!0}placePiece(t,e,s,n,h){for(let o=0;o<e.length;o++)for(let i=0;i<e[0].length;i++)e[o][i]&&(t[s+o][n+i]=h)}shuffleArray(t){for(let e=t.length-1;e>0;e--){let s=Math.floor(Math.random()*(e+1));[t[e],t[s]]=[t[s],t[e]]}}};var et=class{bytes=[];cur=0;bit=0;write(t,e){for(let s=0;s<e;s++)t&1<<s&&(this.cur|=1<<this.bit),this.bit++,this.bit===8&&(this.bytes.push(this.cur),this.cur=0,this.bit=0)}finish(){return this.bit>0&&this.bytes.push(this.cur),new Uint8Array(this.bytes)}},nt=class{constructor(t){this.buf=t}i=0;bit=0;read(t){let e=0;for(let s=0;s<t;s++)this.buf[this.i]&1<<this.bit&&(e|=1<<s),this.bit++,this.bit===8&&(this.bit=0,this.i++);return e}};function ht(X){let t=new Map;for(let e of X)for(let s of e)if(s.shape){let n=JSON.stringify(s.shape);t.has(n)||t.set(n,s.shape)}return[...t.values()]}var st=class{static async serialize(t,e){let s=new et;s.write(t.rows,6),s.write(t.cols,6),s.write(t.symmetry??0,2);let n=ht(t.cells);s.write(n.length,5);for(let c of n){s.write(c.length,4),s.write(c[0].length,4);for(let r of c)for(let l of r)s.write(l,1)}let h=new Map;n.forEach((c,r)=>h.set(JSON.stringify(c),r));for(let c of t.cells)for(let r of c)s.write(r.type,3),s.write(r.color,3),r.shape?(s.write(1,1),s.write(h.get(JSON.stringify(r.shape)),5)):s.write(0,1);for(let c=0;c<t.rows;c++)for(let r=0;r<t.cols+1;r++)s.write(t.vEdges[c][r].type,3);for(let c=0;c<t.rows+1;c++)for(let r=0;r<t.cols;r++)s.write(t.hEdges[c][r].type,3);for(let c=0;c<t.rows+1;c++)for(let r=0;r<t.cols+1;r++)s.write(t.nodes[c][r].type,3);s.write(+!!e.useHexagons,1),s.write(+!!e.useSquares,1),s.write(+!!e.useStars,1),s.write(+!!e.useTetris,1),s.write(+!!e.useEraser,1),s.write(+!!e.useBrokenEdges,1),s.write(e.symmetry??0,2),s.write(Math.round((e.complexity??0)*254),8),s.write(Math.round((e.difficulty??0)*254),8),s.write(Math.round((e.pathLength??0)*254),8);let o=s.finish(),i=new Uint8Array(await new Response(new Blob([o.buffer]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()),f=0;for(let c of i)f^=c;let u=new Uint8Array(i.length+1);return u.set(i),u[i.length]=f,btoa(String.fromCharCode(...u)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}static async deserialize(t){let e=t.replace(/-/g,"+").replace(/_/g,"/");for(;e.length%4;)e+="=";let s=atob(e),n=Uint8Array.from(s,H=>H.charCodeAt(0)),h=0;for(let H=0;H<n.length-1;H++)h^=n[H];if(h!==n.at(-1))throw new Error("Invalid parity data");let o=new Uint8Array(await new Response(new Blob([n.slice(0,-1).buffer]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer()),i=new nt(o),f=i.read(6),u=i.read(6),c=i.read(2),r=i.read(5),l=[];for(let H=0;H<r;H++){let I=i.read(4),k=i.read(4),E=[];for(let w=0;w<I;w++){let R=[];for(let A=0;A<k;A++)R.push(i.read(1));E.push(R)}l.push(E)}let a=[];for(let H=0;H<f;H++){let I=[];for(let k=0;k<u;k++){let E=i.read(3),w=i.read(3),R=i.read(1),A={type:E,color:w};R&&(A.shape=l[i.read(5)].map(F=>F.slice())),I.push(A)}a.push(I)}let y=Array.from({length:f},()=>Array.from({length:u+1},()=>({type:i.read(3)}))),d=Array.from({length:f+1},()=>Array.from({length:u},()=>({type:i.read(3)}))),m=Array.from({length:f+1},()=>Array.from({length:u+1},()=>({type:i.read(3)}))),x=()=>{let H=i.read(8);return Math.round(H/254*1e3)/1e3},p={},v=!!i.read(1),g=!!i.read(1),P=!!i.read(1),b=!!i.read(1),M=!!i.read(1),C=!!i.read(1),S=i.read(2);v&&(p.useHexagons=!0),g&&(p.useSquares=!0),P&&(p.useStars=!0),b&&(p.useTetris=!0),M&&(p.useEraser=!0),C&&(p.useBrokenEdges=!0),p.symmetry=S;let T=x(),z=x(),N=x();return T!==0&&(p.complexity=T),z!==0&&(p.difficulty=z),N!==0&&(p.pathLength=N),{puzzle:{rows:f,cols:u,cells:a,vEdges:y,hEdges:d,nodes:m,symmetry:c},options:p}}};var ot=class{canvas;ctx;puzzle=null;options;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;invalidatedCells=[];invalidatedEdges=[];invalidatedNodes=[];errorCells=[];errorEdges=[];errorNodes=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;canvasRect=null;constructor(t,e,s={}){if(typeof t=="string"){if(typeof document>"u")throw new Error("Cannot look up canvas by ID in a non-browser environment.");let h=document.getElementById(t);if(!(h instanceof HTMLCanvasElement))throw new Error(`Element with id "${t}" is not a canvas.`);this.canvas=h}else this.canvas=t;let n=this.canvas.getContext("2d");if(!n)throw new Error("Could not get 2D context.");this.ctx=n,this.ctx.imageSmoothingEnabled=!1,this.options=this.mergeOptions(s),e&&this.setPuzzle(e),this.initEvents(),this.animate()}mergeOptions(t){let e={blinkDuration:t.animations?.blinkDuration??this.options?.animations?.blinkDuration??1e3,fadeDuration:t.animations?.fadeDuration??this.options?.animations?.fadeDuration??1e3,blinkPeriod:t.animations?.blinkPeriod??this.options?.animations?.blinkPeriod??800},s={path:t.colors?.path??this.options?.colors?.path??"#ffcc00",error:t.colors?.error??this.options?.colors?.error??"#ff4444",success:t.colors?.success??this.options?.colors?.success??"#ffcc00",symmetry:t.colors?.symmetry??this.options?.colors?.symmetry??"rgba(255, 255, 255, 0.5)",interrupted:t.colors?.interrupted??this.options?.colors?.interrupted??"#ffcc00",grid:t.colors?.grid??this.options?.colors?.grid??"#555",node:t.colors?.node??this.options?.colors?.node??"#555",hexagon:t.colors?.hexagon??this.options?.colors?.hexagon??"#000",hexagonMain:t.colors?.hexagonMain??this.options?.colors?.hexagonMain??"#00ffff",hexagonSymmetry:t.colors?.hexagonSymmetry??this.options?.colors?.hexagonSymmetry??"#ffff00",colorMap:t.colors?.colorMap??this.options?.colors?.colorMap??{[O.Black]:"#000",[O.White]:"#fff",[O.Red]:"#f00",[O.Blue]:"#00f",[O.None]:"#ffcc00"},colorList:t.colors?.colorList??this.options?.colors?.colorList};return{gridPadding:t.gridPadding??this.options?.gridPadding??60,cellSize:t.cellSize??this.options?.cellSize??80,nodeRadius:t.nodeRadius??this.options?.nodeRadius??6,startNodeRadius:t.startNodeRadius??this.options?.startNodeRadius??22,pathWidth:t.pathWidth??this.options?.pathWidth??18,exitLength:t.exitLength??this.options?.exitLength??25,autoResize:t.autoResize??this.options?.autoResize??!0,blinkMarksOnError:t.blinkMarksOnError??this.options?.blinkMarksOnError??!0,stayPathOnError:t.stayPathOnError??this.options?.stayPathOnError??!0,animations:e,colors:s,onPathComplete:t.onPathComplete??this.options?.onPathComplete??(()=>{})}}setPuzzle(t){this.puzzle=t,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw()}setOptions(t){this.options=this.mergeOptions({...this.options,...t}),this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}setValidationResult(t,e=[],s=[],n=[],h=[],o=[],i=[]){this.invalidatedCells=e,this.invalidatedEdges=s,this.invalidatedNodes=o,this.errorCells=n,this.errorEdges=h,this.errorNodes=i,this.eraserAnimationStartTime=Date.now(),t?(this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0}resizeCanvas(){!this.puzzle||!this.canvas||(this.canvas.width=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,this.canvas.height=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2)}setCanvasRect(t){this.canvasRect=t}initEvents(){typeof window>"u"||!(this.canvas instanceof HTMLCanvasElement)||(this.canvas.addEventListener("mousedown",t=>this.handleStart(t)),window.addEventListener("mousemove",t=>this.handleMove(t)),window.addEventListener("mouseup",t=>this.handleEnd(t)),this.canvas.addEventListener("touchstart",t=>{this.handleStart(t.touches[0])&&t.preventDefault()},{passive:!1}),window.addEventListener("touchmove",t=>{this.isDrawing&&t.preventDefault(),this.handleMove(t.touches[0])},{passive:!1}),window.addEventListener("touchend",t=>{this.isDrawing&&t.preventDefault(),this.handleEnd(t.changedTouches[0])},{passive:!1}))}getCanvasCoords(t,e){return{x:this.options.gridPadding+t*this.options.cellSize,y:this.options.gridPadding+e*this.options.cellSize}}getExitDir(t,e){return!this.puzzle||this.puzzle.nodes[e]?.[t]?.type!==2?null:t===this.puzzle.cols?{x:1,y:0}:t===0?{x:-1,y:0}:e===0?{x:0,y:-1}:e===this.puzzle.rows?{x:0,y:1}:{x:1,y:0}}handleStart(t){if(!this.puzzle)return!1;let e=this.canvasRect||(this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),s=(t.clientX-e.left)*(this.canvas.width/e.width),n=(t.clientY-e.top)*(this.canvas.height/e.height);for(let h=0;h<=this.puzzle.rows;h++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[h][o].type===1){let i=this.getCanvasCoords(o,h);if(Math.hypot(i.x-s,i.y-n)<this.options.startNodeRadius)return this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.isDrawing=!0,this.path=[{x:o,y:h}],this.currentMousePos=i,this.exitTipPos=null,this.draw(),!0}return!1}handleMove(t){if(!this.puzzle||!this.isDrawing)return;let e=this.canvasRect||(this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),s=(t.clientX-e.left)*(this.canvas.width/e.width),n=(t.clientY-e.top)*(this.canvas.height/e.height),h=this.path[this.path.length-1],o=this.getCanvasCoords(h.x,h.y),i=s-o.x,f=n-o.y,u=this.puzzle.symmetry||0,c=this.getExitDir(h.x,h.y),r=Math.abs(i)>Math.abs(f)?{x:i>0?1:-1,y:0}:{x:0,y:f>0?1:-1};if(c&&r.x===c.x&&r.y===c.y){let d=i*c.x+f*c.y,m=Math.max(0,Math.min(d,this.options.exitLength));this.currentMousePos={x:o.x+c.x*m,y:o.y+c.y*m},this.draw();return}let l=(d,m)=>{let x=this.getEdgeType(h,d);if(d.x<0||d.x>this.puzzle.cols||d.y<0||d.y>this.puzzle.rows||x===2){this.currentMousePos=o;return}let p=x===1?this.options.cellSize*.35:this.options.cellSize,v=this.getEdgeKey(h,d);if(!(this.path.length>=2&&d.x===this.path[this.path.length-2].x&&d.y===this.path[this.path.length-2].y)){for(let b=0;b<this.path.length-1;b++)if(this.getEdgeKey(this.path[b],this.path[b+1])===v){p=0;break}}if(this.path.some(b=>b.x===d.x&&b.y===d.y)&&this.path.length>=2){let b=this.path[this.path.length-2];(d.x!==b.x||d.y!==b.y)&&(p=Math.min(p,this.options.cellSize*.5-this.options.pathWidth*.5))}if(u!==0){let b=this.getSymmetricalPoint(h),M=this.getSymmetricalPoint(d),C=this.getEdgeType(b,M),S=this.getSymmetryPath(this.path),T=this.getEdgeKey(b,M);if(M.x<0||M.x>this.puzzle.cols||M.y<0||M.y>this.puzzle.rows||C===2){this.currentMousePos=o;return}C===1&&(p=Math.min(p,this.options.cellSize*.35));let z=S.some(w=>w.x===d.x&&w.y===d.y),N=this.path.some(w=>w.x===M.x&&w.y===M.y),H=d.x===M.x&&d.y===M.y,I=S.some((w,R)=>R<S.length-1&&this.getEdgeKey(S[R],S[R+1])===v),k=this.path.some((w,R)=>R<this.path.length-1&&this.getEdgeKey(this.path[R],this.path[R+1])===T);(z||N||H||I||k||v===T)&&(p=Math.min(p,this.options.cellSize*.5-this.options.pathWidth*.5))}d.x!==h.x?this.currentMousePos={x:o.x+Math.max(-p,Math.min(p,m)),y:o.y}:this.currentMousePos={x:o.x,y:o.y+Math.max(-p,Math.min(p,m))}};if(Math.abs(i)>Math.abs(f)){let d=i>0?1:-1;l({x:h.x+d,y:h.y},i)}else{let d=f>0?1:-1;l({x:h.x,y:h.y+d},f)}let a=[{x:h.x+1,y:h.y},{x:h.x-1,y:h.y},{x:h.x,y:h.y+1},{x:h.x,y:h.y-1}],y=this.getSymmetryPath(this.path);for(let d of a)if(d.x>=0&&d.x<=this.puzzle.cols&&d.y>=0&&d.y<=this.puzzle.rows){let m=this.getCanvasCoords(d.x,d.y);if(Math.hypot(m.x-this.currentMousePos.x,m.y-this.currentMousePos.y)<this.options.cellSize*.3){let p=this.path.findIndex(v=>v.x===d.x&&v.y===d.y);if(p===-1){if(u!==0){let v=this.getSymmetricalPoint(d);if(d.x===v.x&&d.y===v.y||this.path.some(b=>b.x===v.x&&b.y===v.y)||y.some(b=>b.x===d.x&&b.y===d.y))continue;let g=this.getEdgeKey(h,d),P=this.getEdgeKey(this.getSymmetricalPoint(h),v);if(g===P)continue}this.path.push(d)}else p===this.path.length-2&&this.path.pop()}}this.draw()}handleEnd(t){if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let e=this.path[this.path.length-1],s=this.getCanvasCoords(e.x,e.y),n=this.getExitDir(e.x,e.y);if(n){let h=this.currentMousePos.x-s.x,o=this.currentMousePos.y-s.y;if(h*n.x+o*n.y>0){this.exitTipPos={x:s.x+n.x*this.options.exitLength,y:s.y+n.y*this.options.exitLength},this.options.onPathComplete(this.path);return}}this.exitTipPos=n?{...this.currentMousePos}:null,this.startFade(this.options.colors.interrupted)}getEdgeType(t,e){if(!this.puzzle)return 2;if(t.x===e.x){let s=Math.min(t.y,e.y);return s<0||s>=this.puzzle.rows?2:this.puzzle.vEdges[s][t.x].type}else{let s=Math.min(t.x,e.x);return s<0||s>=this.puzzle.cols?2:this.puzzle.hEdges[t.y][s].type}}startFade(t="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=t,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){let t=Date.now();if(this.isFading){let e=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=e,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0)}this.isInvalidPath&&!this.options.stayPathOnError&&!this.isFading&&this.path.length>0&&t-this.eraserAnimationStartTime>=this.options.animations.blinkDuration&&this.startFade(this.options.colors.error),this.draw(),typeof requestAnimationFrame<"u"&&requestAnimationFrame(()=>this.animate())}draw(){if(!this.puzzle||!this.ctx)return;let t=this.ctx,e=Date.now();if(t.globalAlpha=1,t.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(t),this.drawConstraints(t),this.drawNodes(t),this.path.length===0&&!this.isDrawing&&this.drawRipples(t),this.isFading){if(this.drawPath(t,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let s=this.getSymmetryPath(this.fadingPath),n=this.options.colors.symmetry,h=null;if(this.fadingTipPos){let o=(this.fadingTipPos.x-this.options.gridPadding)/this.options.cellSize,i=(this.fadingTipPos.y-this.options.gridPadding)/this.options.cellSize,f=this.getSymmetricalPoint({x:o,y:i});h={x:f.x*this.options.cellSize+this.options.gridPadding,y:f.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(t,s,!1,n,this.fadeOpacity,h)}}else if(this.path.length>0){let s=this.options.colors.path,n=this.colorToRgba(s).a,h=this.options.colors.error,o=this.isInvalidPath?this.setAlpha(h,n):s;if(this.isSuccessFading&&!this.puzzle.symmetry&&(o=this.setAlpha(this.options.colors.success,n)),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let i=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),f=this.options.animations.blinkDuration;if(i<f){if(this.isSuccessFading)(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(o=this.options.colors.error);else if(this.options.blinkMarksOnError){let u=Math.min(1,i/200),c=i>f*.8?(f-i)/(f*.2):1,r=Math.min(u,c),l=(Math.sin(e*Math.PI*2/this.options.animations.blinkPeriod)+1)/2,a=this.setAlpha(h,n);o=this.lerpColor(s,a,l*r)}}}else if(this.isInvalidPath&&!this.isDrawing&&!this.options.stayPathOnError){let i=e-this.eraserAnimationStartTime,f=this.options.animations.blinkDuration;if(i<f&&this.options.blinkMarksOnError){let u=Math.min(1,i/200),c=i>f*.8?(f-i)/(f*.2):1,r=Math.min(u,c),l=(Math.sin(e*Math.PI*2/this.options.animations.blinkPeriod)+1)/2,a=this.setAlpha(h,n);o=this.lerpColor(s,a,l*r)}}if(this.drawPath(t,this.path,this.isDrawing,o,1,this.isDrawing?this.currentMousePos:this.exitTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let i=this.getSymmetryPath(this.path),f=this.options.colors.symmetry,u=this.colorToRgba(f).a,c=f;if(this.isInvalidPath&&(c=this.setAlpha(h,u)),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let l=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),a=this.options.animations.blinkDuration;if(l<a){if(this.isSuccessFading)(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(c=this.options.colors.error);else if(this.options.blinkMarksOnError){let y=Math.min(1,l/200),d=l>a*.8?(a-l)/(a*.2):1,m=Math.min(y,d),x=(Math.sin(e*Math.PI*2/this.options.animations.blinkPeriod)+1)/2,p=this.setAlpha(h,u);c=this.lerpColor(f,p,x*m)}}}else if(this.isInvalidPath&&!this.isDrawing&&!this.options.stayPathOnError){let l=e-this.eraserAnimationStartTime,a=this.options.animations.blinkDuration;if(l<a&&this.options.blinkMarksOnError){let y=Math.min(1,l/200),d=l>a*.8?(a-l)/(a*.2):1,m=Math.min(y,d),x=(Math.sin(e*Math.PI*2/this.options.animations.blinkPeriod)+1)/2,p=this.setAlpha(h,u);c=this.lerpColor(f,p,x*m)}}let r=null;if(this.isDrawing||this.exitTipPos){let l=this.isDrawing?this.currentMousePos:this.exitTipPos,a=(l.x-this.options.gridPadding)/this.options.cellSize,y=(l.y-this.options.gridPadding)/this.options.cellSize,d=this.getSymmetricalPoint({x:a,y},!0);r={x:d.x*this.options.cellSize+this.options.gridPadding,y:d.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(t,i,this.isDrawing,c,1,r)}}}drawRipples(t){if(!this.puzzle)return;let e=(Date.now()-this.startTime)/500;for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++)if(this.puzzle.nodes[s][n].type===2){let o=this.getCanvasCoords(n,s),i=this.getExitDir(n,s);if(!i)continue;let f={x:o.x+i.x*this.options.exitLength,y:o.y+i.y*this.options.exitLength},u=e%4,c=u*5,r=Math.max(0,1-u/3);t.beginPath(),t.arc(f.x,f.y,c,0,Math.PI*2),t.strokeStyle=`rgba(170, 170, 170, ${r*.4})`,t.lineWidth=2,t.stroke()}}drawGrid(t){if(!this.puzzle||!this.options.colors.grid)return;t.strokeStyle=this.options.colors.grid,t.lineWidth=12,t.lineCap="round";let e=(s,n,h)=>{if(h!==2)if(h===1){let i={x:s.x+(n.x-s.x)*.35,y:s.y+(n.y-s.y)*.35},f={x:s.x+(n.x-s.x)*(.5+.15),y:s.y+(n.y-s.y)*(.5+.15)};t.beginPath(),t.moveTo(s.x,s.y),t.lineTo(i.x,i.y),t.stroke(),t.beginPath(),t.moveTo(f.x,f.y),t.lineTo(n.x,n.y),t.stroke()}else t.beginPath(),t.moveTo(s.x,s.y),t.lineTo(n.x,n.y),t.stroke()};for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<this.puzzle.cols;n++)e(this.getCanvasCoords(n,s),this.getCanvasCoords(n+1,s),this.puzzle.hEdges[s][n].type);for(let s=0;s<this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++)e(this.getCanvasCoords(n,s),this.getCanvasCoords(n,s+1),this.puzzle.vEdges[s][n].type)}drawConstraints(t){if(!this.puzzle)return;let e=Date.now(),s=(Math.sin(e*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;for(let o=0;o<this.puzzle.rows;o++)for(let i=0;i<this.puzzle.cols;i++){let f=this.puzzle.cells[o][i],u=this.getCanvasCoords(i+.5,o+.5),c=this.invalidatedCells.some(m=>m.x===i&&m.y===o),r=this.errorCells.some(m=>m.x===i&&m.y===o),l=1,a,y=this.getColorCode(f.color),d=this.options.colors.error;if(r&&this.options.blinkMarksOnError&&(a=this.lerpColor(y,d,s)),c){let m=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),x=this.options.animations.blinkDuration;if(m<x){if(this.options.blinkMarksOnError){let p=Math.min(1,m/200),v=m>x*.8?(x-m)/(x*.2):1,g=Math.min(p,v);a=this.lerpColor(y,d,s*g)}}else l=Math.max(.3,1-(m-x)/this.options.animations.fadeDuration)}if(l<1||a){let{canvas:m,ctx:x}=this.prepareOffscreen();this.drawConstraintItem(x,f,u,a),t.save(),t.globalAlpha=l,t.drawImage(m,0,0),t.restore()}else this.drawConstraintItem(t,f,u)}t.lineWidth=2;let n=8,h=o=>o===3||o===3?this.options.colors.hexagon:o===4||o===4?this.options.colors.hexagonMain:o===5||o===5?this.options.colors.hexagonSymmetry:this.options.colors.hexagon;for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<this.puzzle.cols;i++){let f=this.puzzle.hEdges[o][i].type;if(f===3||f===4||f===5){let u=this.getCanvasCoords(i+.5,o);t.save();let c=this.invalidatedEdges.some(a=>a.type==="h"&&a.r===o&&a.c===i),r=this.errorEdges.some(a=>a.type==="h"&&a.r===o&&a.c===i),l=h(f);if(r&&this.options.blinkMarksOnError){let a=this.lerpColor(l,this.options.colors.error,s);this.drawHexagon(t,u.x,u.y,n,a)}else if(c){let a=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),y=this.options.animations.blinkDuration;if(a<y)if(this.options.blinkMarksOnError){let d=Math.min(1,a/200),m=a>y*.8?(y-a)/(y*.2):1,x=Math.min(d,m),p=this.lerpColor(l,this.options.colors.error,s*x);this.drawHexagon(t,u.x,u.y,n,p)}else this.drawHexagon(t,u.x,u.y,n,l);else t.globalAlpha*=Math.max(.3,1-(a-y)/this.options.animations.fadeDuration),this.drawHexagon(t,u.x,u.y,n,l)}else this.drawHexagon(t,u.x,u.y,n,l);t.restore()}}for(let o=0;o<this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++){let f=this.puzzle.vEdges[o][i].type;if(f===3||f===4||f===5){let u=this.getCanvasCoords(i,o+.5);t.save();let c=this.invalidatedEdges.some(a=>a.type==="v"&&a.r===o&&a.c===i),r=this.errorEdges.some(a=>a.type==="v"&&a.r===o&&a.c===i),l=h(f);if(r&&this.options.blinkMarksOnError){let a=this.lerpColor(l,this.options.colors.error,s);this.drawHexagon(t,u.x,u.y,n,a)}else if(c){let a=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),y=this.options.animations.blinkDuration;if(a<y)if(this.options.blinkMarksOnError){let d=Math.min(1,a/200),m=a>y*.8?(y-a)/(y*.2):1,x=Math.min(d,m),p=this.lerpColor(l,this.options.colors.error,s*x);this.drawHexagon(t,u.x,u.y,n,p)}else this.drawHexagon(t,u.x,u.y,n,l);else t.globalAlpha*=Math.max(.3,1-(a-y)/this.options.animations.fadeDuration),this.drawHexagon(t,u.x,u.y,n,l)}else this.drawHexagon(t,u.x,u.y,n,l);t.restore()}}for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++){let f=this.puzzle.nodes[o][i].type;if(f===3||f===4||f===5){let u=this.getCanvasCoords(i,o);t.save();let c=this.invalidatedNodes.some(a=>a.x===i&&a.y===o),r=this.errorNodes.some(a=>a.x===i&&a.y===o),l=h(f);if(r&&this.options.blinkMarksOnError){let a=this.lerpColor(l,this.options.colors.error,s);this.drawHexagon(t,u.x,u.y,n,a)}else if(c){let a=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),y=this.options.animations.blinkDuration;if(a<y)if(this.options.blinkMarksOnError){let d=Math.min(1,a/200),m=a>y*.8?(y-a)/(y*.2):1,x=Math.min(d,m),p=this.lerpColor(l,this.options.colors.error,s*x);this.drawHexagon(t,u.x,u.y,n,p)}else this.drawHexagon(t,u.x,u.y,n,l);else t.globalAlpha*=Math.max(.3,1-(a-y)/this.options.animations.fadeDuration),this.drawHexagon(t,u.x,u.y,n,l)}else this.drawHexagon(t,u.x,u.y,n,l);t.restore()}}}drawConstraintItem(t,e,s,n){e.type===1?(t.fillStyle=n||this.getColorCode(e.color),this.drawRoundedRect(t,s.x-26/2,s.y-26/2,26,26,8)):e.type===2?this.drawStar(t,s.x,s.y,12,16,8,e.color,n):e.type===3||e.type===4?this.drawTetris(t,s.x,s.y,e.shape||[],e.type===4,e.color,n):e.type===5&&this.drawEraser(t,s.x,s.y,14,3,e.color,n)}drawNodes(t){if(!this.puzzle)return;let e=(s,n)=>{let h=[];return s>0&&h.push(this.puzzle.hEdges[n][s-1].type),s<this.puzzle.cols&&h.push(this.puzzle.hEdges[n][s].type),n>0&&h.push(this.puzzle.vEdges[n-1][s].type),n<this.puzzle.rows&&h.push(this.puzzle.vEdges[n][s].type),h.length>0&&h.every(o=>o===2)};for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++){if(e(n,s))continue;let h=this.puzzle.nodes[s][n];if(h.type===3||h.type===4||h.type===5)continue;let o=this.getCanvasCoords(n,s);if(h.type===1)this.options.colors.node&&(t.fillStyle=this.options.colors.node),t.beginPath(),t.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),t.fill();else if(h.type===2){let i=this.getExitDir(n,s);if(!i)continue;this.options.colors.node&&(t.strokeStyle=this.options.colors.node),t.lineWidth=12,t.lineCap="round",t.beginPath(),t.moveTo(o.x,o.y),t.lineTo(o.x+i.x*this.options.exitLength,o.y+i.y*this.options.exitLength),t.stroke()}else this.options.colors.node&&(t.fillStyle=this.options.colors.node),t.beginPath(),t.arc(o.x,o.y,this.options.nodeRadius,0,Math.PI*2),t.fill()}}drawPath(t,e,s,n,h,o=null){if(e.length===0||!n||n==="transparent")return;let i=this.colorToRgba(n),f=`rgb(${i.r},${i.g},${i.b})`,u=h*i.a,{canvas:c,ctx:r}=this.prepareOffscreen();this.drawPathInternal(r,e,s,f,o),t.save(),t.globalAlpha=u,t.drawImage(c,0,0),t.restore()}drawPathInternal(t,e,s,n,h=null){t.save(),t.strokeStyle=n,t.fillStyle=n,t.lineWidth=this.options.pathWidth,t.lineCap="round",t.lineJoin="round",t.beginPath();let o=this.getCanvasCoords(e[0].x,e[0].y);t.moveTo(o.x,o.y);for(let f=1;f<e.length;f++){let u=this.getCanvasCoords(e[f].x,e[f].y);t.lineTo(u.x,u.y)}let i=h||this.currentMousePos;(s||h)&&t.lineTo(i.x,i.y),t.stroke(),t.beginPath(),t.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),t.fill(),(s||h)&&(t.beginPath(),t.arc(i.x,i.y,this.options.pathWidth/2,0,Math.PI*2),t.fill()),t.restore()}drawRoundedRect(t,e,s,n,h,o){t.beginPath(),t.moveTo(e+o,s),t.lineTo(e+n-o,s),t.quadraticCurveTo(e+n,s,e+n,s+o),t.lineTo(e+n,s+h-o),t.quadraticCurveTo(e+n,s+h,e+n-o,s+h),t.lineTo(e+o,s+h),t.quadraticCurveTo(e,s+h,e,s+h-o),t.lineTo(e,s+o),t.quadraticCurveTo(e,s,e+o,s),t.closePath(),t.fill()}drawHexagon(t,e,s,n,h){if(!(!this.options.colors.hexagon&&!h)){t.fillStyle=h||this.options.colors.hexagon,t.beginPath();for(let o=0;o<6;o++){let i=Math.PI/3*o,f=e+n*Math.cos(i),u=s+n*Math.sin(i);o===0?t.moveTo(f,u):t.lineTo(f,u)}t.closePath(),t.fill()}}drawEraser(t,e,s,n,h,o,i){t.strokeStyle=i||this.getColorCode(o),t.lineWidth=n*.5,t.lineCap="butt";let f=.5;t.beginPath();for(let u=0;u<h;u++){let c=Math.PI*2/h*u+f,r=e+n*Math.cos(c),l=s+n*Math.sin(c);t.moveTo(e,s),t.lineTo(r,l)}t.stroke()}drawStar(t,e,s,n,h,o,i,f){t.fillStyle=f||this.getColorCode(i),t.beginPath();for(let u=0;u<o*2;u++){let c=u%2===0?h:n,r=Math.PI/o*u,l=e+c*Math.cos(r),a=s+c*Math.sin(r);u===0?t.moveTo(l,a):t.lineTo(l,a)}t.closePath(),t.fill()}drawTetris(t,e,s,n,h,o,i){if(!n||n.length===0)return;let f=12,u=2,c=n[0].length*f+(n[0].length-1)*u,r=n.length*f+(n.length-1)*u;t.save(),t.translate(e,s),h&&t.rotate(Math.PI/8),t.fillStyle=i||this.getColorCode(o,"#ffcc00");for(let l=0;l<n.length;l++)for(let a=0;a<n[l].length;a++)if(n[l][a]){let y=a*(f+u)-c/2,d=l*(f+u)-r/2;t.fillRect(y,d,f,f)}t.restore()}getColorCode(t,e="#666"){return this.options.colors.colorList&&this.options.colors.colorList[t]!==void 0?this.options.colors.colorList[t]:this.options.colors.colorMap&&this.options.colors.colorMap[t]!==void 0?this.options.colors.colorMap[t]:e}colorToRgba(t){if(!t||t==="transparent")return{r:0,g:0,b:0,a:0};if(t.startsWith("rgba")||t.startsWith("rgb")){let s=t.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);if(s)return{r:parseInt(s[1]),g:parseInt(s[2]),b:parseInt(s[3]),a:s[4]?parseFloat(s[4]):1}}let e=t.startsWith("#")?t.slice(1):t;if((e.length===3||e.length===4)&&(e=e.split("").map(s=>s+s).join("")),e.length===6){let s=parseInt(e,16);return{r:s>>16&255,g:s>>8&255,b:s&255,a:1}}else if(e.length===8){let s=parseInt(e,16);return{r:s>>24&255,g:s>>16&255,b:s>>8&255,a:(s&255)/255}}return{r:0,g:0,b:0,a:1}}lerpColor(t,e,s){try{let n=this.colorToRgba(t),h=this.colorToRgba(e),o=Math.round(n.r+(h.r-n.r)*s),i=Math.round(n.g+(h.g-n.g)*s),f=Math.round(n.b+(h.b-n.b)*s),u=n.a+(h.a-n.a)*s;return`rgba(${o},${i},${f},${u})`}catch{return t}}setAlpha(t,e){let s=this.colorToRgba(t);return`rgba(${s.r},${s.g},${s.b},${e})`}getSymmetryPath(t){return!this.puzzle||!this.puzzle.symmetry?[]:t.map(e=>this.getSymmetricalPoint(e))}getSymmetricalPoint(t,e=!1){if(!this.puzzle||!this.puzzle.symmetry)return{...t};let{cols:s,rows:n,symmetry:h}=this.puzzle;return h===1?{x:s-t.x,y:t.y}:h===2?{x:t.x,y:n-t.y}:h===3?{x:s-t.x,y:n-t.y}:{...t}}getEdgeKey(t,e){return t.x<e.x||t.x===e.x&&t.y<e.y?`${t.x},${t.y}-${e.x},${e.y}`:`${e.x},${e.y}-${t.x},${t.y}`}prepareOffscreen(){if(!this.offscreenCanvas){if(typeof document<"u")this.offscreenCanvas=document.createElement("canvas");else if(typeof OffscreenCanvas<"u")this.offscreenCanvas=new OffscreenCanvas(this.canvas.width,this.canvas.height);else throw new Error("Offscreen canvas not supported in this environment.");this.offscreenCtx=this.offscreenCanvas.getContext("2d")}if((this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),!this.offscreenCtx)throw new Error("Could not get offscreen 2D context.");return this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx}}};var rt=class{generator;validator;constructor(){this.generator=new Z,this.validator=new Y}createPuzzle(t,e,s={}){return this.generator.generate(t,e,s).export()}validateSolution(t,e){let s=U.fromData(t);return this.validator.validate(s,e)}calculateDifficulty(t){let e=U.fromData(t);return this.validator.calculateDifficulty(e)}};export{j as CellType,O as Color,lt as Direction,_ as EdgeType,U as Grid,Q as NodeType,Z as PuzzleGenerator,st as PuzzleSerializer,Y as PuzzleValidator,tt as SymmetryType,rt as WitnessCore,ot as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
