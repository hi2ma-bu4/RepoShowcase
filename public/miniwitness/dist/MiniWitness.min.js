/*!
 * MiniWitness 1.2.5
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var le=(n=>(n[n.Up=0]="Up",n[n.Right=1]="Right",n[n.Down=2]="Down",n[n.Left=3]="Left",n))(le||{}),j=(o=>(o[o.None=0]="None",o[o.Square=1]="Square",o[o.Star=2]="Star",o[o.Tetris=3]="Tetris",o[o.TetrisRotated=4]="TetrisRotated",o[o.Eraser=5]="Eraser",o))(j||{}),_=(o=>(o[o.Normal=0]="Normal",o[o.Broken=1]="Broken",o[o.Absent=2]="Absent",o[o.Hexagon=3]="Hexagon",o[o.HexagonMain=4]="HexagonMain",o[o.HexagonSymmetry=5]="HexagonSymmetry",o))(_||{}),Q=(o=>(o[o.Normal=0]="Normal",o[o.Start=1]="Start",o[o.End=2]="End",o[o.Hexagon=3]="Hexagon",o[o.HexagonMain=4]="HexagonMain",o[o.HexagonSymmetry=5]="HexagonSymmetry",o))(Q||{}),ee=(n=>(n[n.None=0]="None",n[n.Horizontal=1]="Horizontal",n[n.Vertical=2]="Vertical",n[n.Rotational=3]="Rotational",n))(ee||{}),O={None:0,Black:1,White:2,Red:3,Blue:4};var U=class X{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];symmetry=0;constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:O.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes,symmetry:this.symmetry}))}static fromData(e){let t=new X(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t.symmetry=e.symmetry||0,t}};var Y=class{validate(e,t,s){let n=t.points;if(n.length<2)return{isValid:!1,errorReason:"Path too short"};let a=e.symmetry||0,o=[];if(a!==0)for(let y of n)o.push(this.getSymmetricalPoint(e,y));let r=n[0],u=n[n.length-1];if(e.nodes[r.y][r.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[u.y][u.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};if(a!==0){let y=o[0],d=o[o.length-1];if(e.nodes[y.y][y.x].type!==1)return{isValid:!1,errorReason:"Symmetrical path must start at Start Node"};if(e.nodes[d.y][d.x].type!==2)return{isValid:!1,errorReason:"Symmetrical path must end at End Node"}}let f=new Set,c=new Set;if(f.add(`${r.x},${r.y}`),a!==0){let y=o[0];if(f.has(`${y.x},${y.y}`))return{isValid:!1,errorReason:"Paths collide at start"};f.add(`${y.x},${y.y}`)}for(let y=0;y<n.length-1;y++){let d=n[y],m=n[y+1];if(Math.abs(d.x-m.x)+Math.abs(d.y-m.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let p=`${m.x},${m.y}`;if(f.has(p))return{isValid:!1,errorReason:"Self-intersecting path or path collision"};if(f.add(p),this.isBrokenEdge(e,d,m))return{isValid:!1,errorReason:"Passed through broken edge"};if(c.add(this.getEdgeKey(d,m)),a!==0){let v=o[y],g=o[y+1],P=`${g.x},${g.y}`;if(f.has(P))return{isValid:!1,errorReason:"Path collision"};if(f.add(P),this.isBrokenEdge(e,v,g))return{isValid:!1,errorReason:"Symmetrical path passed through broken edge"};let b=this.getEdgeKey(v,g);if(c.has(b))return{isValid:!1,errorReason:"Paths cross the same edge"};c.add(b)}}let i=this.calculateRegions(e,n,o,s),h=this.getMissedHexagons(e,n,o),l=this.validateWithErasers(e,i,h.edges,h.nodes);return l.regions=i,l}validateFast(e,t,s,n){let a=this.calculateRegions(e,t,s,n),o=this.getMissedHexagons(e,t,s);return this.validateWithErasers(e,a,o.edges,o.nodes)}isBrokenEdge(e,t,s){let n;if(t.x===s.x){let a=Math.min(t.y,s.y);n=e.vEdges[a][t.x].type}else{let a=Math.min(t.x,s.x);n=e.hEdges[t.y][a].type}return n===1||n===2}isAbsentEdge(e,t,s){if(t.x===s.x){let n=Math.min(t.y,s.y);return e.vEdges[n][t.x].type===2}else{let n=Math.min(t.x,s.x);return e.hEdges[t.y][n].type===2}}getMissedHexagons(e,t,s=[]){let n=new Set,a=new Set;for(let c=0;c<t.length;c++)a.add(`${t[c].x},${t[c].y}`),c<t.length-1&&n.add(this.getEdgeKey(t[c],t[c+1]));let o=new Set,r=new Set;for(let c=0;c<s.length;c++)r.add(`${s[c].x},${s[c].y}`),c<s.length-1&&o.add(this.getEdgeKey(s[c],s[c+1]));let u=[];for(let c=0;c<=e.rows;c++)for(let i=0;i<e.cols;i++){let h=e.hEdges[c][i].type;if(h===3||h===4||h===5){let l=this.getEdgeKey({x:i,y:c},{x:i+1,y:c}),y=!1;h===3?y=n.has(l)||o.has(l):h===4?y=n.has(l):h===5&&(y=o.has(l)),y||u.push({type:"h",r:c,c:i})}}for(let c=0;c<e.rows;c++)for(let i=0;i<=e.cols;i++){let h=e.vEdges[c][i].type;if(h===3||h===4||h===5){let l=this.getEdgeKey({x:i,y:c},{x:i,y:c+1}),y=!1;h===3?y=n.has(l)||o.has(l):h===4?y=n.has(l):h===5&&(y=o.has(l)),y||u.push({type:"v",r:c,c:i})}}let f=[];for(let c=0;c<=e.rows;c++)for(let i=0;i<=e.cols;i++){let h=e.nodes[c][i].type;if(h===3||h===4||h===5){let l=`${i},${c}`,y=!1;h===3?y=a.has(l)||r.has(l):h===4?y=a.has(l):h===5&&(y=r.has(l)),y||f.push({x:i,y:c})}}return{edges:u,nodes:f}}validateWithErasers(e,t,s,n){let a=[],o=!0;for(let l=0;l<t.length;l++){let y=t[l],d=y.filter(g=>e.cells[g.y][g.x].type===5),m=y.filter(g=>e.cells[g.y][g.x].type!==0&&e.cells[g.y][g.x].type!==5),x=[];for(let g=0;g<s.length;g++)this.isHexagonAdjacentToRegion(e,s[g],y)&&x.push(g);let p=[];for(let g=0;g<n.length;g++)this.isNodeHexagonAdjacentToRegion(e,n[g],y)&&p.push(g);let v=this.getPossibleErasures(e,y,d,m,x,p);if(v.length===0){o=!1;let g=this.getBestEffortErasures(e,y,d,m,x,p);a.push([g])}else v.sort((g,P)=>{let b=g.invalidatedCells.length+g.invalidatedHexagons.length+g.invalidatedNodeHexagons.length,M=P.invalidatedCells.length+P.invalidatedHexagons.length+P.invalidatedNodeHexagons.length;return b-M}),a.push(v)}if(o){let l=this.findGlobalAssignment(a,s.length,n.length);if(l)return{isValid:!0,invalidatedCells:l.invalidatedCells,invalidatedEdges:l.invalidatedHexIndices.map(y=>s[y]),invalidatedNodes:l.invalidatedNodeHexIndices.map(y=>n[y])}}let r=[],u=[],f=new Set,c=new Set;for(let l of a){let y=l[0];r.push(...y.errorCells),u.push(...y.invalidatedCells);for(let d of y.invalidatedHexagons)f.add(d);for(let d of y.invalidatedNodeHexagons)c.add(d)}let i=[];for(let l=0;l<s.length;l++)f.has(l)||i.push(s[l]);let h=[];for(let l=0;l<n.length;l++)c.has(l)||h.push(n[l]);return{isValid:!1,errorReason:"Constraints failed",errorCells:r,errorEdges:i,errorNodes:h,invalidatedCells:u,invalidatedEdges:Array.from(f).map(l=>s[l]),invalidatedNodes:Array.from(c).map(l=>n[l])}}isHexagonAdjacentToRegion(e,t,s){let n=new Set(s.map(a=>`${a.x},${a.y}`));if(t.type==="h"){if(t.r>0&&n.has(`${t.c},${t.r-1}`)||t.r<e.rows&&n.has(`${t.c},${t.r}`))return!0}else if(t.c>0&&n.has(`${t.c-1},${t.r}`)||t.c<e.cols&&n.has(`${t.c},${t.r}`))return!0;return!1}isNodeHexagonAdjacentToRegion(e,t,s){let n=new Set(s.map(o=>`${o.x},${o.y}`)),a=[{x:t.x-1,y:t.y-1},{x:t.x,y:t.y-1},{x:t.x-1,y:t.y},{x:t.x,y:t.y}];for(let o of a)if(o.x>=0&&o.x<e.cols&&o.y>=0&&o.y<e.rows&&n.has(`${o.x},${o.y}`))return!0;return!1}getPossibleErasures(e,t,s,n,a,o){let r=[],u=s.length;if(u===0)return this.getRegionErrors(e,t,[]).length===0&&a.length===0&&o.length===0&&r.push({invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!0,errorCells:[]}),r;let f=[...n.map(i=>({type:"cell",pos:i})),...a.map(i=>({type:"hex",index:i})),...o.map(i=>({type:"nodeHex",index:i}))],c=this.getRegionErrors(e,t,[]).length===0&&a.length===0&&o.length===0;for(let i=0;i<=u;i++){let h=this.getNCombinations(s,i);for(let l of h){let y=new Set(l.map(m=>`${m.x},${m.y}`)),d=s.filter(m=>!y.has(`${m.x},${m.y}`));for(let m=0;m<=f.length;m++){if(d.length!==i+m)continue;let x=this.getNCombinations(f,m);for(let p of x){let v=p.filter(S=>S.type==="cell").map(S=>S.pos),g=p.filter(S=>S.type==="hex").map(S=>S.index),P=p.filter(S=>S.type==="nodeHex").map(S=>S.index);if(this.getRegionErrors(e,t,[...v,...l]).length===0){let S=!0;if(c)m>0&&(S=!1);else for(let C=0;C<p.length;C++){let $=[...p.slice(0,C),...p.slice(C+1)],z=$.filter(E=>E.type==="cell").map(E=>E.pos),N=new Set($.filter(E=>E.type==="hex").map(E=>E.index)),H=new Set($.filter(E=>E.type==="nodeHex").map(E=>E.index)),I=a.every(E=>N.has(E)),T=o.every(E=>H.has(E));if(this.getRegionErrors(e,t,z).length===0&&I&&T){S=!1;break}}S&&r.push({invalidatedCells:[...v,...l],invalidatedHexagons:g,invalidatedNodeHexagons:P,isValid:!0,errorCells:[]})}}}}}return r}getBestEffortErasures(e,t,s,n,a,o){let r=this.getRegionErrors(e,t,[]);if(r.length===0&&a.length===0&&o.length===0)return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:[...s]};if(s.length>0){let c=[...n.map(y=>({type:"cell",pos:y})),...a.map(y=>({type:"hex",index:y})),...o.map(y=>({type:"nodeHex",index:y}))],i=null,h=1/0,l=y=>{let d=[],m=[],x=[],p=0;for(let S of y)p<s.length&&(S.type==="cell"?d.push(S.pos):S.type==="hex"?m.push(S.index):x.push(S.index),p++);let v=s.length-p,g=Math.floor(v/2),P=s.slice(p,p+g);p+=g*2;let b=this.getRegionErrors(e,t,[...d,...P]);for(let S=p;S<s.length;S++)b.push(s[S]);let M=b.length;M<h&&(h=M,i={invalidatedCells:[...d,...P],invalidatedHexagons:m,invalidatedNodeHexagons:x,isValid:!1,errorCells:b})};l([...r.map(y=>({type:"cell",pos:y})),...a.map(y=>({type:"hex",index:y})),...o.map(y=>({type:"nodeHex",index:y}))]),l(c);for(let y of r)l([{type:"cell",pos:y}]);if(i)return i}let f=[...r,...s];return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:f}}getNCombinations(e,t){let s=[],n=(a,o)=>{if(o.length===t){s.push([...o]);return}for(let r=a;r<e.length;r++)o.push(e[r]),n(r+1,o),o.pop()};return n(0,[]),s}checkRegionValid(e,t,s){return this.getRegionErrors(e,t,s).length===0}getRegionErrors(e,t,s){let n=new Set(s.map(i=>`${i.x},${i.y}`)),a=new Map,o=new Map,r=new Set,u=new Set,f=[];for(let i of t){if(n.has(`${i.x},${i.y}`))continue;let h=e.cells[i.y][i.x];if(h.type===0)continue;let l=h.color;l!==O.None&&(a.set(l,(a.get(l)||0)+1),o.has(l)||o.set(l,[]),o.get(l).push(i)),h.type===1?u.add(l):h.type===2?r.add(l):(h.type===3||h.type===4)&&h.shape&&f.push({shape:h.shape,rotatable:h.type===4,pos:i})}let c=[];if(u.size>1)for(let i of t)n.has(`${i.x},${i.y}`)||e.cells[i.y][i.x].type===1&&c.push(i);for(let i of r)if(a.get(i)!==2){let h=o.get(i)||[];for(let l of h)e.cells[l.y][l.x].type===2&&c.push(l)}if(f.length>0&&!this.checkTetrisConstraint(t,f.map(i=>({shape:i.shape,rotatable:i.rotatable}))))for(let i of f)c.push(i.pos);return c}findGlobalAssignment(e,t,s){let n=e.length,a=new Array(t).fill(0),o=new Array(s).fill(0),r=[],u=[],f=[],c=i=>{if(i===n)return a.every(h=>h===1)&&o.every(h=>h===1);for(let h of e[i]){let l=!0;for(let y of h.invalidatedHexagons)if(a[y]>0){l=!1;break}if(l){for(let y of h.invalidatedNodeHexagons)if(o[y]>0){l=!1;break}}if(l){for(let y of h.invalidatedHexagons)a[y]++,u.push(y);for(let y of h.invalidatedNodeHexagons)o[y]++,f.push(y);if(r.push(...h.invalidatedCells),c(i+1))return!0;for(let y of h.invalidatedHexagons)a[y]--,u.pop();for(let y of h.invalidatedNodeHexagons)o[y]--,f.pop();for(let y=0;y<h.invalidatedCells.length;y++)r.pop()}}return!1};return c(0)?{invalidatedCells:r,invalidatedHexIndices:u,invalidatedNodeHexIndices:f}:null}checkTetrisConstraint(e,t){if(t.reduce((i,h)=>i+this.getShapeArea(h.shape),0)!==e.length)return!1;let n=Math.min(...e.map(i=>i.x)),a=Math.min(...e.map(i=>i.y)),o=Math.max(...e.map(i=>i.x)),r=Math.max(...e.map(i=>i.y)),u=o-n+1,f=r-a+1,c=Array.from({length:f},()=>Array(u).fill(!1));for(let i of e)c[i.y-a][i.x-n]=!0;return this.canTile(c,t)}getShapeArea(e){let t=0;for(let s of e)for(let n of s)n&&t++;return t}canTile(e,t){let s=-1,n=-1;for(let a=0;a<e.length;a++){for(let o=0;o<e[0].length;o++)if(e[a][o]){s=a,n=o;break}if(s!==-1)break}if(s===-1)return t.length===0;if(t.length===0)return!1;for(let a=0;a<t.length;a++){let o=t[a],r=[...t.slice(0,a),...t.slice(a+1)],u=o.rotatable?this.getAllRotations(o.shape):[o.shape];for(let f of u){let c=[];for(let i=0;i<f.length;i++)for(let h=0;h<f[0].length;h++)f[i][h]&&c.push({r:i,c:h});for(let i of c){let h=s-i.r,l=n-i.c;if(this.canPlace(e,f,h,l)){if(this.placePiece(e,f,h,l,!1),this.canTile(e,r))return!0;this.placePiece(e,f,h,l,!0)}}}}return!1}canPlace(e,t,s,n){for(let a=0;a<t.length;a++)for(let o=0;o<t[0].length;o++)if(t[a][o]){let r=s+a,u=n+o;if(r<0||r>=e.length||u<0||u>=e[0].length||!e[r][u])return!1}return!0}placePiece(e,t,s,n,a){for(let o=0;o<t.length;o++)for(let r=0;r<t[0].length;r++)t[o][r]&&(e[s+o][n+r]=a)}getAllRotations(e){let t=[],s=new Set,n=e;for(let a=0;a<4;a++){let o=JSON.stringify(n);s.has(o)||(t.push(n),s.add(o)),n=this.rotate90(n)}return t}rotate90(e){let t=e.length,s=e[0].length,n=Array.from({length:s},()=>Array(t).fill(0));for(let a=0;a<t;a++)for(let o=0;o<s;o++)n[o][t-1-a]=e[a][o];return n}calculateRegions(e,t,s=[],n){let a=[],o=e.rows,r=e.cols,u=new Uint8Array(o*r),f=new Uint8Array((o+1)*r),c=new Uint8Array(o*(r+1)),i=(l,y)=>{l.x===y.x?c[Math.min(l.y,y.y)*(r+1)+l.x]=1:f[l.y*r+Math.min(l.x,y.x)]=1};for(let l=0;l<t.length-1;l++)i(t[l],t[l+1]);for(let l=0;l<s.length-1;l++)i(s[l],s[l+1]);for(let l=0;l<=o;l++)for(let y=0;y<r;y++)e.hEdges[l][y].type===2&&(f[l*r+y]=1);for(let l=0;l<o;l++)for(let y=0;y<=r;y++)e.vEdges[l][y].type===2&&(c[l*(r+1)+y]=1);let h=n||this.getExternalCells(e);for(let l=0;l<o;l++)for(let y=0;y<r;y++){let d=l*r+y;if(u[d]||h&&h.has(`${y},${l}`))continue;let m=[],x=[d];u[d]=1;let p=0;for(;p<x.length;){let v=x[p++],g=v%r,P=Math.floor(v/r);if(m.push({x:g,y:P}),P>0&&!f[P*r+g]){let b=(P-1)*r+g;!u[b]&&(!h||!h.has(`${g},${P-1}`))&&(u[b]=1,x.push(b))}if(P<o-1&&!f[(P+1)*r+g]){let b=(P+1)*r+g;!u[b]&&(!h||!h.has(`${g},${P+1}`))&&(u[b]=1,x.push(b))}if(g>0&&!c[P*(r+1)+g]){let b=P*r+(g-1);!u[b]&&(!h||!h.has(`${g-1},${P}`))&&(u[b]=1,x.push(b))}if(g<r-1&&!c[P*(r+1)+(g+1)]){let b=P*r+(g+1);!u[b]&&(!h||!h.has(`${g+1},${P}`))&&(u[b]=1,x.push(b))}}a.push(m)}return a}getExternalCells(e){let t=new Set,s=[];for(let n=0;n<e.cols;n++)e.hEdges[0][n].type===2&&(t.has(`${n},0`)||(t.add(`${n},0`),s.push({x:n,y:0}))),e.hEdges[e.rows][n].type===2&&(t.has(`${n},${e.rows-1}`)||(t.add(`${n},${e.rows-1}`),s.push({x:n,y:e.rows-1})));for(let n=0;n<e.rows;n++)e.vEdges[n][0].type===2&&(t.has(`0,${n}`)||(t.add(`0,${n}`),s.push({x:0,y:n}))),e.vEdges[n][e.cols].type===2&&(t.has(`${e.cols-1},${n}`)||(t.add(`${e.cols-1},${n}`),s.push({x:e.cols-1,y:n})));for(;s.length>0;){let n=s.shift(),a=[{nx:n.x,ny:n.y-1,edge:e.hEdges[n.y][n.x]},{nx:n.x,ny:n.y+1,edge:e.hEdges[n.y+1][n.x]},{nx:n.x-1,ny:n.y,edge:e.vEdges[n.y][n.x]},{nx:n.x+1,ny:n.y,edge:e.vEdges[n.y][n.x+1]}];for(let o of a)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),s.push({x:o.nx,y:o.ny}))}return t}getSymmetricalPoint(e,t){let s=e.symmetry||0;return s===1?{x:e.cols-t.x,y:t.y}:s===2?{x:t.x,y:e.rows-t.y}:s===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getSymmetricalPointIndex(e,t){let s=e.cols+1,n=Math.floor(t/s),a=t%s,o=e.symmetry||0,r=n,u=a;return o===1?u=e.cols-a:o===2?r=e.rows-n:o===3&&(u=e.cols-a,r=e.rows-n),r*s+u}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}calculateDifficulty(e){let t=e.rows,s=e.cols,n=s+1,a=(t+1)*n,o=Array.from({length:a},()=>[]),r=[],u=[],f=new Map,c=0,i=new Set,h=new Set;for(let T=0;T<=t;T++)for(let E=0;E<=s;E++){let w=T*n+E;if(e.nodes[T][E].type===1&&r.push(w),e.nodes[T][E].type===2&&u.push(w),(e.nodes[T][E].type===3||e.nodes[T][E].type===4||e.nodes[T][E].type===5)&&(f.set(`n${E},${T}`,c++),h.add(w)),E<s){let R=w+1,A=e.hEdges[T][E].type,F=A===3||A===4||A===5,G=A===1||A===2;o[w].push({next:R,hexType:A,isBroken:G}),o[R].push({next:w,hexType:A,isBroken:G}),F&&(f.set(`eh${E},${T}`,c++),i.add(this.getEdgeKey({x:E,y:T},{x:E+1,y:T})))}if(T<t){let R=w+n,A=e.vEdges[T][E].type,F=A===3||A===4||A===5,G=A===1||A===2;o[w].push({next:R,hexType:A,isBroken:G}),o[R].push({next:w,hexType:A,isBroken:G}),F&&(f.set(`ev${E},${T}`,c++),i.add(this.getEdgeKey({x:E,y:T},{x:E,y:T+1})))}}let l={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},y=c,d=new Set,m=Math.max(1e3,t*s*200),x=this.getExternalCells(e),p=!1;for(let T=0;T<t;T++){for(let E=0;E<s;E++)if(e.cells[T][E].type!==0){p=!0;break}if(p)break}for(let T of r){let E=e.cols+1,w=Math.floor(T/E),R=T%E,A=0n,F=e.nodes[w][R].type;(F===3||F===4)&&(A|=1n<<BigInt(f.get(`n${R},${w}`)));let G=e.symmetry||0;if(G!==0){let V=this.getSymmetricalPointIndex(e,T),B=Math.floor(V/E),q=V%E,k=e.nodes[B][q].type;(k===3||k===5)&&(A|=1n<<BigInt(f.get(`n${q},${B}`)))}let W=1n<<BigInt(T);if(G!==0){let V=this.getSymmetricalPointIndex(e,T);if(V===T)continue;W|=1n<<BigInt(V)}this.exploreSearchSpace(e,T,W,[T],A,y,o,u,d,l,m,x,p,f)}if(l.solutions===0)return 0;let v=i.size+h.size,g=new Set;i.size>0&&g.add(999);let P=0,b=0;for(let T=0;T<t;T++)for(let E=0;E<s;E++){let w=e.cells[T][E];w.type!==0&&(v++,g.add(w.type),w.type===3?P++:w.type===4&&(P++,b++))}let M=l.branchingPoints/(l.totalNodesVisited||1),S=Math.log10(l.totalNodesVisited+1),C=(M*10+S*1.5)/(Math.log2(l.solutions+1)*.5+1);C-=i.size*.05,C+=h.size*.12,P>0&&(C+=b*.5,C+=(P-b)*.2);let $=t*s,z=v/$,N=z<.25?Math.pow(z/.25,4):1,H=g.size<=1?.5:1;C*=N*H;let I=Math.log2($)/5;return C*=I,Math.max(.01,Math.min(1,C/4))}exploreSearchSpace(e,t,s,n,a,o,r,u,f,c,i,h,l=!0,y){if(c.totalNodesVisited++,c.maxDepth=Math.max(c.maxDepth,n.length),c.totalNodesVisited>i)return;let d=e.symmetry||0;if(u.includes(t)){let p=0,v=a;for(;v>0n;)v&1n&&p++,v>>=1n;if(p===o){let g=n.map(M=>({x:M%(e.cols+1),y:Math.floor(M/(e.cols+1))})),P={points:g};if(d!==0){let M=this.getSymmetricalPointIndex(e,t),S=e.cols+1;if(e.nodes[Math.floor(M/S)][M%S].type!==2)return}let b=d!==0?g.map(M=>this.getSymmetricalPoint(e,M)):[];if(l){let M=this.validateFast(e,g,b,h);if(M.isValid){let S=this.getFingerprint(e,g,b,M.regions,h);f.has(S)||(f.add(S),c.solutions++)}}else{let M=this.getFingerprint(e,g,b,void 0,h);f.has(M)||(f.add(M),c.solutions++)}}return}if(!this.canReachEndOptimized(t,s,r,u)){c.backtracks++;return}let m=[];for(let p of r[t]){if(p.isBroken||s&1n<<BigInt(p.next))continue;if(d!==0){let g=this.getSymmetricalPointIndex(e,t),P=this.getSymmetricalPointIndex(e,p.next);if(p.next===P||t===P&&p.next===g)continue}let v=!0;for(let g of r[t])if(g.hexType===3||g.hexType===4){let b=n.length>=2&&g.next===n[n.length-2],M=g.next===p.next;if(!b&&!M){v=!1;break}}if(v){if(d!==0){let g=this.getSymmetricalPointIndex(e,t),P=this.getSymmetricalPointIndex(e,p.next);for(let b of r[g])if(b.hexType===3||b.hexType===5){let S=n.length>=2?this.getSymmetricalPointIndex(e,n[n.length-2]):-1,C=b.next===S,$=b.next===P;if(!C&&!$){v=!1;break}}}v&&m.push(p)}}if(m.length>1&&c.branchingPoints++,e.rows*e.cols>30)for(let p=m.length-1;p>0;p--){let v=Math.floor(Math.random()*(p+1));[m[p],m[v]]=[m[v],m[p]]}let x=e.cols+1;for(let p of m){let v=a,g=Math.floor(p.next/x),P=p.next%x,b=e.nodes[g][P].type;(b===3||b===4)&&(v|=1n<<BigInt(y.get(`n${P},${g}`)));let M=n[n.length-1],S=Math.floor(M/x),C=M%x;if(S===g){let z=Math.min(C,P);(p.hexType===3||p.hexType===4)&&(v|=1n<<BigInt(y.get(`eh${z},${g}`)))}else{let z=Math.min(S,g);(p.hexType===3||p.hexType===4)&&(v|=1n<<BigInt(y.get(`ev${P},${z}`)))}if(d!==0){let z=this.getSymmetricalPointIndex(e,p.next),N=Math.floor(z/x),H=z%x,I=e.nodes[N][H].type;(I===3||I===5)&&(v|=1n<<BigInt(y.get(`n${H},${N}`)));let T=this.getSymmetricalPointIndex(e,M),E=Math.floor(T/x),w=T%x;if(E===N){let R=Math.min(w,H),A=e.hEdges[N][R].type;(A===3||A===5)&&(v|=1n<<BigInt(y.get(`eh${R},${N}`)))}else{let R=Math.min(E,N),A=e.vEdges[R][H].type;(A===3||A===5)&&(v|=1n<<BigInt(y.get(`ev${H},${R}`)))}}n.push(p.next);let $=s|1n<<BigInt(p.next);if(d!==0){let z=this.getSymmetricalPointIndex(e,p.next);$|=1n<<BigInt(z)}if(this.exploreSearchSpace(e,p.next,$,n,v,o,r,u,f,c,i,h,l,y),n.pop(),c.totalNodesVisited>i)return}}countSolutions(e,t=100){let s=e.rows,n=e.cols,a=n+1,o=(s+1)*a,r=Array.from({length:o},()=>[]),u=[],f=[],c=new Map,i=0;for(let m=0;m<=s;m++)for(let x=0;x<=n;x++){let p=m*a+x;if(e.nodes[m][x].type===1&&u.push(p),e.nodes[m][x].type===2&&f.push(p),(e.nodes[m][x].type===3||e.nodes[m][x].type===4||e.nodes[m][x].type===5)&&c.set(`n${x},${m}`,i++),x<n){let v=p+1,g=e.hEdges[m][x].type,P=g===3||g===4||g===5,b=g===1||g===2;r[p].push({next:v,hexType:g,isBroken:b}),r[v].push({next:p,hexType:g,isBroken:b}),P&&c.set(`eh${x},${m}`,i++)}if(m<s){let v=p+a,g=e.vEdges[m][x].type,P=g===3||g===4||g===5,b=g===1||g===2;r[p].push({next:v,hexType:g,isBroken:b}),r[v].push({next:p,hexType:g,isBroken:b}),P&&c.set(`ev${x},${m}`,i++)}}let h=new Set,l=i,y=this.getExternalCells(e),d=!1;for(let m=0;m<s;m++){for(let x=0;x<n;x++)if(e.cells[m][x].type!==0){d=!0;break}if(d)break}for(let m of u){let x=e.cols+1,p=Math.floor(m/x),v=m%x,g=0n,P=e.nodes[p][v].type;(P===3||P===4)&&(g|=1n<<BigInt(c.get(`n${v},${p}`)));let b=e.symmetry||0;if(b!==0){let S=this.getSymmetricalPointIndex(e,m),C=Math.floor(S/x),$=S%x,z=e.nodes[C][$].type;(z===3||z===5)&&(g|=1n<<BigInt(c.get(`n${$},${C}`)))}let M=1n<<BigInt(m);if(b!==0){let S=this.getSymmetricalPointIndex(e,m);if(S===m)continue;M|=1n<<BigInt(S)}this.findPathsOptimized(e,m,M,[m],g,l,r,f,h,t,y,d,c)}return h.size}findPathsOptimized(e,t,s,n,a,o,r,u,f,c,i,h=!0,l){if(f.size>=c)return;let y=e.symmetry||0;if(u.includes(t)){let d=0,m=a;for(;m>0n;)m&1n&&d++,m>>=1n;if(d===o){let x=n.map(v=>({x:v%(e.cols+1),y:Math.floor(v/(e.cols+1))}));if(y!==0){let v=this.getSymmetricalPointIndex(e,t),g=e.cols+1;if(e.nodes[Math.floor(v/g)][v%g].type!==2)return}let p=y!==0?x.map(v=>this.getSymmetricalPoint(e,v)):[];if(!h)f.add(this.getFingerprint(e,x,p,void 0,i));else{let v=this.validateFast(e,x,p,i);v.isValid&&f.add(this.getFingerprint(e,x,p,v.regions,i))}}return}if(this.canReachEndOptimized(t,s,r,u))for(let d of r[t]){if(d.isBroken||s&1n<<BigInt(d.next))continue;if(y!==0){let C=this.getSymmetricalPointIndex(e,t),$=this.getSymmetricalPointIndex(e,d.next);if(d.next===$||t===$&&d.next===C)continue}let m=!0;for(let C of r[t])if(C.hexType===3||C.hexType===4){let z=n.length>=2&&C.next===n[n.length-2],N=C.next===d.next;if(!z&&!N){m=!1;break}}if(!m)continue;if(y!==0){let C=this.getSymmetricalPointIndex(e,t),$=this.getSymmetricalPointIndex(e,d.next);for(let z of r[C])if(z.hexType===3||z.hexType===5){let H=n.length>=2?this.getSymmetricalPointIndex(e,n[n.length-2]):-1,I=z.next===H,T=z.next===$;if(!I&&!T){m=!1;break}}}if(!m)continue;let x=e.cols+1,p=a,v=Math.floor(d.next/x),g=d.next%x,P=e.nodes[v][g].type;(P===3||P===4)&&(p|=1n<<BigInt(l.get(`n${g},${v}`)));let b=Math.floor(t/x),M=t%x;if(b===v){let C=Math.min(M,g);(d.hexType===3||d.hexType===4)&&(p|=1n<<BigInt(l.get(`eh${C},${v}`)))}else{let C=Math.min(b,v);(d.hexType===3||d.hexType===4)&&(p|=1n<<BigInt(l.get(`ev${g},${C}`)))}if(y!==0){let C=this.getSymmetricalPointIndex(e,d.next),$=Math.floor(C/x),z=C%x,N=e.nodes[$][z].type;(N===3||N===5)&&(p|=1n<<BigInt(l.get(`n${z},${$}`)));let H=this.getSymmetricalPointIndex(e,t),I=Math.floor(H/x),T=H%x;if(I===$){let E=Math.min(T,z),w=e.hEdges[$][E].type;(w===3||w===5)&&(p|=1n<<BigInt(l.get(`eh${E},${$}`)))}else{let E=Math.min(I,$),w=e.vEdges[E][z].type;(w===3||w===5)&&(p|=1n<<BigInt(l.get(`ev${z},${E}`)))}}n.push(d.next);let S=s|1n<<BigInt(d.next);if(y!==0){let C=this.getSymmetricalPointIndex(e,d.next);S|=1n<<BigInt(C)}if(this.findPathsOptimized(e,d.next,S,n,p,o,r,u,f,c,i,h,l),n.pop(),f.size>=c)return}}canReachEndOptimized(e,t,s,n){let a=[e],o=t,r=0;for(;r<a.length;){let u=a[r++];if(n.includes(u))return!0;for(let f of s[u])!f.isBroken&&!(o&1n<<BigInt(f.next))&&(o|=1n<<BigInt(f.next),a.push(f.next))}return!1}getFingerprint(e,t,s,n,a){let r=(n||this.calculateRegions(e,t,s,a)).map(f=>{let c="",i=[];for(let h of f){let l=e.cells[h.y][h.x];l.type!==0&&i.push(l.type<<8|l.color)}i.sort((h,l)=>h-l);for(let h of i)c+=h.toString(36)+",";return c}).sort(),u="";for(let f of r)f.length>0&&(u+=f+"|");return u||"empty"}};var Z=class{isWorker;constructor(){this.isWorker=typeof self<"u"&&"postMessage"in self&&!("document"in self)}generate(e,t,s={}){let n=s.difficulty??.5,a=new Y,o=null,r=-1,u=this.isWorker?e*t>30?150:120:e*t>30?100:80,f=this.isWorker?8:5,c=s.symmetry||0,i={x:0,y:e},h={x:t,y:0};c===1?h={x:0,y:0}:c===2?h={x:t,y:e}:c===3&&(h={x:t,y:e});let l=null,y=null,d=null;for(let m=0;m<u;m++){if(m%f===0){l=this.generateRandomPath(new U(e,t),i,h,s.pathLength,c);let g=new U(e,t),P=c!==0?l.map(b=>this.getSymmetricalPoint(g,b,c)):[];y=this.calculateRegions(g,l,P),d=y.map(b=>this.getRegionBoundaryEdges(g,b,l,P))}let x=this.generateFromPath(e,t,l,s,y,d);if(!this.checkAllRequestedConstraintsPresent(x,s))continue;let p=a.calculateDifficulty(x);if(p===0)continue;let v=Math.abs(p-n);if((o===null||v<Math.abs(r-n))&&(r=p,o=x),n>.8&&p>.8||v<.01)break}if(!o){let m=this.generateRandomPath(new U(e,t),i,h,s.pathLength,c);return this.generateFromPath(e,t,m,s)}return o}generateFromPath(e,t,s,n,a,o){let r=new U(e,t),u=n.symmetry||0;r.symmetry=u;let f={x:0,y:e},c={x:t,y:0};if(u===1?c={x:0,y:0}:u===2?c={x:t,y:e}:u===3&&(c={x:t,y:e}),r.nodes[f.y][f.x].type=1,r.nodes[c.y][c.x].type=2,u!==0){let h=this.getSymmetricalPoint(r,f,u),l=this.getSymmetricalPoint(r,c,u);r.nodes[h.y][h.x].type=1,r.nodes[l.y][l.x].type=2}let i=u!==0?s.map(h=>this.getSymmetricalPoint(r,h,u)):[];return this.applyConstraintsBasedOnPath(r,s,n,i,a,o),n.useBrokenEdges&&this.applyBrokenEdges(r,s,n),this.cleanGrid(r),r}generateRandomPath(e,t,s,n,a=0){if(n===void 0)return this.generateSingleRandomPath(e,t,s,void 0,a);let o=e.rows+e.cols,r=(e.rows+1)*(e.cols+1)-1,u=o+n*(r-o),f=[],c=1/0,i=e.rows*e.cols>30?30:50;for(let h=0;h<i;h++){let l=this.generateSingleRandomPath(e,t,s,n,a);if(l.length===0)continue;let y=l.length-1,d=Math.abs(y-u);if(d<c&&(c=d,f=l),c<=2)break}return f}generateSingleRandomPath(e,t,s,n,a=0){let o=new Set,r=[],u=0,f=e.rows*e.cols*200,c=i=>{if(u++,u>f)return!1;o.add(`${i.x},${i.y}`);let h=this.getSymmetricalPoint(e,i,a);if(o.add(`${h.x},${h.y}`),r.push(i),i.x===s.x&&i.y===s.y)return!0;let l=this.getValidNeighbors(e,i,o);a!==0&&(l=l.filter(y=>{let d=this.getSymmetricalPoint(e,y,a);if(d.x<0||d.x>e.cols||d.y<0||d.y>e.rows||o.has(`${d.x},${d.y}`)||y.x===d.x&&y.y===d.y)return!1;let m=this.getEdgeKey(i,y),x=this.getEdgeKey(h,d);return m!==x})),n!==void 0?l.sort((y,d)=>{let m=Math.abs(y.x-s.x)+Math.abs(y.y-s.y),x=Math.abs(d.x-s.x)+Math.abs(d.y-s.y);return(m-x)*(1-n*2)+(Math.random()-.5)*1.5}):this.shuffleArray(l);for(let y of l)if(c(y))return!0;return r.pop(),o.delete(`${i.x},${i.y}`),o.delete(`${h.x},${h.y}`),!1};return c(t),r}getValidNeighbors(e,t,s){let n=[],a=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of a){let r=t.x+o.x,u=t.y+o.y;r>=0&&r<=e.cols&&u>=0&&u<=e.rows&&(s.has(`${r},${u}`)||n.push({x:r,y:u}))}return n}applyBrokenEdges(e,t,s){let n=s.complexity??.5,a=s.symmetry??0,o=new Set;for(let i=0;i<t.length-1;i++)if(o.add(this.getEdgeKey(t[i],t[i+1])),a!==0){let h=this.getSymmetricalPoint(e,t[i],a),l=this.getSymmetricalPoint(e,t[i+1],a);o.add(this.getEdgeKey(h,l))}let r=[];for(let i=0;i<=e.rows;i++)for(let h=0;h<e.cols;h++){let l={x:h,y:i},y={x:h+1,y:i};o.has(this.getEdgeKey(l,y))||r.push({type:"h",r:i,c:h,p1:l,p2:y})}for(let i=0;i<e.rows;i++)for(let h=0;h<=e.cols;h++){let l={x:h,y:i},y={x:h,y:i+1};o.has(this.getEdgeKey(l,y))||r.push({type:"v",r:i,c:h,p1:l,p2:y})}this.shuffleArray(r);let u=Math.max(1,Math.floor(n*(e.rows*e.cols)/4)),f=0;for(let i of r){if(f>=u)break;i.type==="h"?e.hEdges[i.r][i.c].type=1:e.vEdges[i.r][i.c].type=1,f++}let c=!0;for(;c;){c=!1;for(let i=0;i<=e.rows;i++)for(let h=0;h<e.cols;h++)e.hEdges[i][h].type===1&&this.canBecomeAbsent(e,{type:"h",r:i,c:h})&&(e.hEdges[i][h].type=2,c=!0);for(let i=0;i<e.rows;i++)for(let h=0;h<=e.cols;h++)e.vEdges[i][h].type===1&&this.canBecomeAbsent(e,{type:"v",r:i,c:h})&&(e.vEdges[i][h].type=2,c=!0)}for(let i=0;i<=e.rows;i++)for(let h=0;h<=e.cols;h++){let l=[];if(h>0&&l.push({e:e.hEdges[i][h-1],type:"h",r:i,c:h-1}),h<e.cols&&l.push({e:e.hEdges[i][h],type:"h",r:i,c:h}),i>0&&l.push({e:e.vEdges[i-1][h],type:"v",r:i-1,c:h}),i<e.rows&&l.push({e:e.vEdges[i][h],type:"v",r:i,c:h}),l.length>0&&l.every(y=>y.e.type===1||y.e.type===2)&&l.every(y=>!this.isAdjacentToMark(e,y)))for(let y of l)y.e.type=2}}canBecomeAbsent(e,t){if(this.isAdjacentToMark(e,t))return!1;if(t.type==="h"){if(t.r===0||t.r===e.rows)return!0}else if(t.c===0||t.c===e.cols)return!0;let s=t.type==="h"?[{x:t.c,y:t.r},{x:t.c+1,y:t.r}]:[{x:t.c,y:t.r},{x:t.c,y:t.r+1}];for(let n of s){let a=[{type:"h",r:n.y,c:n.x-1},{type:"h",r:n.y,c:n.x},{type:"v",r:n.y-1,c:n.x},{type:"v",r:n.y,c:n.x}];for(let o of a)if(o.c>=0&&o.c<=e.cols&&o.r>=0&&o.r<=e.rows){if(o.type==="h"&&o.c<e.cols){if(e.hEdges[o.r][o.c].type===2)return!0}else if(o.type==="v"&&o.r<e.rows&&e.vEdges[o.r][o.c].type===2)return!0}}return!1}cleanGrid(e){let t=[];for(let o=0;o<=e.rows;o++)for(let r=0;r<=e.cols;r++)e.nodes[o][r].type===1&&t.push({x:r,y:o});let s=new Set,n=[...t];for(let o of t)s.add(`${o.x},${o.y}`);for(;n.length>0;){let o=n.shift(),r=[{nx:o.x,ny:o.y-1,edge:e.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:e.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:e.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:e.hEdges[o.y]?.[o.x]}];for(let u of r)u.edge&&u.edge.type!==2&&(s.has(`${u.nx},${u.ny}`)||(s.add(`${u.nx},${u.ny}`),n.push({x:u.nx,y:u.ny})))}for(let o=0;o<=e.rows;o++)for(let r=0;r<e.cols;r++)(!s.has(`${r},${o}`)||!s.has(`${r+1},${o}`))&&(e.hEdges[o][r].type=2);for(let o=0;o<e.rows;o++)for(let r=0;r<=e.cols;r++)(!s.has(`${r},${o}`)||!s.has(`${r},${o+1}`))&&(e.vEdges[o][r].type=2);let a=this.getExternalCells(e);for(let o of a){let[r,u]=o.split(",").map(Number);e.cells[u][r].type=0}}getExternalCells(e){let t=new Set,s=[];for(let n=0;n<e.cols;n++)e.hEdges[0][n].type===2&&(t.has(`${n},0`)||(t.add(`${n},0`),s.push({x:n,y:0}))),e.hEdges[e.rows][n].type===2&&(t.has(`${n},${e.rows-1}`)||(t.add(`${n},${e.rows-1}`),s.push({x:n,y:e.rows-1})));for(let n=0;n<e.rows;n++)e.vEdges[n][0].type===2&&(t.has(`0,${n}`)||(t.add(`0,${n}`),s.push({x:0,y:n}))),e.vEdges[n][e.cols].type===2&&(t.has(`${e.cols-1},${n}`)||(t.add(`${e.cols-1},${n}`),s.push({x:e.cols-1,y:n})));for(;s.length>0;){let n=s.shift(),a=[{nx:n.x,ny:n.y-1,edge:e.hEdges[n.y][n.x]},{nx:n.x,ny:n.y+1,edge:e.hEdges[n.y+1][n.x]},{nx:n.x-1,ny:n.y,edge:e.vEdges[n.y][n.x]},{nx:n.x+1,ny:n.y,edge:e.vEdges[n.y][n.x+1]}];for(let o of a)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),s.push({x:o.nx,y:o.ny}))}return t}isAdjacentToMark(e,t){if(t.type==="h"){if(t.r>0&&e.cells[t.r-1][t.c].type!==0||t.r<e.rows&&e.cells[t.r][t.c].type!==0)return!0}else if(t.c>0&&e.cells[t.r][t.c-1].type!==0||t.c<e.cols&&e.cells[t.r][t.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let t=0;t<e.rows;t++)for(let s=0;s<e.cols;s++){if(e.cells[t][s].type===0)continue;if([e.hEdges[t][s],e.hEdges[t+1][s],e.vEdges[t][s],e.vEdges[t][s+1]].every(a=>a.type===1||a.type===2))return!0}return!1}getSymmetricalPoint(e,t,s){return s===1?{x:e.cols-t.x,y:t.y}:s===2?{x:t.x,y:e.rows-t.y}:s===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,t,s,n=[],a,o){let r=s.complexity??.5,u=s.useHexagons??!0,f=s.useSquares??!0,c=s.useStars??!0,i=s.useTetris??!1,h=s.useEraser??!1,l=0,y=0,d=0,m=0,x=0,p=0,v=Math.floor(e.rows*e.cols*.45);if(u){let g=s.difficulty??.5,P=s.symmetry||0;for(let b=0;b<t.length-1;b++){let S=this.getValidNeighbors(e,t[b],new Set).length>2,C=r*(g<.4?.6:.3);if(S&&(C=g<.4?C*1:C*.5),Math.random()<C){let $=3,z=t[b],N=t[b+1];if(P!==0){let H=Math.random();H<.3?$=4:H<.6&&($=5,z=this.getSymmetricalPoint(e,t[b],P),N=this.getSymmetricalPoint(e,t[b+1],P))}this.setEdgeHexagon(e,z,N,$),l++}}for(let b=0;b<t.length;b++){let M=t[b];if(e.nodes[M.y][M.x].type!==0||this.hasIncidentHexagonEdge(e,M))continue;let S=r*(g>.6?.15:.05);if(Math.random()<S){let C=3,$=M;if(P!==0){let z=Math.random();z<.3?C=4:z<.6&&(C=5,$=this.getSymmetricalPoint(e,M,P))}e.nodes[$.y][$.x].type=C,l++}}if(l===0&&t.length>=2){let b=Math.floor(Math.random()*(t.length-1)),M=s.symmetry||0,S=3,C=t[b],$=t[b+1];if(M!==0){let z=Math.random();z<.3?S=4:z<.6&&(S=5,C=this.getSymmetricalPoint(e,t[b],M),$=this.getSymmetricalPoint(e,t[b+1],M))}this.setEdgeHexagon(e,C,$,S)}}if(f||c||i||h){let g=a||this.calculateRegions(e,t,n),P=s.availableColors??[O.Black,O.White,O.Red,O.Blue],b=s.defaultColors??{},M=(z,N)=>{if(b[z]!==void 0)return b[z];let H=j[z];return H&&b[H]!==void 0?b[H]:N},S=Array.from({length:g.length},(z,N)=>N);this.shuffleArray(S);let C=new Set,$={square:f,star:c,tetris:i,eraser:h};for(let z=0;z<S.length;z++){let N=S[z],H=g[N],I=S.length-z,T=$.square&&y===0||$.star&&d===0||$.tetris&&m===0||$.eraser&&x===0,E=.2+r*.6;if(T&&I<=3?E=1:T&&I<=6&&(E=.7),Math.random()>E)continue;let w=[...H];this.shuffleArray(w);let R=P[Math.floor(Math.random()*P.length)];if(f&&!c&&I<=2&&C.size===1){let F=P.filter(G=>!C.has(G));F.length>0&&(R=F[Math.floor(Math.random()*F.length)])}let A=f&&Math.random()<.5+r*.3;if(f&&y===0&&I<=2&&(A=!0),f&&!c&&I<=2&&C.size<2&&y>0&&(A=!0),A&&w.length>0){let F=Math.min(w.length,Math.max(4,Math.floor(H.length/4))),G=Math.floor(Math.random()*(F/2))+Math.ceil(F/2);for(let W=0;W<G&&w.length!==0;W++){let V=w.pop();e.cells[V.y][V.x].type=1,e.cells[V.y][V.x].color=R,y++,C.add(R)}}if(i&&p<v){let F=Math.random()<.1+r*.4;m===0&&I<=2&&(F=!0);let G=m===0&&I<=2?6:4;if(F&&w.length>0&&H.length<=G*4&&p+H.length<=v){let W=this.generateTiling(H,G,s);if(W){for(let V of W){if(w.length===0)break;let B=w.pop();e.cells[B.y][B.x].type=V.isRotated?4:3,e.cells[B.y][B.x].shape=V.isRotated?V.displayShape:V.shape;let q=M(3,O.None);if(c&&Math.random()<.5){let k=P.filter(D=>D!==O.Blue&&D!==q);k.length>0&&(q=k[Math.floor(Math.random()*k.length)])}e.cells[B.y][B.x].color=q,m++}p+=H.length}}}if(h&&x<1){let F=.05+r*.2,G=Math.random()<F;if(I<=2&&(G=!0),G&&w.length>=1){let W=[];c&&W.push("star"),f&&W.push("square");let V=[];u&&(V=o?o[N]:this.getRegionBoundaryEdges(e,H,t,n),V.length>0&&W.push("hexagon")),i&&W.push("tetris");let B=W.length>0?W[Math.floor(Math.random()*W.length)]:null;w.length>=2&&(!B||Math.random()<.01)&&(B="eraser");let q=!1;if(B==="hexagon"){let k=V.filter(D=>!this.isEdgeAdjacentToHexagonNode(e,D));if(k.length>0){let D=k[Math.floor(Math.random()*k.length)];D.type==="h"?e.hEdges[D.r][D.c].type=3:e.vEdges[D.r][D.c].type=3,l++,q=!0}}else if(B==="square"&&w.length>=2){let k=w.pop();e.cells[k.y][k.x].type=1;let D=H.find(L=>e.cells[L.y][L.x].type===1),K=D?e.cells[D.y][D.x].color:void 0;e.cells[k.y][k.x].color=P.find(L=>L!==K)||O.Red,y++,q=!0}else if(B==="star"&&w.length>=2){let k=w.pop();e.cells[k.y][k.x].type=2,e.cells[k.y][k.x].color=P[Math.floor(Math.random()*P.length)],d++,q=!0}else if(B==="tetris"&&w.length>=2){let k=this.generateTiling(H,4,s),D=[];if(k&&k.length>0){let K=0;for(let L of k){let J=this.getShapeArea(L.shape);if(K+J<H.length)D.push(L),K+=J;else break}}if(D.length===0&&H.length>1&&(D=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),D.length>0){for(let K of D){if(w.length<2)break;let L=w.pop();e.cells[L.y][L.x].type=K.isRotated?4:3,e.cells[L.y][L.x].shape=K.isRotated?K.displayShape:K.shape;let J=O.None;if(c&&Math.random()<.3){let ie=P.filter(ae=>ae!==O.Blue);J=ie[Math.floor(Math.random()*ie.length)]}e.cells[L.y][L.x].color=J,m++}q=!0}}else if(B==="eraser"&&w.length>=2){let k=w.pop();e.cells[k.y][k.x].type=5,e.cells[k.y][k.x].color=M(5,O.White),x++,q=!0}if(!q&&w.length>=2){let k=w.pop();e.cells[k.y][k.x].type=5,e.cells[k.y][k.x].color=M(5,O.White),x++,q=!0}if(q){let k=w.pop();e.cells[k.y][k.x].type=5;let D=M(5,O.White);if(c&&Math.random()<.4){let K=P.filter(L=>L!==D);K.length>0&&(D=K[Math.floor(Math.random()*K.length)])}e.cells[k.y][k.x].color=D,x++}}}if(c){let F=Math.max(1,Math.floor(H.length/8));for(let G=0;G<F;G++)for(let W of P){if(w.length<1)break;if(Math.random()>.3+r*.4)continue;let V=H.filter(B=>e.cells[B.y][B.x].color===W).length;if(V===1){let B=w.pop();e.cells[B.y][B.x].type=2,e.cells[B.y][B.x].color=W,d++}else if(V===0&&w.length>=2)for(let B=0;B<2;B++){let q=w.pop();e.cells[q.y][q.x].type=2,e.cells[q.y][q.x].color=W,d++}}}}if(f&&!c&&C.size<2){for(let z of g)if(z.every(N=>e.cells[N.y][N.x].type===0)){let N=P.find(I=>!C.has(I))||O.White,H=z[Math.floor(Math.random()*z.length)];e.cells[H.y][H.x].type=1,e.cells[H.y][H.x].color=N,C.add(N),y++;break}}}}calculateRegions(e,t,s=[]){let n=[],a=e.rows,o=e.cols,r=new Uint8Array(a*o),u=new Uint8Array((a+1)*o),f=new Uint8Array(a*(o+1)),c=(i,h)=>{i.x===h.x?f[Math.min(i.y,h.y)*(o+1)+i.x]=1:u[i.y*o+Math.min(i.x,h.x)]=1};for(let i=0;i<t.length-1;i++)c(t[i],t[i+1]);for(let i=0;i<s.length-1;i++)c(s[i],s[i+1]);for(let i=0;i<=a;i++)for(let h=0;h<o;h++)e.hEdges[i][h].type===2&&(u[i*o+h]=1);for(let i=0;i<a;i++)for(let h=0;h<=o;h++)e.vEdges[i][h].type===2&&(f[i*(o+1)+h]=1);for(let i=0;i<a;i++)for(let h=0;h<o;h++){let l=i*o+h;if(r[l])continue;let y=[],d=[l];r[l]=1;let m=0;for(;m<d.length;){let x=d[m++],p=x%o,v=Math.floor(x/o);if(y.push({x:p,y:v}),v>0&&!u[v*o+p]){let g=(v-1)*o+p;r[g]||(r[g]=1,d.push(g))}if(v<a-1&&!u[(v+1)*o+p]){let g=(v+1)*o+p;r[g]||(r[g]=1,d.push(g))}if(p>0&&!f[v*(o+1)+p]){let g=v*o+(p-1);r[g]||(r[g]=1,d.push(g))}if(p<o-1&&!f[v*(o+1)+(p+1)]){let g=v*o+(p+1);r[g]||(r[g]=1,d.push(g))}}n.push(y)}return n}isAbsentEdge(e,t,s){if(t.x===s.x){let n=Math.min(t.y,s.y);return e.vEdges[n][t.x].type===2}else{let n=Math.min(t.x,s.x);return e.hEdges[t.y][n].type===2}}getRegionBoundaryEdges(e,t,s,n=[]){let a=new Set;for(let u=0;u<s.length-1;u++)a.add(this.getEdgeKey(s[u],s[u+1]));for(let u=0;u<n.length-1;u++)a.add(this.getEdgeKey(n[u],n[u+1]));let o=[];for(let u of t){let f=[{type:"h",r:u.y,c:u.x},{type:"h",r:u.y+1,c:u.x},{type:"v",r:u.y,c:u.x},{type:"v",r:u.y,c:u.x+1}];for(let c of f){let i=c.type==="h"?{x:c.c,y:c.r}:{x:c.c,y:c.r},h=c.type==="h"?{x:c.c+1,y:c.r}:{x:c.c,y:c.r+1},l=this.getEdgeKey(i,h);!a.has(l)&&!this.isAbsentEdge(e,i,h)&&o.push(c)}}let r=new Map;for(let u of o)r.set(`${u.type},${u.r},${u.c}`,u);return Array.from(r.values())}setEdgeHexagon(e,t,s,n=3){t.x===s.x?e.vEdges[Math.min(t.y,s.y)][t.x].type=n:e.hEdges[t.y][Math.min(t.x,s.x)].type=n}hasIncidentHexagonEdge(e,t){let s=n=>n===3||n===4||n===5;return!!(t.x>0&&s(e.hEdges[t.y][t.x-1].type)||t.x<e.cols&&s(e.hEdges[t.y][t.x].type)||t.y>0&&s(e.vEdges[t.y-1][t.x].type)||t.y<e.rows&&s(e.vEdges[t.y][t.x].type))}isEdgeAdjacentToHexagonNode(e,t){let s=n=>n===3||n===4||n===5;return t.type==="h"?s(e.nodes[t.r][t.c].type)||s(e.nodes[t.r][t.c+1].type):s(e.nodes[t.r][t.c].type)||s(e.nodes[t.r+1][t.c].type)}checkAllRequestedConstraintsPresent(e,t){let s=t.useHexagons??!0,n=t.useSquares??!0,a=t.useStars??!0,o=t.useTetris??!1,r=t.useEraser??!1;if(t.useBrokenEdges??!1){let f=!1;for(let c=0;c<=e.rows;c++)for(let i=0;i<e.cols;i++)if(e.hEdges[c][i].type===1||e.hEdges[c][i].type===2){f=!0;break}if(!f){for(let c=0;c<e.rows;c++)for(let i=0;i<=e.cols;i++)if(e.vEdges[c][i].type===1||e.vEdges[c][i].type===2){f=!0;break}}if(!f)return!1}if(s){let f=!1,c=h=>h===3||h===4||h===5,i=h=>h===3||h===4||h===5;for(let h=0;h<=e.rows;h++)for(let l=0;l<e.cols;l++)if(c(e.hEdges[h][l].type)){f=!0;break}if(!f){for(let h=0;h<e.rows;h++)for(let l=0;l<=e.cols;l++)if(c(e.vEdges[h][l].type)){f=!0;break}}if(!f){for(let h=0;h<=e.rows;h++)for(let l=0;l<=e.cols;l++)if(i(e.nodes[h][l].type)){f=!0;break}}if(!f)return!1}if(n||a||o||r){let f=!1,c=!1,i=!1,h=!1,l=new Set,y=new Set;for(let d=0;d<e.rows;d++)for(let m=0;m<e.cols;m++){let x=e.cells[d][m].type;x===1&&(f=!0,l.add(e.cells[d][m].color)),x===2&&(c=!0,y.add(e.cells[d][m].color)),(x===3||x===4)&&(i=!0),x===5&&(h=!0)}if(n&&!f||a&&!c||o&&!i||r&&!h)return!1;if(n&&f&&l.size<2){let d=l.values().next().value;if(d===void 0||!y.has(d))return!1}}return!this.hasIsolatedMark(e)}generateTiling(e,t,s){let n=Math.min(...e.map(i=>i.x)),a=Math.min(...e.map(i=>i.y)),o=Math.max(...e.map(i=>i.x)),r=Math.max(...e.map(i=>i.y)),u=o-n+1,f=r-a+1,c=Array.from({length:f},()=>Array(u).fill(!1));for(let i of e)c[i.y-a][i.x-n]=!0;return this.tilingDfs(c,[],t,s)}tilingDfs(e,t,s,n){let a=-1,o=-1;for(let f=0;f<e.length;f++){for(let c=0;c<e[0].length;c++)if(e[f][c]){a=f,o=c;break}if(a!==-1)break}if(a===-1)return t;if(t.length>=s)return null;let r=n.difficulty??.5,u=[...this.TETRIS_SHAPES];this.shuffleArray(u),r>.6&&u.sort((f,c)=>this.getShapeArea(c)-this.getShapeArea(f));for(let f of u){let c=this.isRotationallyInvariant(f),i=c?[f]:this.getAllRotations(f);this.shuffleArray(i);for(let h of i){let l=[];for(let y=0;y<h.length;y++)for(let d=0;d<h[0].length;d++)h[y][d]&&l.push({r:y,c:d});for(let y of l){let d=a-y.r,m=o-y.c;if(this.canPlace(e,h,d,m)){this.placePiece(e,h,d,m,!1);let x=this.tilingDfs(e,[...t,{shape:h,displayShape:f,isRotated:!c&&Math.random()<.3+r*.6}],s,n);if(x)return x;this.placePiece(e,h,d,m,!0)}}}}return null}getShapeArea(e){let t=0;for(let s of e)for(let n of s)n&&t++;return t}isRotationallyInvariant(e){let t=this.getShapeArea(e);return t===1||t===4&&e.length===2&&e[0].length===2}getAllRotations(e){let t=[],s=new Set,n=e;for(let a=0;a<4;a++){let o=JSON.stringify(n);s.has(o)||(t.push(n),s.add(o)),n=this.rotate90(n)}return t}rotate90(e){let t=e.length,s=e[0].length,n=Array.from({length:s},()=>Array(t).fill(0));for(let a=0;a<t;a++)for(let o=0;o<s;o++)n[o][t-1-a]=e[a][o];return n}canPlace(e,t,s,n){for(let a=0;a<t.length;a++)for(let o=0;o<t[0].length;o++)if(t[a][o]){let r=s+a,u=n+o;if(r<0||r>=e.length||u<0||u>=e[0].length||!e[r][u])return!1}return!0}placePiece(e,t,s,n,a){for(let o=0;o<t.length;o++)for(let r=0;r<t[0].length;r++)t[o][r]&&(e[s+o][n+r]=a)}shuffleArray(e){for(let t=e.length-1;t>0;t--){let s=Math.floor(Math.random()*(t+1));[e[t],e[s]]=[e[s],e[t]]}}};var te=class{bytes=[];cur=0;bit=0;write(e,t){for(let s=0;s<t;s++)e&1<<s&&(this.cur|=1<<this.bit),this.bit++,this.bit===8&&(this.bytes.push(this.cur),this.cur=0,this.bit=0)}finish(){return this.bit>0&&this.bytes.push(this.cur),new Uint8Array(this.bytes)}},ne=class{constructor(e){this.buf=e}i=0;bit=0;read(e){let t=0;for(let s=0;s<e;s++)this.buf[this.i]&1<<this.bit&&(t|=1<<s),this.bit++,this.bit===8&&(this.bit=0,this.i++);return t}};function he(X){let e=new Map;for(let t of X)for(let s of t)if(s.shape){let n=JSON.stringify(s.shape);e.has(n)||e.set(n,s.shape)}return[...e.values()]}var se=class{static async serialize(e,t){let s=new te;s.write(e.rows,6),s.write(e.cols,6),s.write(e.symmetry??0,2);let n=he(e.cells);s.write(n.length,5);for(let c of n){s.write(c.length,4),s.write(c[0].length,4);for(let i of c)for(let h of i)s.write(h,1)}let a=new Map;n.forEach((c,i)=>a.set(JSON.stringify(c),i));for(let c of e.cells)for(let i of c)s.write(i.type,3),s.write(i.color,3),i.shape?(s.write(1,1),s.write(a.get(JSON.stringify(i.shape)),5)):s.write(0,1);for(let c=0;c<e.rows;c++)for(let i=0;i<e.cols+1;i++)s.write(e.vEdges[c][i].type,3);for(let c=0;c<e.rows+1;c++)for(let i=0;i<e.cols;i++)s.write(e.hEdges[c][i].type,3);for(let c=0;c<e.rows+1;c++)for(let i=0;i<e.cols+1;i++)s.write(e.nodes[c][i].type,3);s.write(+!!t.useHexagons,1),s.write(+!!t.useSquares,1),s.write(+!!t.useStars,1),s.write(+!!t.useTetris,1),s.write(+!!t.useEraser,1),s.write(+!!t.useBrokenEdges,1),s.write(t.symmetry??0,2),s.write(Math.round((t.complexity??0)*254),8),s.write(Math.round((t.difficulty??0)*254),8),s.write(Math.round((t.pathLength??0)*254),8);let o=s.finish(),r=new Uint8Array(await new Response(new Blob([o.buffer]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()),u=0;for(let c of r)u^=c;let f=new Uint8Array(r.length+1);return f.set(r),f[r.length]=u,btoa(String.fromCharCode(...f)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}static async deserialize(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4;)t+="=";let s=atob(t),n=Uint8Array.from(s,H=>H.charCodeAt(0)),a=0;for(let H=0;H<n.length-1;H++)a^=n[H];if(a!==n.at(-1))throw new Error("Invalid parity data");let o=new Uint8Array(await new Response(new Blob([n.slice(0,-1).buffer]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer()),r=new ne(o),u=r.read(6),f=r.read(6),c=r.read(2),i=r.read(5),h=[];for(let H=0;H<i;H++){let I=r.read(4),T=r.read(4),E=[];for(let w=0;w<I;w++){let R=[];for(let A=0;A<T;A++)R.push(r.read(1));E.push(R)}h.push(E)}let l=[];for(let H=0;H<u;H++){let I=[];for(let T=0;T<f;T++){let E=r.read(3),w=r.read(3),R=r.read(1),A={type:E,color:w};R&&(A.shape=h[r.read(5)].map(F=>F.slice())),I.push(A)}l.push(I)}let y=Array.from({length:u},()=>Array.from({length:f+1},()=>({type:r.read(3)}))),d=Array.from({length:u+1},()=>Array.from({length:f},()=>({type:r.read(3)}))),m=Array.from({length:u+1},()=>Array.from({length:f+1},()=>({type:r.read(3)}))),x=()=>{let H=r.read(8);return Math.round(H/254*1e3)/1e3},p={},v=!!r.read(1),g=!!r.read(1),P=!!r.read(1),b=!!r.read(1),M=!!r.read(1),S=!!r.read(1),C=r.read(2);v&&(p.useHexagons=!0),g&&(p.useSquares=!0),P&&(p.useStars=!0),b&&(p.useTetris=!0),M&&(p.useEraser=!0),S&&(p.useBrokenEdges=!0),p.symmetry=C;let $=x(),z=x(),N=x();return $!==0&&(p.complexity=$),z!==0&&(p.difficulty=z),N!==0&&(p.pathLength=N),{puzzle:{rows:u,cols:f,cells:l,vEdges:y,hEdges:d,nodes:m,symmetry:c},options:p}}};var oe=class{canvas;ctx;puzzle=null;options;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;invalidatedCells=[];invalidatedEdges=[];invalidatedNodes=[];errorCells=[];errorEdges=[];errorNodes=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;canvasRect=null;constructor(e,t,s={}){if(typeof e=="string"){if(typeof document>"u")throw new Error("Cannot look up canvas by ID in a non-browser environment.");let a=document.getElementById(e);if(!(a instanceof HTMLCanvasElement))throw new Error(`Element with id "${e}" is not a canvas.`);this.canvas=a}else this.canvas=e;let n=this.canvas.getContext("2d");if(!n)throw new Error("Could not get 2D context.");this.ctx=n,this.ctx.imageSmoothingEnabled=!1,this.options=this.mergeOptions(s),t&&this.setPuzzle(t),this.initEvents(),this.animate()}mergeOptions(e){let t={blinkDuration:e.animations?.blinkDuration??this.options?.animations?.blinkDuration??1e3,fadeDuration:e.animations?.fadeDuration??this.options?.animations?.fadeDuration??1e3,blinkPeriod:e.animations?.blinkPeriod??this.options?.animations?.blinkPeriod??800},s={path:e.colors?.path??this.options?.colors?.path??"#ffcc00",error:e.colors?.error??this.options?.colors?.error??"#ff4444",success:e.colors?.success??this.options?.colors?.success??"#ffcc00",symmetry:e.colors?.symmetry??this.options?.colors?.symmetry??"rgba(255, 255, 255, 0.5)",interrupted:e.colors?.interrupted??this.options?.colors?.interrupted??"#ffcc00",grid:e.colors?.grid??this.options?.colors?.grid??"#555",node:e.colors?.node??this.options?.colors?.node??"#555",hexagon:e.colors?.hexagon??this.options?.colors?.hexagon??"#000",hexagonMain:e.colors?.hexagonMain??this.options?.colors?.hexagonMain??"#00ffff",hexagonSymmetry:e.colors?.hexagonSymmetry??this.options?.colors?.hexagonSymmetry??"#ffff00",colorMap:e.colors?.colorMap??this.options?.colors?.colorMap??{[O.Black]:"#000",[O.White]:"#fff",[O.Red]:"#f00",[O.Blue]:"#00f",[O.None]:"#ffcc00"},colorList:e.colors?.colorList??this.options?.colors?.colorList};return{gridPadding:e.gridPadding??this.options?.gridPadding??60,cellSize:e.cellSize??this.options?.cellSize??80,nodeRadius:e.nodeRadius??this.options?.nodeRadius??6,startNodeRadius:e.startNodeRadius??this.options?.startNodeRadius??22,pathWidth:e.pathWidth??this.options?.pathWidth??18,exitLength:e.exitLength??this.options?.exitLength??25,autoResize:e.autoResize??this.options?.autoResize??!0,blinkMarksOnError:e.blinkMarksOnError??this.options?.blinkMarksOnError??!0,stayPathOnError:e.stayPathOnError??this.options?.stayPathOnError??!0,animations:t,colors:s,onPathComplete:e.onPathComplete??this.options?.onPathComplete??(()=>{})}}setPuzzle(e){this.puzzle=e,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw()}setOptions(e){this.options=this.mergeOptions({...this.options,...e}),this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}setValidationResult(e,t=[],s=[],n=[],a=[],o=[],r=[]){this.invalidatedCells=t,this.invalidatedEdges=s,this.invalidatedNodes=o,this.errorCells=n,this.errorEdges=a,this.errorNodes=r,this.eraserAnimationStartTime=Date.now(),e?(this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0}resizeCanvas(){!this.puzzle||!this.canvas||(this.canvas.width=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,this.canvas.height=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2)}setCanvasRect(e){this.canvasRect=e}initEvents(){typeof window>"u"||!(this.canvas instanceof HTMLCanvasElement)||(this.canvas.addEventListener("mousedown",e=>this.handleStart(e)),window.addEventListener("mousemove",e=>this.handleMove(e)),window.addEventListener("mouseup",e=>this.handleEnd(e)),this.canvas.addEventListener("touchstart",e=>{this.handleStart(e.touches[0])&&e.preventDefault()},{passive:!1}),window.addEventListener("touchmove",e=>{this.isDrawing&&e.preventDefault(),this.handleMove(e.touches[0])},{passive:!1}),window.addEventListener("touchend",e=>{this.isDrawing&&e.preventDefault(),this.handleEnd(e.changedTouches[0])},{passive:!1}))}getCanvasCoords(e,t){return{x:this.options.gridPadding+e*this.options.cellSize,y:this.options.gridPadding+t*this.options.cellSize}}getExitDir(e,t){return!this.puzzle||this.puzzle.nodes[t]?.[e]?.type!==2?null:e===this.puzzle.cols?{x:1,y:0}:e===0?{x:-1,y:0}:t===0?{x:0,y:-1}:t===this.puzzle.rows?{x:0,y:1}:{x:1,y:0}}handleStart(e){if(!this.puzzle)return!1;let t=this.canvasRect||(this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),s=(e.clientX-t.left)*(this.canvas.width/t.width),n=(e.clientY-t.top)*(this.canvas.height/t.height);for(let a=0;a<=this.puzzle.rows;a++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[a][o].type===1){let r=this.getCanvasCoords(o,a);if(Math.hypot(r.x-s,r.y-n)<this.options.startNodeRadius)return this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.isDrawing=!0,this.path=[{x:o,y:a}],this.currentMousePos=r,this.exitTipPos=null,this.draw(),!0}return!1}handleMove(e){if(!this.puzzle||!this.isDrawing)return;let t=this.canvasRect||(this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),s=(e.clientX-t.left)*(this.canvas.width/t.width),n=(e.clientY-t.top)*(this.canvas.height/t.height),a=this.path[this.path.length-1],o=this.getCanvasCoords(a.x,a.y),r=s-o.x,u=n-o.y,f=this.puzzle.symmetry||0,c=this.getExitDir(a.x,a.y),i=Math.abs(r)>Math.abs(u)?{x:r>0?1:-1,y:0}:{x:0,y:u>0?1:-1};if(c&&i.x===c.x&&i.y===c.y){let d=r*c.x+u*c.y,m=Math.max(0,Math.min(d,this.options.exitLength));this.currentMousePos={x:o.x+c.x*m,y:o.y+c.y*m},this.draw();return}let h=(d,m)=>{let x=this.getEdgeType(a,d);if(d.x<0||d.x>this.puzzle.cols||d.y<0||d.y>this.puzzle.rows||x===2){this.currentMousePos=o;return}let p=x===1?this.options.cellSize*.35:this.options.cellSize,v=this.getEdgeKey(a,d);if(!(this.path.length>=2&&d.x===this.path[this.path.length-2].x&&d.y===this.path[this.path.length-2].y)){for(let b=0;b<this.path.length-1;b++)if(this.getEdgeKey(this.path[b],this.path[b+1])===v){p=0;break}}if(this.path.some(b=>b.x===d.x&&b.y===d.y)&&this.path.length>=2){let b=this.path[this.path.length-2];(d.x!==b.x||d.y!==b.y)&&(p=Math.min(p,this.options.cellSize*.5-this.options.pathWidth*.5))}if(f!==0){let b=this.getSymmetricalPoint(a),M=this.getSymmetricalPoint(d),S=this.getEdgeType(b,M),C=this.getSymmetryPath(this.path),$=this.getEdgeKey(b,M);if(M.x<0||M.x>this.puzzle.cols||M.y<0||M.y>this.puzzle.rows||S===2){this.currentMousePos=o;return}S===1&&(p=Math.min(p,this.options.cellSize*.35));let z=C.some(w=>w.x===d.x&&w.y===d.y),N=this.path.some(w=>w.x===M.x&&w.y===M.y),H=d.x===M.x&&d.y===M.y,I=C.some((w,R)=>R<C.length-1&&this.getEdgeKey(C[R],C[R+1])===v),T=this.path.some((w,R)=>R<this.path.length-1&&this.getEdgeKey(this.path[R],this.path[R+1])===$);(z||N||H||I||T||v===$)&&(p=Math.min(p,this.options.cellSize*.5-this.options.pathWidth*.5))}d.x!==a.x?this.currentMousePos={x:o.x+Math.max(-p,Math.min(p,m)),y:o.y}:this.currentMousePos={x:o.x,y:o.y+Math.max(-p,Math.min(p,m))}};if(Math.abs(r)>Math.abs(u)){let d=r>0?1:-1;h({x:a.x+d,y:a.y},r)}else{let d=u>0?1:-1;h({x:a.x,y:a.y+d},u)}let l=[{x:a.x+1,y:a.y},{x:a.x-1,y:a.y},{x:a.x,y:a.y+1},{x:a.x,y:a.y-1}],y=this.getSymmetryPath(this.path);for(let d of l)if(d.x>=0&&d.x<=this.puzzle.cols&&d.y>=0&&d.y<=this.puzzle.rows){let m=this.getCanvasCoords(d.x,d.y);if(Math.hypot(m.x-this.currentMousePos.x,m.y-this.currentMousePos.y)<this.options.cellSize*.3){let p=this.path.findIndex(v=>v.x===d.x&&v.y===d.y);if(p===-1){if(f!==0){let v=this.getSymmetricalPoint(d);if(d.x===v.x&&d.y===v.y||this.path.some(b=>b.x===v.x&&b.y===v.y)||y.some(b=>b.x===d.x&&b.y===d.y))continue;let g=this.getEdgeKey(a,d),P=this.getEdgeKey(this.getSymmetricalPoint(a),v);if(g===P)continue}this.path.push(d)}else p===this.path.length-2&&this.path.pop()}}this.draw()}handleEnd(e){if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let t=this.path[this.path.length-1],s=this.getCanvasCoords(t.x,t.y),n=this.getExitDir(t.x,t.y);if(n){let a=this.currentMousePos.x-s.x,o=this.currentMousePos.y-s.y;if(a*n.x+o*n.y>0){this.exitTipPos={x:s.x+n.x*this.options.exitLength,y:s.y+n.y*this.options.exitLength},this.options.onPathComplete(this.path);return}}this.exitTipPos=n?{...this.currentMousePos}:null,this.startFade(this.options.colors.interrupted)}getEdgeType(e,t){if(!this.puzzle)return 2;if(e.x===t.x){let s=Math.min(e.y,t.y);return s<0||s>=this.puzzle.rows?2:this.puzzle.vEdges[s][e.x].type}else{let s=Math.min(e.x,t.x);return s<0||s>=this.puzzle.cols?2:this.puzzle.hEdges[e.y][s].type}}startFade(e="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=e,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){let e=Date.now();if(this.isFading){let t=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=t,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0)}this.isInvalidPath&&!this.options.stayPathOnError&&!this.isFading&&this.path.length>0&&this.startFade(this.options.colors.error),this.draw(),typeof requestAnimationFrame<"u"&&requestAnimationFrame(()=>this.animate())}draw(){if(!this.puzzle||!this.ctx)return;let e=this.ctx,t=Date.now();if(e.globalAlpha=1,e.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(e),this.drawConstraints(e),this.drawNodes(e),this.path.length===0&&!this.isDrawing&&this.drawRipples(e),this.isFading){if(this.drawPath(e,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let s=this.getSymmetryPath(this.fadingPath),n=this.options.colors.symmetry;if(this.isInvalidPath){let o=this.colorToRgba(n).a;n=this.setAlpha(this.options.colors.error,o)}let a=null;if(this.fadingTipPos){let o=(this.fadingTipPos.x-this.options.gridPadding)/this.options.cellSize,r=(this.fadingTipPos.y-this.options.gridPadding)/this.options.cellSize,u=this.getSymmetricalPoint({x:o,y:r});a={x:u.x*this.options.cellSize+this.options.gridPadding,y:u.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,s,!1,n,this.fadeOpacity,a)}}else if(this.path.length>0){let s=this.options.colors.path,n=this.colorToRgba(s).a,a=this.options.colors.error,o=this.isInvalidPath?this.setAlpha(a,n):s;this.isSuccessFading&&!this.puzzle.symmetry&&(o=this.setAlpha(this.options.colors.success,n));let r=1;if(!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let u=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),f=this.options.animations.blinkDuration;u<f&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(o=this.options.colors.error,this.options.stayPathOnError||(r=Math.max(0,1-u/this.options.animations.fadeDuration)))}if(this.drawPath(e,this.path,this.isDrawing,o,r,this.isDrawing?this.currentMousePos:this.exitTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let u=this.getSymmetryPath(this.path),f=this.options.colors.symmetry,c=this.colorToRgba(f).a,i=f,h=r;if(this.isInvalidPath&&(i=this.setAlpha(a,c)),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let y=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),d=this.options.animations.blinkDuration;y<d&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(i=this.options.colors.error)}let l=null;if(this.isDrawing||this.exitTipPos){let y=this.isDrawing?this.currentMousePos:this.exitTipPos,d=(y.x-this.options.gridPadding)/this.options.cellSize,m=(y.y-this.options.gridPadding)/this.options.cellSize,x=this.getSymmetricalPoint({x:d,y:m},!0);l={x:x.x*this.options.cellSize+this.options.gridPadding,y:x.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,u,this.isDrawing,i,h,l)}}}drawRipples(e){if(!this.puzzle)return;let t=(Date.now()-this.startTime)/500;for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++)if(this.puzzle.nodes[s][n].type===2){let o=this.getCanvasCoords(n,s),r=this.getExitDir(n,s);if(!r)continue;let u={x:o.x+r.x*this.options.exitLength,y:o.y+r.y*this.options.exitLength},f=t%4,c=f*5,i=Math.max(0,1-f/3);e.beginPath(),e.arc(u.x,u.y,c,0,Math.PI*2),e.strokeStyle=`rgba(170, 170, 170, ${i*.4})`,e.lineWidth=2,e.stroke()}}drawGrid(e){if(!this.puzzle||!this.options.colors.grid)return;e.strokeStyle=this.options.colors.grid,e.lineWidth=12,e.lineCap="round";let t=(s,n,a)=>{if(a!==2)if(a===1){let r={x:s.x+(n.x-s.x)*.35,y:s.y+(n.y-s.y)*.35},u={x:s.x+(n.x-s.x)*(.5+.15),y:s.y+(n.y-s.y)*(.5+.15)};e.beginPath(),e.moveTo(s.x,s.y),e.lineTo(r.x,r.y),e.stroke(),e.beginPath(),e.moveTo(u.x,u.y),e.lineTo(n.x,n.y),e.stroke()}else e.beginPath(),e.moveTo(s.x,s.y),e.lineTo(n.x,n.y),e.stroke()};for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<this.puzzle.cols;n++)t(this.getCanvasCoords(n,s),this.getCanvasCoords(n+1,s),this.puzzle.hEdges[s][n].type);for(let s=0;s<this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++)t(this.getCanvasCoords(n,s),this.getCanvasCoords(n,s+1),this.puzzle.vEdges[s][n].type)}drawConstraints(e){if(!this.puzzle)return;let t=Date.now(),s=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;for(let o=0;o<this.puzzle.rows;o++)for(let r=0;r<this.puzzle.cols;r++){let u=this.puzzle.cells[o][r],f=this.getCanvasCoords(r+.5,o+.5),c=this.invalidatedCells.some(m=>m.x===r&&m.y===o),i=this.errorCells.some(m=>m.x===r&&m.y===o),h=1,l,y=this.getColorCode(u.color),d=this.options.colors.error;if(i&&this.options.blinkMarksOnError&&(l=this.lerpColor(y,d,s)),c){let m=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),x=this.options.animations.blinkDuration;if(m<x){if(this.options.blinkMarksOnError){let p=Math.min(1,m/200),v=m>x*.8?(x-m)/(x*.2):1,g=Math.min(p,v);l=this.lerpColor(y,d,s*g)}}else h=Math.max(.3,1-(m-x)/this.options.animations.fadeDuration)}if(h<1||l){let{canvas:m,ctx:x}=this.prepareOffscreen();this.drawConstraintItem(x,u,f,l),e.save(),e.globalAlpha=h,e.drawImage(m,0,0),e.restore()}else this.drawConstraintItem(e,u,f)}e.lineWidth=2;let n=8,a=o=>o===3||o===3?this.options.colors.hexagon:o===4||o===4?this.options.colors.hexagonMain:o===5||o===5?this.options.colors.hexagonSymmetry:this.options.colors.hexagon;for(let o=0;o<=this.puzzle.rows;o++)for(let r=0;r<this.puzzle.cols;r++){let u=this.puzzle.hEdges[o][r].type;if(u===3||u===4||u===5){let f=this.getCanvasCoords(r+.5,o);e.save();let c=this.invalidatedEdges.some(l=>l.type==="h"&&l.r===o&&l.c===r),i=this.errorEdges.some(l=>l.type==="h"&&l.r===o&&l.c===r),h=a(u);if(i&&this.options.blinkMarksOnError){let l=this.lerpColor(h,this.options.colors.error,s);this.drawHexagon(e,f.x,f.y,n,l)}else if(c){let l=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),y=this.options.animations.blinkDuration;if(l<y)if(this.options.blinkMarksOnError){let d=Math.min(1,l/200),m=l>y*.8?(y-l)/(y*.2):1,x=Math.min(d,m),p=this.lerpColor(h,this.options.colors.error,s*x);this.drawHexagon(e,f.x,f.y,n,p)}else this.drawHexagon(e,f.x,f.y,n,h);else e.globalAlpha*=Math.max(.3,1-(l-y)/this.options.animations.fadeDuration),this.drawHexagon(e,f.x,f.y,n,h)}else this.drawHexagon(e,f.x,f.y,n,h);e.restore()}}for(let o=0;o<this.puzzle.rows;o++)for(let r=0;r<=this.puzzle.cols;r++){let u=this.puzzle.vEdges[o][r].type;if(u===3||u===4||u===5){let f=this.getCanvasCoords(r,o+.5);e.save();let c=this.invalidatedEdges.some(l=>l.type==="v"&&l.r===o&&l.c===r),i=this.errorEdges.some(l=>l.type==="v"&&l.r===o&&l.c===r),h=a(u);if(i&&this.options.blinkMarksOnError){let l=this.lerpColor(h,this.options.colors.error,s);this.drawHexagon(e,f.x,f.y,n,l)}else if(c){let l=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),y=this.options.animations.blinkDuration;if(l<y)if(this.options.blinkMarksOnError){let d=Math.min(1,l/200),m=l>y*.8?(y-l)/(y*.2):1,x=Math.min(d,m),p=this.lerpColor(h,this.options.colors.error,s*x);this.drawHexagon(e,f.x,f.y,n,p)}else this.drawHexagon(e,f.x,f.y,n,h);else e.globalAlpha*=Math.max(.3,1-(l-y)/this.options.animations.fadeDuration),this.drawHexagon(e,f.x,f.y,n,h)}else this.drawHexagon(e,f.x,f.y,n,h);e.restore()}}for(let o=0;o<=this.puzzle.rows;o++)for(let r=0;r<=this.puzzle.cols;r++){let u=this.puzzle.nodes[o][r].type;if(u===3||u===4||u===5){let f=this.getCanvasCoords(r,o);e.save();let c=this.invalidatedNodes.some(l=>l.x===r&&l.y===o),i=this.errorNodes.some(l=>l.x===r&&l.y===o),h=a(u);if(i&&this.options.blinkMarksOnError){let l=this.lerpColor(h,this.options.colors.error,s);this.drawHexagon(e,f.x,f.y,n,l)}else if(c){let l=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),y=this.options.animations.blinkDuration;if(l<y)if(this.options.blinkMarksOnError){let d=Math.min(1,l/200),m=l>y*.8?(y-l)/(y*.2):1,x=Math.min(d,m),p=this.lerpColor(h,this.options.colors.error,s*x);this.drawHexagon(e,f.x,f.y,n,p)}else this.drawHexagon(e,f.x,f.y,n,h);else e.globalAlpha*=Math.max(.3,1-(l-y)/this.options.animations.fadeDuration),this.drawHexagon(e,f.x,f.y,n,h)}else this.drawHexagon(e,f.x,f.y,n,h);e.restore()}}}drawConstraintItem(e,t,s,n){t.type===1?(e.fillStyle=n||this.getColorCode(t.color),this.drawRoundedRect(e,s.x-26/2,s.y-26/2,26,26,8)):t.type===2?this.drawStar(e,s.x,s.y,12,16,8,t.color,n):t.type===3||t.type===4?this.drawTetris(e,s.x,s.y,t.shape||[],t.type===4,t.color,n):t.type===5&&this.drawEraser(e,s.x,s.y,14,3,t.color,n)}drawNodes(e){if(!this.puzzle)return;let t=(s,n)=>{let a=[];return s>0&&a.push(this.puzzle.hEdges[n][s-1].type),s<this.puzzle.cols&&a.push(this.puzzle.hEdges[n][s].type),n>0&&a.push(this.puzzle.vEdges[n-1][s].type),n<this.puzzle.rows&&a.push(this.puzzle.vEdges[n][s].type),a.length>0&&a.every(o=>o===2)};for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++){if(t(n,s))continue;let a=this.puzzle.nodes[s][n];if(a.type===3||a.type===4||a.type===5)continue;let o=this.getCanvasCoords(n,s);if(a.type===1)this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill();else if(a.type===2){let r=this.getExitDir(n,s);if(!r)continue;this.options.colors.node&&(e.strokeStyle=this.options.colors.node),e.lineWidth=12,e.lineCap="round",e.beginPath(),e.moveTo(o.x,o.y),e.lineTo(o.x+r.x*this.options.exitLength,o.y+r.y*this.options.exitLength),e.stroke()}else this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.nodeRadius,0,Math.PI*2),e.fill()}}drawPath(e,t,s,n,a,o=null){if(t.length===0||!n||n==="transparent")return;let r=this.colorToRgba(n),u=`rgb(${r.r},${r.g},${r.b})`,f=a*r.a,{canvas:c,ctx:i}=this.prepareOffscreen();this.drawPathInternal(i,t,s,u,o),e.save(),e.globalAlpha=f,e.drawImage(c,0,0),e.restore()}drawPathInternal(e,t,s,n,a=null){e.save(),e.strokeStyle=n,e.fillStyle=n,e.lineWidth=this.options.pathWidth,e.lineCap="round",e.lineJoin="round",e.beginPath();let o=this.getCanvasCoords(t[0].x,t[0].y);e.moveTo(o.x,o.y);for(let u=1;u<t.length;u++){let f=this.getCanvasCoords(t[u].x,t[u].y);e.lineTo(f.x,f.y)}let r=a||this.currentMousePos;(s||a)&&e.lineTo(r.x,r.y),e.stroke(),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill(),(s||a)&&(e.beginPath(),e.arc(r.x,r.y,this.options.pathWidth/2,0,Math.PI*2),e.fill()),e.restore()}drawRoundedRect(e,t,s,n,a,o){e.beginPath(),e.moveTo(t+o,s),e.lineTo(t+n-o,s),e.quadraticCurveTo(t+n,s,t+n,s+o),e.lineTo(t+n,s+a-o),e.quadraticCurveTo(t+n,s+a,t+n-o,s+a),e.lineTo(t+o,s+a),e.quadraticCurveTo(t,s+a,t,s+a-o),e.lineTo(t,s+o),e.quadraticCurveTo(t,s,t+o,s),e.closePath(),e.fill()}drawHexagon(e,t,s,n,a){if(!(!this.options.colors.hexagon&&!a)){e.fillStyle=a||this.options.colors.hexagon,e.beginPath();for(let o=0;o<6;o++){let r=Math.PI/3*o,u=t+n*Math.cos(r),f=s+n*Math.sin(r);o===0?e.moveTo(u,f):e.lineTo(u,f)}e.closePath(),e.fill()}}drawEraser(e,t,s,n,a,o,r){e.strokeStyle=r||this.getColorCode(o),e.lineWidth=n*.5,e.lineCap="butt";let u=.5;e.beginPath();for(let f=0;f<a;f++){let c=Math.PI*2/a*f+u,i=t+n*Math.cos(c),h=s+n*Math.sin(c);e.moveTo(t,s),e.lineTo(i,h)}e.stroke()}drawStar(e,t,s,n,a,o,r,u){e.fillStyle=u||this.getColorCode(r),e.beginPath();for(let f=0;f<o*2;f++){let c=f%2===0?a:n,i=Math.PI/o*f,h=t+c*Math.cos(i),l=s+c*Math.sin(i);f===0?e.moveTo(h,l):e.lineTo(h,l)}e.closePath(),e.fill()}drawTetris(e,t,s,n,a,o,r){if(!n||n.length===0)return;let u=12,f=2,c=n[0].length*u+(n[0].length-1)*f,i=n.length*u+(n.length-1)*f;e.save(),e.translate(t,s),a&&e.rotate(Math.PI/8),e.fillStyle=r||this.getColorCode(o,"#ffcc00");for(let h=0;h<n.length;h++)for(let l=0;l<n[h].length;l++)if(n[h][l]){let y=l*(u+f)-c/2,d=h*(u+f)-i/2;e.fillRect(y,d,u,u)}e.restore()}getColorCode(e,t="#666"){return this.options.colors.colorList&&this.options.colors.colorList[e]!==void 0?this.options.colors.colorList[e]:this.options.colors.colorMap&&this.options.colors.colorMap[e]!==void 0?this.options.colors.colorMap[e]:t}colorToRgba(e){if(!e||e==="transparent")return{r:0,g:0,b:0,a:0};if(e.startsWith("rgba")||e.startsWith("rgb")){let s=e.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);if(s)return{r:parseInt(s[1]),g:parseInt(s[2]),b:parseInt(s[3]),a:s[4]?parseFloat(s[4]):1}}let t=e.startsWith("#")?e.slice(1):e;if((t.length===3||t.length===4)&&(t=t.split("").map(s=>s+s).join("")),t.length===6){let s=parseInt(t,16);return{r:s>>16&255,g:s>>8&255,b:s&255,a:1}}else if(t.length===8){let s=parseInt(t,16);return{r:s>>24&255,g:s>>16&255,b:s>>8&255,a:(s&255)/255}}return{r:0,g:0,b:0,a:1}}lerpColor(e,t,s){try{let n=this.colorToRgba(e),a=this.colorToRgba(t),o=Math.round(n.r+(a.r-n.r)*s),r=Math.round(n.g+(a.g-n.g)*s),u=Math.round(n.b+(a.b-n.b)*s),f=n.a+(a.a-n.a)*s;return`rgba(${o},${r},${u},${f})`}catch{return e}}setAlpha(e,t){let s=this.colorToRgba(e);return`rgba(${s.r},${s.g},${s.b},${t})`}getSymmetryPath(e){return!this.puzzle||!this.puzzle.symmetry?[]:e.map(t=>this.getSymmetricalPoint(t))}getSymmetricalPoint(e,t=!1){if(!this.puzzle||!this.puzzle.symmetry)return{...e};let{cols:s,rows:n,symmetry:a}=this.puzzle;return a===1?{x:s-e.x,y:e.y}:a===2?{x:e.x,y:n-e.y}:a===3?{x:s-e.x,y:n-e.y}:{...e}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}prepareOffscreen(){if(!this.offscreenCanvas){if(typeof document<"u")this.offscreenCanvas=document.createElement("canvas");else if(typeof OffscreenCanvas<"u")this.offscreenCanvas=new OffscreenCanvas(this.canvas.width,this.canvas.height);else throw new Error("Offscreen canvas not supported in this environment.");this.offscreenCtx=this.offscreenCanvas.getContext("2d")}if((this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),!this.offscreenCtx)throw new Error("Could not get offscreen 2D context.");return this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx}}};var re=class{generator;validator;constructor(){this.generator=new Z,this.validator=new Y}createPuzzle(e,t,s={}){return this.generator.generate(e,t,s).export()}validateSolution(e,t){let s=U.fromData(e);return this.validator.validate(s,t)}calculateDifficulty(e){let t=U.fromData(e);return this.validator.calculateDifficulty(t)}};export{j as CellType,O as Color,le as Direction,_ as EdgeType,U as Grid,Q as NodeType,Z as PuzzleGenerator,se as PuzzleSerializer,Y as PuzzleValidator,ee as SymmetryType,re as WitnessCore,oe as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
