/*!
 * MiniWitness 1.1.6
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var oe=(s=>(s[s.Up=0]="Up",s[s.Right=1]="Right",s[s.Down=2]="Down",s[s.Left=3]="Left",s))(oe||{}),U=(o=>(o[o.None=0]="None",o[o.Square=1]="Square",o[o.Star=2]="Star",o[o.Tetris=3]="Tetris",o[o.TetrisRotated=4]="TetrisRotated",o[o.Eraser=5]="Eraser",o))(U||{}),X=(s=>(s[s.Normal=0]="Normal",s[s.Broken=1]="Broken",s[s.Absent=2]="Absent",s[s.Hexagon=3]="Hexagon",s))(X||{}),Y=(s=>(s[s.Normal=0]="Normal",s[s.Start=1]="Start",s[s.End=2]="End",s[s.Hexagon=3]="Hexagon",s))(Y||{}),k={None:0,Black:1,White:2,Red:3,Blue:4};var W=class L{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:k.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes}))}static fromData(e){let t=new L(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t}};var K=class{validate(e,t){let n=t.points;if(n.length<2)return{isValid:!1,errorReason:"Path too short"};let s=n[0],a=n[n.length-1];if(e.nodes[s.y][s.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[a.y][a.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};let o=new Set;o.add(`${s.x},${s.y}`);for(let c=0;c<n.length-1;c++){let l=n[c],r=n[c+1];if(Math.abs(l.x-r.x)+Math.abs(l.y-r.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let d=`${r.x},${r.y}`;if(o.has(d))return{isValid:!1,errorReason:"Self-intersecting path"};if(o.add(d),this.isBrokenEdge(e,l,r))return{isValid:!1,errorReason:"Passed through broken edge"}}let i=this.calculateRegions(e,n),h=this.getMissedHexagons(e,n);return this.validateWithErasers(e,i,h.edges,h.nodes)}isBrokenEdge(e,t,n){let s;if(t.x===n.x){let a=Math.min(t.y,n.y);s=e.vEdges[a][t.x].type}else{let a=Math.min(t.x,n.x);s=e.hEdges[t.y][a].type}return s===1||s===2}isAbsentEdge(e,t,n){if(t.x===n.x){let s=Math.min(t.y,n.y);return e.vEdges[s][t.x].type===2}else{let s=Math.min(t.x,n.x);return e.hEdges[t.y][s].type===2}}getMissedHexagons(e,t){let n=new Set,s=new Set;for(let i=0;i<t.length;i++)s.add(`${t[i].x},${t[i].y}`),i<t.length-1&&n.add(this.getEdgeKey(t[i],t[i+1]));let a=[];for(let i=0;i<=e.rows;i++)for(let h=0;h<e.cols;h++)if(e.hEdges[i][h].type===3){let c=this.getEdgeKey({x:h,y:i},{x:h+1,y:i});n.has(c)||a.push({type:"h",r:i,c:h})}for(let i=0;i<e.rows;i++)for(let h=0;h<=e.cols;h++)if(e.vEdges[i][h].type===3){let c=this.getEdgeKey({x:h,y:i},{x:h,y:i+1});n.has(c)||a.push({type:"v",r:i,c:h})}let o=[];for(let i=0;i<=e.rows;i++)for(let h=0;h<=e.cols;h++)e.nodes[i][h].type===3&&(s.has(`${h},${i}`)||o.push({x:h,y:i}));return{edges:a,nodes:o}}validateWithErasers(e,t,n,s){let a=[],o=!0;for(let d=0;d<t.length;d++){let f=t[d],p=f.filter(b=>e.cells[b.y][b.x].type===5),y=f.filter(b=>e.cells[b.y][b.x].type!==0&&e.cells[b.y][b.x].type!==5),m=[];for(let b=0;b<n.length;b++)this.isHexagonAdjacentToRegion(e,n[b],f)&&m.push(b);let g=[];for(let b=0;b<s.length;b++)this.isNodeHexagonAdjacentToRegion(e,s[b],f)&&g.push(b);let E=this.getPossibleErasures(e,f,p,y,m,g);if(E.length===0){o=!1;let b=this.getBestEffortErasures(e,f,p,y,m,g);a.push([b])}else E.sort((b,M)=>{let N=b.invalidatedCells.length+b.invalidatedHexagons.length+b.invalidatedNodeHexagons.length,F=M.invalidatedCells.length+M.invalidatedHexagons.length+M.invalidatedNodeHexagons.length;return N-F}),a.push(E)}if(o){let d=this.findGlobalAssignment(a,n.length,s.length);if(d)return{isValid:!0,invalidatedCells:d.invalidatedCells,invalidatedEdges:d.invalidatedHexIndices.map(f=>n[f]),invalidatedNodes:d.invalidatedNodeHexIndices.map(f=>s[f])}}let i=[],h=[],c=new Set,l=new Set;for(let d of a){let f=d[0];i.push(...f.errorCells),h.push(...f.invalidatedCells);for(let p of f.invalidatedHexagons)c.add(p);for(let p of f.invalidatedNodeHexagons)l.add(p)}let r=[];for(let d=0;d<n.length;d++)c.has(d)||r.push(n[d]);let u=[];for(let d=0;d<s.length;d++)l.has(d)||u.push(s[d]);return{isValid:!1,errorReason:"Constraints failed",errorCells:i,errorEdges:r,errorNodes:u,invalidatedCells:h,invalidatedEdges:Array.from(c).map(d=>n[d]),invalidatedNodes:Array.from(l).map(d=>s[d])}}isHexagonAdjacentToRegion(e,t,n){let s=new Set(n.map(a=>`${a.x},${a.y}`));if(t.type==="h"){if(t.r>0&&s.has(`${t.c},${t.r-1}`)||t.r<e.rows&&s.has(`${t.c},${t.r}`))return!0}else if(t.c>0&&s.has(`${t.c-1},${t.r}`)||t.c<e.cols&&s.has(`${t.c},${t.r}`))return!0;return!1}isNodeHexagonAdjacentToRegion(e,t,n){let s=new Set(n.map(o=>`${o.x},${o.y}`)),a=[{x:t.x-1,y:t.y-1},{x:t.x,y:t.y-1},{x:t.x-1,y:t.y},{x:t.x,y:t.y}];for(let o of a)if(o.x>=0&&o.x<e.cols&&o.y>=0&&o.y<e.rows&&s.has(`${o.x},${o.y}`))return!0;return!1}getPossibleErasures(e,t,n,s,a,o){let i=[],h=n.length;if(h===0)return this.getRegionErrors(e,t,[]).length===0&&a.length===0&&o.length===0&&i.push({invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!0,errorCells:[]}),i;let c=[...s.map(r=>({type:"cell",pos:r})),...a.map(r=>({type:"hex",index:r})),...o.map(r=>({type:"nodeHex",index:r}))],l=this.getRegionErrors(e,t,[]).length===0&&a.length===0&&o.length===0;for(let r=0;r<=h;r++){let u=this.getNCombinations(n,r);for(let d of u){let f=new Set(d.map(y=>`${y.x},${y.y}`)),p=n.filter(y=>!f.has(`${y.x},${y.y}`));for(let y=0;y<=c.length;y++){if(p.length!==r+y)continue;let m=this.getNCombinations(c,y);for(let g of m){let E=g.filter(v=>v.type==="cell").map(v=>v.pos),b=g.filter(v=>v.type==="hex").map(v=>v.index),M=g.filter(v=>v.type==="nodeHex").map(v=>v.index);if(this.getRegionErrors(e,t,[...E,...d]).length===0){let v=!0;if(l)y>0&&(v=!1);else for(let $=0;$<g.length;$++){let z=[...g.slice(0,$),...g.slice($+1)],x=z.filter(w=>w.type==="cell").map(w=>w.pos),S=new Set(z.filter(w=>w.type==="hex").map(w=>w.index)),A=new Set(z.filter(w=>w.type==="nodeHex").map(w=>w.index)),P=a.every(w=>S.has(w)),D=o.every(w=>A.has(w));if(this.getRegionErrors(e,t,x).length===0&&P&&D){v=!1;break}}v&&i.push({invalidatedCells:[...E,...d],invalidatedHexagons:b,invalidatedNodeHexagons:M,isValid:!0,errorCells:[]})}}}}}return i}getBestEffortErasures(e,t,n,s,a,o){let i=this.getRegionErrors(e,t,[]);if(i.length===0&&a.length===0&&o.length===0)return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:[...n]};if(n.length>0){let l=[...s.map(f=>({type:"cell",pos:f})),...a.map(f=>({type:"hex",index:f})),...o.map(f=>({type:"nodeHex",index:f}))],r=null,u=1/0,d=f=>{let p=[],y=[],m=[],g=0;for(let v of f)g<n.length&&(v.type==="cell"?p.push(v.pos):v.type==="hex"?y.push(v.index):m.push(v.index),g++);let E=n.length-g,b=Math.floor(E/2),M=n.slice(g,g+b);g+=b*2;let N=this.getRegionErrors(e,t,[...p,...M]);for(let v=g;v<n.length;v++)N.push(n[v]);let F=N.length;F<u&&(u=F,r={invalidatedCells:[...p,...M],invalidatedHexagons:y,invalidatedNodeHexagons:m,isValid:!1,errorCells:N})};d([...i.map(f=>({type:"cell",pos:f})),...a.map(f=>({type:"hex",index:f})),...o.map(f=>({type:"nodeHex",index:f}))]),d(l);for(let f of i)d([{type:"cell",pos:f}]);if(r)return r}let c=[...i,...n];return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:c}}getNCombinations(e,t){let n=[],s=(a,o)=>{if(o.length===t){n.push([...o]);return}for(let i=a;i<e.length;i++)o.push(e[i]),s(i+1,o),o.pop()};return s(0,[]),n}checkRegionValid(e,t,n){return this.getRegionErrors(e,t,n).length===0}getRegionErrors(e,t,n){let s=new Set(n.map(r=>`${r.x},${r.y}`)),a=new Map,o=new Map,i=new Set,h=new Set,c=[];for(let r of t){if(s.has(`${r.x},${r.y}`))continue;let u=e.cells[r.y][r.x];if(u.type===0)continue;let d=u.color;d!==k.None&&(a.set(d,(a.get(d)||0)+1),o.has(d)||o.set(d,[]),o.get(d).push(r)),u.type===1?h.add(d):u.type===2?i.add(d):(u.type===3||u.type===4)&&u.shape&&c.push({shape:u.shape,rotatable:u.type===4,pos:r})}let l=[];if(h.size>1)for(let r of t)s.has(`${r.x},${r.y}`)||e.cells[r.y][r.x].type===1&&l.push(r);for(let r of i)if(a.get(r)!==2){let u=o.get(r)||[];for(let d of u)e.cells[d.y][d.x].type===2&&l.push(d)}if(c.length>0&&!this.checkTetrisConstraint(t,c.map(r=>({shape:r.shape,rotatable:r.rotatable}))))for(let r of c)l.push(r.pos);return l}findGlobalAssignment(e,t,n){let s=e.length,a=new Array(t).fill(0),o=new Array(n).fill(0),i=[],h=[],c=[],l=r=>{if(r===s)return a.every(u=>u===1)&&o.every(u=>u===1);for(let u of e[r]){let d=!0;for(let f of u.invalidatedHexagons)if(a[f]>0){d=!1;break}if(d){for(let f of u.invalidatedNodeHexagons)if(o[f]>0){d=!1;break}}if(d){for(let f of u.invalidatedHexagons)a[f]++,h.push(f);for(let f of u.invalidatedNodeHexagons)o[f]++,c.push(f);if(i.push(...u.invalidatedCells),l(r+1))return!0;for(let f of u.invalidatedHexagons)a[f]--,h.pop();for(let f of u.invalidatedNodeHexagons)o[f]--,c.pop();for(let f=0;f<u.invalidatedCells.length;f++)i.pop()}}return!1};return l(0)?{invalidatedCells:i,invalidatedHexIndices:h,invalidatedNodeHexIndices:c}:null}checkTetrisConstraint(e,t){if(t.reduce((r,u)=>r+this.getShapeArea(u.shape),0)!==e.length)return!1;let s=Math.min(...e.map(r=>r.x)),a=Math.min(...e.map(r=>r.y)),o=Math.max(...e.map(r=>r.x)),i=Math.max(...e.map(r=>r.y)),h=o-s+1,c=i-a+1,l=Array.from({length:c},()=>Array(h).fill(!1));for(let r of e)l[r.y-a][r.x-s]=!0;return this.canTile(l,t)}getShapeArea(e){let t=0;for(let n of e)for(let s of n)s&&t++;return t}canTile(e,t){let n=-1,s=-1;for(let a=0;a<e.length;a++){for(let o=0;o<e[0].length;o++)if(e[a][o]){n=a,s=o;break}if(n!==-1)break}if(n===-1)return t.length===0;if(t.length===0)return!1;for(let a=0;a<t.length;a++){let o=t[a],i=[...t.slice(0,a),...t.slice(a+1)],h=o.rotatable?this.getAllRotations(o.shape):[o.shape];for(let c of h){let l=[];for(let r=0;r<c.length;r++)for(let u=0;u<c[0].length;u++)c[r][u]&&l.push({r,c:u});for(let r of l){let u=n-r.r,d=s-r.c;if(this.canPlace(e,c,u,d)){if(this.placePiece(e,c,u,d,!1),this.canTile(e,i))return!0;this.placePiece(e,c,u,d,!0)}}}}return!1}canPlace(e,t,n,s){for(let a=0;a<t.length;a++)for(let o=0;o<t[0].length;o++)if(t[a][o]){let i=n+a,h=s+o;if(i<0||i>=e.length||h<0||h>=e[0].length||!e[i][h])return!1}return!0}placePiece(e,t,n,s,a){for(let o=0;o<t.length;o++)for(let i=0;i<t[0].length;i++)t[o][i]&&(e[n+o][s+i]=a)}getAllRotations(e){let t=[],n=new Set,s=e;for(let a=0;a<4;a++){let o=JSON.stringify(s);n.has(o)||(t.push(s),n.add(o)),s=this.rotate90(s)}return t}rotate90(e){let t=e.length,n=e[0].length,s=Array.from({length:n},()=>Array(t).fill(0));for(let a=0;a<t;a++)for(let o=0;o<n;o++)s[o][t-1-a]=e[a][o];return s}calculateRegions(e,t){let n=[],s=new Set,a=new Set;for(let i=0;i<t.length-1;i++)a.add(this.getEdgeKey(t[i],t[i+1]));let o=this.getExternalCells(e);for(let i=0;i<e.rows;i++)for(let h=0;h<e.cols;h++){if(s.has(`${h},${i}`)||o.has(`${h},${i}`))continue;let c=[],l=[{x:h,y:i}];for(s.add(`${h},${i}`);l.length>0;){let r=l.shift();c.push(r);let u=[{nx:r.x,ny:r.y-1,p1:{x:r.x,y:r.y},p2:{x:r.x+1,y:r.y}},{nx:r.x,ny:r.y+1,p1:{x:r.x,y:r.y+1},p2:{x:r.x+1,y:r.y+1}},{nx:r.x-1,ny:r.y,p1:{x:r.x,y:r.y},p2:{x:r.x,y:r.y+1}},{nx:r.x+1,ny:r.y,p1:{x:r.x+1,y:r.y},p2:{x:r.x+1,y:r.y+1}}];for(let d of u)if(d.nx>=0&&d.nx<e.cols&&d.ny>=0&&d.ny<e.rows){let f=`${d.nx},${d.ny}`;if(!s.has(f)&&!o.has(f)){let p=this.getEdgeKey(d.p1,d.p2);!a.has(p)&&!this.isAbsentEdge(e,d.p1,d.p2)&&(s.add(f),l.push({x:d.nx,y:d.ny}))}}}n.push(c)}return n}getExternalCells(e){let t=new Set,n=[];for(let s=0;s<e.cols;s++)e.hEdges[0][s].type===2&&(t.has(`${s},0`)||(t.add(`${s},0`),n.push({x:s,y:0}))),e.hEdges[e.rows][s].type===2&&(t.has(`${s},${e.rows-1}`)||(t.add(`${s},${e.rows-1}`),n.push({x:s,y:e.rows-1})));for(let s=0;s<e.rows;s++)e.vEdges[s][0].type===2&&(t.has(`0,${s}`)||(t.add(`0,${s}`),n.push({x:0,y:s}))),e.vEdges[s][e.cols].type===2&&(t.has(`${e.cols-1},${s}`)||(t.add(`${e.cols-1},${s}`),n.push({x:e.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),a=[{nx:s.x,ny:s.y-1,edge:e.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:e.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:e.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:e.vEdges[s.y][s.x+1]}];for(let o of a)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return t}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}calculateDifficulty(e){let t=e.rows,n=e.cols,s=n+1,a=(t+1)*s,o=Array.from({length:a},()=>[]),i=[],h=[],c=new Set,l=new Set;for(let x=0;x<=t;x++)for(let S=0;S<=n;S++){let A=x*s+S;if(e.nodes[x][S].type===1&&i.push(A),e.nodes[x][S].type===2&&h.push(A),e.nodes[x][S].type===3&&l.add(A),S<n){let P=A+1,D=e.hEdges[x][S].type,w=D===3,T=D===1||D===2;o[A].push({next:P,isHexagon:w,isBroken:T}),o[P].push({next:A,isHexagon:w,isBroken:T}),w&&c.add(this.getEdgeKey({x:S,y:x},{x:S+1,y:x}))}if(x<t){let P=A+s,D=e.vEdges[x][S].type,w=D===3,T=D===1||D===2;o[A].push({next:P,isHexagon:w,isBroken:T}),o[P].push({next:A,isHexagon:w,isBroken:T}),w&&c.add(this.getEdgeKey({x:S,y:x},{x:S,y:x+1}))}}let r={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},u=c.size+l.size,d=new Set,f=Math.max(1e3,t*n*200);for(let x of i){let S=l.has(x)?1:0;this.exploreSearchSpace(e,x,1n<<BigInt(x),[x],S,u,o,h,d,r,f)}if(r.solutions===0)return 0;let p=c.size+l.size,y=new Set;c.size>0&&y.add(999);let m=0,g=0;for(let x=0;x<t;x++)for(let S=0;S<n;S++){let A=e.cells[x][S];A.type!==0&&(p++,y.add(A.type),A.type===3?m++:A.type===4&&(m++,g++))}let E=r.branchingPoints/(r.totalNodesVisited||1),b=Math.log10(r.totalNodesVisited+1),M=(E*10+b*1.5)/(Math.log2(r.solutions+1)*.5+1);M-=c.size*.05,M+=l.size*.12,m>0&&(M+=g*.5,M+=(m-g)*.2);let N=t*n,F=p/N,v=F<.25?Math.pow(F/.25,4):1,$=y.size<=1?.5:1;M*=v*$;let z=Math.log2(N)/5;return M*=z,Math.max(.01,Math.min(1,M/4))}exploreSearchSpace(e,t,n,s,a,o,i,h,c,l,r){if(l.totalNodesVisited++,l.maxDepth=Math.max(l.maxDepth,s.length),l.totalNodesVisited>r)return;if(h.includes(t)){if(a===o){let f={points:s.map(p=>({x:p%(e.cols+1),y:Math.floor(p/(e.cols+1))}))};if(this.validate(e,f).isValid){let p=this.getFingerprint(e,f.points);c.has(p)||(c.add(p),l.solutions++)}}return}if(!this.canReachEndOptimized(t,n,i,h)){l.backtracks++;return}let u=[];for(let f of i[t]){if(f.isBroken||n&1n<<BigInt(f.next))continue;let p=!0;for(let y of i[t])if(y.isHexagon){let m=s.length>=2&&y.next===s[s.length-2],g=y.next===f.next;if(!m&&!g){p=!1;break}}p&&u.push(f)}if(u.length>1&&l.branchingPoints++,e.rows*e.cols>30)for(let f=u.length-1;f>0;f--){let p=Math.floor(Math.random()*(f+1));[u[f],u[p]]=[u[p],u[f]]}let d=e.cols+1;for(let f of u){let p=e.nodes[Math.floor(f.next/d)][f.next%d].type===3?1:0;if(s.push(f.next),this.exploreSearchSpace(e,f.next,n|1n<<BigInt(f.next),s,a+(f.isHexagon?1:0)+p,o,i,h,c,l,r),s.pop(),l.totalNodesVisited>r)return}}countSolutions(e,t=100){let n=e.rows,s=e.cols,a=s+1,o=(n+1)*a,i=Array.from({length:o},()=>[]),h=[],c=[],l=new Set,r=new Set;for(let f=0;f<=n;f++)for(let p=0;p<=s;p++){let y=f*a+p;if(e.nodes[f][p].type===1&&h.push(y),e.nodes[f][p].type===2&&c.push(y),e.nodes[f][p].type===3&&r.add(y),p<s){let m=y+1,g=e.hEdges[f][p].type,E=g===3,b=g===1||g===2;i[y].push({next:m,isHexagon:E,isBroken:b}),i[m].push({next:y,isHexagon:E,isBroken:b}),E&&l.add(this.getEdgeKey({x:p,y:f},{x:p+1,y:f}))}if(f<n){let m=y+a,g=e.vEdges[f][p].type,E=g===3,b=g===1||g===2;i[y].push({next:m,isHexagon:E,isBroken:b}),i[m].push({next:y,isHexagon:E,isBroken:b}),E&&l.add(this.getEdgeKey({x:p,y:f},{x:p,y:f+1}))}}let u=new Set,d=l.size+r.size;for(let f of h){let p=r.has(f)?1:0;this.findPathsOptimized(e,f,1n<<BigInt(f),[f],p,d,i,c,u,t)}return u.size}findPathsOptimized(e,t,n,s,a,o,i,h,c,l){if(!(c.size>=l)){if(h.includes(t)){if(a===o){let r={points:s.map(u=>({x:u%(e.cols+1),y:Math.floor(u/(e.cols+1))}))};this.validate(e,r).isValid&&c.add(this.getFingerprint(e,r.points))}return}if(this.canReachEndOptimized(t,n,i,h))for(let r of i[t]){if(r.isBroken||n&1n<<BigInt(r.next))continue;let u=!0;for(let p of i[t])if(p.isHexagon){let y=s.length>=2&&p.next===s[s.length-2],m=p.next===r.next;if(!y&&!m){u=!1;break}}if(!u)continue;let d=e.cols+1,f=e.nodes[Math.floor(r.next/d)][r.next%d].type===3?1:0;if(s.push(r.next),this.findPathsOptimized(e,r.next,n|1n<<BigInt(r.next),s,a+(r.isHexagon?1:0)+f,o,i,h,c,l),s.pop(),c.size>=l)return}}}canReachEndOptimized(e,t,n,s){let a=[e],o=t,i=0;for(;i<a.length;){let h=a[i++];if(s.includes(h))return!0;for(let c of n[h])!c.isBroken&&!(o&1n<<BigInt(c.next))&&(o|=1n<<BigInt(c.next),a.push(c.next))}return!1}getFingerprint(e,t){return this.calculateRegions(e,t).map(a=>a.map(i=>e.cells[i.y][i.x]).filter(i=>i.type!==0).map(i=>`${i.type}:${i.color}`).sort().join(",")).sort().filter(a=>a.length>0).join("|")||"empty"}};var J=class{generate(e,t,n={}){let s=n.difficulty??.5,a=new K,o=null,i=-1,h=e*t>30?50:80,c=5,l={x:0,y:e},r={x:t,y:0},u=null;for(let d=0;d<h;d++){d%c===0&&(u=this.generateRandomPath(new W(e,t),l,r,n.pathLength));let f=this.generateFromPath(e,t,u,n);if(!this.checkAllRequestedConstraintsPresent(f,n))continue;let p=a.calculateDifficulty(f);if(p===0)continue;let y=Math.abs(p-s);if((o===null||y<Math.abs(i-s))&&(i=p,o=f),s>.8&&p>.8||y<.05)break}if(!o){let d=this.generateRandomPath(new W(e,t),l,r,n.pathLength);return this.generateFromPath(e,t,d,n)}return o}generateFromPath(e,t,n,s){let a=new W(e,t),o={x:0,y:e},i={x:t,y:0};return a.nodes[o.y][o.x].type=1,a.nodes[i.y][i.x].type=2,this.applyConstraintsBasedOnPath(a,n,s),s.useBrokenEdges&&this.applyBrokenEdges(a,n,s),this.cleanGrid(a),a}generateRandomPath(e,t,n,s){if(s===void 0)return this.generateSingleRandomPath(e,t,n);let a=e.rows+e.cols,o=(e.rows+1)*(e.cols+1)-1,i=a+s*(o-a),h=[],c=1/0,l=50;for(let r=0;r<l;r++){let u=this.generateSingleRandomPath(e,t,n,s),d=u.length-1,f=Math.abs(d-i);if(f<c&&(c=f,h=u),c<=1)break}return h}generateSingleRandomPath(e,t,n,s){let a=new Set,o=[],i=h=>{if(a.add(`${h.x},${h.y}`),o.push(h),h.x===n.x&&h.y===n.y)return!0;let c=this.getValidNeighbors(e,h,a);s!==void 0?c.sort((l,r)=>{let u=Math.abs(l.x-n.x)+Math.abs(l.y-n.y),d=Math.abs(r.x-n.x)+Math.abs(r.y-n.y);return(u-d)*(1-s*2)+(Math.random()-.5)*1.5}):this.shuffleArray(c);for(let l of c)if(i(l))return!0;return o.pop(),!1};return i(t),o}getValidNeighbors(e,t,n){let s=[],a=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of a){let i=t.x+o.x,h=t.y+o.y;i>=0&&i<=e.cols&&h>=0&&h<=e.rows&&(n.has(`${i},${h}`)||s.push({x:i,y:h}))}return s}applyBrokenEdges(e,t,n){let s=n.complexity??.5,a=new Set;for(let l=0;l<t.length-1;l++)a.add(this.getEdgeKey(t[l],t[l+1]));let o=[];for(let l=0;l<=e.rows;l++)for(let r=0;r<e.cols;r++){let u={x:r,y:l},d={x:r+1,y:l};a.has(this.getEdgeKey(u,d))||o.push({type:"h",r:l,c:r,p1:u,p2:d})}for(let l=0;l<e.rows;l++)for(let r=0;r<=e.cols;r++){let u={x:r,y:l},d={x:r,y:l+1};a.has(this.getEdgeKey(u,d))||o.push({type:"v",r:l,c:r,p1:u,p2:d})}this.shuffleArray(o);let i=Math.max(1,Math.floor(s*(e.rows*e.cols)/4)),h=0;for(let l of o){if(h>=i)break;l.type==="h"?e.hEdges[l.r][l.c].type=1:e.vEdges[l.r][l.c].type=1,h++}let c=!0;for(;c;){c=!1;for(let l=0;l<=e.rows;l++)for(let r=0;r<e.cols;r++)e.hEdges[l][r].type===1&&this.canBecomeAbsent(e,{type:"h",r:l,c:r})&&(e.hEdges[l][r].type=2,c=!0);for(let l=0;l<e.rows;l++)for(let r=0;r<=e.cols;r++)e.vEdges[l][r].type===1&&this.canBecomeAbsent(e,{type:"v",r:l,c:r})&&(e.vEdges[l][r].type=2,c=!0)}for(let l=0;l<=e.rows;l++)for(let r=0;r<=e.cols;r++){let u=[];if(r>0&&u.push({e:e.hEdges[l][r-1],type:"h",r:l,c:r-1}),r<e.cols&&u.push({e:e.hEdges[l][r],type:"h",r:l,c:r}),l>0&&u.push({e:e.vEdges[l-1][r],type:"v",r:l-1,c:r}),l<e.rows&&u.push({e:e.vEdges[l][r],type:"v",r:l,c:r}),u.length>0&&u.every(d=>d.e.type===1||d.e.type===2)&&u.every(d=>!this.isAdjacentToMark(e,d)))for(let d of u)d.e.type=2}}canBecomeAbsent(e,t){if(this.isAdjacentToMark(e,t))return!1;if(t.type==="h"){if(t.r===0||t.r===e.rows)return!0}else if(t.c===0||t.c===e.cols)return!0;let n=t.type==="h"?[{x:t.c,y:t.r},{x:t.c+1,y:t.r}]:[{x:t.c,y:t.r},{x:t.c,y:t.r+1}];for(let s of n){let a=[{type:"h",r:s.y,c:s.x-1},{type:"h",r:s.y,c:s.x},{type:"v",r:s.y-1,c:s.x},{type:"v",r:s.y,c:s.x}];for(let o of a)if(o.c>=0&&o.c<=e.cols&&o.r>=0&&o.r<=e.rows){if(o.type==="h"&&o.c<e.cols){if(e.hEdges[o.r][o.c].type===2)return!0}else if(o.type==="v"&&o.r<e.rows&&e.vEdges[o.r][o.c].type===2)return!0}}return!1}cleanGrid(e){let t=[];for(let o=0;o<=e.rows;o++)for(let i=0;i<=e.cols;i++)e.nodes[o][i].type===1&&t.push({x:i,y:o});let n=new Set,s=[...t];for(let o of t)n.add(`${o.x},${o.y}`);for(;s.length>0;){let o=s.shift(),i=[{nx:o.x,ny:o.y-1,edge:e.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:e.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:e.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:e.hEdges[o.y]?.[o.x]}];for(let h of i)h.edge&&h.edge.type!==2&&(n.has(`${h.nx},${h.ny}`)||(n.add(`${h.nx},${h.ny}`),s.push({x:h.nx,y:h.ny})))}for(let o=0;o<=e.rows;o++)for(let i=0;i<e.cols;i++)(!n.has(`${i},${o}`)||!n.has(`${i+1},${o}`))&&(e.hEdges[o][i].type=2);for(let o=0;o<e.rows;o++)for(let i=0;i<=e.cols;i++)(!n.has(`${i},${o}`)||!n.has(`${i},${o+1}`))&&(e.vEdges[o][i].type=2);let a=this.getExternalCells(e);for(let o of a){let[i,h]=o.split(",").map(Number);e.cells[h][i].type=0}}getExternalCells(e){let t=new Set,n=[];for(let s=0;s<e.cols;s++)e.hEdges[0][s].type===2&&(t.has(`${s},0`)||(t.add(`${s},0`),n.push({x:s,y:0}))),e.hEdges[e.rows][s].type===2&&(t.has(`${s},${e.rows-1}`)||(t.add(`${s},${e.rows-1}`),n.push({x:s,y:e.rows-1})));for(let s=0;s<e.rows;s++)e.vEdges[s][0].type===2&&(t.has(`0,${s}`)||(t.add(`0,${s}`),n.push({x:0,y:s}))),e.vEdges[s][e.cols].type===2&&(t.has(`${e.cols-1},${s}`)||(t.add(`${e.cols-1},${s}`),n.push({x:e.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),a=[{nx:s.x,ny:s.y-1,edge:e.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:e.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:e.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:e.vEdges[s.y][s.x+1]}];for(let o of a)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return t}isAdjacentToMark(e,t){if(t.type==="h"){if(t.r>0&&e.cells[t.r-1][t.c].type!==0||t.r<e.rows&&e.cells[t.r][t.c].type!==0)return!0}else if(t.c>0&&e.cells[t.r][t.c-1].type!==0||t.c<e.cols&&e.cells[t.r][t.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let t=0;t<e.rows;t++)for(let n=0;n<e.cols;n++){if(e.cells[t][n].type===0)continue;if([e.hEdges[t][n],e.hEdges[t+1][n],e.vEdges[t][n],e.vEdges[t][n+1]].every(a=>a.type===1||a.type===2))return!0}return!1}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,t,n){let s=n.complexity??.5,a=n.useHexagons??!0,o=n.useSquares??!0,i=n.useStars??!0,h=n.useTetris??!1,c=n.useEraser??!1,l=0,r=0,u=0,d=0,f=0,p=0,y=Math.floor(e.rows*e.cols*.45);if(a){let m=n.difficulty??.5;for(let g=0;g<t.length-1;g++){let b=this.getValidNeighbors(e,t[g],new Set).length>2,M=s*(m<.4?.6:.3);b&&(M=m<.4?M*1:M*.5),Math.random()<M&&(this.setEdgeHexagon(e,t[g],t[g+1]),l++)}for(let g=0;g<t.length;g++){let E=t[g];if(e.nodes[E.y][E.x].type!==0||this.hasIncidentHexagonEdge(e,E))continue;let b=s*(m>.6?.15:.05);Math.random()<b&&(e.nodes[E.y][E.x].type=3,l++)}if(l===0&&t.length>=2){let g=Math.floor(Math.random()*(t.length-1));this.setEdgeHexagon(e,t[g],t[g+1])}}if(o||i||h||c){let m=this.calculateRegions(e,t),g=n.availableColors??[k.Black,k.White,k.Red,k.Blue],E=n.defaultColors??{},b=(v,$)=>{if(E[v]!==void 0)return E[v];let z=U[v];return z&&E[z]!==void 0?E[z]:$},M=Array.from({length:m.length},(v,$)=>$);this.shuffleArray(M);let N=new Set,F={square:o,star:i,tetris:h,eraser:c};for(let v=0;v<M.length;v++){let $=M[v],z=m[$],x=M.length-v,S=F.square&&r===0||F.star&&u===0||F.tetris&&d===0||F.eraser&&f===0,A=.2+s*.6;if(S&&x<=3?A=1:S&&x<=6&&(A=.7),Math.random()>A)continue;let P=[...z];this.shuffleArray(P);let D=g[Math.floor(Math.random()*g.length)];if(o&&!i&&x<=2&&N.size===1){let T=g.filter(q=>!N.has(q));T.length>0&&(D=T[Math.floor(Math.random()*T.length)])}let w=o&&Math.random()<.5+s*.3;if(o&&r===0&&x<=2&&(w=!0),o&&!i&&x<=2&&N.size<2&&r>0&&(w=!0),w&&P.length>0){let T=Math.min(P.length,Math.max(4,Math.floor(z.length/4))),q=Math.floor(Math.random()*(T/2))+Math.ceil(T/2);for(let I=0;I<q&&P.length!==0;I++){let O=P.pop();e.cells[O.y][O.x].type=1,e.cells[O.y][O.x].color=D,r++,N.add(D)}}if(h&&p<y){let T=Math.random()<.1+s*.4;d===0&&x<=2&&(T=!0);let q=d===0&&x<=2?6:4;if(T&&P.length>0&&z.length<=q*4&&p+z.length<=y){let I=this.generateTiling(z,q,n);if(I){for(let O of I){if(P.length===0)break;let R=P.pop();e.cells[R.y][R.x].type=O.isRotated?4:3,e.cells[R.y][R.x].shape=O.isRotated?O.displayShape:O.shape;let B=b(3,k.None);if(i&&Math.random()<.5){let C=g.filter(H=>H!==k.Blue&&H!==B);C.length>0&&(B=C[Math.floor(Math.random()*C.length)])}e.cells[R.y][R.x].color=B,d++}p+=z.length}}}if(c&&f<1){let T=.05+s*.2,q=Math.random()<T;if(x<=2&&(q=!0),q&&P.length>=1){let I=[];i&&I.push("star"),o&&I.push("square");let O=[];a&&(O=this.getRegionBoundaryEdges(e,z,t),O.length>0&&I.push("hexagon")),h&&I.push("tetris");let R=I.length>0?I[Math.floor(Math.random()*I.length)]:null;P.length>=2&&(!R||Math.random()<.01)&&(R="eraser");let B=!1;if(R==="hexagon"){let C=O.filter(H=>!this.isEdgeAdjacentToHexagonNode(e,H));if(C.length>0){let H=C[Math.floor(Math.random()*C.length)];H.type==="h"?e.hEdges[H.r][H.c].type=3:e.vEdges[H.r][H.c].type=3,l++,B=!0}}else if(R==="square"&&P.length>=2){let C=P.pop();e.cells[C.y][C.x].type=1;let H=z.find(G=>e.cells[G.y][G.x].type===1),V=H?e.cells[H.y][H.x].color:void 0;e.cells[C.y][C.x].color=g.find(G=>G!==V)||k.Red,r++,B=!0}else if(R==="star"&&P.length>=2){let C=P.pop();e.cells[C.y][C.x].type=2,e.cells[C.y][C.x].color=g[Math.floor(Math.random()*g.length)],u++,B=!0}else if(R==="tetris"&&P.length>=2){let C=this.generateTiling(z,4,n),H=[];if(C&&C.length>0){let V=0;for(let G of C){let j=this.getShapeArea(G.shape);if(V+j<z.length)H.push(G),V+=j;else break}}if(H.length===0&&z.length>1&&(H=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),H.length>0){for(let V of H){if(P.length<2)break;let G=P.pop();e.cells[G.y][G.x].type=V.isRotated?4:3,e.cells[G.y][G.x].shape=V.isRotated?V.displayShape:V.shape;let j=k.None;if(i&&Math.random()<.3){let te=g.filter(ne=>ne!==k.Blue);j=te[Math.floor(Math.random()*te.length)]}e.cells[G.y][G.x].color=j,d++}B=!0}}else if(R==="eraser"&&P.length>=2){let C=P.pop();e.cells[C.y][C.x].type=5,e.cells[C.y][C.x].color=b(5,k.White),f++,B=!0}if(!B&&P.length>=2){let C=P.pop();e.cells[C.y][C.x].type=5,e.cells[C.y][C.x].color=b(5,k.White),f++,B=!0}if(B){let C=P.pop();e.cells[C.y][C.x].type=5;let H=b(5,k.White);if(i&&Math.random()<.4){let V=g.filter(G=>G!==H);V.length>0&&(H=V[Math.floor(Math.random()*V.length)])}e.cells[C.y][C.x].color=H,f++}}}if(i){let T=Math.max(1,Math.floor(z.length/8));for(let q=0;q<T;q++)for(let I of g){if(P.length<1)break;if(Math.random()>.3+s*.4)continue;let O=z.filter(R=>e.cells[R.y][R.x].color===I).length;if(O===1){let R=P.pop();e.cells[R.y][R.x].type=2,e.cells[R.y][R.x].color=I,u++}else if(O===0&&P.length>=2)for(let R=0;R<2;R++){let B=P.pop();e.cells[B.y][B.x].type=2,e.cells[B.y][B.x].color=I,u++}}}}if(o&&!i&&N.size<2){for(let v of m)if(v.every($=>e.cells[$.y][$.x].type===0)){let $=g.find(x=>!N.has(x))||k.White,z=v[Math.floor(Math.random()*v.length)];e.cells[z.y][z.x].type=1,e.cells[z.y][z.x].color=$,N.add($),r++;break}}}}calculateRegions(e,t){let n=[],s=new Set,a=new Set;for(let o=0;o<t.length-1;o++)a.add(this.getEdgeKey(t[o],t[o+1]));for(let o=0;o<e.rows;o++)for(let i=0;i<e.cols;i++){if(s.has(`${i},${o}`))continue;let h=[],c=[{x:i,y:o}];for(s.add(`${i},${o}`);c.length>0;){let l=c.shift();h.push(l);let r=[{dx:0,dy:-1,p1:{x:l.x,y:l.y},p2:{x:l.x+1,y:l.y}},{dx:0,dy:1,p1:{x:l.x,y:l.y+1},p2:{x:l.x+1,y:l.y+1}},{dx:-1,dy:0,p1:{x:l.x,y:l.y},p2:{x:l.x,y:l.y+1}},{dx:1,dy:0,p1:{x:l.x+1,y:l.y},p2:{x:l.x+1,y:l.y+1}}];for(let u of r){let d=l.x+u.dx,f=l.y+u.dy;d>=0&&d<e.cols&&f>=0&&f<e.rows&&!s.has(`${d},${f}`)&&!a.has(this.getEdgeKey(u.p1,u.p2))&&!this.isAbsentEdge(e,u.p1,u.p2)&&(s.add(`${d},${f}`),c.push({x:d,y:f}))}}n.push(h)}return n}isAbsentEdge(e,t,n){if(t.x===n.x){let s=Math.min(t.y,n.y);return e.vEdges[s][t.x].type===2}else{let s=Math.min(t.x,n.x);return e.hEdges[t.y][s].type===2}}getRegionBoundaryEdges(e,t,n){let s=new Set;for(let i=0;i<n.length-1;i++)s.add(this.getEdgeKey(n[i],n[i+1]));let a=[];for(let i of t){let h=[{type:"h",r:i.y,c:i.x},{type:"h",r:i.y+1,c:i.x},{type:"v",r:i.y,c:i.x},{type:"v",r:i.y,c:i.x+1}];for(let c of h){let l=c.type==="h"?{x:c.c,y:c.r}:{x:c.c,y:c.r},r=c.type==="h"?{x:c.c+1,y:c.r}:{x:c.c,y:c.r+1},u=this.getEdgeKey(l,r);!s.has(u)&&!this.isAbsentEdge(e,l,r)&&a.push(c)}}let o=new Map;for(let i of a)o.set(`${i.type},${i.r},${i.c}`,i);return Array.from(o.values())}setEdgeHexagon(e,t,n){t.x===n.x?e.vEdges[Math.min(t.y,n.y)][t.x].type=3:e.hEdges[t.y][Math.min(t.x,n.x)].type=3}hasIncidentHexagonEdge(e,t){return t.x>0&&e.hEdges[t.y][t.x-1].type===3||t.x<e.cols&&e.hEdges[t.y][t.x].type===3||t.y>0&&e.vEdges[t.y-1][t.x].type===3||t.y<e.rows&&e.vEdges[t.y][t.x].type===3}isEdgeAdjacentToHexagonNode(e,t){return t.type==="h"?e.nodes[t.r][t.c].type===3||e.nodes[t.r][t.c+1].type===3:e.nodes[t.r][t.c].type===3||e.nodes[t.r+1][t.c].type===3}checkAllRequestedConstraintsPresent(e,t){let n=t.useHexagons??!0,s=t.useSquares??!0,a=t.useStars??!0,o=t.useTetris??!1,i=t.useEraser??!1;if(t.useBrokenEdges??!1){let c=!1;for(let l=0;l<=e.rows;l++)for(let r=0;r<e.cols;r++)if(e.hEdges[l][r].type===1||e.hEdges[l][r].type===2){c=!0;break}if(!c){for(let l=0;l<e.rows;l++)for(let r=0;r<=e.cols;r++)if(e.vEdges[l][r].type===1||e.vEdges[l][r].type===2){c=!0;break}}if(!c)return!1}if(n){let c=!1;for(let l=0;l<=e.rows;l++)for(let r=0;r<e.cols;r++)if(e.hEdges[l][r].type===3){c=!0;break}if(!c){for(let l=0;l<e.rows;l++)for(let r=0;r<=e.cols;r++)if(e.vEdges[l][r].type===3){c=!0;break}}if(!c){for(let l=0;l<=e.rows;l++)for(let r=0;r<=e.cols;r++)if(e.nodes[l][r].type===3){c=!0;break}}if(!c)return!1}if(s||a||o||i){let c=!1,l=!1,r=!1,u=!1,d=new Set;for(let f=0;f<e.rows;f++)for(let p=0;p<e.cols;p++){let y=e.cells[f][p].type;y===1&&(c=!0,d.add(e.cells[f][p].color)),y===2&&(l=!0),(y===3||y===4)&&(r=!0),y===5&&(u=!0)}if(s&&!c||a&&!l||o&&!r||i&&!u||s&&c&&!l&&d.size<2)return!1}return!this.hasIsolatedMark(e)}generateTiling(e,t,n){let s=Math.min(...e.map(r=>r.x)),a=Math.min(...e.map(r=>r.y)),o=Math.max(...e.map(r=>r.x)),i=Math.max(...e.map(r=>r.y)),h=o-s+1,c=i-a+1,l=Array.from({length:c},()=>Array(h).fill(!1));for(let r of e)l[r.y-a][r.x-s]=!0;return this.tilingDfs(l,[],t,n)}tilingDfs(e,t,n,s){let a=-1,o=-1;for(let c=0;c<e.length;c++){for(let l=0;l<e[0].length;l++)if(e[c][l]){a=c,o=l;break}if(a!==-1)break}if(a===-1)return t;if(t.length>=n)return null;let i=s.difficulty??.5,h=[...this.TETRIS_SHAPES];this.shuffleArray(h),i>.6&&h.sort((c,l)=>this.getShapeArea(l)-this.getShapeArea(c));for(let c of h){let l=this.isRotationallyInvariant(c),r=l?[c]:this.getAllRotations(c);this.shuffleArray(r);for(let u of r){let d=[];for(let f=0;f<u.length;f++)for(let p=0;p<u[0].length;p++)u[f][p]&&d.push({r:f,c:p});for(let f of d){let p=a-f.r,y=o-f.c;if(this.canPlace(e,u,p,y)){this.placePiece(e,u,p,y,!1);let m=this.tilingDfs(e,[...t,{shape:u,displayShape:c,isRotated:!l&&Math.random()<.3+i*.6}],n,s);if(m)return m;this.placePiece(e,u,p,y,!0)}}}}return null}getShapeArea(e){let t=0;for(let n of e)for(let s of n)s&&t++;return t}isRotationallyInvariant(e){let t=this.getShapeArea(e);return t===1||t===4&&e.length===2&&e[0].length===2}getAllRotations(e){let t=[],n=new Set,s=e;for(let a=0;a<4;a++){let o=JSON.stringify(s);n.has(o)||(t.push(s),n.add(o)),s=this.rotate90(s)}return t}rotate90(e){let t=e.length,n=e[0].length,s=Array.from({length:n},()=>Array(t).fill(0));for(let a=0;a<t;a++)for(let o=0;o<n;o++)s[o][t-1-a]=e[a][o];return s}canPlace(e,t,n,s){for(let a=0;a<t.length;a++)for(let o=0;o<t[0].length;o++)if(t[a][o]){let i=n+a,h=s+o;if(i<0||i>=e.length||h<0||h>=e[0].length||!e[i][h])return!1}return!0}placePiece(e,t,n,s,a){for(let o=0;o<t.length;o++)for(let i=0;i<t[0].length;i++)t[o][i]&&(e[n+o][s+i]=a)}shuffleArray(e){for(let t=e.length-1;t>0;t--){let n=Math.floor(Math.random()*(t+1));[e[t],e[n]]=[e[n],e[t]]}}};var _=class{bytes=[];cur=0;bit=0;write(e,t){for(let n=0;n<t;n++)e&1<<n&&(this.cur|=1<<this.bit),this.bit++,this.bit===8&&(this.bytes.push(this.cur),this.cur=0,this.bit=0)}finish(){return this.bit>0&&this.bytes.push(this.cur),new Uint8Array(this.bytes)}},Q=class{constructor(e){this.buf=e}i=0;bit=0;read(e){let t=0;for(let n=0;n<e;n++)this.buf[this.i]&1<<this.bit&&(t|=1<<n),this.bit++,this.bit===8&&(this.bit=0,this.i++);return t}};function ie(L){let e=new Map;for(let t of L)for(let n of t)if(n.shape){let s=JSON.stringify(n.shape);e.has(s)||e.set(s,n.shape)}return[...e.values()]}var Z=class{static async serialize(e,t){let n=new _;n.write(e.rows,6),n.write(e.cols,6);let s=ie(e.cells);n.write(s.length,5);for(let l of s){n.write(l.length,4),n.write(l[0].length,4);for(let r of l)for(let u of r)n.write(u,1)}let a=new Map;s.forEach((l,r)=>a.set(JSON.stringify(l),r));for(let l of e.cells)for(let r of l)n.write(r.type,3),n.write(r.color,3),r.shape?(n.write(1,1),n.write(a.get(JSON.stringify(r.shape)),5)):n.write(0,1);for(let l=0;l<e.rows;l++)for(let r=0;r<e.cols+1;r++)n.write(e.vEdges[l][r].type,2);for(let l=0;l<e.rows+1;l++)for(let r=0;r<e.cols;r++)n.write(e.hEdges[l][r].type,2);for(let l=0;l<e.rows+1;l++)for(let r=0;r<e.cols+1;r++)n.write(e.nodes[l][r].type,2);n.write(+!!t.useHexagons,1),n.write(+!!t.useSquares,1),n.write(+!!t.useStars,1),n.write(+!!t.useTetris,1),n.write(+!!t.useEraser,1),n.write(+!!t.useBrokenEdges,1),n.write(Math.round((t.complexity??0)*254),8),n.write(Math.round((t.difficulty??0)*254),8),n.write(Math.round((t.pathLength??0)*254),8);let o=n.finish(),i=new Uint8Array(await new Response(new Blob([o.buffer]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()),h=0;for(let l of i)h^=l;let c=new Uint8Array(i.length+1);return c.set(i),c[i.length]=h,btoa(String.fromCharCode(...c)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}static async deserialize(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4;)t+="=";let n=atob(t),s=Uint8Array.from(n,x=>x.charCodeAt(0)),a=0;for(let x=0;x<s.length-1;x++)a^=s[x];if(a!==s.at(-1))throw new Error("Invalid parity data");let o=new Uint8Array(await new Response(new Blob([s.slice(0,-1).buffer]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer()),i=new Q(o),h=i.read(6),c=i.read(6),l=i.read(5),r=[];for(let x=0;x<l;x++){let S=i.read(4),A=i.read(4),P=[];for(let D=0;D<S;D++){let w=[];for(let T=0;T<A;T++)w.push(i.read(1));P.push(w)}r.push(P)}let u=[];for(let x=0;x<h;x++){let S=[];for(let A=0;A<c;A++){let P=i.read(3),D=i.read(3),w=i.read(1),T={type:P,color:D};w&&(T.shape=r[i.read(5)].map(q=>q.slice())),S.push(T)}u.push(S)}let d=Array.from({length:h},()=>Array.from({length:c+1},()=>({type:i.read(2)}))),f=Array.from({length:h+1},()=>Array.from({length:c},()=>({type:i.read(2)}))),p=Array.from({length:h+1},()=>Array.from({length:c+1},()=>({type:i.read(2)}))),y=()=>{let x=i.read(8);return Math.round(x/254*1e3)/1e3},m={},g=!!i.read(1),E=!!i.read(1),b=!!i.read(1),M=!!i.read(1),N=!!i.read(1),F=!!i.read(1);g&&(m.useHexagons=!0),E&&(m.useSquares=!0),b&&(m.useStars=!0),M&&(m.useTetris=!0),N&&(m.useEraser=!0),F&&(m.useBrokenEdges=!0);let v=y(),$=y(),z=y();return v!==0&&(m.complexity=v),$!==0&&(m.difficulty=$),z!==0&&(m.pathLength=z),{puzzle:{rows:h,cols:c,cells:u,vEdges:d,hEdges:f,nodes:p},options:m}}};var ee=class{canvas;ctx;puzzle=null;options;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;invalidatedCells=[];invalidatedEdges=[];invalidatedNodes=[];errorCells=[];errorEdges=[];errorNodes=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;constructor(e,t,n={}){if(typeof window>"u"){this.canvas={},this.ctx={},this.options=this.mergeOptions(n);return}if(typeof e=="string"){let a=document.getElementById(e);if(!(a instanceof HTMLCanvasElement))throw new Error(`Element with id "${e}" is not a canvas.`);this.canvas=a}else this.canvas=e;let s=this.canvas.getContext("2d");if(!s)throw new Error("Could not get 2D context.");this.ctx=s,this.ctx.imageSmoothingEnabled=!1,this.options=this.mergeOptions(n),t&&this.setPuzzle(t),this.initEvents(),this.animate()}mergeOptions(e){return{gridPadding:e.gridPadding??60,cellSize:e.cellSize??80,nodeRadius:e.nodeRadius??6,startNodeRadius:e.startNodeRadius??22,pathWidth:e.pathWidth??18,exitLength:e.exitLength??25,autoResize:e.autoResize??!0,animations:{blinkDuration:e.animations?.blinkDuration??1e3,fadeDuration:e.animations?.fadeDuration??1e3,blinkPeriod:e.animations?.blinkPeriod??800},colors:{path:e.colors?.path??"#ffcc00",error:e.colors?.error??"#ff4444",success:e.colors?.success??"#ffcc00",interrupted:e.colors?.interrupted??"#ffcc00",grid:e.colors?.grid??"#555",node:e.colors?.node??"#555",hexagon:e.colors?.hexagon??"#000",colorMap:e.colors?.colorMap??{[k.Black]:"#000",[k.White]:"#fff",[k.Red]:"#f00",[k.Blue]:"#00f",[k.None]:"#ffcc00"},colorList:e.colors?.colorList},onPathComplete:e.onPathComplete??(()=>{})}}setPuzzle(e){this.puzzle=e,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw()}setOptions(e){this.options=this.mergeOptions({...this.options,...e}),this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}setValidationResult(e,t=[],n=[],s=[],a=[],o=[],i=[]){this.invalidatedCells=t,this.invalidatedEdges=n,this.invalidatedNodes=o,this.errorCells=s,this.errorEdges=a,this.errorNodes=i,this.eraserAnimationStartTime=Date.now(),e?(this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0}resizeCanvas(){!this.puzzle||!this.canvas||(this.canvas.width=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,this.canvas.height=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2)}initEvents(){typeof window>"u"||(this.canvas.addEventListener("mousedown",e=>this.handleStart(e)),window.addEventListener("mousemove",e=>this.handleMove(e)),window.addEventListener("mouseup",e=>this.handleEnd(e)),this.canvas.addEventListener("touchstart",e=>{this.handleStart(e.touches[0])&&e.preventDefault()},{passive:!1}),window.addEventListener("touchmove",e=>{this.isDrawing&&e.preventDefault(),this.handleMove(e.touches[0])},{passive:!1}),window.addEventListener("touchend",e=>{this.isDrawing&&e.preventDefault(),this.handleEnd(e.changedTouches[0])},{passive:!1}))}getCanvasCoords(e,t){return{x:this.options.gridPadding+e*this.options.cellSize,y:this.options.gridPadding+t*this.options.cellSize}}getExitDir(e,t){return!this.puzzle||this.puzzle.nodes[t][e].type!==2?null:e===this.puzzle.cols?{x:1,y:0}:e===0?{x:-1,y:0}:t===0?{x:0,y:-1}:t===this.puzzle.rows?{x:0,y:1}:{x:1,y:0}}handleStart(e){if(!this.puzzle)return!1;let t=this.canvas.getBoundingClientRect(),n=(e.clientX-t.left)*(this.canvas.width/t.width),s=(e.clientY-t.top)*(this.canvas.height/t.height);for(let a=0;a<=this.puzzle.rows;a++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[a][o].type===1){let i=this.getCanvasCoords(o,a);if(Math.hypot(i.x-n,i.y-s)<this.options.startNodeRadius)return this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.isDrawing=!0,this.path=[{x:o,y:a}],this.currentMousePos=i,this.exitTipPos=null,this.draw(),!0}return!1}handleMove(e){if(!this.puzzle||!this.isDrawing)return;let t=this.canvas.getBoundingClientRect(),n=(e.clientX-t.left)*(this.canvas.width/t.width),s=(e.clientY-t.top)*(this.canvas.height/t.height),a=this.path[this.path.length-1],o=this.getCanvasCoords(a.x,a.y),i=n-o.x,h=s-o.y,c=this.getExitDir(a.x,a.y);if(c){let r=i*c.x+h*c.y;if(r>0){let u=Math.min(r,this.options.exitLength);this.currentMousePos={x:o.x+c.x*u,y:o.y+c.y*u},this.draw();return}}if(Math.abs(i)>Math.abs(h)){let r=i>0?1:-1,u={x:a.x+r,y:a.y},d=this.getEdgeType(a,u);if(u.x>=0&&u.x<=this.puzzle.cols&&d!==2){let f=d===1?this.options.cellSize*.35:this.options.cellSize;this.currentMousePos={x:o.x+Math.max(-f,Math.min(f,i)),y:o.y}}else this.currentMousePos=o}else{let r=h>0?1:-1,u={x:a.x,y:a.y+r},d=this.getEdgeType(a,u);if(u.y>=0&&u.y<=this.puzzle.rows&&d!==2){let f=d===1?this.options.cellSize*.35:this.options.cellSize;this.currentMousePos={x:o.x,y:o.y+Math.max(-f,Math.min(f,h))}}else this.currentMousePos=o}let l=[{x:a.x+1,y:a.y},{x:a.x-1,y:a.y},{x:a.x,y:a.y+1},{x:a.x,y:a.y-1}];for(let r of l)if(r.x>=0&&r.x<=this.puzzle.cols&&r.y>=0&&r.y<=this.puzzle.rows){let u=this.getCanvasCoords(r.x,r.y);if(Math.hypot(u.x-this.currentMousePos.x,u.y-this.currentMousePos.y)<this.options.cellSize*.3){let f=this.path.findIndex(p=>p.x===r.x&&p.y===r.y);f===-1?this.path.push(r):f===this.path.length-2&&this.path.pop()}}this.draw()}handleEnd(e){if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let t=this.path[this.path.length-1],n=this.getCanvasCoords(t.x,t.y),s=this.getExitDir(t.x,t.y);if(s&&Math.hypot(this.currentMousePos.x-n.x,this.currentMousePos.y-n.y)>this.options.exitLength*.1){this.exitTipPos={...this.currentMousePos},this.options.onPathComplete(this.path);return}this.exitTipPos=s?{...this.currentMousePos}:null,this.startFade(this.options.colors.interrupted)}getEdgeType(e,t){if(!this.puzzle)return 2;if(e.x===t.x){let n=Math.min(e.y,t.y);return n<0||n>=this.puzzle.rows?2:this.puzzle.vEdges[n][e.x].type}else{let n=Math.min(e.x,t.x);return n<0||n>=this.puzzle.cols?2:this.puzzle.hEdges[e.y][n].type}}startFade(e="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=e,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){if(!(typeof window>"u")){if(this.draw(),this.isFading){let e=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=e,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0)}requestAnimationFrame(()=>this.animate())}}draw(){if(!this.puzzle||!this.ctx)return;let e=this.ctx,t=Date.now();if(e.globalAlpha=1,e.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(e),this.drawConstraints(e),this.drawNodes(e),this.path.length===0&&!this.isDrawing&&this.drawRipples(e),this.isFading)this.drawPath(e,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos);else if(this.path.length>0){let n=this.isInvalidPath?this.options.colors.error:this.options.colors.path;if(this.isSuccessFading&&(n=this.options.colors.success),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let s=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),a=this.options.animations.blinkDuration;if(s<a)if(this.isSuccessFading)(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&(n=this.options.colors.error);else{let o=Math.min(1,s/200),i=s>a*.8?(a-s)/(a*.2):1,h=Math.min(o,i),c=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;n=this.lerpColor(this.options.colors.path,this.options.colors.error,c*h)}}this.drawPath(e,this.path,this.isDrawing,n,1,this.isDrawing?this.currentMousePos:this.exitTipPos)}}drawRipples(e){if(!this.puzzle)return;let t=(Date.now()-this.startTime)/500;for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)if(this.puzzle.nodes[n][s].type===2){let o=this.getCanvasCoords(s,n),i=this.getExitDir(s,n);if(!i)continue;let h={x:o.x+i.x*this.options.exitLength,y:o.y+i.y*this.options.exitLength},c=t%4,l=c*5,r=Math.max(0,1-c/3);e.beginPath(),e.arc(h.x,h.y,l,0,Math.PI*2),e.strokeStyle=`rgba(170, 170, 170, ${r*.4})`,e.lineWidth=2,e.stroke()}}drawGrid(e){if(!this.puzzle||!this.options.colors.grid)return;e.strokeStyle=this.options.colors.grid,e.lineWidth=12,e.lineCap="round";let t=(n,s,a)=>{if(a!==2)if(a===1){let i={x:n.x+(s.x-n.x)*.35,y:n.y+(s.y-n.y)*.35},h={x:n.x+(s.x-n.x)*(.5+.15),y:n.y+(s.y-n.y)*(.5+.15)};e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(i.x,i.y),e.stroke(),e.beginPath(),e.moveTo(h.x,h.y),e.lineTo(s.x,s.y),e.stroke()}else e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(s.x,s.y),e.stroke()};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<this.puzzle.cols;s++)t(this.getCanvasCoords(s,n),this.getCanvasCoords(s+1,n),this.puzzle.hEdges[n][s].type);for(let n=0;n<this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)t(this.getCanvasCoords(s,n),this.getCanvasCoords(s,n+1),this.puzzle.vEdges[n][s].type)}drawConstraints(e){if(!this.puzzle)return;let t=Date.now(),n=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;for(let a=0;a<this.puzzle.rows;a++)for(let o=0;o<this.puzzle.cols;o++){let i=this.puzzle.cells[a][o],h=this.getCanvasCoords(o+.5,a+.5),c=this.invalidatedCells.some(p=>p.x===o&&p.y===a),l=this.errorCells.some(p=>p.x===o&&p.y===a),r=1,u,d=this.getColorCode(i.color),f=this.options.colors.error;if(l&&(u=this.lerpColor(d,f,n)),c){let p=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),y=this.options.animations.blinkDuration;if(this.isFading)r=this.fadeOpacity;else if(p<y){let m=Math.min(1,p/200),g=p>y*.8?(y-p)/(y*.2):1,E=Math.min(m,g);u=this.lerpColor(d,f,n*E)}else r=Math.max(.3,1-(p-y)/this.options.animations.fadeDuration)}if(r<1||u){let{canvas:p,ctx:y}=this.prepareOffscreen();this.drawConstraintItem(y,i,h,u),e.save(),e.globalAlpha=r,e.drawImage(p,0,0),e.restore()}else this.drawConstraintItem(e,i,h)}e.lineWidth=2;let s=8;for(let a=0;a<=this.puzzle.rows;a++)for(let o=0;o<this.puzzle.cols;o++)if(this.puzzle.hEdges[a][o].type===3){let i=this.getCanvasCoords(o+.5,a);e.save();let h=this.invalidatedEdges.some(l=>l.type==="h"&&l.r===a&&l.c===o);if(this.errorEdges.some(l=>l.type==="h"&&l.r===a&&l.c===o)){let l=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(e,i.x,i.y,s,l)}else if(h){let l=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),r=this.options.animations.blinkDuration;if(this.isFading)e.globalAlpha*=this.fadeOpacity;else if(l<r){let u=Math.min(1,l/200),d=l>r*.8?(r-l)/(r*.2):1,f=Math.min(u,d),p=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*f);this.drawHexagon(e,i.x,i.y,s,p)}else e.globalAlpha*=Math.max(.3,1-(l-r)/this.options.animations.fadeDuration),this.drawHexagon(e,i.x,i.y,s)}else this.drawHexagon(e,i.x,i.y,s);e.restore()}for(let a=0;a<this.puzzle.rows;a++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.vEdges[a][o].type===3){let i=this.getCanvasCoords(o,a+.5);e.save();let h=this.invalidatedEdges.some(l=>l.type==="v"&&l.r===a&&l.c===o);if(this.errorEdges.some(l=>l.type==="v"&&l.r===a&&l.c===o)){let l=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(e,i.x,i.y,s,l)}else if(h){let l=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),r=this.options.animations.blinkDuration;if(this.isFading)e.globalAlpha*=this.fadeOpacity;else if(l<r){let u=Math.min(1,l/200),d=l>r*.8?(r-l)/(r*.2):1,f=Math.min(u,d),p=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*f);this.drawHexagon(e,i.x,i.y,s,p)}else e.globalAlpha*=Math.max(.3,1-(l-r)/this.options.animations.fadeDuration),this.drawHexagon(e,i.x,i.y,s)}else this.drawHexagon(e,i.x,i.y,s);e.restore()}for(let a=0;a<=this.puzzle.rows;a++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[a][o].type===3){let i=this.getCanvasCoords(o,a);e.save();let h=this.invalidatedNodes.some(l=>l.x===o&&l.y===a);if(this.errorNodes.some(l=>l.x===o&&l.y===a)){let l=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(e,i.x,i.y,s,l)}else if(h){let l=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),r=this.options.animations.blinkDuration;if(this.isFading)e.globalAlpha*=this.fadeOpacity;else if(l<r){let u=Math.min(1,l/200),d=l>r*.8?(r-l)/(r*.2):1,f=Math.min(u,d),p=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*f);this.drawHexagon(e,i.x,i.y,s,p)}else e.globalAlpha*=Math.max(.3,1-(l-r)/this.options.animations.fadeDuration),this.drawHexagon(e,i.x,i.y,s)}else this.drawHexagon(e,i.x,i.y,s);e.restore()}}drawConstraintItem(e,t,n,s){t.type===1?(e.fillStyle=s||this.getColorCode(t.color),this.drawRoundedRect(e,n.x-26/2,n.y-26/2,26,26,8)):t.type===2?this.drawStar(e,n.x,n.y,12,16,8,t.color,s):t.type===3||t.type===4?this.drawTetris(e,n.x,n.y,t.shape||[],t.type===4,t.color,s):t.type===5&&this.drawEraser(e,n.x,n.y,14,3,t.color,s)}drawNodes(e){if(!this.puzzle)return;let t=(n,s)=>{let a=[];return n>0&&a.push(this.puzzle.hEdges[s][n-1].type),n<this.puzzle.cols&&a.push(this.puzzle.hEdges[s][n].type),s>0&&a.push(this.puzzle.vEdges[s-1][n].type),s<this.puzzle.rows&&a.push(this.puzzle.vEdges[s][n].type),a.length>0&&a.every(o=>o===2)};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++){if(t(s,n))continue;let a=this.puzzle.nodes[n][s];if(a.type===3)continue;let o=this.getCanvasCoords(s,n);if(a.type===1)this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill();else if(a.type===2){let i=this.getExitDir(s,n);if(!i)continue;this.options.colors.node&&(e.strokeStyle=this.options.colors.node),e.lineWidth=12,e.lineCap="round",e.beginPath(),e.moveTo(o.x,o.y),e.lineTo(o.x+i.x*this.options.exitLength,o.y+i.y*this.options.exitLength),e.stroke()}else this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.nodeRadius,0,Math.PI*2),e.fill()}}drawPath(e,t,n,s,a,o=null){if(!(t.length===0||!s))if(a<1){let{canvas:i,ctx:h}=this.prepareOffscreen();this.drawPathInternal(h,t,n,s,o),e.save(),e.globalAlpha=a,e.drawImage(i,0,0),e.restore()}else this.drawPathInternal(e,t,n,s,o)}drawPathInternal(e,t,n,s,a=null){e.save(),e.strokeStyle=s,e.fillStyle=s,e.lineWidth=this.options.pathWidth,e.lineCap="round",e.lineJoin="round",e.beginPath();let o=this.getCanvasCoords(t[0].x,t[0].y);e.moveTo(o.x,o.y);for(let i=1;i<t.length;i++){let h=this.getCanvasCoords(t[i].x,t[i].y);e.lineTo(h.x,h.y)}if(n||a){let i=a||this.currentMousePos;e.lineTo(i.x,i.y)}e.stroke(),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill(),n&&(e.beginPath(),e.arc(this.currentMousePos.x,this.currentMousePos.y,this.options.pathWidth/2,0,Math.PI*2),e.fill()),e.restore()}drawRoundedRect(e,t,n,s,a,o){e.beginPath(),e.moveTo(t+o,n),e.lineTo(t+s-o,n),e.quadraticCurveTo(t+s,n,t+s,n+o),e.lineTo(t+s,n+a-o),e.quadraticCurveTo(t+s,n+a,t+s-o,n+a),e.lineTo(t+o,n+a),e.quadraticCurveTo(t,n+a,t,n+a-o),e.lineTo(t,n+o),e.quadraticCurveTo(t,n,t+o,n),e.closePath(),e.fill()}drawHexagon(e,t,n,s,a){if(!(!this.options.colors.hexagon&&!a)){e.fillStyle=a||this.options.colors.hexagon,e.beginPath();for(let o=0;o<6;o++){let i=Math.PI/3*o,h=t+s*Math.cos(i),c=n+s*Math.sin(i);o===0?e.moveTo(h,c):e.lineTo(h,c)}e.closePath(),e.fill()}}drawEraser(e,t,n,s,a,o,i){e.strokeStyle=i||this.getColorCode(o),e.lineWidth=s*.5,e.lineCap="butt";let h=.5;e.beginPath();for(let c=0;c<a;c++){let l=Math.PI*2/a*c+h,r=t+s*Math.cos(l),u=n+s*Math.sin(l);e.moveTo(t,n),e.lineTo(r,u)}e.stroke()}drawStar(e,t,n,s,a,o,i,h){e.fillStyle=h||this.getColorCode(i),e.beginPath();for(let c=0;c<o*2;c++){let l=c%2===0?a:s,r=Math.PI/o*c,u=t+l*Math.cos(r),d=n+l*Math.sin(r);c===0?e.moveTo(u,d):e.lineTo(u,d)}e.closePath(),e.fill()}drawTetris(e,t,n,s,a,o,i){if(!s||s.length===0)return;let h=12,c=2,l=s[0].length*h+(s[0].length-1)*c,r=s.length*h+(s.length-1)*c;e.save(),e.translate(t,n),a&&e.rotate(Math.PI/8),e.fillStyle=i||this.getColorCode(o,"#ffcc00");for(let u=0;u<s.length;u++)for(let d=0;d<s[u].length;d++)if(s[u][d]){let f=d*(h+c)-l/2,p=u*(h+c)-r/2;e.fillRect(f,p,h,h)}e.restore()}getColorCode(e,t="#666"){return this.options.colors.colorList&&this.options.colors.colorList[e]!==void 0?this.options.colors.colorList[e]:this.options.colors.colorMap&&this.options.colors.colorMap[e]!==void 0?this.options.colors.colorMap[e]:t}hexToRgb(e){let t=e.startsWith("#")?e.slice(1):e;t.length===3&&(t=t.split("").map(s=>s+s).join(""));let n=parseInt(t,16);return{r:n>>16&255,g:n>>8&255,b:n&255}}rgbToHex(e,t,n){return"#"+((1<<24)+(e<<16)+(t<<8)+n).toString(16).slice(1)}lerpColor(e,t,n){try{let s=this.hexToRgb(e),a=this.hexToRgb(t);return this.rgbToHex(Math.round(s.r+(a.r-s.r)*n),Math.round(s.g+(a.g-s.g)*n),Math.round(s.b+(a.b-s.b)*n))}catch{return e}}prepareOffscreen(){return typeof document>"u"?{canvas:{},ctx:{}}:(this.offscreenCanvas||(this.offscreenCanvas=document.createElement("canvas"),this.offscreenCtx=this.offscreenCanvas.getContext("2d")),(this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx})}};var se=class{generator;validator;constructor(){this.generator=new J,this.validator=new K}createPuzzle(e,t,n={}){return this.generator.generate(e,t,n).export()}validateSolution(e,t){let n=W.fromData(e);return this.validator.validate(n,t)}calculateDifficulty(e){let t=W.fromData(e);return this.validator.calculateDifficulty(t)}};export{U as CellType,k as Color,oe as Direction,X as EdgeType,W as Grid,Y as NodeType,J as PuzzleGenerator,Z as PuzzleSerializer,K as PuzzleValidator,se as WitnessCore,ee as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
