/*!
 * MiniWitness 1.3.2
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var Ee=(n=>(n[n.Up=0]="Up",n[n.Right=1]="Right",n[n.Down=2]="Down",n[n.Left=3]="Left",n))(Ee||{}),re=(c=>(c[c.None=0]="None",c[c.Square=1]="Square",c[c.Star=2]="Star",c[c.Tetris=3]="Tetris",c[c.TetrisRotated=4]="TetrisRotated",c[c.TetrisNegative=5]="TetrisNegative",c[c.TetrisNegativeRotated=6]="TetrisNegativeRotated",c[c.Eraser=7]="Eraser",c[c.Triangle=8]="Triangle",c))(re||{}),le=(o=>(o[o.Normal=0]="Normal",o[o.Broken=1]="Broken",o[o.Absent=2]="Absent",o[o.Hexagon=3]="Hexagon",o[o.HexagonMain=4]="HexagonMain",o[o.HexagonSymmetry=5]="HexagonSymmetry",o))(le||{}),he=(o=>(o[o.Normal=0]="Normal",o[o.Start=1]="Start",o[o.End=2]="End",o[o.Hexagon=3]="Hexagon",o[o.HexagonMain=4]="HexagonMain",o[o.HexagonSymmetry=5]="HexagonSymmetry",o))(he||{}),ue=(n=>(n[n.None=0]="None",n[n.Horizontal=1]="Horizontal",n[n.Vertical=2]="Vertical",n[n.Rotational=3]="Rotational",n))(ue||{}),U={None:0,Black:1,White:2,Red:3,Blue:4},Se=(s=>(s[s.Mulberry32=0]="Mulberry32",s[s.XorShift128Plus=1]="XorShift128Plus",s[s.MathRandom=2]="MathRandom",s))(Se||{});var oe=class j{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];symmetry=0;seed;constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:U.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes,symmetry:this.symmetry,seed:this.seed}))}static fromData(e){let t=new j(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t.symmetry=e.symmetry||0,t.seed=e.seed,t}};var de=class{state;constructor(e){this.state=e>>>0}next(){let e=(this.state+=1831565813)|0;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}},pe=class{s0;s1;constructor(e,t){this.s0=e>>>0,this.s1=t>>>0,this.s0===0&&this.s1===0&&(this.s1=1)}next(){let e=this.s0,t=this.s1;return this.s0=t,e^=e<<23,this.s1=e^t^e>>>17^t>>>26,(this.s1+t>>>0)/4294967296}},ge=class{next(){return Math.random()}};function ye(j,e){switch(j){case 0:return new de(Number(e&0xffffffffn));case 1:return new pe(Number(e&0xffffffffn),Number(e>>32n&0xffffffffn));case 2:return new ge;default:return new de(Number(e&0xffffffffn))}}var ae=class{tetrisCache=new Map;rng=null;setRng(e){this.rng=e}validate(e,t,s){let n=t.points;if(n.length<2)return{isValid:!1,errorReason:"Path too short"};let r=e.symmetry||0,o=[];if(r!==0)for(let h of n)o.push(this.getSymmetricalPoint(e,h));let i=n[0],d=n[n.length-1];if(e.nodes[i.y][i.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[d.y][d.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};if(r!==0){let h=o[0],p=o[o.length-1];if(e.nodes[h.y][h.x].type!==1)return{isValid:!1,errorReason:"Symmetrical path must start at Start Node"};if(e.nodes[p.y][p.x].type!==2)return{isValid:!1,errorReason:"Symmetrical path must end at End Node"}}let c=new Set,y=new Set;if(c.add(`${i.x},${i.y}`),r!==0){let h=o[0];if(c.has(`${h.x},${h.y}`))return{isValid:!1,errorReason:"Paths collide at start"};c.add(`${h.x},${h.y}`)}for(let h=0;h<n.length-1;h++){let p=n[h],m=n[h+1];if(Math.abs(p.x-m.x)+Math.abs(p.y-m.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let x=`${m.x},${m.y}`;if(c.has(x))return{isValid:!1,errorReason:"Self-intersecting path or path collision"};if(c.add(x),this.isBrokenEdge(e,p,m))return{isValid:!1,errorReason:"Passed through broken edge"};if(y.add(this.getEdgeKey(p,m)),r!==0){let b=o[h],P=o[h+1],S=`${P.x},${P.y}`;if(c.has(S))return{isValid:!1,errorReason:"Path collision"};if(c.add(S),this.isBrokenEdge(e,b,P))return{isValid:!1,errorReason:"Symmetrical path passed through broken edge"};let C=this.getEdgeKey(b,P);if(y.has(C))return{isValid:!1,errorReason:"Paths cross the same edge"};y.add(C)}}let l=this.calculateRegions(e,n,o,s),f=this.getMissedHexagons(e,n,o),u=new Set;for(let h=0;h<n.length-1;h++)u.add(this.getEdgeKey(n[h],n[h+1]));if(r!==0)for(let h=0;h<o.length-1;h++)u.add(this.getEdgeKey(o[h],o[h+1]));let a=this.validateWithErasers(e,l,f.edges,f.nodes,u);return a.regions=l,a}validateFast(e,t,s,n){let r=this.calculateRegions(e,t,s,n),o=this.getMissedHexagons(e,t,s),i=new Set;for(let c=0;c<t.length-1;c++)i.add(this.getEdgeKey(t[c],t[c+1]));if((e.symmetry||0)!==0)for(let c=0;c<s.length-1;c++)i.add(this.getEdgeKey(s[c],s[c+1]));return this.validateWithErasers(e,r,o.edges,o.nodes,i)}isBrokenEdge(e,t,s){let n;if(t.x===s.x){let r=Math.min(t.y,s.y);n=e.vEdges[r][t.x].type}else{let r=Math.min(t.x,s.x);n=e.hEdges[t.y][r].type}return n===1||n===2}isAbsentEdge(e,t,s){if(t.x===s.x){let n=Math.min(t.y,s.y);return e.vEdges[n][t.x].type===2}else{let n=Math.min(t.x,s.x);return e.hEdges[t.y][n].type===2}}getMissedHexagons(e,t,s=[]){let n=new Set,r=new Set;for(let y=0;y<t.length;y++)r.add(`${t[y].x},${t[y].y}`),y<t.length-1&&n.add(this.getEdgeKey(t[y],t[y+1]));let o=new Set,i=new Set;for(let y=0;y<s.length;y++)i.add(`${s[y].x},${s[y].y}`),y<s.length-1&&o.add(this.getEdgeKey(s[y],s[y+1]));let d=[];for(let y=0;y<=e.rows;y++)for(let l=0;l<e.cols;l++){let f=e.hEdges[y][l].type;if(f===3||f===4||f===5){let u=this.getEdgeKey({x:l,y},{x:l+1,y}),a=!1;f===3?a=n.has(u)||o.has(u):f===4?a=n.has(u):f===5&&(a=o.has(u)),a||d.push({type:"h",r:y,c:l})}}for(let y=0;y<e.rows;y++)for(let l=0;l<=e.cols;l++){let f=e.vEdges[y][l].type;if(f===3||f===4||f===5){let u=this.getEdgeKey({x:l,y},{x:l,y:y+1}),a=!1;f===3?a=n.has(u)||o.has(u):f===4?a=n.has(u):f===5&&(a=o.has(u)),a||d.push({type:"v",r:y,c:l})}}let c=[];for(let y=0;y<=e.rows;y++)for(let l=0;l<=e.cols;l++){let f=e.nodes[y][l].type;if(f===3||f===4||f===5){let u=`${l},${y}`,a=!1;f===3?a=r.has(u)||i.has(u):f===4?a=r.has(u):f===5&&(a=i.has(u)),a||c.push({x:l,y})}}return{edges:d,nodes:c}}validateWithErasers(e,t,s,n,r){let o=[],i=!0;for(let a=0;a<t.length;a++){let h=t[a],p=h.filter(P=>e.cells[P.y][P.x].type===7),m=h.filter(P=>e.cells[P.y][P.x].type!==0&&e.cells[P.y][P.x].type!==7),g=[];for(let P=0;P<s.length;P++)this.isHexagonAdjacentToRegion(e,s[P],h)&&g.push(P);let x=[];for(let P=0;P<n.length;P++)this.isNodeHexagonAdjacentToRegion(e,n[P],h)&&x.push(P);let b=this.getPossibleErasures(e,h,p,m,g,x,r);if(b.length===0){i=!1;let P=this.getBestEffortErasures(e,h,p,m,g,x,r);o.push([P])}else b.sort((P,S)=>{let C=P.invalidatedCells.length+P.invalidatedHexagons.length+P.invalidatedNodeHexagons.length,v=S.invalidatedCells.length+S.invalidatedHexagons.length+S.invalidatedNodeHexagons.length;if(C!==v)return C-v;let E=P.invalidatedHexagons.length+P.invalidatedNodeHexagons.length,N=S.invalidatedHexagons.length+S.invalidatedNodeHexagons.length;return E!==N?N-E:P.invalidatedCells.length-S.invalidatedCells.length}),o.push(b)}if(i){let a=this.findGlobalAssignment(o,s.length,n.length);if(a)return{isValid:!0,invalidatedCells:a.invalidatedCells,invalidatedEdges:a.invalidatedHexIndices.map(h=>s[h]),invalidatedNodes:a.invalidatedNodeHexIndices.map(h=>n[h])}}let d=[],c=[],y=new Set,l=new Set;for(let a of o){let h=a[0];d.push(...h.errorCells),c.push(...h.invalidatedCells);for(let p of h.invalidatedHexagons)y.add(p);for(let p of h.invalidatedNodeHexagons)l.add(p)}let f=[];for(let a=0;a<s.length;a++)y.has(a)||f.push(s[a]);let u=[];for(let a=0;a<n.length;a++)l.has(a)||u.push(n[a]);return{isValid:!1,errorReason:"Constraints failed",errorCells:d,errorEdges:f,errorNodes:u,invalidatedCells:c,invalidatedEdges:Array.from(y).map(a=>s[a]),invalidatedNodes:Array.from(l).map(a=>n[a])}}isHexagonAdjacentToRegion(e,t,s){let n=new Set(s.map(r=>`${r.x},${r.y}`));if(t.type==="h"){if(t.r>0&&n.has(`${t.c},${t.r-1}`)||t.r<e.rows&&n.has(`${t.c},${t.r}`))return!0}else if(t.c>0&&n.has(`${t.c-1},${t.r}`)||t.c<e.cols&&n.has(`${t.c},${t.r}`))return!0;return!1}isNodeHexagonAdjacentToRegion(e,t,s){let n=new Set(s.map(o=>`${o.x},${o.y}`)),r=[{x:t.x-1,y:t.y-1},{x:t.x,y:t.y-1},{x:t.x-1,y:t.y},{x:t.x,y:t.y}];for(let o of r)if(o.x>=0&&o.x<e.cols&&o.y>=0&&o.y<e.rows&&n.has(`${o.x},${o.y}`))return!0;return!1}getPossibleErasures(e,t,s,n,r,o,i){let d=[],c=s.length;if(c===0)return this.getRegionErrors(e,t,[],i).length===0&&r.length===0&&o.length===0&&d.push({invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!0,errorCells:[]}),d;let y=[...n.map(f=>({type:"cell",pos:f})),...r.map(f=>({type:"hex",index:f})),...o.map(f=>({type:"nodeHex",index:f}))],l=this.getRegionErrors(e,t,[],i).length===0&&r.length===0&&o.length===0;for(let f=0;f<=c;f++){let u=this.getNCombinations(s,f);for(let a of u){let h=new Set(a.map(m=>`${m.x},${m.y}`)),p=s.filter(m=>!h.has(`${m.x},${m.y}`));for(let m=0;m<=y.length;m++){if(p.length!==f+m)continue;let g=this.getNCombinations(y,m);for(let x of g){let b=x.filter(E=>E.type==="cell").map(E=>E.pos),P=x.filter(E=>E.type==="hex").map(E=>E.index),S=x.filter(E=>E.type==="nodeHex").map(E=>E.index);if(this.getRegionErrors(e,t,[...b,...a],i).length===0){let E=!0;if(l)m>0&&(E=!1);else for(let N=0;N<x.length;N++){let w=[...x.slice(0,N),...x.slice(N+1)],H=w.filter($=>$.type==="cell").map($=>$.pos),O=new Set(w.filter($=>$.type==="hex").map($=>$.index)),L=new Set(w.filter($=>$.type==="nodeHex").map($=>$.index)),B=r.every($=>O.has($)),I=o.every($=>L.has($));if(this.getRegionErrors(e,t,H,i).length===0&&B&&I){E=!1;break}}E&&d.push({invalidatedCells:[...b,...a],invalidatedHexagons:P,invalidatedNodeHexagons:S,isValid:!0,errorCells:[]})}}}}}return d}getBestEffortErasures(e,t,s,n,r,o,i){let d=this.getRegionErrors(e,t,[],i);if(d.length===0&&r.length===0&&o.length===0)return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:[...s]};if(s.length>0){let l=[...n.map(h=>({type:"cell",pos:h})),...r.map(h=>({type:"hex",index:h})),...o.map(h=>({type:"nodeHex",index:h}))],f=null,u=1/0,a=h=>{let p=[],m=[],g=[],x=0;for(let w of h)x<s.length&&(w.type==="cell"?p.push(w.pos):w.type==="hex"?m.push(w.index):g.push(w.index),x++);let b=s.length-x,P=Math.floor(b/2),S=s.slice(x,x+P);x+=P*2;let C=this.getRegionErrors(e,t,[...p,...S],i);for(let w=x;w<s.length;w++)C.push(s[w]);let v=Math.max(0,r.length-m.length),E=Math.max(0,o.length-g.length),N=C.length+v+E;N<u&&(u=N,f={invalidatedCells:[...p,...S],invalidatedHexagons:m,invalidatedNodeHexagons:g,isValid:!1,errorCells:C})};a([...d.map(h=>({type:"cell",pos:h})),...r.map(h=>({type:"hex",index:h})),...o.map(h=>({type:"nodeHex",index:h}))]),a(l);for(let h of d)a([{type:"cell",pos:h}]);if(f)return f}let y=[...d,...s];return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:y}}getNCombinations(e,t){let s=[],n=(r,o)=>{if(o.length===t){s.push([...o]);return}for(let i=r;i<e.length;i++)o.push(e[i]),n(i+1,o),o.pop()};return n(0,[]),s}checkRegionValid(e,t,s,n){return this.getRegionErrors(e,t,s,n).length===0}getRegionErrors(e,t,s,n){let r=new Set(s.map(a=>`${a.x},${a.y}`)),o=new Map,i=new Map,d=new Set,c=new Set,y=[],l=[],f=[];for(let a of t){if(r.has(`${a.x},${a.y}`))continue;let h=e.cells[a.y][a.x];if(h.type===0)continue;let p=h.color;p!==U.None&&(o.set(p,(o.get(p)||0)+1),i.has(p)||i.set(p,[]),i.get(p).push(a)),h.type===1?c.add(p):h.type===2?d.add(p):h.type===3||h.type===4?h.shape&&y.push({shape:h.shape,rotatable:h.type===4,pos:a}):h.type===5||h.type===6?h.shape&&l.push({shape:h.shape,rotatable:h.type===6,pos:a}):h.type===8&&f.push({count:h.count||0,pos:a})}let u=[];if(c.size>1)for(let a of t)r.has(`${a.x},${a.y}`)||e.cells[a.y][a.x].type===1&&u.push(a);for(let a of d)if(o.get(a)!==2){let h=i.get(a)||[];for(let p of h)e.cells[p.y][p.x].type===2&&u.push(p)}for(let a of f){let h=0,p=[this.getEdgeKey({x:a.pos.x,y:a.pos.y},{x:a.pos.x+1,y:a.pos.y}),this.getEdgeKey({x:a.pos.x,y:a.pos.y+1},{x:a.pos.x+1,y:a.pos.y+1}),this.getEdgeKey({x:a.pos.x,y:a.pos.y},{x:a.pos.x,y:a.pos.y+1}),this.getEdgeKey({x:a.pos.x+1,y:a.pos.y},{x:a.pos.x+1,y:a.pos.y+1})];for(let m of p)n.has(m)&&h++;h!==a.count&&u.push(a.pos)}if((y.length>0||l.length>0)&&!this.checkTetrisConstraint(e,t,y.map(a=>({shape:a.shape,rotatable:a.rotatable})),l.map(a=>({shape:a.shape,rotatable:a.rotatable})))){for(let a of y)u.push(a.pos);for(let a of l)u.push(a.pos)}return u}findGlobalAssignment(e,t,s){let n=e.length,r=new Array(t).fill(0),o=new Array(s).fill(0),i=[],d=[],c=[],y=l=>{if(l===n)return r.every(f=>f===1)&&o.every(f=>f===1);for(let f of e[l]){let u=!0;for(let a of f.invalidatedHexagons)if(r[a]>0){u=!1;break}if(u){for(let a of f.invalidatedNodeHexagons)if(o[a]>0){u=!1;break}}if(u){for(let a of f.invalidatedHexagons)r[a]++,d.push(a);for(let a of f.invalidatedNodeHexagons)o[a]++,c.push(a);if(i.push(...f.invalidatedCells),y(l+1))return!0;for(let a of f.invalidatedHexagons)r[a]--,d.pop();for(let a of f.invalidatedNodeHexagons)o[a]--,c.pop();for(let a=0;a<f.invalidatedCells.length;a++)i.pop()}}return!1};return y(0)?{invalidatedCells:i,invalidatedHexIndices:d,invalidatedNodeHexIndices:c}:null}checkTetrisConstraint(e,t,s,n=[]){let r=s.reduce((v,E)=>v+this.getShapeArea(E.shape),0),o=n.reduce((v,E)=>v+this.getShapeArea(E.shape),0),i=r-o;if(i<0||i!==0&&i!==t.length)return!1;let d=e.rows,c=e.cols;this.tetrisCache.size>1e4&&this.tetrisCache.clear();let y=new Uint8Array(d*c);for(let v of t)y[v.y*c+v.x]=1;let l=(v,E)=>`${this.getShapeKey(v.shape)}-${v.rotatable}-${E}`,f=[...s.map(v=>l(v,1)),...n.map(v=>l(v,-1))].sort().join("|"),u=`${d}x${c}:${y.join("")}:${f}`;if(this.tetrisCache.has(u))return this.tetrisCache.get(u);let a=new Int8Array(d*c);if(i>0)for(let v=0;v<y.length;v++)a[v]=y[v];let h=new Int8Array(d*c),p=[],m=[...s.map(v=>({...v,sign:1})),...n.map(v=>({...v,sign:-1}))];for(let v of m){let E=v.rotatable?this.getAllRotations(v.shape):[v.shape],N=this.getShapeKey(E[0]),w=p.find(H=>H.sign===v.sign&&(v.rotatable?H.rotations.length>1:H.rotations.length===1)&&this.getShapeKey(H.rotations[0].shape)===N);w?w.count++:p.push({rotations:E.map(H=>({shape:H,h:H.length,w:H[0].length})),sign:v.sign,area:this.getShapeArea(v.shape),count:1})}p.sort((v,E)=>E.sign-v.sign||E.area-v.area);let g=i>0?t.length:0,x=0,b=r,P=o,S=(v,E,N)=>{if(g>b||x>P)return!1;if(v===p.length)return g===0&&x===0;let w=p[v],H=E+1,O=H===w.count;w.sign===1?b-=w.area:P-=w.area;for(let L of w.rotations){let B=L.h,I=L.w,$=E===0?0:N;for(let M=$;M<=d*c-(B>0?(B-1)*c+I:0);M++){let T=Math.floor(M/c),k=M%c;if(T>d-B||k>c-I)continue;let K=!0,z=[];for(let F=0;F<B;F++){for(let Q=0;Q<I;Q++)if(L.shape[F][Q]){let se=(T+F)*c+(k+Q);w.sign===1?h[se]<a[se]?g--:x++:h[se]<=a[se]?g++:x--,h[se]+=w.sign,z.push(se),h[se]<0&&(K=!1),w.sign===1&&h[se]>1+o&&(K=!1)}if(!K)break}if(K){if(O){if(S(v+1,0,0)){for(let F of z)h[F]-=w.sign,w.sign===1?h[F]<a[F]?g++:x--:h[F]<=a[F]?g--:x++;return w.sign===1?b+=w.area:P+=w.area,!0}}else if(S(v,H,M)){for(let F of z)h[F]-=w.sign,w.sign===1?h[F]<a[F]?g++:x--:h[F]<=a[F]?g--:x++;return w.sign===1?b+=w.area:P+=w.area,!0}}for(let F of z)h[F]-=w.sign,w.sign===1?h[F]<a[F]?g++:x--:h[F]<=a[F]?g--:x++}}return w.sign===1?b+=w.area:P+=w.area,!1},C=S(0,0,0);return this.tetrisCache.set(u,C),C}getShapeArea(e){let t=0;for(let s of e)for(let n of s)n&&t++;return t}getShapeKey(e){return JSON.stringify(e)}getAllRotations(e){let t=[],s=new Set,n=e;for(let r=0;r<4;r++){let o=this.getShapeKey(n);s.has(o)||(t.push(n),s.add(o)),n=this.rotate90(n)}return t}rotate90(e){let t=e.length,s=e[0].length,n=Array.from({length:s},()=>Array(t).fill(0));for(let r=0;r<t;r++)for(let o=0;o<s;o++)n[o][t-1-r]=e[r][o];return n}calculateRegions(e,t,s=[],n){let r=[],o=e.rows,i=e.cols,d=new Uint8Array(o*i),c=new Uint8Array((o+1)*i),y=new Uint8Array(o*(i+1)),l=(u,a)=>{u.x===a.x?y[Math.min(u.y,a.y)*(i+1)+u.x]=1:c[u.y*i+Math.min(u.x,a.x)]=1};for(let u=0;u<t.length-1;u++)l(t[u],t[u+1]);for(let u=0;u<s.length-1;u++)l(s[u],s[u+1]);for(let u=0;u<=o;u++)for(let a=0;a<i;a++)e.hEdges[u][a].type===2&&(c[u*i+a]=1);for(let u=0;u<o;u++)for(let a=0;a<=i;a++)e.vEdges[u][a].type===2&&(y[u*(i+1)+a]=1);let f=n||this.getExternalCells(e);for(let u=0;u<o;u++)for(let a=0;a<i;a++){let h=u*i+a;if(d[h]||f&&f.has(`${a},${u}`))continue;let p=[],m=[h];d[h]=1;let g=0;for(;g<m.length;){let x=m[g++],b=x%i,P=Math.floor(x/i);if(p.push({x:b,y:P}),P>0&&!c[P*i+b]){let S=(P-1)*i+b;!d[S]&&(!f||!f.has(`${b},${P-1}`))&&(d[S]=1,m.push(S))}if(P<o-1&&!c[(P+1)*i+b]){let S=(P+1)*i+b;!d[S]&&(!f||!f.has(`${b},${P+1}`))&&(d[S]=1,m.push(S))}if(b>0&&!y[P*(i+1)+b]){let S=P*i+(b-1);!d[S]&&(!f||!f.has(`${b-1},${P}`))&&(d[S]=1,m.push(S))}if(b<i-1&&!y[P*(i+1)+(b+1)]){let S=P*i+(b+1);!d[S]&&(!f||!f.has(`${b+1},${P}`))&&(d[S]=1,m.push(S))}}r.push(p)}return r}getExternalCells(e){let t=new Set,s=[];for(let n=0;n<e.cols;n++)e.hEdges[0][n].type===2&&(t.has(`${n},0`)||(t.add(`${n},0`),s.push({x:n,y:0}))),e.hEdges[e.rows][n].type===2&&(t.has(`${n},${e.rows-1}`)||(t.add(`${n},${e.rows-1}`),s.push({x:n,y:e.rows-1})));for(let n=0;n<e.rows;n++)e.vEdges[n][0].type===2&&(t.has(`0,${n}`)||(t.add(`0,${n}`),s.push({x:0,y:n}))),e.vEdges[n][e.cols].type===2&&(t.has(`${e.cols-1},${n}`)||(t.add(`${e.cols-1},${n}`),s.push({x:e.cols-1,y:n})));for(;s.length>0;){let n=s.shift(),r=[{nx:n.x,ny:n.y-1,edge:e.hEdges[n.y][n.x]},{nx:n.x,ny:n.y+1,edge:e.hEdges[n.y+1][n.x]},{nx:n.x-1,ny:n.y,edge:e.vEdges[n.y][n.x]},{nx:n.x+1,ny:n.y,edge:e.vEdges[n.y][n.x+1]}];for(let o of r)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),s.push({x:o.nx,y:o.ny}))}return t}getSymmetricalPoint(e,t){let s=e.symmetry||0;return s===1?{x:e.cols-t.x,y:t.y}:s===2?{x:t.x,y:e.rows-t.y}:s===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getSymmetricalPointIndex(e,t){let s=e.cols+1,n=Math.floor(t/s),r=t%s,o=e.symmetry||0,i=n,d=r;return o===1?d=e.cols-r:o===2?i=e.rows-n:o===3&&(d=e.cols-r,i=e.rows-n),i*s+d}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}calculateDifficulty(e){let t=e.rows,s=e.cols,n=s+1,r=(t+1)*n,o=Array.from({length:r},()=>[]),i=[],d=[],c=new Map,y=0,l=new Set,f=new Set;for(let M=0;M<=t;M++)for(let T=0;T<=s;T++){let k=M*n+T;if(e.nodes[M][T].type===1&&i.push(k),e.nodes[M][T].type===2&&d.push(k),(e.nodes[M][T].type===3||e.nodes[M][T].type===4||e.nodes[M][T].type===5)&&(c.set(`n${T},${M}`,y++),f.add(k)),T<s){let K=k+1,z=e.hEdges[M][T].type,F=z===3||z===4||z===5,Q=z===1||z===2;o[k].push({next:K,hexType:z,isBroken:Q}),o[K].push({next:k,hexType:z,isBroken:Q}),F&&(c.set(`eh${T},${M}`,y++),l.add(this.getEdgeKey({x:T,y:M},{x:T+1,y:M})))}if(M<t){let K=k+n,z=e.vEdges[M][T].type,F=z===3||z===4||z===5,Q=z===1||z===2;o[k].push({next:K,hexType:z,isBroken:Q}),o[K].push({next:k,hexType:z,isBroken:Q}),F&&(c.set(`ev${T},${M}`,y++),l.add(this.getEdgeKey({x:T,y:M},{x:T,y:M+1})))}}let u={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},a=y,h=new Set,p=Math.max(1e3,t*s*200),m=this.getExternalCells(e),g=!1;for(let M=0;M<t;M++){for(let T=0;T<s;T++)if(e.cells[M][T].type!==0){g=!0;break}if(g)break}this.tetrisCache.clear();for(let M of i){let T=e.cols+1,k=Math.floor(M/T),K=M%T,z=0n,F=e.nodes[k][K].type;(F===3||F===4)&&(z|=1n<<BigInt(c.get(`n${K},${k}`)));let Q=e.symmetry||0;if(Q!==0){let X=this.getSymmetricalPointIndex(e,M),J=Math.floor(X/T),_=X%T,V=e.nodes[J][_].type;(V===3||V===5)&&(z|=1n<<BigInt(c.get(`n${_},${J}`)))}let se=1n<<BigInt(M);if(Q!==0){let X=this.getSymmetricalPointIndex(e,M);if(X===M)continue;se|=1n<<BigInt(X)}this.exploreSearchSpace(e,M,se,[M],z,a,o,d,h,u,p,m,g,c)}if(u.solutions===0)return 0;let x=l.size+f.size,b=new Set;l.size>0&&b.add(999);let P=0,S=0,C=0;for(let M=0;M<t;M++)for(let T=0;T<s;T++){let k=e.cells[M][T];k.type!==0&&(x++,b.add(k.type),k.type===3?P++:k.type===4?(P++,S++):k.type===8&&C++)}let v=u.branchingPoints/(u.totalNodesVisited||1),E=Math.log10(u.totalNodesVisited+1),N=(v*10+E*1.5)/(Math.log2(u.solutions+1)*.5+1);N-=l.size*.05,N+=f.size*.12,P>0&&(N+=(P-S)*.5,N+=S*.2);let w=0,H=0;for(let M=0;M<t;M++)for(let T=0;T<s;T++){let k=e.cells[M][T];k.type===5?w++:k.type===6&&(w++,H++)}w>0&&(N+=(w-H)*.6,N+=H*.3),C>0&&(N+=C*.25);let O=t*s,L=x/O,B=L<.25?Math.pow(L/.25,4):1,I=b.size<=1?.5:1;N*=B*I;let $=Math.log2(O)/5;return N*=$,Math.max(.01,Math.min(1,N/4))}exploreSearchSpace(e,t,s,n,r,o,i,d,c,y,l,f,u=!0,a){if(y.totalNodesVisited++,y.maxDepth=Math.max(y.maxDepth,n.length),y.totalNodesVisited>l)return;let h=e.symmetry||0;if(d.includes(t)){let g=0,x=r;for(;x>0n;)x&1n&&g++,x>>=1n;if(g===o){let b=n.map(C=>({x:C%(e.cols+1),y:Math.floor(C/(e.cols+1))})),P={points:b};if(h!==0){let C=this.getSymmetricalPointIndex(e,t),v=e.cols+1;if(e.nodes[Math.floor(C/v)][C%v].type!==2)return}let S=h!==0?b.map(C=>this.getSymmetricalPoint(e,C)):[];if(u){let C=this.validateFast(e,b,S,f);if(C.isValid){let v=this.getFingerprint(e,b,S,C.regions,f);c.has(v)||(c.add(v),y.solutions++)}}else{let C=this.getFingerprint(e,b,S,void 0,f);c.has(C)||(c.add(C),y.solutions++)}}return}if(!this.canReachEndOptimized(t,s,i,d)){y.backtracks++;return}let p=[];for(let g of i[t]){if(g.isBroken||s&1n<<BigInt(g.next))continue;if(h!==0){let b=this.getSymmetricalPointIndex(e,t),P=this.getSymmetricalPointIndex(e,g.next);if(g.next===P||t===P&&g.next===b)continue}let x=!0;for(let b of i[t])if(b.hexType===3||b.hexType===4){let S=n.length>=2&&b.next===n[n.length-2],C=b.next===g.next;if(!S&&!C){x=!1;break}}if(x){if(h!==0){let b=this.getSymmetricalPointIndex(e,t),P=this.getSymmetricalPointIndex(e,g.next);for(let S of i[b])if(S.hexType===3||S.hexType===5){let v=n.length>=2?this.getSymmetricalPointIndex(e,n[n.length-2]):-1,E=S.next===v,N=S.next===P;if(!E&&!N){x=!1;break}}}x&&p.push(g)}}if(p.length>1&&y.branchingPoints++,e.rows*e.cols>30)for(let g=p.length-1;g>0;g--){let x=this.rng?this.rng.next():Math.random(),b=Math.floor(x*(g+1));[p[g],p[b]]=[p[b],p[g]]}let m=e.cols+1;for(let g of p){let x=r,b=Math.floor(g.next/m),P=g.next%m,S=e.nodes[b][P].type;(S===3||S===4)&&(x|=1n<<BigInt(a.get(`n${P},${b}`)));let C=n[n.length-1],v=Math.floor(C/m),E=C%m;if(v===b){let w=Math.min(E,P);(g.hexType===3||g.hexType===4)&&(x|=1n<<BigInt(a.get(`eh${w},${b}`)))}else{let w=Math.min(v,b);(g.hexType===3||g.hexType===4)&&(x|=1n<<BigInt(a.get(`ev${P},${w}`)))}if(h!==0){let w=this.getSymmetricalPointIndex(e,g.next),H=Math.floor(w/m),O=w%m,L=e.nodes[H][O].type;(L===3||L===5)&&(x|=1n<<BigInt(a.get(`n${O},${H}`)));let B=this.getSymmetricalPointIndex(e,C),I=Math.floor(B/m),$=B%m;if(I===H){let M=Math.min($,O),T=e.hEdges[H][M].type;(T===3||T===5)&&(x|=1n<<BigInt(a.get(`eh${M},${H}`)))}else{let M=Math.min(I,H),T=e.vEdges[M][O].type;(T===3||T===5)&&(x|=1n<<BigInt(a.get(`ev${O},${M}`)))}}n.push(g.next);let N=s|1n<<BigInt(g.next);if(h!==0){let w=this.getSymmetricalPointIndex(e,g.next);N|=1n<<BigInt(w)}if(this.exploreSearchSpace(e,g.next,N,n,x,o,i,d,c,y,l,f,u,a),n.pop(),y.totalNodesVisited>l)return}}countSolutions(e,t=100){let s=e.rows,n=e.cols,r=n+1,o=(s+1)*r,i=Array.from({length:o},()=>[]),d=[],c=[],y=new Map,l=0;for(let p=0;p<=s;p++)for(let m=0;m<=n;m++){let g=p*r+m;if(e.nodes[p][m].type===1&&d.push(g),e.nodes[p][m].type===2&&c.push(g),(e.nodes[p][m].type===3||e.nodes[p][m].type===4||e.nodes[p][m].type===5)&&y.set(`n${m},${p}`,l++),m<n){let x=g+1,b=e.hEdges[p][m].type,P=b===3||b===4||b===5,S=b===1||b===2;i[g].push({next:x,hexType:b,isBroken:S}),i[x].push({next:g,hexType:b,isBroken:S}),P&&y.set(`eh${m},${p}`,l++)}if(p<s){let x=g+r,b=e.vEdges[p][m].type,P=b===3||b===4||b===5,S=b===1||b===2;i[g].push({next:x,hexType:b,isBroken:S}),i[x].push({next:g,hexType:b,isBroken:S}),P&&y.set(`ev${m},${p}`,l++)}}let f=new Set,u=l,a=this.getExternalCells(e),h=!1;for(let p=0;p<s;p++){for(let m=0;m<n;m++)if(e.cells[p][m].type!==0){h=!0;break}if(h)break}this.tetrisCache.clear();for(let p of d){let m=e.cols+1,g=Math.floor(p/m),x=p%m,b=0n,P=e.nodes[g][x].type;(P===3||P===4)&&(b|=1n<<BigInt(y.get(`n${x},${g}`)));let S=e.symmetry||0;if(S!==0){let v=this.getSymmetricalPointIndex(e,p),E=Math.floor(v/m),N=v%m,w=e.nodes[E][N].type;(w===3||w===5)&&(b|=1n<<BigInt(y.get(`n${N},${E}`)))}let C=1n<<BigInt(p);if(S!==0){let v=this.getSymmetricalPointIndex(e,p);if(v===p)continue;C|=1n<<BigInt(v)}this.findPathsOptimized(e,p,C,[p],b,u,i,c,f,t,a,h,y)}return f.size}findPathsOptimized(e,t,s,n,r,o,i,d,c,y,l,f=!0,u){if(c.size>=y)return;let a=e.symmetry||0;if(d.includes(t)){let h=0,p=r;for(;p>0n;)p&1n&&h++,p>>=1n;if(h===o){let m=n.map(x=>({x:x%(e.cols+1),y:Math.floor(x/(e.cols+1))}));if(a!==0){let x=this.getSymmetricalPointIndex(e,t),b=e.cols+1;if(e.nodes[Math.floor(x/b)][x%b].type!==2)return}let g=a!==0?m.map(x=>this.getSymmetricalPoint(e,x)):[];if(!f)c.add(this.getFingerprint(e,m,g,void 0,l));else{let x=this.validateFast(e,m,g,l);x.isValid&&c.add(this.getFingerprint(e,m,g,x.regions,l))}}return}if(this.canReachEndOptimized(t,s,i,d))for(let h of i[t]){if(h.isBroken||s&1n<<BigInt(h.next))continue;if(a!==0){let E=this.getSymmetricalPointIndex(e,t),N=this.getSymmetricalPointIndex(e,h.next);if(h.next===N||t===N&&h.next===E)continue}let p=!0;for(let E of i[t])if(E.hexType===3||E.hexType===4){let w=n.length>=2&&E.next===n[n.length-2],H=E.next===h.next;if(!w&&!H){p=!1;break}}if(!p)continue;if(a!==0){let E=this.getSymmetricalPointIndex(e,t),N=this.getSymmetricalPointIndex(e,h.next);for(let w of i[E])if(w.hexType===3||w.hexType===5){let O=n.length>=2?this.getSymmetricalPointIndex(e,n[n.length-2]):-1,L=w.next===O,B=w.next===N;if(!L&&!B){p=!1;break}}}if(!p)continue;let m=e.cols+1,g=r,x=Math.floor(h.next/m),b=h.next%m,P=e.nodes[x][b].type;(P===3||P===4)&&(g|=1n<<BigInt(u.get(`n${b},${x}`)));let S=Math.floor(t/m),C=t%m;if(S===x){let E=Math.min(C,b);(h.hexType===3||h.hexType===4)&&(g|=1n<<BigInt(u.get(`eh${E},${x}`)))}else{let E=Math.min(S,x);(h.hexType===3||h.hexType===4)&&(g|=1n<<BigInt(u.get(`ev${b},${E}`)))}if(a!==0){let E=this.getSymmetricalPointIndex(e,h.next),N=Math.floor(E/m),w=E%m,H=e.nodes[N][w].type;(H===3||H===5)&&(g|=1n<<BigInt(u.get(`n${w},${N}`)));let O=this.getSymmetricalPointIndex(e,t),L=Math.floor(O/m),B=O%m;if(L===N){let I=Math.min(B,w),$=e.hEdges[N][I].type;($===3||$===5)&&(g|=1n<<BigInt(u.get(`eh${I},${N}`)))}else{let I=Math.min(L,N),$=e.vEdges[I][w].type;($===3||$===5)&&(g|=1n<<BigInt(u.get(`ev${w},${I}`)))}}n.push(h.next);let v=s|1n<<BigInt(h.next);if(a!==0){let E=this.getSymmetricalPointIndex(e,h.next);v|=1n<<BigInt(E)}if(this.findPathsOptimized(e,h.next,v,n,g,o,i,d,c,y,l,f,u),n.pop(),c.size>=y)return}}canReachEndOptimized(e,t,s,n){let r=[e],o=t,i=0;for(;i<r.length;){let d=r[i++];if(n.includes(d))return!0;for(let c of s[d])!c.isBroken&&!(o&1n<<BigInt(c.next))&&(o|=1n<<BigInt(c.next),r.push(c.next))}return!1}getFingerprint(e,t,s,n,r){let i=(n||this.calculateRegions(e,t,s,r)).map(c=>{let y="",l=[];for(let f of c){let u=e.cells[f.y][f.x];u.type!==0&&l.push(u.type<<8|u.color)}l.sort((f,u)=>f-u);for(let f of l)y+=f.toString(36)+",";return y}).sort(),d="";for(let c of i)c.length>0&&(d+=c+"|");return d||"empty"}};var ce=class{isWorker;TETRIS_SHAPES_WITH_ROTATIONS=[];rng=null;constructor(){this.isWorker=typeof self<"u"&&"postMessage"in self&&!("document"in self);for(let e of this.TETRIS_SHAPES)this.TETRIS_SHAPES_WITH_ROTATIONS.push(this.getAllRotations(e))}stringToSeed(e){try{if(/^[0-9a-fA-F]+$/.test(e))return BigInt("0x"+e)}catch{}let t=0n;for(let s=0;s<e.length;s++)t=(t<<5n)-t+BigInt(e.charCodeAt(s));return t}generate(e,t,s={}){let n=s.rngType??0,r=s.seed;r||(r=Math.floor(Math.random()*4294967295).toString(16));let o=r,i=this.stringToSeed(r),d=s.difficulty??.5,c=new ae,y=null,l=-1,f=e*t<=16,u=this.isWorker?e*t>30?120:f?250:150:e*t>30?80:f?200:100,a=this.isWorker?8:f?12:6,h=s.symmetry||0,p={x:0,y:e},m={x:t,y:0};h===1?m={x:0,y:0}:h===2?m={x:t,y:e}:h===3&&(m={x:t,y:e});let g=null,x=null,b=null;for(let P=0;P<u;P++){let S=(i^0x5deece66dn)+0xbn;if(this.rng=ye(n,i^0x5deece66dn),c.setRng(this.rng),P%a===0){g=this.generateRandomPath(new oe(e,t),p,m,s.pathLength,h);let w=new oe(e,t),H=h!==0?g.map(O=>this.getSymmetricalPoint(w,O,h)):[];x=this.calculateRegions(w,g,H),b=x.map(O=>this.getRegionBoundaryEdges(w,O,g,H))}let C=this.generateFromPath(e,t,g,s,x,b);if(!c.validate(C,{points:g}).isValid){i=S;continue}if(!this.checkAllRequestedConstraintsPresent(C,s)){i=S;continue}let E=c.calculateDifficulty(C);if(E===0){i=S;continue}let N=Math.abs(E-d);if((y===null||N<Math.abs(l-d))&&(l=E,y=C,y.seed=o),d>.8&&E>.8){y.seed=o;break}if(N<.01){y.seed=o;break}i=S}if(!y){for(let C=0;C<50;C++){this.rng=ye(n,i),c.setRng(this.rng);let v=this.generateRandomPath(new oe(e,t),p,m,s.pathLength,h),E=this.generateFromPath(e,t,v,s);if(c.validate(E,{points:v}).isValid)return E.seed=o,E;i=(i^0x5deece66dn)+0xbn}this.rng=ye(n,i),c.setRng(this.rng);let P=this.generateRandomPath(new oe(e,t),p,m,s.pathLength,h),S=this.generateFromPath(e,t,P,s);return S.seed=o,S}return y}generateFromPath(e,t,s,n,r,o){let i=new oe(e,t),d=n.symmetry||0;i.symmetry=d;let c={x:0,y:e},y={x:t,y:0};if(d===1?y={x:0,y:0}:d===2?y={x:t,y:e}:d===3&&(y={x:t,y:e}),i.nodes[c.y][c.x].type=1,i.nodes[y.y][y.x].type=2,d!==0){let f=this.getSymmetricalPoint(i,c,d),u=this.getSymmetricalPoint(i,y,d);i.nodes[f.y][f.x].type=1,i.nodes[u.y][u.x].type=2}let l=d!==0?s.map(f=>this.getSymmetricalPoint(i,f,d)):[];return this.applyConstraintsBasedOnPath(i,s,n,l,r,o),n.useBrokenEdges&&this.applyBrokenEdges(i,s,n),this.cleanGrid(i),i}generateRandomPath(e,t,s,n,r=0){if(n===void 0)return this.generateSingleRandomPath(e,t,s,void 0,r);let o=e.rows+e.cols,i=(e.rows+1)*(e.cols+1)-1,d=o+n*(i-o),c=[],y=1/0,l=e.rows*e.cols>30?30:50;for(let f=0;f<l;f++){let u=this.generateSingleRandomPath(e,t,s,n,r);if(u.length===0)continue;let a=u.length-1,h=Math.abs(a-d);if(h<y&&(y=h,c=u),y<=2)break}return c}generateSingleRandomPath(e,t,s,n,r=0){let o=new Set,i=[],d=0,c=e.rows*e.cols*200,y=l=>{if(d++,d>c)return!1;o.add(`${l.x},${l.y}`);let f=this.getSymmetricalPoint(e,l,r);if(o.add(`${f.x},${f.y}`),i.push(l),l.x===s.x&&l.y===s.y)return!0;let u=this.getValidNeighbors(e,l,o);r!==0&&(u=u.filter(a=>{let h=this.getSymmetricalPoint(e,a,r);if(h.x<0||h.x>e.cols||h.y<0||h.y>e.rows||o.has(`${h.x},${h.y}`)||a.x===h.x&&a.y===h.y)return!1;let p=this.getEdgeKey(l,a),m=this.getEdgeKey(f,h);return p!==m})),n!==void 0?u.sort((a,h)=>{let p=Math.abs(a.x-s.x)+Math.abs(a.y-s.y),m=Math.abs(h.x-s.x)+Math.abs(h.y-s.y);return(p-m)*(1-n*2)+(this.rng.next()-.5)*1.5}):this.shuffleArray(u);for(let a of u)if(y(a))return!0;return i.pop(),o.delete(`${l.x},${l.y}`),o.delete(`${f.x},${f.y}`),!1};return y(t),i}getValidNeighbors(e,t,s){let n=[],r=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of r){let i=t.x+o.x,d=t.y+o.y;i>=0&&i<=e.cols&&d>=0&&d<=e.rows&&(s.has(`${i},${d}`)||n.push({x:i,y:d}))}return n}applyBrokenEdges(e,t,s){let n=s.complexity??.5,r=s.symmetry??0,o=new Set;for(let l=0;l<t.length-1;l++)if(o.add(this.getEdgeKey(t[l],t[l+1])),r!==0){let f=this.getSymmetricalPoint(e,t[l],r),u=this.getSymmetricalPoint(e,t[l+1],r);o.add(this.getEdgeKey(f,u))}let i=[];for(let l=0;l<=e.rows;l++)for(let f=0;f<e.cols;f++){let u={x:f,y:l},a={x:f+1,y:l};o.has(this.getEdgeKey(u,a))||i.push({type:"h",r:l,c:f,p1:u,p2:a})}for(let l=0;l<e.rows;l++)for(let f=0;f<=e.cols;f++){let u={x:f,y:l},a={x:f,y:l+1};o.has(this.getEdgeKey(u,a))||i.push({type:"v",r:l,c:f,p1:u,p2:a})}this.shuffleArray(i);let d=Math.max(1,Math.floor(n*(e.rows*e.cols)/4)),c=0;for(let l of i){if(c>=d)break;l.type==="h"?e.hEdges[l.r][l.c].type=1:e.vEdges[l.r][l.c].type=1,c++}let y=!0;for(;y;){y=!1;for(let l=0;l<=e.rows;l++)for(let f=0;f<e.cols;f++)e.hEdges[l][f].type===1&&this.canBecomeAbsent(e,{type:"h",r:l,c:f})&&(e.hEdges[l][f].type=2,y=!0);for(let l=0;l<e.rows;l++)for(let f=0;f<=e.cols;f++)e.vEdges[l][f].type===1&&this.canBecomeAbsent(e,{type:"v",r:l,c:f})&&(e.vEdges[l][f].type=2,y=!0)}for(let l=0;l<=e.rows;l++)for(let f=0;f<=e.cols;f++){let u=[];if(f>0&&u.push({e:e.hEdges[l][f-1],type:"h",r:l,c:f-1}),f<e.cols&&u.push({e:e.hEdges[l][f],type:"h",r:l,c:f}),l>0&&u.push({e:e.vEdges[l-1][f],type:"v",r:l-1,c:f}),l<e.rows&&u.push({e:e.vEdges[l][f],type:"v",r:l,c:f}),u.length>0&&u.every(a=>a.e.type===1||a.e.type===2)&&u.every(a=>!this.isAdjacentToMark(e,a)))for(let a of u)a.e.type=2}}canBecomeAbsent(e,t){if(this.isAdjacentToMark(e,t))return!1;if(t.type==="h"){if(t.r===0||t.r===e.rows)return!0}else if(t.c===0||t.c===e.cols)return!0;let s=t.type==="h"?[{x:t.c,y:t.r},{x:t.c+1,y:t.r}]:[{x:t.c,y:t.r},{x:t.c,y:t.r+1}];for(let n of s){let r=[{type:"h",r:n.y,c:n.x-1},{type:"h",r:n.y,c:n.x},{type:"v",r:n.y-1,c:n.x},{type:"v",r:n.y,c:n.x}];for(let o of r)if(o.c>=0&&o.c<=e.cols&&o.r>=0&&o.r<=e.rows){if(o.type==="h"&&o.c<e.cols){if(e.hEdges[o.r][o.c].type===2)return!0}else if(o.type==="v"&&o.r<e.rows&&e.vEdges[o.r][o.c].type===2)return!0}}return!1}cleanGrid(e){let t=[];for(let o=0;o<=e.rows;o++)for(let i=0;i<=e.cols;i++)e.nodes[o][i].type===1&&t.push({x:i,y:o});let s=new Set,n=[...t];for(let o of t)s.add(`${o.x},${o.y}`);for(;n.length>0;){let o=n.shift(),i=[{nx:o.x,ny:o.y-1,edge:e.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:e.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:e.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:e.hEdges[o.y]?.[o.x]}];for(let d of i)d.edge&&d.edge.type!==2&&(s.has(`${d.nx},${d.ny}`)||(s.add(`${d.nx},${d.ny}`),n.push({x:d.nx,y:d.ny})))}for(let o=0;o<=e.rows;o++)for(let i=0;i<e.cols;i++)(!s.has(`${i},${o}`)||!s.has(`${i+1},${o}`))&&(e.hEdges[o][i].type=2);for(let o=0;o<e.rows;o++)for(let i=0;i<=e.cols;i++)(!s.has(`${i},${o}`)||!s.has(`${i},${o+1}`))&&(e.vEdges[o][i].type=2);let r=this.getExternalCells(e);for(let o of r){let[i,d]=o.split(",").map(Number);e.cells[d][i].type=0}}getExternalCells(e){let t=new Set,s=[];for(let n=0;n<e.cols;n++)e.hEdges[0][n].type===2&&(t.has(`${n},0`)||(t.add(`${n},0`),s.push({x:n,y:0}))),e.hEdges[e.rows][n].type===2&&(t.has(`${n},${e.rows-1}`)||(t.add(`${n},${e.rows-1}`),s.push({x:n,y:e.rows-1})));for(let n=0;n<e.rows;n++)e.vEdges[n][0].type===2&&(t.has(`0,${n}`)||(t.add(`0,${n}`),s.push({x:0,y:n}))),e.vEdges[n][e.cols].type===2&&(t.has(`${e.cols-1},${n}`)||(t.add(`${e.cols-1},${n}`),s.push({x:e.cols-1,y:n})));for(;s.length>0;){let n=s.shift(),r=[{nx:n.x,ny:n.y-1,edge:e.hEdges[n.y][n.x]},{nx:n.x,ny:n.y+1,edge:e.hEdges[n.y+1][n.x]},{nx:n.x-1,ny:n.y,edge:e.vEdges[n.y][n.x]},{nx:n.x+1,ny:n.y,edge:e.vEdges[n.y][n.x+1]}];for(let o of r)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),s.push({x:o.nx,y:o.ny}))}return t}isAdjacentToMark(e,t){if(t.type==="h"){if(t.r>0&&e.cells[t.r-1][t.c].type!==0||t.r<e.rows&&e.cells[t.r][t.c].type!==0)return!0}else if(t.c>0&&e.cells[t.r][t.c-1].type!==0||t.c<e.cols&&e.cells[t.r][t.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let t=0;t<e.rows;t++)for(let s=0;s<e.cols;s++){if(e.cells[t][s].type===0)continue;if([e.hEdges[t][s],e.hEdges[t+1][s],e.vEdges[t][s],e.vEdges[t][s+1]].every(r=>r.type===1||r.type===2))return!0}return!1}getSymmetricalPoint(e,t,s){return s===1?{x:e.cols-t.x,y:t.y}:s===2?{x:t.x,y:e.rows-t.y}:s===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,t,s,n=[],r,o){let i=s.complexity??.5,d=s.useHexagons??!0,c=s.useSquares??!0,y=s.useStars??!0,l=s.useTetris??!1,f=s.useTetrisNegative??!1,u=s.useEraser??!1,a=s.useTriangles??!1,h=0,p=0,m=0,g=0,x=0,b=0,P=Math.floor(e.rows*e.cols*.6);if(d){let S=s.difficulty??.5,C=s.symmetry||0;for(let v=0;v<t.length-1;v++){let N=this.getValidNeighbors(e,t[v],new Set).length>2,w=i*(S<.4?.6:.3);if(N&&(w=S<.4?w*1:w*.5),this.rng.next()<w){let H=3,O=t[v],L=t[v+1];if(C!==0){let B=this.rng.next();B<.3?H=4:B<.6&&(H=5,O=this.getSymmetricalPoint(e,t[v],C),L=this.getSymmetricalPoint(e,t[v+1],C))}this.setEdgeHexagon(e,O,L,H),h++}}for(let v=0;v<t.length;v++){let E=t[v];if(e.nodes[E.y][E.x].type!==0||this.hasIncidentHexagonEdge(e,E))continue;let N=i*(S>.6?.15:.05);if(this.rng.next()<N){let w=3,H=E;if(C!==0){let O=this.rng.next();O<.3?w=4:O<.6&&(w=5,H=this.getSymmetricalPoint(e,E,C))}e.nodes[H.y][H.x].type=w,h++}}if(h===0&&t.length>=2){let v=Math.floor(this.rng.next()*(t.length-1)),E=s.symmetry||0,N=3,w=t[v],H=t[v+1];if(E!==0){let O=this.rng.next();O<.3?N=4:O<.6&&(N=5,w=this.getSymmetricalPoint(e,t[v],E),H=this.getSymmetricalPoint(e,t[v+1],E))}this.setEdgeHexagon(e,w,H,N)}}if(c||y||l||u||a){let S=r||this.calculateRegions(e,t,n),C=s.availableColors??[U.Black,U.White,U.Red,U.Blue],v=s.defaultColors??{},E=(I,$)=>{if(v[I]!==void 0)return v[I];let M=re[I];return M&&v[M]!==void 0?v[M]:I===4?E(3,$):I===6?E(5,$):$},N=Array.from({length:S.length},(I,$)=>$);this.shuffleArray(N);let w=new Set,H={square:c,star:y,tetris:l,tetrisNegative:f,eraser:u,triangle:a},O=0,L=0,B=new Set;for(let I=0;I<t.length-1;I++)B.add(this.getEdgeKey(t[I],t[I+1]));for(let I=0;I<n.length-1;I++)B.add(this.getEdgeKey(n[I],n[I+1]));for(let I=0;I<N.length;I++){let $=N[I],M=S[$],T=N.length-I,k=H.square&&p===0||H.star&&m===0||H.tetris&&g===0||H.tetrisNegative&&O===0||H.eraser&&x===0||H.triangle&&L===0,K=.2+i*.6;if(k&&T<=3?K=1:k&&T<=6&&(K=.7),this.rng.next()>K)continue;let z=[...M];this.shuffleArray(z);let F=new Set,Q=C[Math.floor(this.rng.next()*C.length)];if(c&&w.size<2){let X=C.filter(J=>!w.has(J));X.length>0&&(Q=X[Math.floor(this.rng.next()*X.length)])}let se=c&&this.rng.next()<.5+i*.3;if(c&&p===0&&T<=2&&(se=!0),c&&!y&&T<=2&&w.size<2&&p>0&&(se=!0),se&&z.length>0){let X=Math.min(z.length,Math.max(4,Math.floor(M.length/4))),J=Math.floor(this.rng.next()*(X/2))+Math.ceil(X/2);for(let _=0;_<J&&z.length!==0;_++){let V=z.pop();e.cells[V.y][V.x].type=1,e.cells[V.y][V.x].color=Q,p++,w.add(Q),F.add(Q)}}if(l||f){let X=this.rng.next()<.1+i*.4;g===0&&T<=3&&(X=!0),f&&O===0&&T<=2&&(X=!0);let J=g===0&&T<=2?6:4,_=b+M.length<=P||k&&l&&g===0&&M.length<=30||k&&f&&O===0&&M.length<=30;if(X&&z.length>0&&_){let V=M.length<=25?this.generateTiling(M,J,s):null;if(V){let D=[],Y=.2+i*.3;if(f&&O===0&&T<=3&&(Y=.9),f&&this.rng.next()<Y){let A=s.difficulty??.5;if(this.rng.next()<.1&&z.length>=2){let G=!1;if(z.length>=3&&this.rng.next()<.8){let Z=this.rng.next()<.5,ne=1+Math.floor(this.rng.next()*2),te=this.TETRIS_SHAPES.filter(ie=>this.getShapeArea(ie)===ne),ee=te[Math.floor(this.rng.next()*te.length)],q=this.findStandardTriple(ee);q&&(Z?(V.push({shape:ee,displayShape:ee,isRotated:!this.isRotationallyInvariant(ee)&&this.rng.next()<A*.7,isNegative:!1}),V.push({shape:q.n,displayShape:q.n,isRotated:!this.isRotationallyInvariant(q.n)&&this.rng.next()<A*.7,isNegative:!1}),D.push({shape:q.p,displayShape:q.p,isRotated:!this.isRotationallyInvariant(q.p)&&this.rng.next()<A*.7,isNegative:!0})):(V.push({shape:q.p,displayShape:q.p,isRotated:!this.isRotationallyInvariant(q.p)&&this.rng.next()<A*.7,isNegative:!1}),D.push({shape:ee,displayShape:ee,isRotated:!this.isRotationallyInvariant(ee)&&this.rng.next()<A*.7,isNegative:!0}),D.push({shape:q.n,displayShape:q.n,isRotated:!this.isRotationallyInvariant(q.n)&&this.rng.next()<A*.7,isNegative:!0})),G=!0)}if(!G){let Z=3+Math.floor(this.rng.next()*2),ne=this.TETRIS_SHAPES.filter(te=>this.getShapeArea(te)===Z);if(this.shuffleArray(ne),ne.length>0){let te=ne[0],ee=ne[0];V.push({shape:te,displayShape:te,isRotated:!this.isRotationallyInvariant(te)&&this.rng.next()<A*.7,isNegative:!1}),D.push({shape:ee,displayShape:ee,isRotated:!this.isRotationallyInvariant(ee)&&this.rng.next()<A*.7,isNegative:!0})}}}else if(V.length>0){let G=this.rng.next()<.3?2:1;for(let Z=0;Z<G&&!(z.length<1);Z++){let ne=Math.floor(this.rng.next()*V.length),te=V[ne];if(te.isNegative)continue;let ee=!1;if(z.length>=2&&this.rng.next()<.2){let q=this.findStandardTriple(te.shape);if(q){let ie=this.findStandardTriple(q.p);ie&&(V[ne]={shape:ie.p,displayShape:ie.p,isRotated:!this.isRotationallyInvariant(ie.p)&&this.rng.next()<A*.7,isNegative:!1},D.push({shape:q.n,displayShape:q.n,isRotated:!this.isRotationallyInvariant(q.n)&&this.rng.next()<A*.7,isNegative:!0}),D.push({shape:ie.n,displayShape:ie.n,isRotated:!this.isRotationallyInvariant(ie.n)&&this.rng.next()<A*.7,isNegative:!0}),ee=!0)}}if(!ee){let q=this.findStandardTriple(te.shape);q&&(V.some(Pe=>!Pe.isNegative&&this.isSameShape(Pe.shape,q.n))||(V[ne]={shape:q.p,displayShape:q.p,isRotated:!this.isRotationallyInvariant(q.p)&&this.rng.next()<A*.7,isNegative:!1},D.push({shape:q.n,displayShape:q.n,isRotated:!this.isRotationallyInvariant(q.n)&&this.rng.next()<A*.7,isNegative:!0})))}}}}let R=[...V,...D];if(R.length>z.length)continue;for(let A of R){if(z.length===0)break;let W=z.pop();if(A.isNegative)e.cells[W.y][W.x].type=A.isRotated?6:5,e.cells[W.y][W.x].color=E(5,U.None),O++;else{e.cells[W.y][W.x].type=A.isRotated?4:3;let Z=E(3,U.None),ne=Z;if(y&&this.rng.next()<.3){let te=C.filter(ee=>ee!==Z&&!F.has(ee));te.length>0&&(ne=te[Math.floor(this.rng.next()*te.length)],F.add(ne))}e.cells[W.y][W.x].color=ne}e.cells[W.y][W.x].shape=A.isRotated?A.displayShape:A.shape,g++}b+=M.length}}}if(a){let X=this.rng.next()<.2+i*.5;if(L===0&&T<=2&&(X=!0),X&&z.length>0){this.shuffleArray(z);let J=Math.min(z.length,Math.max(1,Math.floor(M.length/3))),_=0;for(let V=0;V<z.length&&_<J;V++){let D=z[V],Y=[this.getEdgeKey({x:D.x,y:D.y},{x:D.x+1,y:D.y}),this.getEdgeKey({x:D.x,y:D.y+1},{x:D.x+1,y:D.y+1}),this.getEdgeKey({x:D.x,y:D.y},{x:D.x,y:D.y+1}),this.getEdgeKey({x:D.x+1,y:D.y},{x:D.x+1,y:D.y+1})],R=0;for(let A of Y)B.has(A)&&R++;if(R>=1&&R<=3){e.cells[D.y][D.x].type=8,e.cells[D.y][D.x].count=R;let A=E(8,U.None),W=A;if(y&&this.rng.next()<.3){let G=C.filter(Z=>Z!==A&&!F.has(Z));G.length>0&&(W=G[Math.floor(this.rng.next()*G.length)],F.add(W))}e.cells[D.y][D.x].color=W,z.splice(V,1),V--,L++,_++}}}}if(u&&x<1){let X=.05+i*.2,J=this.rng.next()<X;if(T<=2&&(J=!0),J&&z.length>=1){let _=[];y&&_.push("star"),c&&_.push("square");let V=[];d&&(V=o?o[$]:this.getRegionBoundaryEdges(e,M,t,n),V.length>0&&_.push("hexagon")),l&&_.push("tetris"),f&&_.push("tetrisNegative"),a&&_.push("triangle"),this.shuffleArray(_),z.length>=2&&_.push("eraser");let D=!1;for(let Y of _){if(D)break;if(Y==="hexagon"){let R=V.filter(A=>!this.isEdgeAdjacentToHexagonNode(e,A));if(R.length>0){let A=R[Math.floor(this.rng.next()*R.length)];A.type==="h"?e.hEdges[A.r][A.c].type=3:e.vEdges[A.r][A.c].type=3,h++,D=!0}}else if(Y==="square"&&z.length>=2){let R=z.pop();e.cells[R.y][R.x].type=1;let A=M.find(G=>e.cells[G.y][G.x].type===1),W=A?e.cells[A.y][A.x].color:void 0;e.cells[R.y][R.x].color=C.find(G=>G!==W)||U.Red,p++,D=!0}else if(Y==="star"&&z.length>=2){let R=z.pop();e.cells[R.y][R.x].type=2,e.cells[R.y][R.x].color=C[Math.floor(this.rng.next()*C.length)],m++,D=!0}else if(Y==="tetris"&&z.length>=2){let R=this.generateTiling(M,4,s),A=[];if(R&&R.length>0){let W=0;for(let G of R){let Z=this.getShapeArea(G.shape);if(W+Z<M.length)A.push(G),W+=Z;else break}}if(A.length===0&&M.length>1&&(A=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),A.length>0){for(let W of A){if(z.length<2)break;let G=z.pop();e.cells[G.y][G.x].type=W.isRotated?4:3,e.cells[G.y][G.x].shape=W.isRotated?W.displayShape:W.shape,e.cells[G.y][G.x].color=E(e.cells[G.y][G.x].type,U.None),g++}D=!0}}else if(Y==="tetrisNegative"&&this.canPlaceGeneratedTetrisNegative(e,M,z)){if(!this.hasRegionTetrisSymbol(e,M)){let A=z.pop();e.cells[A.y][A.x].type=3,e.cells[A.y][A.x].shape=[[1]],e.cells[A.y][A.x].color=E(3,U.None),g++}let R=z.pop();e.cells[R.y][R.x].type=5,e.cells[R.y][R.x].shape=[[1]],e.cells[R.y][R.x].color=E(5,U.None),O++}else if(Y==="triangle"&&z.length>=2){let R=z.pop();e.cells[R.y][R.x].type=8;let A=[this.getEdgeKey({x:R.x,y:R.y},{x:R.x+1,y:R.y}),this.getEdgeKey({x:R.x,y:R.y+1},{x:R.x+1,y:R.y+1}),this.getEdgeKey({x:R.x,y:R.y},{x:R.x,y:R.y+1}),this.getEdgeKey({x:R.x+1,y:R.y},{x:R.x+1,y:R.y+1})],W=0;for(let Z of A)B.has(Z)&&W++;let G=(W+1)%4;G===0&&(G=1),e.cells[R.y][R.x].count=G,e.cells[R.y][R.x].color=E(8,U.None),L++,D=!0}else if(Y==="eraser"&&this.canPlaceGeneratedEraser(e,M,z)){let R=z.pop();e.cells[R.y][R.x].type=7,e.cells[R.y][R.x].color=E(7,U.White),x++,D=!0}}if(D&&this.canPlaceGeneratedEraser(e,M,z)){let Y=z.pop();e.cells[Y.y][Y.x].type=7;let R=E(7,U.White),A=R;if(y&&this.rng.next()<.3){let W=C.filter(G=>G!==R&&!F.has(G));W.length>0&&(A=W[Math.floor(this.rng.next()*W.length)],F.add(A))}e.cells[Y.y][Y.x].color=A,x++}}}if(y){for(let J of C){if(z.length<1)break;if(M.filter(V=>e.cells[V.y][V.x].color===J).length===1&&(J!==U.White||F.has(J))){let V=z.pop();e.cells[V.y][V.x].type=2,e.cells[V.y][V.x].color=J,m++}}let X=Math.max(1,Math.floor(M.length/8));for(let J=0;J<X&&!(z.length<2);J++)for(let _ of C){if(z.length<2)break;if(this.rng.next()>.3+i*.4)continue;if(M.filter(D=>e.cells[D.y][D.x].color===_).length===0)for(let D=0;D<2;D++){let Y=z.pop();e.cells[Y.y][Y.x].type=2,e.cells[Y.y][Y.x].color=_,m++}}}}if(c&&w.size<2){let I=w.values().next().value;if(!(I!==void 0&&m>0&&Array.from({length:e.rows*e.cols}).some((M,T)=>{let k=Math.floor(T/e.cols),K=T%e.cols;return e.cells[k][K].type===2&&e.cells[k][K].color===I}))){for(let M of S){if(w.size>=2)break;if(M.some(k=>e.cells[k.y][k.x].type===1))continue;let T=M.filter(k=>e.cells[k.y][k.x].type===0);if(T.length>0){let k=C.find(z=>!w.has(z))||U.White,K=T[Math.floor(this.rng.next()*T.length)];e.cells[K.y][K.x].type=1,e.cells[K.y][K.x].color=k,w.add(k),p++}}if(w.size<2&&y&&I!==void 0)for(let M of S){let T=M.filter(k=>e.cells[k.y][k.x].type===0);if(T.length>0){let k=T[Math.floor(this.rng.next()*T.length)];e.cells[k.y][k.x].type=2,e.cells[k.y][k.x].color=I,m++;break}}}}}}calculateRegions(e,t,s=[]){let n=[],r=e.rows,o=e.cols,i=new Uint8Array(r*o),d=new Uint8Array((r+1)*o),c=new Uint8Array(r*(o+1)),y=(l,f)=>{l.x===f.x?c[Math.min(l.y,f.y)*(o+1)+l.x]=1:d[l.y*o+Math.min(l.x,f.x)]=1};for(let l=0;l<t.length-1;l++)y(t[l],t[l+1]);for(let l=0;l<s.length-1;l++)y(s[l],s[l+1]);for(let l=0;l<=r;l++)for(let f=0;f<o;f++)e.hEdges[l][f].type===2&&(d[l*o+f]=1);for(let l=0;l<r;l++)for(let f=0;f<=o;f++)e.vEdges[l][f].type===2&&(c[l*(o+1)+f]=1);for(let l=0;l<r;l++)for(let f=0;f<o;f++){let u=l*o+f;if(i[u])continue;let a=[],h=[u];i[u]=1;let p=0;for(;p<h.length;){let m=h[p++],g=m%o,x=Math.floor(m/o);if(a.push({x:g,y:x}),x>0&&!d[x*o+g]){let b=(x-1)*o+g;i[b]||(i[b]=1,h.push(b))}if(x<r-1&&!d[(x+1)*o+g]){let b=(x+1)*o+g;i[b]||(i[b]=1,h.push(b))}if(g>0&&!c[x*(o+1)+g]){let b=x*o+(g-1);i[b]||(i[b]=1,h.push(b))}if(g<o-1&&!c[x*(o+1)+(g+1)]){let b=x*o+(g+1);i[b]||(i[b]=1,h.push(b))}}n.push(a)}return n}isAbsentEdge(e,t,s){if(t.x===s.x){let n=Math.min(t.y,s.y);return e.vEdges[n][t.x].type===2}else{let n=Math.min(t.x,s.x);return e.hEdges[t.y][n].type===2}}getRegionBoundaryEdges(e,t,s,n=[]){let r=new Set;for(let d=0;d<s.length-1;d++)r.add(this.getEdgeKey(s[d],s[d+1]));for(let d=0;d<n.length-1;d++)r.add(this.getEdgeKey(n[d],n[d+1]));let o=[];for(let d of t){let c=[{type:"h",r:d.y,c:d.x},{type:"h",r:d.y+1,c:d.x},{type:"v",r:d.y,c:d.x},{type:"v",r:d.y,c:d.x+1}];for(let y of c){let l=y.type==="h"?{x:y.c,y:y.r}:{x:y.c,y:y.r},f=y.type==="h"?{x:y.c+1,y:y.r}:{x:y.c,y:y.r+1},u=this.getEdgeKey(l,f);!r.has(u)&&!this.isAbsentEdge(e,l,f)&&o.push(y)}}let i=new Map;for(let d of o)i.set(`${d.type},${d.r},${d.c}`,d);return Array.from(i.values())}setEdgeHexagon(e,t,s,n=3){t.x===s.x?e.vEdges[Math.min(t.y,s.y)][t.x].type=n:e.hEdges[t.y][Math.min(t.x,s.x)].type=n}hasIncidentHexagonEdge(e,t){let s=n=>n===3||n===4||n===5;return!!(t.x>0&&s(e.hEdges[t.y][t.x-1].type)||t.x<e.cols&&s(e.hEdges[t.y][t.x].type)||t.y>0&&s(e.vEdges[t.y-1][t.x].type)||t.y<e.rows&&s(e.vEdges[t.y][t.x].type))}isEdgeAdjacentToHexagonNode(e,t){let s=n=>n===3||n===4||n===5;return t.type==="h"?s(e.nodes[t.r][t.c].type)||s(e.nodes[t.r][t.c+1].type):s(e.nodes[t.r][t.c].type)||s(e.nodes[t.r+1][t.c].type)}checkAllRequestedConstraintsPresent(e,t){let s=t.useHexagons??!0,n=t.useSquares??!0,r=t.useStars??!0,o=t.useTetris??!1,i=t.useTetrisNegative??!1,d=t.useEraser??!1,c=t.useTriangles??!1;if(t.useBrokenEdges??!1){let l=!1;for(let f=0;f<=e.rows;f++)for(let u=0;u<e.cols;u++)if(e.hEdges[f][u].type===1||e.hEdges[f][u].type===2){l=!0;break}if(!l){for(let f=0;f<e.rows;f++)for(let u=0;u<=e.cols;u++)if(e.vEdges[f][u].type===1||e.vEdges[f][u].type===2){l=!0;break}}if(!l)return!1}if(s){let l=!1,f=a=>a===3||a===4||a===5,u=a=>a===3||a===4||a===5;for(let a=0;a<=e.rows;a++)for(let h=0;h<e.cols;h++)if(f(e.hEdges[a][h].type)){l=!0;break}if(!l){for(let a=0;a<e.rows;a++)for(let h=0;h<=e.cols;h++)if(f(e.vEdges[a][h].type)){l=!0;break}}if(!l){for(let a=0;a<=e.rows;a++)for(let h=0;h<=e.cols;h++)if(u(e.nodes[a][h].type)){l=!0;break}}if(!l)return!1}if(n||r||o||d){let l=!1,f=!1,u=!1,a=!1,h=!1,p=!1,m=new Set,g=new Set;for(let x=0;x<e.rows;x++)for(let b=0;b<e.cols;b++){let P=e.cells[x][b].type;P===1&&(l=!0,m.add(e.cells[x][b].color)),P===2&&(f=!0,g.add(e.cells[x][b].color)),(P===3||P===4)&&(u=!0),(P===5||P===6)&&(a=!0),P===7&&(h=!0),P===8&&(p=!0)}if(n&&!l||r&&!f||o&&!u||i&&!a||d&&!h||c&&!p)return!1;if(n&&l&&m.size<2){let x=m.values().next().value;if(x===void 0||!g.has(x))return!1}}return!this.hasIsolatedMark(e)}generateTiling(e,t,s){let n=Math.min(...e.map(l=>l.x)),r=Math.min(...e.map(l=>l.y)),o=Math.max(...e.map(l=>l.x)),i=Math.max(...e.map(l=>l.y)),d=o-n+1,c=i-r+1,y=Array.from({length:c},()=>Array(d).fill(!1));for(let l of e)y[l.y-r][l.x-n]=!0;return this.tilingDfs(y,[],t,s)}tilingDfs(e,t,s,n){let r=-1,o=-1;for(let c=0;c<e.length;c++){for(let y=0;y<e[0].length;y++)if(e[c][y]){r=c,o=y;break}if(r!==-1)break}if(r===-1)return t;if(t.length>=s)return null;let i=n.difficulty??.5,d=Array.from({length:this.TETRIS_SHAPES.length},(c,y)=>y);this.shuffleArray(d),i>.6&&d.sort((c,y)=>this.getShapeArea(this.TETRIS_SHAPES[y])-this.getShapeArea(this.TETRIS_SHAPES[c]));for(let c of d){let y=this.TETRIS_SHAPES[c],l=this.TETRIS_SHAPES_WITH_ROTATIONS[c],f=Array.from({length:l.length},(u,a)=>a);this.shuffleArray(f);for(let u of f){let a=l[u],h=[];for(let p=0;p<a.length;p++)for(let m=0;m<a[0].length;m++)a[p][m]&&h.push({r:p,c:m});for(let p of h){let m=r-p.r,g=o-p.c;if(this.canPlace(e,a,m,g)){this.placePiece(e,a,m,g,!1);let x=l.length>1&&this.rng.next()<.3+i*.6,b=this.tilingDfs(e,[...t,{shape:a,displayShape:y,isRotated:x}],s,n);if(b)return b;this.placePiece(e,a,m,g,!0)}}}}return null}getShapeArea(e){let t=0;for(let s of e)for(let n of s)n&&t++;return t}isRotationallyInvariant(e){return this.getAllRotations(e).length===1}getAllRotations(e){let t=[],s=new Set,n=e;for(let r=0;r<4;r++){let o=JSON.stringify(n);s.has(o)||(t.push(n),s.add(o)),n=this.rotate90(n)}return t}rotate90(e){let t=e.length,s=e[0].length,n=Array.from({length:s},()=>Array(t).fill(0));for(let r=0;r<t;r++)for(let o=0;o<s;o++)n[o][t-1-r]=e[r][o];return n}canPlace(e,t,s,n){for(let r=0;r<t.length;r++)for(let o=0;o<t[0].length;o++)if(t[r][o]){let i=s+r,d=n+o;if(i<0||i>=e.length||d<0||d>=e[0].length||!e[i][d])return!1}return!0}placePiece(e,t,s,n,r){for(let o=0;o<t.length;o++)for(let i=0;i<t[0].length;i++)t[o][i]&&(e[s+o][n+i]=r)}isSameShape(e,t){let s=this.getAllRotations(e),n=JSON.stringify(t);return s.some(r=>JSON.stringify(r)===n)}countRegionNonEraserSymbols(e,t){let s=0;for(let n of t){let r=e.cells[n.y][n.x].type;r!==0&&r!==7&&s++}return s}hasRegionTetrisSymbol(e,t){for(let s of t){let n=e.cells[s.y][s.x].type;if(n===3||n===4)return!0}return!1}canPlaceGeneratedTetrisNegative(e,t,s){return s.length<1?!1:this.hasRegionTetrisSymbol(e,t)?!0:s.length>=2}canPlaceGeneratedEraser(e,t,s){return s.length<1?!1:this.countRegionNonEraserSymbols(e,t)>0?!0:s.length>=2}canTilePieceWith(e,t,s){let n=this.getShapeArea(e),r=this.getShapeArea(t),o=this.getShapeArea(s);if(n!==r+o)return!1;let i=this.getAllRotations(t),d=this.getAllRotations(s),c=e.length,y=e[0].length;for(let l of i)for(let f of d){let u=l.length,a=l[0].length,h=f.length,p=f[0].length;for(let m=0;m<=c-u;m++)for(let g=0;g<=y-a;g++)for(let x=0;x<=c-h;x++)for(let b=0;b<=y-p;b++){let P=Array.from({length:c},()=>Array(y).fill(0)),S=!0;for(let C=0;C<u;C++)for(let v=0;v<a;v++)l[C][v]&&(P[m+C][g+v]=1);for(let C=0;C<h;C++){for(let v=0;v<p;v++)if(f[C][v]){if(P[x+C][b+v]){S=!1;break}P[x+C][b+v]=1}if(!S)break}if(S){let C=!0;for(let v=0;v<c;v++){for(let E=0;E<y;E++)if(P[v][E]!==e[v][E]){C=!1;break}if(!C)break}if(C)return!0}}}return!1}findStandardTriple(e){let t=this.getShapeArea(e),s=[...this.TETRIS_SHAPES];this.shuffleArray(s);for(let n of s){let r=this.getShapeArea(n),o=t+r;if(o>5)continue;let i=this.TETRIS_SHAPES.filter(d=>this.getShapeArea(d)===o);for(let d of i)if(this.canTilePieceWith(d,e,n))return{p:d,n}}return null}shuffleArray(e){for(let t=e.length-1;t>0;t--){let s=Math.floor(this.rng.next()*(t+1));[e[t],e[s]]=[e[s],e[t]]}}};var fe=class{canvas;ctx=null;worker=null;puzzle=null;options;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;invalidatedCells=[];invalidatedEdges=[];invalidatedNodes=[];errorCells=[];errorEdges=[];errorNodes=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;canvasRect=null;isDestroyed=!1;animationFrameId=null;timeoutId=null;boundMouseDown=null;boundMouseMove=null;boundMouseUp=null;boundTouchStart=null;boundTouchMove=null;boundTouchEnd=null;boundUpdateRect=null;constructor(e,t,s={}){if(typeof e=="string"){if(typeof document>"u")throw new Error("Cannot look up canvas by ID in a non-browser environment.");let n=document.getElementById(e);if(!(n instanceof HTMLCanvasElement))throw new Error(`Element with id "${e}" is not a canvas.`);this.canvas=n}else this.canvas=e;if(this.options=this.mergeOptions(s),this.options.useWorker&&typeof window<"u"&&this.canvas instanceof HTMLCanvasElement&&this.canvas.transferControlToOffscreen){let n=this.options.workerScript??import.meta.url;if(n){this.worker=new Worker(n,{type:"module"});let r=this.canvas.transferControlToOffscreen(),o=this.sanitizeOptions(this.options);this.worker.postMessage({type:"init",payload:{canvas:r,options:o}},[r]),this.worker.addEventListener("message",i=>{let{type:d,payload:c}=i.data;d==="drawingStarted"?this.isDrawing=c!==!1:d==="drawingEnded"?this.isDrawing=!1:d==="pathComplete"&&this.options.onPathComplete?this.options.onPathComplete(c):d==="puzzleCreated"&&this.options.onPuzzleCreated?this.options.onPuzzleCreated(c):d==="validationResult"&&this.options.onValidationResult&&this.options.onValidationResult(c)})}}if(!this.worker){let n=this.canvas.getContext("2d");if(!n)throw new Error("Could not get 2D context.");this.ctx=n,this.ctx.imageSmoothingEnabled=!1,this.animate()}t&&this.setPuzzle(t),this.initEvents()}mergeOptions(e){let t={blinkDuration:e.animations?.blinkDuration??this.options?.animations?.blinkDuration??1e3,fadeDuration:e.animations?.fadeDuration??this.options?.animations?.fadeDuration??1e3,blinkPeriod:e.animations?.blinkPeriod??this.options?.animations?.blinkPeriod??800},s={path:e.colors?.path??this.options?.colors?.path??"#ffcc00",error:e.colors?.error??this.options?.colors?.error??"#ff4444",success:e.colors?.success??this.options?.colors?.success??"#ffcc00",symmetry:e.colors?.symmetry??this.options?.colors?.symmetry??"rgba(255, 255, 255, 0.5)",interrupted:e.colors?.interrupted??this.options?.colors?.interrupted??"#ffcc00",grid:e.colors?.grid??this.options?.colors?.grid??"#555",node:e.colors?.node??this.options?.colors?.node??"#555",hexagon:e.colors?.hexagon??this.options?.colors?.hexagon??"#000",hexagonMain:e.colors?.hexagonMain??this.options?.colors?.hexagonMain??"#00ffff",hexagonSymmetry:e.colors?.hexagonSymmetry??this.options?.colors?.hexagonSymmetry??"#ffff00",colorMap:e.colors?.colorMap??this.options?.colors?.colorMap??{[U.Black]:"#000",[U.White]:"#fff",[U.Red]:"#f00",[U.Blue]:"#00f",[U.None]:"#ffcc00"},colorList:e.colors?.colorList??this.options?.colors?.colorList};return{gridPadding:e.gridPadding??this.options?.gridPadding??60,cellSize:e.cellSize??this.options?.cellSize??80,nodeRadius:e.nodeRadius??this.options?.nodeRadius??6,startNodeRadius:e.startNodeRadius??this.options?.startNodeRadius??22,pathWidth:e.pathWidth??this.options?.pathWidth??18,exitLength:e.exitLength??this.options?.exitLength??25,autoResize:e.autoResize??this.options?.autoResize??!0,blinkMarksOnError:e.blinkMarksOnError??this.options?.blinkMarksOnError??!0,stayPathOnError:e.stayPathOnError??this.options?.stayPathOnError??!0,autoValidate:e.autoValidate??this.options?.autoValidate??!1,useWorker:e.useWorker??this.options?.useWorker??!1,workerScript:e.workerScript??this.options?.workerScript,animations:t,colors:s,onPathComplete:e.onPathComplete??this.options?.onPathComplete??(()=>{}),onPuzzleCreated:e.onPuzzleCreated??this.options?.onPuzzleCreated,onValidationResult:e.onValidationResult??this.options?.onValidationResult}}setPuzzle(e){if(this.worker){this.puzzle=e,this.options.autoResize&&this.resizeCanvas(),this.worker.postMessage({type:"setPuzzle",payload:{puzzle:e}});return}this.puzzle=e,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw()}setOptions(e){if(this.options=this.mergeOptions({...this.options,...e}),this.worker){this.options.autoResize&&this.puzzle&&this.resizeCanvas();let t=this.sanitizeOptions(e);this.worker.postMessage({type:"setOptions",payload:t});return}this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}setValidationResult(e,t=[],s=[],n=[],r=[],o=[],i=[]){this.worker||(this.invalidatedCells=t,this.invalidatedEdges=s,this.invalidatedNodes=o,this.errorCells=n,this.errorEdges=r,this.errorNodes=i,this.eraserAnimationStartTime=Date.now(),e?(this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0)}resizeCanvas(){if(!this.puzzle||!this.canvas)return;let e=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,t=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2;if(typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement)try{this.canvas.width=e,this.canvas.height=t}catch{}else this.canvas.width=e,this.canvas.height=t;this.worker&&this.boundUpdateRect&&this.boundUpdateRect()}setCanvasRect(e){let t={left:e.left,top:e.top,width:e.width,height:e.height};this.canvasRect=t,this.worker&&this.worker.postMessage({type:"setCanvasRect",payload:t})}createPuzzle(e,t,s){this.worker&&this.worker.postMessage({type:"createPuzzle",payload:{rows:e,cols:t,genOptions:s}})}initEvents(){typeof window>"u"||typeof HTMLCanvasElement>"u"||!(this.canvas instanceof HTMLCanvasElement)||(this.boundMouseDown=e=>{this.handleStart(e)&&e.cancelable&&e.preventDefault()},this.boundMouseMove=e=>{this.isDrawing&&e.cancelable&&e.preventDefault(),this.handleMove(e)},this.boundMouseUp=e=>{this.isDrawing&&e.cancelable&&e.preventDefault(),this.handleEnd(e)},this.boundTouchStart=e=>{this.handleStart(e.touches[0])&&e.cancelable&&e.preventDefault()},this.boundTouchMove=e=>{this.isDrawing&&(e.cancelable&&e.preventDefault(),this.handleMove(e.touches[0]))},this.boundTouchEnd=e=>{this.isDrawing&&(e.cancelable&&e.preventDefault(),this.handleEnd(e.changedTouches[0]))},this.canvas.addEventListener("mousedown",this.boundMouseDown),window.addEventListener("mousemove",this.boundMouseMove,{passive:!1}),window.addEventListener("mouseup",this.boundMouseUp,{passive:!1}),this.canvas.addEventListener("touchstart",this.boundTouchStart,{passive:!1}),window.addEventListener("touchmove",this.boundTouchMove,{passive:!1}),window.addEventListener("touchend",this.boundTouchEnd,{passive:!1}),this.worker&&(this.boundUpdateRect=()=>{if(this.canvas instanceof HTMLCanvasElement){let e=this.canvas.getBoundingClientRect();this.setCanvasRect(e)}},window.addEventListener("resize",this.boundUpdateRect),window.addEventListener("scroll",this.boundUpdateRect),this.boundUpdateRect()))}destroy(){this.isDestroyed=!0,this.worker&&(this.worker.terminate(),this.worker=null),this.animationFrameId!==null&&typeof cancelAnimationFrame<"u"&&cancelAnimationFrame(this.animationFrameId),this.timeoutId!==null&&clearTimeout(this.timeoutId),!(typeof window>"u"||typeof HTMLCanvasElement>"u"||!(this.canvas instanceof HTMLCanvasElement))&&(this.boundMouseDown&&this.canvas.removeEventListener("mousedown",this.boundMouseDown),this.boundMouseMove&&window.removeEventListener("mousemove",this.boundMouseMove),this.boundMouseUp&&window.removeEventListener("mouseup",this.boundMouseUp),this.boundTouchStart&&this.canvas.removeEventListener("touchstart",this.boundTouchStart),this.boundTouchMove&&window.removeEventListener("touchmove",this.boundTouchMove),this.boundTouchEnd&&window.removeEventListener("touchend",this.boundTouchEnd),this.boundUpdateRect&&(window.removeEventListener("resize",this.boundUpdateRect),window.removeEventListener("scroll",this.boundUpdateRect)),this.boundMouseDown=null,this.boundMouseMove=null,this.boundMouseUp=null,this.boundTouchStart=null,this.boundTouchMove=null,this.boundTouchEnd=null)}getCanvasCoords(e,t){return{x:this.options.gridPadding+e*this.options.cellSize,y:this.options.gridPadding+t*this.options.cellSize}}getExitDir(e,t){return!this.puzzle||this.puzzle.nodes[t]?.[e]?.type!==2?null:e===this.puzzle.cols?{x:1,y:0}:e===0?{x:-1,y:0}:t===0?{x:0,y:-1}:t===this.puzzle.rows?{x:0,y:1}:{x:1,y:0}}handleStart(e){if(this.worker)return this.isDrawing=!0,this.worker.postMessage({type:"event",payload:{eventType:"mousedown",eventData:{clientX:e.clientX,clientY:e.clientY}}}),!0;if(!this.puzzle)return!1;let t=this.canvasRect||(typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),s=(e.clientX-t.left)*(this.canvas.width/t.width),n=(e.clientY-t.top)*(this.canvas.height/t.height);for(let r=0;r<=this.puzzle.rows;r++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[r][o].type===1){let i=this.getCanvasCoords(o,r);if(Math.hypot(i.x-s,i.y-n)<this.options.startNodeRadius)return this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.isDrawing=!0,this.path=[{x:o,y:r}],this.currentMousePos=i,this.exitTipPos=null,this.draw(),!0}return!1}handleMove(e){if(this.worker){this.isDrawing&&this.worker.postMessage({type:"event",payload:{eventType:"mousemove",eventData:{clientX:e.clientX,clientY:e.clientY}}});return}if(!this.puzzle||!this.isDrawing)return;let t=this.canvasRect||(typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),s=(e.clientX-t.left)*(this.canvas.width/t.width),n=(e.clientY-t.top)*(this.canvas.height/t.height),r=this.path[this.path.length-1],o=this.getCanvasCoords(r.x,r.y),i=s-o.x,d=n-o.y,c=this.puzzle.symmetry||0,y=this.getExitDir(r.x,r.y),l=Math.abs(i)>Math.abs(d)?{x:i>0?1:-1,y:0}:{x:0,y:d>0?1:-1};if(y&&l.x===y.x&&l.y===y.y){let h=i*y.x+d*y.y,p=Math.max(0,Math.min(h,this.options.exitLength));this.currentMousePos={x:o.x+y.x*p,y:o.y+y.y*p},this.draw();return}let f=(h,p)=>{let m=this.getEdgeType(r,h);if(h.x<0||h.x>this.puzzle.cols||h.y<0||h.y>this.puzzle.rows||m===2){this.currentMousePos=o;return}let g=m===1?this.options.cellSize*.35:this.options.cellSize,x=this.getEdgeKey(r,h);if(!(this.path.length>=2&&h.x===this.path[this.path.length-2].x&&h.y===this.path[this.path.length-2].y)){for(let S=0;S<this.path.length-1;S++)if(this.getEdgeKey(this.path[S],this.path[S+1])===x){g=0;break}}if(this.path.some(S=>S.x===h.x&&S.y===h.y)&&this.path.length>=2){let S=this.path[this.path.length-2];(h.x!==S.x||h.y!==S.y)&&(g=Math.min(g,this.options.cellSize*.5-this.options.pathWidth*.5))}if(c!==0){let S=this.getSymmetricalPoint(r),C=this.getSymmetricalPoint(h),v=this.getEdgeType(S,C),E=this.getSymmetryPath(this.path),N=this.getEdgeKey(S,C);if(C.x<0||C.x>this.puzzle.cols||C.y<0||C.y>this.puzzle.rows||v===2){this.currentMousePos=o;return}v===1&&(g=Math.min(g,this.options.cellSize*.35));let w=E.some($=>$.x===h.x&&$.y===h.y),H=this.path.some($=>$.x===C.x&&$.y===C.y),O=h.x===C.x&&h.y===C.y,L=E.some(($,M)=>M<E.length-1&&this.getEdgeKey(E[M],E[M+1])===x),B=this.path.some(($,M)=>M<this.path.length-1&&this.getEdgeKey(this.path[M],this.path[M+1])===N);(w||H||O||L||B||x===N)&&(g=Math.min(g,this.options.cellSize*.5-this.options.pathWidth*.5))}h.x!==r.x?this.currentMousePos={x:o.x+Math.max(-g,Math.min(g,p)),y:o.y}:this.currentMousePos={x:o.x,y:o.y+Math.max(-g,Math.min(g,p))}};if(Math.abs(i)>Math.abs(d)){let h=i>0?1:-1;f({x:r.x+h,y:r.y},i)}else{let h=d>0?1:-1;f({x:r.x,y:r.y+h},d)}let u=[{x:r.x+1,y:r.y},{x:r.x-1,y:r.y},{x:r.x,y:r.y+1},{x:r.x,y:r.y-1}],a=this.getSymmetryPath(this.path);for(let h of u)if(h.x>=0&&h.x<=this.puzzle.cols&&h.y>=0&&h.y<=this.puzzle.rows){let p=this.getCanvasCoords(h.x,h.y);if(Math.hypot(p.x-this.currentMousePos.x,p.y-this.currentMousePos.y)<this.options.cellSize*.3){let g=this.path.findIndex(x=>x.x===h.x&&x.y===h.y);if(g===-1){if(c!==0){let x=this.getSymmetricalPoint(h);if(h.x===x.x&&h.y===x.y||this.path.some(S=>S.x===x.x&&S.y===x.y)||a.some(S=>S.x===h.x&&S.y===h.y))continue;let b=this.getEdgeKey(r,h),P=this.getEdgeKey(this.getSymmetricalPoint(r),x);if(b===P)continue}this.path.push(h)}else g===this.path.length-2&&this.path.pop()}}this.draw()}handleEnd(e){if(this.worker){this.isDrawing&&(this.isDrawing=!1,this.worker.postMessage({type:"event",payload:{eventType:"mouseup",eventData:{clientX:e.clientX,clientY:e.clientY}}}));return}if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let t=this.path[this.path.length-1],s=this.getCanvasCoords(t.x,t.y),n=this.getExitDir(t.x,t.y);if(n){let r=this.currentMousePos.x-s.x,o=this.currentMousePos.y-s.y;if(r*n.x+o*n.y>0){this.exitTipPos={x:s.x+n.x*this.options.exitLength,y:s.y+n.y*this.options.exitLength},this.options.onPathComplete(this.path);return}}this.exitTipPos=n?{...this.currentMousePos}:null,this.startFade(this.options.colors.interrupted)}getEdgeType(e,t){if(!this.puzzle)return 2;if(e.x===t.x){let s=Math.min(e.y,t.y);return s<0||s>=this.puzzle.rows?2:this.puzzle.vEdges[s][e.x].type}else{let s=Math.min(e.x,t.x);return s<0||s>=this.puzzle.cols?2:this.puzzle.hEdges[e.y][s].type}}startFade(e="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=e,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){if(this.isDestroyed)return;let e=Date.now();if(this.isFading){let t=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=t,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0)}this.isInvalidPath&&!this.options.stayPathOnError&&!this.isFading&&this.path.length>0&&this.startFade(this.options.colors.error),this.draw(),typeof requestAnimationFrame<"u"?this.animationFrameId=requestAnimationFrame(()=>this.animate()):(this.timeoutId=setTimeout(()=>this.animate(),1e3/60),this.timeoutId&&this.timeoutId.unref&&this.timeoutId.unref())}draw(){if(!this.puzzle||!this.ctx)return;let e=this.ctx,t=Date.now();if(e.globalAlpha=1,e.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(e),this.drawConstraints(e),this.drawNodes(e),this.path.length===0&&!this.isDrawing&&this.drawRipples(e),this.isFading){if(this.drawPath(e,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let s=this.getSymmetryPath(this.fadingPath),n=this.options.colors.symmetry;if(this.isInvalidPath){let o=this.colorToRgba(n).a;n=this.setAlpha(this.options.colors.error,o)}let r=null;if(this.fadingTipPos){let o=(this.fadingTipPos.x-this.options.gridPadding)/this.options.cellSize,i=(this.fadingTipPos.y-this.options.gridPadding)/this.options.cellSize,d=this.getSymmetricalPoint({x:o,y:i});r={x:d.x*this.options.cellSize+this.options.gridPadding,y:d.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,s,!1,n,this.fadeOpacity,r)}}else if(this.path.length>0){let s=this.options.colors.path,n=this.colorToRgba(s).a,r=this.options.colors.error,o=this.isInvalidPath?this.setAlpha(r,n):s;this.isSuccessFading&&!this.puzzle.symmetry&&(o=this.setAlpha(this.options.colors.success,n));let i=1;if(!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let y=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),l=this.options.animations.blinkDuration;y<l&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(o=this.setAlpha(this.options.colors.error,n),this.options.stayPathOnError||(i=Math.max(0,1-y/this.options.animations.fadeDuration)))}let d=null;if(this.isDrawing||this.exitTipPos){let y=this.isDrawing?this.currentMousePos:this.exitTipPos;if(this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let l=(y.x-this.options.gridPadding)/this.options.cellSize,f=(y.y-this.options.gridPadding)/this.options.cellSize,u=this.getSymmetricalPoint({x:l,y:f},!0);d={x:u.x*this.options.cellSize+this.options.gridPadding,y:u.y*this.options.cellSize+this.options.gridPadding}}}let c=this.isPathAtExit(this.path,this.isDrawing?this.currentMousePos:this.exitTipPos);if(c&&!this.isInvalidPath&&!this.isSuccessFading){let y=this.colorToRgba(o).a,l=(Math.sin(t*Math.PI*2/600)+1)/2;o=this.lerpColor(o,"#ffffff",l*.6),o=this.setAlpha(o,y)}if(this.drawPath(e,this.path,this.isDrawing,o,i,this.isDrawing?this.currentMousePos:this.exitTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let y=this.getSymmetryPath(this.path),l=this.options.colors.symmetry,f=this.colorToRgba(l).a,u=l,a=i;if(this.isInvalidPath&&(u=this.setAlpha(r,f)),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let h=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),p=this.options.animations.blinkDuration;h<p&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(u=this.setAlpha(this.options.colors.error,f))}if(c&&!this.isInvalidPath&&!this.isSuccessFading){let h=(Math.sin(t*Math.PI*2/400)+1)/2;u=this.lerpColor(u,"#ffffff",h*.6),u=this.setAlpha(u,f)}this.drawPath(e,y,this.isDrawing,u,a,d)}}}drawRipples(e){if(!this.puzzle)return;let t=(Date.now()-this.startTime)/500;for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++)if(this.puzzle.nodes[s][n].type===2){let o=this.getCanvasCoords(n,s),i=this.getExitDir(n,s);if(!i)continue;let d={x:o.x+i.x*this.options.exitLength,y:o.y+i.y*this.options.exitLength},c=t%4,y=c*5,l=Math.max(0,1-c/3);e.beginPath(),e.arc(d.x,d.y,y,0,Math.PI*2),e.strokeStyle=`rgba(170, 170, 170, ${l*.4})`,e.lineWidth=2,e.stroke()}}drawGrid(e){if(!this.puzzle||!this.options.colors.grid)return;e.strokeStyle=this.options.colors.grid,e.lineWidth=12,e.lineCap="round";let t=(s,n,r)=>{if(r!==2)if(r===1){let i={x:s.x+(n.x-s.x)*.35,y:s.y+(n.y-s.y)*.35},d={x:s.x+(n.x-s.x)*(.5+.15),y:s.y+(n.y-s.y)*(.5+.15)};e.beginPath(),e.moveTo(s.x,s.y),e.lineTo(i.x,i.y),e.stroke(),e.beginPath(),e.moveTo(d.x,d.y),e.lineTo(n.x,n.y),e.stroke()}else e.beginPath(),e.moveTo(s.x,s.y),e.lineTo(n.x,n.y),e.stroke()};for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<this.puzzle.cols;n++)t(this.getCanvasCoords(n,s),this.getCanvasCoords(n+1,s),this.puzzle.hEdges[s][n].type);for(let s=0;s<this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++)t(this.getCanvasCoords(n,s),this.getCanvasCoords(n,s+1),this.puzzle.vEdges[s][n].type)}drawConstraints(e){if(!this.puzzle)return;let t=Date.now(),s=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;for(let o=0;o<this.puzzle.rows;o++)for(let i=0;i<this.puzzle.cols;i++){let d=this.puzzle.cells[o][i],c=this.getCanvasCoords(i+.5,o+.5),y=this.invalidatedCells.some(p=>p.x===i&&p.y===o),l=this.errorCells.some(p=>p.x===i&&p.y===o),f=1,u,a=this.getColorCode(d.color),h=this.options.colors.error;if(l&&this.options.blinkMarksOnError&&(u=this.lerpColor(a,h,s)),y){let p=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),m=this.options.animations.blinkDuration;if(p<m){if(this.options.blinkMarksOnError){let g=Math.min(1,p/200),x=p>m*.8?(m-p)/(m*.2):1,b=Math.min(g,x);u=this.lerpColor(a,h,s*b)}}else f=Math.max(.3,1-(p-m)/this.options.animations.fadeDuration)}if(f<1||u){let{canvas:p,ctx:m}=this.prepareOffscreen();this.drawConstraintItem(m,d,c,u),e.save(),e.globalAlpha=f,e.drawImage(p,0,0),e.restore()}else this.drawConstraintItem(e,d,c)}e.lineWidth=2;let n=8,r=o=>o===3||o===3?this.options.colors.hexagon:o===4||o===4?this.options.colors.hexagonMain:o===5||o===5?this.options.colors.hexagonSymmetry:this.options.colors.hexagon;for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<this.puzzle.cols;i++){let d=this.puzzle.hEdges[o][i].type;if(d===3||d===4||d===5){let c=this.getCanvasCoords(i+.5,o);e.save();let y=this.invalidatedEdges.some(u=>u.type==="h"&&u.r===o&&u.c===i),l=this.errorEdges.some(u=>u.type==="h"&&u.r===o&&u.c===i),f=r(d);if(l&&this.options.blinkMarksOnError){let u=this.lerpColor(f,this.options.colors.error,s);this.drawHexagon(e,c.x,c.y,n,u)}else if(y){let u=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),a=this.options.animations.blinkDuration;if(u<a)if(this.options.blinkMarksOnError){let h=Math.min(1,u/200),p=u>a*.8?(a-u)/(a*.2):1,m=Math.min(h,p),g=this.lerpColor(f,this.options.colors.error,s*m);this.drawHexagon(e,c.x,c.y,n,g)}else this.drawHexagon(e,c.x,c.y,n,f);else e.globalAlpha*=Math.max(.3,1-(u-a)/this.options.animations.fadeDuration),this.drawHexagon(e,c.x,c.y,n,f)}else this.drawHexagon(e,c.x,c.y,n,f);e.restore()}}for(let o=0;o<this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++){let d=this.puzzle.vEdges[o][i].type;if(d===3||d===4||d===5){let c=this.getCanvasCoords(i,o+.5);e.save();let y=this.invalidatedEdges.some(u=>u.type==="v"&&u.r===o&&u.c===i),l=this.errorEdges.some(u=>u.type==="v"&&u.r===o&&u.c===i),f=r(d);if(l&&this.options.blinkMarksOnError){let u=this.lerpColor(f,this.options.colors.error,s);this.drawHexagon(e,c.x,c.y,n,u)}else if(y){let u=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),a=this.options.animations.blinkDuration;if(u<a)if(this.options.blinkMarksOnError){let h=Math.min(1,u/200),p=u>a*.8?(a-u)/(a*.2):1,m=Math.min(h,p),g=this.lerpColor(f,this.options.colors.error,s*m);this.drawHexagon(e,c.x,c.y,n,g)}else this.drawHexagon(e,c.x,c.y,n,f);else e.globalAlpha*=Math.max(.3,1-(u-a)/this.options.animations.fadeDuration),this.drawHexagon(e,c.x,c.y,n,f)}else this.drawHexagon(e,c.x,c.y,n,f);e.restore()}}for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++){let d=this.puzzle.nodes[o][i].type;if(d===3||d===4||d===5){let c=this.getCanvasCoords(i,o);e.save();let y=this.invalidatedNodes.some(u=>u.x===i&&u.y===o),l=this.errorNodes.some(u=>u.x===i&&u.y===o),f=r(d);if(l&&this.options.blinkMarksOnError){let u=this.lerpColor(f,this.options.colors.error,s);this.drawHexagon(e,c.x,c.y,n,u)}else if(y){let u=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),a=this.options.animations.blinkDuration;if(u<a)if(this.options.blinkMarksOnError){let h=Math.min(1,u/200),p=u>a*.8?(a-u)/(a*.2):1,m=Math.min(h,p),g=this.lerpColor(f,this.options.colors.error,s*m);this.drawHexagon(e,c.x,c.y,n,g)}else this.drawHexagon(e,c.x,c.y,n,f);else e.globalAlpha*=Math.max(.3,1-(u-a)/this.options.animations.fadeDuration),this.drawHexagon(e,c.x,c.y,n,f)}else this.drawHexagon(e,c.x,c.y,n,f);e.restore()}}}drawConstraintItem(e,t,s,n){t.type===1?(e.fillStyle=n||this.getColorCode(t.color),this.drawRoundedRect(e,s.x-26/2,s.y-26/2,26,26,8)):t.type===2?this.drawStar(e,s.x,s.y,12,16,8,t.color,n):t.type===3||t.type===4?this.drawTetris(e,s.x,s.y,t.shape||[],t.type===4,t.color,!1,n):t.type===5||t.type===6?this.drawTetris(e,s.x,s.y,t.shape||[],t.type===6,t.color,!0,n):t.type===7?this.drawEraser(e,s.x,s.y,14,3,t.color,n):t.type===8&&this.drawTriangle(e,s.x,s.y,t.count||0,t.color,n)}drawNodes(e){if(!this.puzzle)return;let t=(s,n)=>{let r=[];return s>0&&r.push(this.puzzle.hEdges[n][s-1].type),s<this.puzzle.cols&&r.push(this.puzzle.hEdges[n][s].type),n>0&&r.push(this.puzzle.vEdges[n-1][s].type),n<this.puzzle.rows&&r.push(this.puzzle.vEdges[n][s].type),r.length>0&&r.every(o=>o===2)};for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++){if(t(n,s))continue;let r=this.puzzle.nodes[s][n];if(r.type===3||r.type===4||r.type===5)continue;let o=this.getCanvasCoords(n,s);if(r.type===1)this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill();else if(r.type===2){let i=this.getExitDir(n,s);if(!i)continue;this.options.colors.node&&(e.strokeStyle=this.options.colors.node),e.lineWidth=12,e.lineCap="round",e.beginPath(),e.moveTo(o.x,o.y),e.lineTo(o.x+i.x*this.options.exitLength,o.y+i.y*this.options.exitLength),e.stroke()}else this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.nodeRadius,0,Math.PI*2),e.fill()}}drawPath(e,t,s,n,r,o=null){if(t.length===0||!n||n==="transparent")return;let i=this.colorToRgba(n),d=`rgb(${i.r},${i.g},${i.b})`,c=r*i.a,{canvas:y,ctx:l}=this.prepareOffscreen();this.drawPathInternal(l,t,s,d,o),e.save(),e.globalAlpha=c,e.drawImage(y,0,0),e.restore()}drawPathInternal(e,t,s,n,r=null){e.save(),e.strokeStyle=n,e.fillStyle=n,e.lineWidth=this.options.pathWidth,e.lineCap="round",e.lineJoin="round",e.beginPath();let o=this.getCanvasCoords(t[0].x,t[0].y);e.moveTo(o.x,o.y);for(let d=1;d<t.length;d++){let c=this.getCanvasCoords(t[d].x,t[d].y);e.lineTo(c.x,c.y)}let i=r||this.currentMousePos;(s||r)&&e.lineTo(i.x,i.y),e.stroke(),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill(),(s||r)&&(e.beginPath(),e.arc(i.x,i.y,this.options.pathWidth/2,0,Math.PI*2),e.fill()),e.restore()}drawRoundedRect(e,t,s,n,r,o){e.beginPath(),e.moveTo(t+o,s),e.lineTo(t+n-o,s),e.quadraticCurveTo(t+n,s,t+n,s+o),e.lineTo(t+n,s+r-o),e.quadraticCurveTo(t+n,s+r,t+n-o,s+r),e.lineTo(t+o,s+r),e.quadraticCurveTo(t,s+r,t,s+r-o),e.lineTo(t,s+o),e.quadraticCurveTo(t,s,t+o,s),e.closePath(),e.fill()}drawHexagon(e,t,s,n,r){if(!(!this.options.colors.hexagon&&!r)){e.fillStyle=r||this.options.colors.hexagon,e.beginPath();for(let o=0;o<6;o++){let i=Math.PI/3*o,d=t+n*Math.cos(i),c=s+n*Math.sin(i);o===0?e.moveTo(d,c):e.lineTo(d,c)}e.closePath(),e.fill()}}drawEraser(e,t,s,n,r,o,i){e.strokeStyle=i||this.getColorCode(o),e.lineWidth=n*.5,e.lineCap="butt";let d=.5;e.beginPath();for(let c=0;c<r;c++){let y=Math.PI*2/r*c+d,l=t+n*Math.cos(y),f=s+n*Math.sin(y);e.moveTo(t,s),e.lineTo(l,f)}e.stroke()}drawStar(e,t,s,n,r,o,i,d){e.fillStyle=d||this.getColorCode(i),e.beginPath();for(let c=0;c<o*2;c++){let y=c%2===0?r:n,l=Math.PI/o*c,f=t+y*Math.cos(l),u=s+y*Math.sin(l);c===0?e.moveTo(f,u):e.lineTo(f,u)}e.closePath(),e.fill()}drawTriangle(e,t,s,n,r,o){if(n<=0)return;let i=o||this.getColorCode(r,"#ffcc00");e.fillStyle=i;let c=12*.8,y=c*2.2,l=(u,a)=>{e.beginPath();for(let h=0;h<3;h++){let p=Math.PI*2*h/3-Math.PI/2,m=u+c*Math.cos(p),g=a+c*Math.sin(p);h===0?e.moveTo(m,g):e.lineTo(m,g)}e.closePath(),e.fill()},f=(n-1)*y*.5;for(let u=0;u<n;u++)l(t-f+u*y,s)}drawTetris(e,t,s,n,r,o,i,d){if(!n||n.length===0)return;let c=12,y=2,l=n[0].length*c+(n[0].length-1)*y,f=n.length*c+(n.length-1)*y;e.save(),e.translate(t,s),r&&e.rotate(Math.PI/8);let u=d||this.getColorCode(o,i?"#00ffff":"#ffcc00");if(i){e.strokeStyle=u,e.lineWidth=2;for(let a=0;a<n.length;a++)for(let h=0;h<n[a].length;h++)if(n[a][h]){let p=h*(c+y)-l/2,m=a*(c+y)-f/2;e.strokeRect(p+1,m+1,c-2,c-2)}}else{e.fillStyle=u;for(let a=0;a<n.length;a++)for(let h=0;h<n[a].length;h++)if(n[a][h]){let p=h*(c+y)-l/2,m=a*(c+y)-f/2;e.fillRect(p,m,c,c)}}e.restore()}getColorCode(e,t="#666"){return this.options.colors.colorList&&this.options.colors.colorList[e]!==void 0?this.options.colors.colorList[e]:this.options.colors.colorMap&&this.options.colors.colorMap[e]!==void 0?this.options.colors.colorMap[e]:t}colorToRgba(e){if(!e||e==="transparent")return{r:0,g:0,b:0,a:0};if(e.startsWith("rgba")||e.startsWith("rgb")){let s=e.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);if(s)return{r:parseInt(s[1]),g:parseInt(s[2]),b:parseInt(s[3]),a:s[4]?parseFloat(s[4]):1}}let t=e.startsWith("#")?e.slice(1):e;if((t.length===3||t.length===4)&&(t=t.split("").map(s=>s+s).join("")),t.length===6){let s=parseInt(t,16);return{r:s>>16&255,g:s>>8&255,b:s&255,a:1}}else if(t.length===8){let s=parseInt(t,16);return{r:s>>24&255,g:s>>16&255,b:s>>8&255,a:(s&255)/255}}return{r:0,g:0,b:0,a:1}}lerpColor(e,t,s){try{let n=this.colorToRgba(e),r=this.colorToRgba(t),o=Math.round(n.r+(r.r-n.r)*s),i=Math.round(n.g+(r.g-n.g)*s),d=Math.round(n.b+(r.b-n.b)*s),c=n.a+(r.a-n.a)*s;return`rgba(${o},${i},${d},${c})`}catch{return e}}setAlpha(e,t){let s=this.colorToRgba(e);return`rgba(${s.r},${s.g},${s.b},${t})`}getSymmetryPath(e){return!this.puzzle||!this.puzzle.symmetry?[]:e.map(t=>this.getSymmetricalPoint(t))}getSymmetricalPoint(e,t=!1){if(!this.puzzle||!this.puzzle.symmetry)return{...e};let{cols:s,rows:n,symmetry:r}=this.puzzle;return r===1?{x:s-e.x,y:e.y}:r===2?{x:e.x,y:n-e.y}:r===3?{x:s-e.x,y:n-e.y}:{...e}}isPathAtExit(e,t){if(e.length===0||!t)return!1;let s=e[e.length-1],n=this.getExitDir(s.x,s.y);if(!n)return!1;let r=this.getCanvasCoords(s.x,s.y),o=t.x-r.x,i=t.y-r.y;return o*n.x+i*n.y>=this.options.exitLength*.9}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}sanitizeOptions(e){let t={};for(let s in e){let n=e[s];if(n&&typeof n=="object"&&!Array.isArray(n)){t[s]={};for(let r in n)typeof n[r]!="function"&&(t[s][r]=n[r])}else typeof n!="function"&&(t[s]=n)}return t}prepareOffscreen(){if(!this.offscreenCanvas){if(typeof document<"u")this.offscreenCanvas=document.createElement("canvas");else if(typeof OffscreenCanvas<"u")this.offscreenCanvas=new OffscreenCanvas(this.canvas.width,this.canvas.height);else throw new Error("Offscreen canvas not supported in this environment.");this.offscreenCtx=this.offscreenCanvas.getContext("2d")}if((this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),!this.offscreenCtx)throw new Error("Could not get offscreen 2D context.");return this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx}}};var me=class{bytes=[];cur=0;bit=0;write(e,t){for(let s=0;s<t;s++)e&1<<s&&(this.cur|=1<<this.bit),this.bit++,this.bit===8&&(this.bytes.push(this.cur),this.cur=0,this.bit=0)}finish(){return this.bit>0&&this.bytes.push(this.cur),new Uint8Array(this.bytes)}},xe=class{constructor(e){this.buf=e}i=0;bit=0;read(e){let t=0;for(let s=0;s<e;s++)this.buf[this.i]&1<<this.bit&&(t|=1<<s),this.bit++,this.bit===8&&(this.bit=0,this.i++);return t}};function we(j){let e=new Map;for(let t of j)for(let s of t)if(s.shape){let n=JSON.stringify(s.shape);e.has(n)||e.set(n,s.shape)}return[...e.values()]}var be=class{static async serialize(e,t){let s=new me;s.write(e.rows,6),s.write(e.cols,6),s.write(e.symmetry??0,2);let n=we(e.cells);s.write(n.length,5);for(let y of n){s.write(y.length,4),s.write(y[0].length,4);for(let l of y)for(let f of l)s.write(f,1)}let r=new Map;n.forEach((y,l)=>r.set(JSON.stringify(y),l));for(let y of e.cells)for(let l of y)s.write(l.type,4),s.write(l.color,3),l.type===8?s.write(l.count||0,2):l.shape?(s.write(1,1),s.write(r.get(JSON.stringify(l.shape)),5)):s.write(0,1);for(let y=0;y<e.rows;y++)for(let l=0;l<e.cols+1;l++)s.write(e.vEdges[y][l].type,3);for(let y=0;y<e.rows+1;y++)for(let l=0;l<e.cols;l++)s.write(e.hEdges[y][l].type,3);for(let y=0;y<e.rows+1;y++)for(let l=0;l<e.cols+1;l++)s.write(e.nodes[y][l].type,3);s.write(+!!t.useHexagons,1),s.write(+!!t.useSquares,1),s.write(+!!t.useStars,1),s.write(+!!t.useTetris,1),s.write(+!!t.useTetrisNegative,1),s.write(+!!t.useEraser,1),s.write(+!!t.useTriangles,1),s.write(+!!t.useBrokenEdges,1),s.write(t.symmetry??0,2),s.write(Math.round((t.complexity??0)*254),8),s.write(Math.round((t.difficulty??0)*254),8),s.write(Math.round((t.pathLength??0)*254),8);let o=s.finish(),i=new Uint8Array(await new Response(new Blob([o.buffer]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()),d=0;for(let y of i)d^=y;let c=new Uint8Array(i.length+1);return c.set(i),c[i.length]=d,btoa(String.fromCharCode(...c)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}static async deserialize(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4;)t+="=";let s=atob(t),n=Uint8Array.from(s,B=>B.charCodeAt(0)),r=0;for(let B=0;B<n.length-1;B++)r^=n[B];if(r!==n.at(-1))throw new Error("Invalid parity data");let o=new Uint8Array(await new Response(new Blob([n.slice(0,-1).buffer]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer()),i=new xe(o),d=i.read(6),c=i.read(6),y=i.read(2),l=i.read(5),f=[];for(let B=0;B<l;B++){let I=i.read(4),$=i.read(4),M=[];for(let T=0;T<I;T++){let k=[];for(let K=0;K<$;K++)k.push(i.read(1));M.push(k)}f.push(M)}let u=[];for(let B=0;B<d;B++){let I=[];for(let $=0;$<c;$++){let M=i.read(4),T=i.read(3),k={type:M,color:T};M===8?k.count=i.read(2):i.read(1)&&(k.shape=f[i.read(5)].map(z=>z.slice())),I.push(k)}u.push(I)}let a=Array.from({length:d},()=>Array.from({length:c+1},()=>({type:i.read(3)}))),h=Array.from({length:d+1},()=>Array.from({length:c},()=>({type:i.read(3)}))),p=Array.from({length:d+1},()=>Array.from({length:c+1},()=>({type:i.read(3)}))),m=()=>{let B=i.read(8);return Math.round(B/254*1e3)/1e3},g={},x=!!i.read(1),b=!!i.read(1),P=!!i.read(1),S=!!i.read(1),C=!!i.read(1),v=!!i.read(1),E=!!i.read(1),N=!!i.read(1),w=i.read(2);x&&(g.useHexagons=!0),b&&(g.useSquares=!0),P&&(g.useStars=!0),S&&(g.useTetris=!0),C&&(g.useTetrisNegative=!0),v&&(g.useEraser=!0),E&&(g.useTriangles=!0),N&&(g.useBrokenEdges=!0),g.symmetry=w;let H=m(),O=m(),L=m();return H!==0&&(g.complexity=H),O!==0&&(g.difficulty=O),L!==0&&(g.pathLength=L),{puzzle:{rows:d,cols:c,cells:u,vEdges:a,hEdges:h,nodes:p,symmetry:y},options:g}}};var ve=class{generator;validator;constructor(){this.generator=new ce,this.validator=new ae}createPuzzle(e,t,s={}){return this.generator.generate(e,t,s).export()}validateSolution(e,t){let s=oe.fromData(e);return this.validator.validate(s,t)}calculateDifficulty(e){let t=oe.fromData(e);return this.validator.calculateDifficulty(t)}};if(typeof self<"u"&&"postMessage"in self&&!("document"in self)){let j=new ve,e=null,t=null;self.addEventListener("message",s=>{let{type:n,payload:r}=s.data;switch(n){case"init":{let{canvas:o,options:i}=r;e=new fe(o,void 0,{...i,onPathComplete:d=>{if(self.postMessage({type:"drawingEnded"}),i.autoValidate&&t){let c=j.validateSolution(t,{points:d});e.setValidationResult(c.isValid,c.invalidatedCells,c.invalidatedEdges,c.errorCells,c.errorEdges,c.invalidatedNodes,c.errorNodes),self.postMessage({type:"validationResult",payload:c})}else self.postMessage({type:"pathComplete",payload:d})}});break}case"createPuzzle":{let{rows:o,cols:i,genOptions:d}=r,c=j.createPuzzle(o,i,d);self.postMessage({type:"puzzleCreated",payload:{puzzle:c,genOptions:d}});break}case"setPuzzle":{t=r.puzzle,e&&t&&(e.setPuzzle(t),r.options&&e.setOptions(r.options));break}case"setOptions":{e&&e.setOptions(r);break}case"setCanvasRect":{e&&e.setCanvasRect(r);break}case"validate":{if(t){let o=j.validateSolution(t,{points:r.path});e&&e.setValidationResult(o.isValid,o.invalidatedCells,o.invalidatedEdges,o.errorCells,o.errorEdges,o.invalidatedNodes,o.errorNodes),self.postMessage({type:"validationResult",payload:o})}break}case"event":{let{eventType:o,eventData:i}=r;if(e)if(o==="mousedown"||o==="touchstart"){let d=e.handleStart(i);self.postMessage({type:"drawingStarted",payload:d})}else o==="mousemove"||o==="touchmove"?e.handleMove(i):(o==="mouseup"||o==="touchend")&&(e.handleEnd(i),self.postMessage({type:"drawingEnded"}));break}}})}export{re as CellType,U as Color,Ee as Direction,le as EdgeType,oe as Grid,he as NodeType,ce as PuzzleGenerator,be as PuzzleSerializer,ae as PuzzleValidator,Se as RngType,ue as SymmetryType,ve as WitnessCore,fe as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
