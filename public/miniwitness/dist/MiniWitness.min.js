/*!
 * MiniWitness 1.2.5
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var fe=(s=>(s[s.Up=0]="Up",s[s.Right=1]="Right",s[s.Down=2]="Down",s[s.Left=3]="Left",s))(fe||{}),ee=(u=>(u[u.None=0]="None",u[u.Square=1]="Square",u[u.Star=2]="Star",u[u.Tetris=3]="Tetris",u[u.TetrisRotated=4]="TetrisRotated",u[u.Eraser=5]="Eraser",u[u.TetrisNegative=6]="TetrisNegative",u[u.TetrisNegativeRotated=7]="TetrisNegativeRotated",u))(ee||{}),te=(o=>(o[o.Normal=0]="Normal",o[o.Broken=1]="Broken",o[o.Absent=2]="Absent",o[o.Hexagon=3]="Hexagon",o[o.HexagonMain=4]="HexagonMain",o[o.HexagonSymmetry=5]="HexagonSymmetry",o))(te||{}),se=(o=>(o[o.Normal=0]="Normal",o[o.Start=1]="Start",o[o.End=2]="End",o[o.Hexagon=3]="Hexagon",o[o.HexagonMain=4]="HexagonMain",o[o.HexagonSymmetry=5]="HexagonSymmetry",o))(se||{}),oe=(s=>(s[s.None=0]="None",s[s.Horizontal=1]="Horizontal",s[s.Vertical=2]="Vertical",s[s.Rotational=3]="Rotational",s))(oe||{}),K={None:0,Black:1,White:2,Red:3,Blue:4,Cyan:5};var _=class j{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];symmetry=0;constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:K.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes,symmetry:this.symmetry}))}static fromData(e){let t=new j(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t.symmetry=e.symmetry||0,t}};var Z=class{tetrisCache=new Map;validate(e,t,n){let s=t.points;if(s.length<2)return{isValid:!1,errorReason:"Path too short"};let h=e.symmetry||0,o=[];if(h!==0)for(let c of s)o.push(this.getSymmetricalPoint(e,c));let i=s[0],u=s[s.length-1];if(e.nodes[i.y][i.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[u.y][u.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};if(h!==0){let c=o[0],d=o[o.length-1];if(e.nodes[c.y][c.x].type!==1)return{isValid:!1,errorReason:"Symmetrical path must start at Start Node"};if(e.nodes[d.y][d.x].type!==2)return{isValid:!1,errorReason:"Symmetrical path must end at End Node"}}let y=new Set,f=new Set;if(y.add(`${i.x},${i.y}`),h!==0){let c=o[0];if(y.has(`${c.x},${c.y}`))return{isValid:!1,errorReason:"Paths collide at start"};y.add(`${c.x},${c.y}`)}for(let c=0;c<s.length-1;c++){let d=s[c],m=s[c+1];if(Math.abs(d.x-m.x)+Math.abs(d.y-m.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let p=`${m.x},${m.y}`;if(y.has(p))return{isValid:!1,errorReason:"Self-intersecting path or path collision"};if(y.add(p),this.isBrokenEdge(e,d,m))return{isValid:!1,errorReason:"Passed through broken edge"};if(f.add(this.getEdgeKey(d,m)),h!==0){let v=o[c],g=o[c+1],C=`${g.x},${g.y}`;if(y.has(C))return{isValid:!1,errorReason:"Path collision"};if(y.add(C),this.isBrokenEdge(e,v,g))return{isValid:!1,errorReason:"Symmetrical path passed through broken edge"};let P=this.getEdgeKey(v,g);if(f.has(P))return{isValid:!1,errorReason:"Paths cross the same edge"};f.add(P)}}let a=this.calculateRegions(e,s,o,n),l=this.getMissedHexagons(e,s,o),r=this.validateWithErasers(e,a,l.edges,l.nodes);return r.regions=a,r}validateFast(e,t,n,s){let h=this.calculateRegions(e,t,n,s),o=this.getMissedHexagons(e,t,n);return this.validateWithErasers(e,h,o.edges,o.nodes)}isBrokenEdge(e,t,n){let s;if(t.x===n.x){let h=Math.min(t.y,n.y);s=e.vEdges[h][t.x].type}else{let h=Math.min(t.x,n.x);s=e.hEdges[t.y][h].type}return s===1||s===2}isAbsentEdge(e,t,n){if(t.x===n.x){let s=Math.min(t.y,n.y);return e.vEdges[s][t.x].type===2}else{let s=Math.min(t.x,n.x);return e.hEdges[t.y][s].type===2}}getMissedHexagons(e,t,n=[]){let s=new Set,h=new Set;for(let f=0;f<t.length;f++)h.add(`${t[f].x},${t[f].y}`),f<t.length-1&&s.add(this.getEdgeKey(t[f],t[f+1]));let o=new Set,i=new Set;for(let f=0;f<n.length;f++)i.add(`${n[f].x},${n[f].y}`),f<n.length-1&&o.add(this.getEdgeKey(n[f],n[f+1]));let u=[];for(let f=0;f<=e.rows;f++)for(let a=0;a<e.cols;a++){let l=e.hEdges[f][a].type;if(l===3||l===4||l===5){let r=this.getEdgeKey({x:a,y:f},{x:a+1,y:f}),c=!1;l===3?c=s.has(r)||o.has(r):l===4?c=s.has(r):l===5&&(c=o.has(r)),c||u.push({type:"h",r:f,c:a})}}for(let f=0;f<e.rows;f++)for(let a=0;a<=e.cols;a++){let l=e.vEdges[f][a].type;if(l===3||l===4||l===5){let r=this.getEdgeKey({x:a,y:f},{x:a,y:f+1}),c=!1;l===3?c=s.has(r)||o.has(r):l===4?c=s.has(r):l===5&&(c=o.has(r)),c||u.push({type:"v",r:f,c:a})}}let y=[];for(let f=0;f<=e.rows;f++)for(let a=0;a<=e.cols;a++){let l=e.nodes[f][a].type;if(l===3||l===4||l===5){let r=`${a},${f}`,c=!1;l===3?c=h.has(r)||i.has(r):l===4?c=h.has(r):l===5&&(c=i.has(r)),c||y.push({x:a,y:f})}}return{edges:u,nodes:y}}validateWithErasers(e,t,n,s){let h=[],o=!0;for(let r=0;r<t.length;r++){let c=t[r],d=c.filter(g=>e.cells[g.y][g.x].type===5),m=c.filter(g=>e.cells[g.y][g.x].type!==0&&e.cells[g.y][g.x].type!==5),x=[];for(let g=0;g<n.length;g++)this.isHexagonAdjacentToRegion(e,n[g],c)&&x.push(g);let p=[];for(let g=0;g<s.length;g++)this.isNodeHexagonAdjacentToRegion(e,s[g],c)&&p.push(g);let v=this.getPossibleErasures(e,c,d,m,x,p);if(v.length===0){o=!1;let g=this.getBestEffortErasures(e,c,d,m,x,p);h.push([g])}else v.sort((g,C)=>{let P=g.invalidatedCells.length+g.invalidatedHexagons.length+g.invalidatedNodeHexagons.length,E=C.invalidatedCells.length+C.invalidatedHexagons.length+C.invalidatedNodeHexagons.length;return P-E}),h.push(v)}if(o){let r=this.findGlobalAssignment(h,n.length,s.length);if(r)return{isValid:!0,invalidatedCells:r.invalidatedCells,invalidatedEdges:r.invalidatedHexIndices.map(c=>n[c]),invalidatedNodes:r.invalidatedNodeHexIndices.map(c=>s[c])}}let i=[],u=[],y=new Set,f=new Set;for(let r of h){let c=r[0];i.push(...c.errorCells),u.push(...c.invalidatedCells);for(let d of c.invalidatedHexagons)y.add(d);for(let d of c.invalidatedNodeHexagons)f.add(d)}let a=[];for(let r=0;r<n.length;r++)y.has(r)||a.push(n[r]);let l=[];for(let r=0;r<s.length;r++)f.has(r)||l.push(s[r]);return{isValid:!1,errorReason:"Constraints failed",errorCells:i,errorEdges:a,errorNodes:l,invalidatedCells:u,invalidatedEdges:Array.from(y).map(r=>n[r]),invalidatedNodes:Array.from(f).map(r=>s[r])}}isHexagonAdjacentToRegion(e,t,n){let s=new Set(n.map(h=>`${h.x},${h.y}`));if(t.type==="h"){if(t.r>0&&s.has(`${t.c},${t.r-1}`)||t.r<e.rows&&s.has(`${t.c},${t.r}`))return!0}else if(t.c>0&&s.has(`${t.c-1},${t.r}`)||t.c<e.cols&&s.has(`${t.c},${t.r}`))return!0;return!1}isNodeHexagonAdjacentToRegion(e,t,n){let s=new Set(n.map(o=>`${o.x},${o.y}`)),h=[{x:t.x-1,y:t.y-1},{x:t.x,y:t.y-1},{x:t.x-1,y:t.y},{x:t.x,y:t.y}];for(let o of h)if(o.x>=0&&o.x<e.cols&&o.y>=0&&o.y<e.rows&&s.has(`${o.x},${o.y}`))return!0;return!1}getPossibleErasures(e,t,n,s,h,o){let i=[],u=n.length;if(u===0)return this.getRegionErrors(e,t,[]).length===0&&h.length===0&&o.length===0&&i.push({invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!0,errorCells:[]}),i;let y=[...s.map(a=>({type:"cell",pos:a})),...h.map(a=>({type:"hex",index:a})),...o.map(a=>({type:"nodeHex",index:a}))],f=this.getRegionErrors(e,t,[]).length===0&&h.length===0&&o.length===0;for(let a=0;a<=u;a++){let l=this.getNCombinations(n,a);for(let r of l){let c=new Set(r.map(m=>`${m.x},${m.y}`)),d=n.filter(m=>!c.has(`${m.x},${m.y}`));for(let m=0;m<=y.length;m++){if(d.length!==a+m)continue;let x=this.getNCombinations(y,m);for(let p of x){let v=p.filter(b=>b.type==="cell").map(b=>b.pos),g=p.filter(b=>b.type==="hex").map(b=>b.index),C=p.filter(b=>b.type==="nodeHex").map(b=>b.index);if(this.getRegionErrors(e,t,[...v,...r]).length===0){let b=!0;if(f)m>0&&(b=!1);else for(let w=0;w<p.length;w++){let H=[...p.slice(0,w),...p.slice(w+1)],M=H.filter(A=>A.type==="cell").map(A=>A.pos),N=new Set(H.filter(A=>A.type==="hex").map(A=>A.index)),I=new Set(H.filter(A=>A.type==="nodeHex").map(A=>A.index)),R=h.every(A=>N.has(A)),G=o.every(A=>I.has(A));if(this.getRegionErrors(e,t,M).length===0&&R&&G){b=!1;break}}b&&i.push({invalidatedCells:[...v,...r],invalidatedHexagons:g,invalidatedNodeHexagons:C,isValid:!0,errorCells:[]})}}}}}return i}getBestEffortErasures(e,t,n,s,h,o){let i=this.getRegionErrors(e,t,[]);if(i.length===0&&h.length===0&&o.length===0)return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:[...n]};if(n.length>0){let f=[...s.map(c=>({type:"cell",pos:c})),...h.map(c=>({type:"hex",index:c})),...o.map(c=>({type:"nodeHex",index:c}))],a=null,l=1/0,r=c=>{let d=[],m=[],x=[],p=0;for(let b of c)p<n.length&&(b.type==="cell"?d.push(b.pos):b.type==="hex"?m.push(b.index):x.push(b.index),p++);let v=n.length-p,g=Math.floor(v/2),C=n.slice(p,p+g);p+=g*2;let P=this.getRegionErrors(e,t,[...d,...C]);for(let b=p;b<n.length;b++)P.push(n[b]);let E=P.length;E<l&&(l=E,a={invalidatedCells:[...d,...C],invalidatedHexagons:m,invalidatedNodeHexagons:x,isValid:!1,errorCells:P})};r([...i.map(c=>({type:"cell",pos:c})),...h.map(c=>({type:"hex",index:c})),...o.map(c=>({type:"nodeHex",index:c}))]),r(f);for(let c of i)r([{type:"cell",pos:c}]);if(a)return a}let y=[...i,...n];return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:y}}getNCombinations(e,t){let n=[],s=(h,o)=>{if(o.length===t){n.push([...o]);return}for(let i=h;i<e.length;i++)o.push(e[i]),s(i+1,o),o.pop()};return s(0,[]),n}checkRegionValid(e,t,n){return this.getRegionErrors(e,t,n).length===0}getRegionErrors(e,t,n){let s=new Set(n.map(l=>`${l.x},${l.y}`)),h=new Map,o=new Map,i=new Set,u=new Set,y=[],f=[];for(let l of t){if(s.has(`${l.x},${l.y}`))continue;let r=e.cells[l.y][l.x];if(r.type===0)continue;let c=r.color;c!==K.None&&(h.set(c,(h.get(c)||0)+1),o.has(c)||o.set(c,[]),o.get(c).push(l)),r.type===1?u.add(c):r.type===2?i.add(c):r.type===3||r.type===4?r.shape&&y.push({shape:r.shape,rotatable:r.type===4,pos:l}):(r.type===6||r.type===7)&&r.shape&&f.push({shape:r.shape,rotatable:r.type===7,pos:l})}let a=[];if(u.size>1)for(let l of t)s.has(`${l.x},${l.y}`)||e.cells[l.y][l.x].type===1&&a.push(l);for(let l of i)if(h.get(l)!==2){let r=o.get(l)||[];for(let c of r)e.cells[c.y][c.x].type===2&&a.push(c)}if((y.length>0||f.length>0)&&!this.checkTetrisConstraint(e,t,y.map(l=>({shape:l.shape,rotatable:l.rotatable})),f.map(l=>({shape:l.shape,rotatable:l.rotatable})))){for(let l of y)a.push(l.pos);for(let l of f)a.push(l.pos)}return a}findGlobalAssignment(e,t,n){let s=e.length,h=new Array(t).fill(0),o=new Array(n).fill(0),i=[],u=[],y=[],f=a=>{if(a===s)return h.every(l=>l===1)&&o.every(l=>l===1);for(let l of e[a]){let r=!0;for(let c of l.invalidatedHexagons)if(h[c]>0){r=!1;break}if(r){for(let c of l.invalidatedNodeHexagons)if(o[c]>0){r=!1;break}}if(r){for(let c of l.invalidatedHexagons)h[c]++,u.push(c);for(let c of l.invalidatedNodeHexagons)o[c]++,y.push(c);if(i.push(...l.invalidatedCells),f(a+1))return!0;for(let c of l.invalidatedHexagons)h[c]--,u.pop();for(let c of l.invalidatedNodeHexagons)o[c]--,y.pop();for(let c=0;c<l.invalidatedCells.length;c++)i.pop()}}return!1};return f(0)?{invalidatedCells:i,invalidatedHexIndices:u,invalidatedNodeHexIndices:y}:null}checkTetrisConstraint(e,t,n,s=[]){let h=n.reduce((b,w)=>b+this.getShapeArea(w.shape),0),o=s.reduce((b,w)=>b+this.getShapeArea(w.shape),0),i=h-o;if(i<0||i!==0&&i!==t.length)return!1;let u=e.rows,y=e.cols;this.tetrisCache.size>1e4&&this.tetrisCache.clear();let f=new Uint8Array(u*y);for(let b of t)f[b.y*y+b.x]=1;let a=(b,w)=>`${this.getShapeKey(b.shape)}-${b.rotatable}-${w}`,l=[...n.map(b=>a(b,1)),...s.map(b=>a(b,-1))].sort().join("|"),r=`${u}x${y}:${f.join("")}:${l}`;if(this.tetrisCache.has(r))return this.tetrisCache.get(r);let c=new Int8Array(u*y);if(i>0)for(let b=0;b<f.length;b++)c[b]=f[b];let d=new Int8Array(u*y),m=[],x=[...n.map(b=>({...b,sign:1})),...s.map(b=>({...b,sign:-1}))];for(let b of x){let w=b.rotatable?this.getAllRotations(b.shape):[b.shape],H=this.getShapeKey(w[0]),M=m.find(N=>N.sign===b.sign&&(b.rotatable?N.rotations.length>1:N.rotations.length===1)&&this.getShapeKey(N.rotations[0].shape)===H);M?M.count++:m.push({rotations:w.map(N=>({shape:N,h:N.length,w:N[0].length})),sign:b.sign,area:this.getShapeArea(b.shape),count:1})}m.sort((b,w)=>w.sign-b.sign||w.area-b.area);let p=i>0?t.length:0,v=0,g=h,C=o,P=(b,w,H)=>{if(p>g||v>C)return!1;if(b===m.length)return p===0&&v===0;let M=m[b],N=w+1,I=N===M.count;M.sign===1?g-=M.area:C-=M.area;for(let R of M.rotations){let G=R.h,A=R.w,z=w===0?0:H;for(let S=z;S<=u*y-(G>0?(G-1)*y+A:0);S++){let B=Math.floor(S/y),X=S%y;if(B>u-G||X>y-A)continue;let k=!0,U=[];for(let T=0;T<G;T++){for(let W=0;W<A;W++)if(R.shape[T][W]){let O=(B+T)*y+(X+W);M.sign===1?d[O]<c[O]?p--:v++:d[O]<=c[O]?p++:v--,d[O]+=M.sign,U.push(O),d[O]<0&&(k=!1),M.sign===1&&d[O]>1+o&&(k=!1)}if(!k)break}if(k){if(I){if(P(b+1,0,0)){for(let T of U)d[T]-=M.sign,M.sign===1?d[T]<c[T]?p++:v--:d[T]<=c[T]?p--:v++;return M.sign===1?g+=M.area:C+=M.area,!0}}else if(P(b,N,S)){for(let T of U)d[T]-=M.sign,M.sign===1?d[T]<c[T]?p++:v--:d[T]<=c[T]?p--:v++;return M.sign===1?g+=M.area:C+=M.area,!0}}for(let T of U)d[T]-=M.sign,M.sign===1?d[T]<c[T]?p++:v--:d[T]<=c[T]?p--:v++}}return M.sign===1?g+=M.area:C+=M.area,!1},E=P(0,0,0);return this.tetrisCache.set(r,E),E}getShapeArea(e){let t=0;for(let n of e)for(let s of n)s&&t++;return t}getShapeKey(e){return JSON.stringify(e)}getAllRotations(e){let t=[],n=new Set,s=e;for(let h=0;h<4;h++){let o=this.getShapeKey(s);n.has(o)||(t.push(s),n.add(o)),s=this.rotate90(s)}return t}rotate90(e){let t=e.length,n=e[0].length,s=Array.from({length:n},()=>Array(t).fill(0));for(let h=0;h<t;h++)for(let o=0;o<n;o++)s[o][t-1-h]=e[h][o];return s}calculateRegions(e,t,n=[],s){let h=[],o=e.rows,i=e.cols,u=new Uint8Array(o*i),y=new Uint8Array((o+1)*i),f=new Uint8Array(o*(i+1)),a=(r,c)=>{r.x===c.x?f[Math.min(r.y,c.y)*(i+1)+r.x]=1:y[r.y*i+Math.min(r.x,c.x)]=1};for(let r=0;r<t.length-1;r++)a(t[r],t[r+1]);for(let r=0;r<n.length-1;r++)a(n[r],n[r+1]);for(let r=0;r<=o;r++)for(let c=0;c<i;c++)e.hEdges[r][c].type===2&&(y[r*i+c]=1);for(let r=0;r<o;r++)for(let c=0;c<=i;c++)e.vEdges[r][c].type===2&&(f[r*(i+1)+c]=1);let l=s||this.getExternalCells(e);for(let r=0;r<o;r++)for(let c=0;c<i;c++){let d=r*i+c;if(u[d]||l&&l.has(`${c},${r}`))continue;let m=[],x=[d];u[d]=1;let p=0;for(;p<x.length;){let v=x[p++],g=v%i,C=Math.floor(v/i);if(m.push({x:g,y:C}),C>0&&!y[C*i+g]){let P=(C-1)*i+g;!u[P]&&(!l||!l.has(`${g},${C-1}`))&&(u[P]=1,x.push(P))}if(C<o-1&&!y[(C+1)*i+g]){let P=(C+1)*i+g;!u[P]&&(!l||!l.has(`${g},${C+1}`))&&(u[P]=1,x.push(P))}if(g>0&&!f[C*(i+1)+g]){let P=C*i+(g-1);!u[P]&&(!l||!l.has(`${g-1},${C}`))&&(u[P]=1,x.push(P))}if(g<i-1&&!f[C*(i+1)+(g+1)]){let P=C*i+(g+1);!u[P]&&(!l||!l.has(`${g+1},${C}`))&&(u[P]=1,x.push(P))}}h.push(m)}return h}getExternalCells(e){let t=new Set,n=[];for(let s=0;s<e.cols;s++)e.hEdges[0][s].type===2&&(t.has(`${s},0`)||(t.add(`${s},0`),n.push({x:s,y:0}))),e.hEdges[e.rows][s].type===2&&(t.has(`${s},${e.rows-1}`)||(t.add(`${s},${e.rows-1}`),n.push({x:s,y:e.rows-1})));for(let s=0;s<e.rows;s++)e.vEdges[s][0].type===2&&(t.has(`0,${s}`)||(t.add(`0,${s}`),n.push({x:0,y:s}))),e.vEdges[s][e.cols].type===2&&(t.has(`${e.cols-1},${s}`)||(t.add(`${e.cols-1},${s}`),n.push({x:e.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),h=[{nx:s.x,ny:s.y-1,edge:e.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:e.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:e.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:e.vEdges[s.y][s.x+1]}];for(let o of h)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return t}getSymmetricalPoint(e,t){let n=e.symmetry||0;return n===1?{x:e.cols-t.x,y:t.y}:n===2?{x:t.x,y:e.rows-t.y}:n===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getSymmetricalPointIndex(e,t){let n=e.cols+1,s=Math.floor(t/n),h=t%n,o=e.symmetry||0,i=s,u=h;return o===1?u=e.cols-h:o===2?i=e.rows-s:o===3&&(u=e.cols-h,i=e.rows-s),i*n+u}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}calculateDifficulty(e){let t=e.rows,n=e.cols,s=n+1,h=(t+1)*s,o=Array.from({length:h},()=>[]),i=[],u=[],y=new Map,f=0,a=new Set,l=new Set;for(let z=0;z<=t;z++)for(let S=0;S<=n;S++){let B=z*s+S;if(e.nodes[z][S].type===1&&i.push(B),e.nodes[z][S].type===2&&u.push(B),(e.nodes[z][S].type===3||e.nodes[z][S].type===4||e.nodes[z][S].type===5)&&(y.set(`n${S},${z}`,f++),l.add(B)),S<n){let X=B+1,k=e.hEdges[z][S].type,U=k===3||k===4||k===5,T=k===1||k===2;o[B].push({next:X,hexType:k,isBroken:T}),o[X].push({next:B,hexType:k,isBroken:T}),U&&(y.set(`eh${S},${z}`,f++),a.add(this.getEdgeKey({x:S,y:z},{x:S+1,y:z})))}if(z<t){let X=B+s,k=e.vEdges[z][S].type,U=k===3||k===4||k===5,T=k===1||k===2;o[B].push({next:X,hexType:k,isBroken:T}),o[X].push({next:B,hexType:k,isBroken:T}),U&&(y.set(`ev${S},${z}`,f++),a.add(this.getEdgeKey({x:S,y:z},{x:S,y:z+1})))}}let r={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},c=f,d=new Set,m=Math.max(1e3,t*n*200),x=this.getExternalCells(e),p=!1;for(let z=0;z<t;z++){for(let S=0;S<n;S++)if(e.cells[z][S].type!==0){p=!0;break}if(p)break}this.tetrisCache.clear();for(let z of i){let S=e.cols+1,B=Math.floor(z/S),X=z%S,k=0n,U=e.nodes[B][X].type;(U===3||U===4)&&(k|=1n<<BigInt(y.get(`n${X},${B}`)));let T=e.symmetry||0;if(T!==0){let O=this.getSymmetricalPointIndex(e,z),D=Math.floor(O/S),$=O%S,V=e.nodes[D][$].type;(V===3||V===5)&&(k|=1n<<BigInt(y.get(`n${$},${D}`)))}let W=1n<<BigInt(z);if(T!==0){let O=this.getSymmetricalPointIndex(e,z);if(O===z)continue;W|=1n<<BigInt(O)}this.exploreSearchSpace(e,z,W,[z],k,c,o,u,d,r,m,x,p,y)}if(r.solutions===0)return 0;let v=a.size+l.size,g=new Set;a.size>0&&g.add(999);let C=0,P=0;for(let z=0;z<t;z++)for(let S=0;S<n;S++){let B=e.cells[z][S];B.type!==0&&(v++,g.add(B.type),B.type===3?C++:B.type===4&&(C++,P++))}let E=r.branchingPoints/(r.totalNodesVisited||1),b=Math.log10(r.totalNodesVisited+1),w=(E*10+b*1.5)/(Math.log2(r.solutions+1)*.5+1);w-=a.size*.05,w+=l.size*.12,C>0&&(w+=(C-P)*.5,w+=P*.2);let H=0,M=0;for(let z=0;z<t;z++)for(let S=0;S<n;S++){let B=e.cells[z][S];B.type===6?H++:B.type===7&&(H++,M++)}H>0&&(w+=(H-M)*.6,w+=M*.3);let N=t*n,I=v/N,R=I<.25?Math.pow(I/.25,4):1,G=g.size<=1?.5:1;w*=R*G;let A=Math.log2(N)/5;return w*=A,Math.max(.01,Math.min(1,w/4))}exploreSearchSpace(e,t,n,s,h,o,i,u,y,f,a,l,r=!0,c){if(f.totalNodesVisited++,f.maxDepth=Math.max(f.maxDepth,s.length),f.totalNodesVisited>a)return;let d=e.symmetry||0;if(u.includes(t)){let p=0,v=h;for(;v>0n;)v&1n&&p++,v>>=1n;if(p===o){let g=s.map(E=>({x:E%(e.cols+1),y:Math.floor(E/(e.cols+1))})),C={points:g};if(d!==0){let E=this.getSymmetricalPointIndex(e,t),b=e.cols+1;if(e.nodes[Math.floor(E/b)][E%b].type!==2)return}let P=d!==0?g.map(E=>this.getSymmetricalPoint(e,E)):[];if(r){let E=this.validateFast(e,g,P,l);if(E.isValid){let b=this.getFingerprint(e,g,P,E.regions,l);y.has(b)||(y.add(b),f.solutions++)}}else{let E=this.getFingerprint(e,g,P,void 0,l);y.has(E)||(y.add(E),f.solutions++)}}return}if(!this.canReachEndOptimized(t,n,i,u)){f.backtracks++;return}let m=[];for(let p of i[t]){if(p.isBroken||n&1n<<BigInt(p.next))continue;if(d!==0){let g=this.getSymmetricalPointIndex(e,t),C=this.getSymmetricalPointIndex(e,p.next);if(p.next===C||t===C&&p.next===g)continue}let v=!0;for(let g of i[t])if(g.hexType===3||g.hexType===4){let P=s.length>=2&&g.next===s[s.length-2],E=g.next===p.next;if(!P&&!E){v=!1;break}}if(v){if(d!==0){let g=this.getSymmetricalPointIndex(e,t),C=this.getSymmetricalPointIndex(e,p.next);for(let P of i[g])if(P.hexType===3||P.hexType===5){let b=s.length>=2?this.getSymmetricalPointIndex(e,s[s.length-2]):-1,w=P.next===b,H=P.next===C;if(!w&&!H){v=!1;break}}}v&&m.push(p)}}if(m.length>1&&f.branchingPoints++,e.rows*e.cols>30)for(let p=m.length-1;p>0;p--){let v=Math.floor(Math.random()*(p+1));[m[p],m[v]]=[m[v],m[p]]}let x=e.cols+1;for(let p of m){let v=h,g=Math.floor(p.next/x),C=p.next%x,P=e.nodes[g][C].type;(P===3||P===4)&&(v|=1n<<BigInt(c.get(`n${C},${g}`)));let E=s[s.length-1],b=Math.floor(E/x),w=E%x;if(b===g){let M=Math.min(w,C);(p.hexType===3||p.hexType===4)&&(v|=1n<<BigInt(c.get(`eh${M},${g}`)))}else{let M=Math.min(b,g);(p.hexType===3||p.hexType===4)&&(v|=1n<<BigInt(c.get(`ev${C},${M}`)))}if(d!==0){let M=this.getSymmetricalPointIndex(e,p.next),N=Math.floor(M/x),I=M%x,R=e.nodes[N][I].type;(R===3||R===5)&&(v|=1n<<BigInt(c.get(`n${I},${N}`)));let G=this.getSymmetricalPointIndex(e,E),A=Math.floor(G/x),z=G%x;if(A===N){let S=Math.min(z,I),B=e.hEdges[N][S].type;(B===3||B===5)&&(v|=1n<<BigInt(c.get(`eh${S},${N}`)))}else{let S=Math.min(A,N),B=e.vEdges[S][I].type;(B===3||B===5)&&(v|=1n<<BigInt(c.get(`ev${I},${S}`)))}}s.push(p.next);let H=n|1n<<BigInt(p.next);if(d!==0){let M=this.getSymmetricalPointIndex(e,p.next);H|=1n<<BigInt(M)}if(this.exploreSearchSpace(e,p.next,H,s,v,o,i,u,y,f,a,l,r,c),s.pop(),f.totalNodesVisited>a)return}}countSolutions(e,t=100){let n=e.rows,s=e.cols,h=s+1,o=(n+1)*h,i=Array.from({length:o},()=>[]),u=[],y=[],f=new Map,a=0;for(let m=0;m<=n;m++)for(let x=0;x<=s;x++){let p=m*h+x;if(e.nodes[m][x].type===1&&u.push(p),e.nodes[m][x].type===2&&y.push(p),(e.nodes[m][x].type===3||e.nodes[m][x].type===4||e.nodes[m][x].type===5)&&f.set(`n${x},${m}`,a++),x<s){let v=p+1,g=e.hEdges[m][x].type,C=g===3||g===4||g===5,P=g===1||g===2;i[p].push({next:v,hexType:g,isBroken:P}),i[v].push({next:p,hexType:g,isBroken:P}),C&&f.set(`eh${x},${m}`,a++)}if(m<n){let v=p+h,g=e.vEdges[m][x].type,C=g===3||g===4||g===5,P=g===1||g===2;i[p].push({next:v,hexType:g,isBroken:P}),i[v].push({next:p,hexType:g,isBroken:P}),C&&f.set(`ev${x},${m}`,a++)}}let l=new Set,r=a,c=this.getExternalCells(e),d=!1;for(let m=0;m<n;m++){for(let x=0;x<s;x++)if(e.cells[m][x].type!==0){d=!0;break}if(d)break}this.tetrisCache.clear();for(let m of u){let x=e.cols+1,p=Math.floor(m/x),v=m%x,g=0n,C=e.nodes[p][v].type;(C===3||C===4)&&(g|=1n<<BigInt(f.get(`n${v},${p}`)));let P=e.symmetry||0;if(P!==0){let b=this.getSymmetricalPointIndex(e,m),w=Math.floor(b/x),H=b%x,M=e.nodes[w][H].type;(M===3||M===5)&&(g|=1n<<BigInt(f.get(`n${H},${w}`)))}let E=1n<<BigInt(m);if(P!==0){let b=this.getSymmetricalPointIndex(e,m);if(b===m)continue;E|=1n<<BigInt(b)}this.findPathsOptimized(e,m,E,[m],g,r,i,y,l,t,c,d,f)}return l.size}findPathsOptimized(e,t,n,s,h,o,i,u,y,f,a,l=!0,r){if(y.size>=f)return;let c=e.symmetry||0;if(u.includes(t)){let d=0,m=h;for(;m>0n;)m&1n&&d++,m>>=1n;if(d===o){let x=s.map(v=>({x:v%(e.cols+1),y:Math.floor(v/(e.cols+1))}));if(c!==0){let v=this.getSymmetricalPointIndex(e,t),g=e.cols+1;if(e.nodes[Math.floor(v/g)][v%g].type!==2)return}let p=c!==0?x.map(v=>this.getSymmetricalPoint(e,v)):[];if(!l)y.add(this.getFingerprint(e,x,p,void 0,a));else{let v=this.validateFast(e,x,p,a);v.isValid&&y.add(this.getFingerprint(e,x,p,v.regions,a))}}return}if(this.canReachEndOptimized(t,n,i,u))for(let d of i[t]){if(d.isBroken||n&1n<<BigInt(d.next))continue;if(c!==0){let w=this.getSymmetricalPointIndex(e,t),H=this.getSymmetricalPointIndex(e,d.next);if(d.next===H||t===H&&d.next===w)continue}let m=!0;for(let w of i[t])if(w.hexType===3||w.hexType===4){let M=s.length>=2&&w.next===s[s.length-2],N=w.next===d.next;if(!M&&!N){m=!1;break}}if(!m)continue;if(c!==0){let w=this.getSymmetricalPointIndex(e,t),H=this.getSymmetricalPointIndex(e,d.next);for(let M of i[w])if(M.hexType===3||M.hexType===5){let I=s.length>=2?this.getSymmetricalPointIndex(e,s[s.length-2]):-1,R=M.next===I,G=M.next===H;if(!R&&!G){m=!1;break}}}if(!m)continue;let x=e.cols+1,p=h,v=Math.floor(d.next/x),g=d.next%x,C=e.nodes[v][g].type;(C===3||C===4)&&(p|=1n<<BigInt(r.get(`n${g},${v}`)));let P=Math.floor(t/x),E=t%x;if(P===v){let w=Math.min(E,g);(d.hexType===3||d.hexType===4)&&(p|=1n<<BigInt(r.get(`eh${w},${v}`)))}else{let w=Math.min(P,v);(d.hexType===3||d.hexType===4)&&(p|=1n<<BigInt(r.get(`ev${g},${w}`)))}if(c!==0){let w=this.getSymmetricalPointIndex(e,d.next),H=Math.floor(w/x),M=w%x,N=e.nodes[H][M].type;(N===3||N===5)&&(p|=1n<<BigInt(r.get(`n${M},${H}`)));let I=this.getSymmetricalPointIndex(e,t),R=Math.floor(I/x),G=I%x;if(R===H){let A=Math.min(G,M),z=e.hEdges[H][A].type;(z===3||z===5)&&(p|=1n<<BigInt(r.get(`eh${A},${H}`)))}else{let A=Math.min(R,H),z=e.vEdges[A][M].type;(z===3||z===5)&&(p|=1n<<BigInt(r.get(`ev${M},${A}`)))}}s.push(d.next);let b=n|1n<<BigInt(d.next);if(c!==0){let w=this.getSymmetricalPointIndex(e,d.next);b|=1n<<BigInt(w)}if(this.findPathsOptimized(e,d.next,b,s,p,o,i,u,y,f,a,l,r),s.pop(),y.size>=f)return}}canReachEndOptimized(e,t,n,s){let h=[e],o=t,i=0;for(;i<h.length;){let u=h[i++];if(s.includes(u))return!0;for(let y of n[u])!y.isBroken&&!(o&1n<<BigInt(y.next))&&(o|=1n<<BigInt(y.next),h.push(y.next))}return!1}getFingerprint(e,t,n,s,h){let i=(s||this.calculateRegions(e,t,n,h)).map(y=>{let f="",a=[];for(let l of y){let r=e.cells[l.y][l.x];r.type!==0&&a.push(r.type<<8|r.color)}a.sort((l,r)=>l-r);for(let l of a)f+=l.toString(36)+",";return f}).sort(),u="";for(let y of i)y.length>0&&(u+=y+"|");return u||"empty"}};var ne=class{isWorker;constructor(){this.isWorker=typeof self<"u"&&"postMessage"in self&&!("document"in self)}generate(e,t,n={}){let s=n.difficulty??.5,h=new Z,o=null,i=-1,u=this.isWorker?e*t>30?150:120:e*t>30?100:80,y=this.isWorker?8:5,f=n.symmetry||0,a={x:0,y:e},l={x:t,y:0};f===1?l={x:0,y:0}:f===2?l={x:t,y:e}:f===3&&(l={x:t,y:e});let r=null,c=null,d=null;for(let m=0;m<u;m++){if(m%y===0){r=this.generateRandomPath(new _(e,t),a,l,n.pathLength,f);let g=new _(e,t),C=f!==0?r.map(P=>this.getSymmetricalPoint(g,P,f)):[];c=this.calculateRegions(g,r,C),d=c.map(P=>this.getRegionBoundaryEdges(g,P,r,C))}let x=this.generateFromPath(e,t,r,n,c,d);if(!this.checkAllRequestedConstraintsPresent(x,n))continue;let p=h.calculateDifficulty(x);if(p===0)continue;let v=Math.abs(p-s);if((o===null||v<Math.abs(i-s))&&(i=p,o=x),s>.8&&p>.8||v<.01)break}if(!o){let m=this.generateRandomPath(new _(e,t),a,l,n.pathLength,f);return this.generateFromPath(e,t,m,n)}return o}generateFromPath(e,t,n,s,h,o){let i=new _(e,t),u=s.symmetry||0;i.symmetry=u;let y={x:0,y:e},f={x:t,y:0};if(u===1?f={x:0,y:0}:u===2?f={x:t,y:e}:u===3&&(f={x:t,y:e}),i.nodes[y.y][y.x].type=1,i.nodes[f.y][f.x].type=2,u!==0){let l=this.getSymmetricalPoint(i,y,u),r=this.getSymmetricalPoint(i,f,u);i.nodes[l.y][l.x].type=1,i.nodes[r.y][r.x].type=2}let a=u!==0?n.map(l=>this.getSymmetricalPoint(i,l,u)):[];return this.applyConstraintsBasedOnPath(i,n,s,a,h,o),s.useBrokenEdges&&this.applyBrokenEdges(i,n,s),this.cleanGrid(i),i}generateRandomPath(e,t,n,s,h=0){if(s===void 0)return this.generateSingleRandomPath(e,t,n,void 0,h);let o=e.rows+e.cols,i=(e.rows+1)*(e.cols+1)-1,u=o+s*(i-o),y=[],f=1/0,a=e.rows*e.cols>30?30:50;for(let l=0;l<a;l++){let r=this.generateSingleRandomPath(e,t,n,s,h);if(r.length===0)continue;let c=r.length-1,d=Math.abs(c-u);if(d<f&&(f=d,y=r),f<=2)break}return y}generateSingleRandomPath(e,t,n,s,h=0){let o=new Set,i=[],u=0,y=e.rows*e.cols*200,f=a=>{if(u++,u>y)return!1;o.add(`${a.x},${a.y}`);let l=this.getSymmetricalPoint(e,a,h);if(o.add(`${l.x},${l.y}`),i.push(a),a.x===n.x&&a.y===n.y)return!0;let r=this.getValidNeighbors(e,a,o);h!==0&&(r=r.filter(c=>{let d=this.getSymmetricalPoint(e,c,h);if(d.x<0||d.x>e.cols||d.y<0||d.y>e.rows||o.has(`${d.x},${d.y}`)||c.x===d.x&&c.y===d.y)return!1;let m=this.getEdgeKey(a,c),x=this.getEdgeKey(l,d);return m!==x})),s!==void 0?r.sort((c,d)=>{let m=Math.abs(c.x-n.x)+Math.abs(c.y-n.y),x=Math.abs(d.x-n.x)+Math.abs(d.y-n.y);return(m-x)*(1-s*2)+(Math.random()-.5)*1.5}):this.shuffleArray(r);for(let c of r)if(f(c))return!0;return i.pop(),o.delete(`${a.x},${a.y}`),o.delete(`${l.x},${l.y}`),!1};return f(t),i}getValidNeighbors(e,t,n){let s=[],h=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of h){let i=t.x+o.x,u=t.y+o.y;i>=0&&i<=e.cols&&u>=0&&u<=e.rows&&(n.has(`${i},${u}`)||s.push({x:i,y:u}))}return s}applyBrokenEdges(e,t,n){let s=n.complexity??.5,h=n.symmetry??0,o=new Set;for(let a=0;a<t.length-1;a++)if(o.add(this.getEdgeKey(t[a],t[a+1])),h!==0){let l=this.getSymmetricalPoint(e,t[a],h),r=this.getSymmetricalPoint(e,t[a+1],h);o.add(this.getEdgeKey(l,r))}let i=[];for(let a=0;a<=e.rows;a++)for(let l=0;l<e.cols;l++){let r={x:l,y:a},c={x:l+1,y:a};o.has(this.getEdgeKey(r,c))||i.push({type:"h",r:a,c:l,p1:r,p2:c})}for(let a=0;a<e.rows;a++)for(let l=0;l<=e.cols;l++){let r={x:l,y:a},c={x:l,y:a+1};o.has(this.getEdgeKey(r,c))||i.push({type:"v",r:a,c:l,p1:r,p2:c})}this.shuffleArray(i);let u=Math.max(1,Math.floor(s*(e.rows*e.cols)/4)),y=0;for(let a of i){if(y>=u)break;a.type==="h"?e.hEdges[a.r][a.c].type=1:e.vEdges[a.r][a.c].type=1,y++}let f=!0;for(;f;){f=!1;for(let a=0;a<=e.rows;a++)for(let l=0;l<e.cols;l++)e.hEdges[a][l].type===1&&this.canBecomeAbsent(e,{type:"h",r:a,c:l})&&(e.hEdges[a][l].type=2,f=!0);for(let a=0;a<e.rows;a++)for(let l=0;l<=e.cols;l++)e.vEdges[a][l].type===1&&this.canBecomeAbsent(e,{type:"v",r:a,c:l})&&(e.vEdges[a][l].type=2,f=!0)}for(let a=0;a<=e.rows;a++)for(let l=0;l<=e.cols;l++){let r=[];if(l>0&&r.push({e:e.hEdges[a][l-1],type:"h",r:a,c:l-1}),l<e.cols&&r.push({e:e.hEdges[a][l],type:"h",r:a,c:l}),a>0&&r.push({e:e.vEdges[a-1][l],type:"v",r:a-1,c:l}),a<e.rows&&r.push({e:e.vEdges[a][l],type:"v",r:a,c:l}),r.length>0&&r.every(c=>c.e.type===1||c.e.type===2)&&r.every(c=>!this.isAdjacentToMark(e,c)))for(let c of r)c.e.type=2}}canBecomeAbsent(e,t){if(this.isAdjacentToMark(e,t))return!1;if(t.type==="h"){if(t.r===0||t.r===e.rows)return!0}else if(t.c===0||t.c===e.cols)return!0;let n=t.type==="h"?[{x:t.c,y:t.r},{x:t.c+1,y:t.r}]:[{x:t.c,y:t.r},{x:t.c,y:t.r+1}];for(let s of n){let h=[{type:"h",r:s.y,c:s.x-1},{type:"h",r:s.y,c:s.x},{type:"v",r:s.y-1,c:s.x},{type:"v",r:s.y,c:s.x}];for(let o of h)if(o.c>=0&&o.c<=e.cols&&o.r>=0&&o.r<=e.rows){if(o.type==="h"&&o.c<e.cols){if(e.hEdges[o.r][o.c].type===2)return!0}else if(o.type==="v"&&o.r<e.rows&&e.vEdges[o.r][o.c].type===2)return!0}}return!1}cleanGrid(e){let t=[];for(let o=0;o<=e.rows;o++)for(let i=0;i<=e.cols;i++)e.nodes[o][i].type===1&&t.push({x:i,y:o});let n=new Set,s=[...t];for(let o of t)n.add(`${o.x},${o.y}`);for(;s.length>0;){let o=s.shift(),i=[{nx:o.x,ny:o.y-1,edge:e.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:e.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:e.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:e.hEdges[o.y]?.[o.x]}];for(let u of i)u.edge&&u.edge.type!==2&&(n.has(`${u.nx},${u.ny}`)||(n.add(`${u.nx},${u.ny}`),s.push({x:u.nx,y:u.ny})))}for(let o=0;o<=e.rows;o++)for(let i=0;i<e.cols;i++)(!n.has(`${i},${o}`)||!n.has(`${i+1},${o}`))&&(e.hEdges[o][i].type=2);for(let o=0;o<e.rows;o++)for(let i=0;i<=e.cols;i++)(!n.has(`${i},${o}`)||!n.has(`${i},${o+1}`))&&(e.vEdges[o][i].type=2);let h=this.getExternalCells(e);for(let o of h){let[i,u]=o.split(",").map(Number);e.cells[u][i].type=0}}getExternalCells(e){let t=new Set,n=[];for(let s=0;s<e.cols;s++)e.hEdges[0][s].type===2&&(t.has(`${s},0`)||(t.add(`${s},0`),n.push({x:s,y:0}))),e.hEdges[e.rows][s].type===2&&(t.has(`${s},${e.rows-1}`)||(t.add(`${s},${e.rows-1}`),n.push({x:s,y:e.rows-1})));for(let s=0;s<e.rows;s++)e.vEdges[s][0].type===2&&(t.has(`0,${s}`)||(t.add(`0,${s}`),n.push({x:0,y:s}))),e.vEdges[s][e.cols].type===2&&(t.has(`${e.cols-1},${s}`)||(t.add(`${e.cols-1},${s}`),n.push({x:e.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),h=[{nx:s.x,ny:s.y-1,edge:e.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:e.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:e.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:e.vEdges[s.y][s.x+1]}];for(let o of h)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return t}isAdjacentToMark(e,t){if(t.type==="h"){if(t.r>0&&e.cells[t.r-1][t.c].type!==0||t.r<e.rows&&e.cells[t.r][t.c].type!==0)return!0}else if(t.c>0&&e.cells[t.r][t.c-1].type!==0||t.c<e.cols&&e.cells[t.r][t.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let t=0;t<e.rows;t++)for(let n=0;n<e.cols;n++){if(e.cells[t][n].type===0)continue;if([e.hEdges[t][n],e.hEdges[t+1][n],e.vEdges[t][n],e.vEdges[t][n+1]].every(h=>h.type===1||h.type===2))return!0}return!1}getSymmetricalPoint(e,t,n){return n===1?{x:e.cols-t.x,y:t.y}:n===2?{x:t.x,y:e.rows-t.y}:n===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,t,n,s=[],h,o){let i=n.complexity??.5,u=n.useHexagons??!0,y=n.useSquares??!0,f=n.useStars??!0,a=n.useTetris??!1,l=n.useTetrisNegative??!1,r=n.useEraser??!1,c=0,d=0,m=0,x=0,p=0,v=0,g=Math.floor(e.rows*e.cols*.45);if(u){let C=n.difficulty??.5,P=n.symmetry||0;for(let E=0;E<t.length-1;E++){let w=this.getValidNeighbors(e,t[E],new Set).length>2,H=i*(C<.4?.6:.3);if(w&&(H=C<.4?H*1:H*.5),Math.random()<H){let M=3,N=t[E],I=t[E+1];if(P!==0){let R=Math.random();R<.3?M=4:R<.6&&(M=5,N=this.getSymmetricalPoint(e,t[E],P),I=this.getSymmetricalPoint(e,t[E+1],P))}this.setEdgeHexagon(e,N,I,M),c++}}for(let E=0;E<t.length;E++){let b=t[E];if(e.nodes[b.y][b.x].type!==0||this.hasIncidentHexagonEdge(e,b))continue;let w=i*(C>.6?.15:.05);if(Math.random()<w){let H=3,M=b;if(P!==0){let N=Math.random();N<.3?H=4:N<.6&&(H=5,M=this.getSymmetricalPoint(e,b,P))}e.nodes[M.y][M.x].type=H,c++}}if(c===0&&t.length>=2){let E=Math.floor(Math.random()*(t.length-1)),b=n.symmetry||0,w=3,H=t[E],M=t[E+1];if(b!==0){let N=Math.random();N<.3?w=4:N<.6&&(w=5,H=this.getSymmetricalPoint(e,t[E],b),M=this.getSymmetricalPoint(e,t[E+1],b))}this.setEdgeHexagon(e,H,M,w)}}if(y||f||a||r){let C=h||this.calculateRegions(e,t,s),P=n.availableColors??[K.Black,K.White,K.Red,K.Blue],E=n.defaultColors??{},b=(N,I)=>{if(E[N]!==void 0)return E[N];let R=ee[N];return R&&E[R]!==void 0?E[R]:I},w=Array.from({length:C.length},(N,I)=>I);this.shuffleArray(w);let H=new Set,M={square:y,star:f,tetris:a,eraser:r};for(let N=0;N<w.length;N++){let I=w[N],R=C[I],G=w.length-N,A=M.square&&d===0||M.star&&m===0||M.tetris&&x===0||M.eraser&&p===0,z=.2+i*.6;if(A&&G<=3?z=1:A&&G<=6&&(z=.7),Math.random()>z)continue;let S=[...R];this.shuffleArray(S);let B=P[Math.floor(Math.random()*P.length)];if(y&&!f&&G<=2&&H.size===1){let k=P.filter(U=>!H.has(U));k.length>0&&(B=k[Math.floor(Math.random()*k.length)])}let X=y&&Math.random()<.5+i*.3;if(y&&d===0&&G<=2&&(X=!0),y&&!f&&G<=2&&H.size<2&&d>0&&(X=!0),X&&S.length>0){let k=Math.min(S.length,Math.max(4,Math.floor(R.length/4))),U=Math.floor(Math.random()*(k/2))+Math.ceil(k/2);for(let T=0;T<U&&S.length!==0;T++){let W=S.pop();e.cells[W.y][W.x].type=1,e.cells[W.y][W.x].color=B,d++,H.add(B)}}if((a||l)&&v<g){let k=Math.random()<.1+i*.4;x===0&&G<=2&&(k=!0);let U=x===0&&G<=2?6:4;if(k&&S.length>0&&v+R.length<=g){let T=this.generateTiling(R,U,n);if(T){let W=[];if(l&&Math.random()<.2+i*.3){let D=n.difficulty??.5;if(Math.random()<.1&&S.length>=2){let V=!1;if(S.length>=3&&Math.random()<.8){let L=Math.random()<.5,F=1+Math.floor(Math.random()*2),Y=this.TETRIS_SHAPES.filter(Q=>this.getShapeArea(Q)===F),J=Y[Math.floor(Math.random()*Y.length)],q=this.findStandardTriple(J);q&&(L?(T.push({shape:J,displayShape:J,isRotated:!this.isRotationallyInvariant(J)&&Math.random()<D*.7,isNegative:!1}),T.push({shape:q.n,displayShape:q.n,isRotated:!this.isRotationallyInvariant(q.n)&&Math.random()<D*.7,isNegative:!1}),W.push({shape:q.p,displayShape:q.p,isRotated:!this.isRotationallyInvariant(q.p)&&Math.random()<D*.7,isNegative:!0})):(T.push({shape:q.p,displayShape:q.p,isRotated:!this.isRotationallyInvariant(q.p)&&Math.random()<D*.7,isNegative:!1}),W.push({shape:J,displayShape:J,isRotated:!this.isRotationallyInvariant(J)&&Math.random()<D*.7,isNegative:!0}),W.push({shape:q.n,displayShape:q.n,isRotated:!this.isRotationallyInvariant(q.n)&&Math.random()<D*.7,isNegative:!0})),V=!0)}if(!V){let L=3+Math.floor(Math.random()*2),F=this.TETRIS_SHAPES.filter(Y=>this.getShapeArea(Y)===L);if(this.shuffleArray(F),F.length>0){let Y=F[0],J=F[0];T.push({shape:Y,displayShape:Y,isRotated:!this.isRotationallyInvariant(Y)&&Math.random()<D*.7,isNegative:!1}),W.push({shape:J,displayShape:J,isRotated:!this.isRotationallyInvariant(J)&&Math.random()<D*.7,isNegative:!0})}}}else if(T.length>0){let V=Math.random()<.3?2:1;for(let L=0;L<V&&!(S.length<1);L++){let F=Math.floor(Math.random()*T.length),Y=T[F];if(Y.isNegative)continue;let J=!1;if(S.length>=2&&Math.random()<.2){let q=this.findStandardTriple(Y.shape);if(q){let Q=this.findStandardTriple(q.p);Q&&(T[F]={shape:Q.p,displayShape:Q.p,isRotated:!this.isRotationallyInvariant(Q.p)&&Math.random()<D*.7,isNegative:!1},W.push({shape:q.n,displayShape:q.n,isRotated:!this.isRotationallyInvariant(q.n)&&Math.random()<D*.7,isNegative:!0}),W.push({shape:Q.n,displayShape:Q.n,isRotated:!this.isRotationallyInvariant(Q.n)&&Math.random()<D*.7,isNegative:!0}),J=!0)}}if(!J){let q=this.findStandardTriple(Y.shape);q&&(T.some(he=>!he.isNegative&&this.isSameShape(he.shape,q.n))||(T[F]={shape:q.p,displayShape:q.p,isRotated:!this.isRotationallyInvariant(q.p)&&Math.random()<D*.7,isNegative:!1},W.push({shape:q.n,displayShape:q.n,isRotated:!this.isRotationallyInvariant(q.n)&&Math.random()<D*.7,isNegative:!0})))}}}}let O=[...T,...W];for(let D of O){if(S.length===0)break;let $=S.pop();if(D.isNegative)e.cells[$.y][$.x].type=D.isRotated?7:6,e.cells[$.y][$.x].color=b(6,K.Cyan);else{e.cells[$.y][$.x].type=D.isRotated?4:3;let L=b(3,K.None);if(f&&Math.random()<.5){let F=P.filter(Y=>Y!==L);F.length>0&&(L=F[Math.floor(Math.random()*F.length)])}e.cells[$.y][$.x].color=L}e.cells[$.y][$.x].shape=D.isRotated?D.displayShape:D.shape,x++}v+=R.length}}}if(r&&p<1){let k=.05+i*.2,U=Math.random()<k;if(G<=2&&(U=!0),U&&S.length>=1){let T=[];f&&T.push("star"),y&&T.push("square");let W=[];u&&(W=o?o[I]:this.getRegionBoundaryEdges(e,R,t,s),W.length>0&&T.push("hexagon")),a&&T.push("tetris");let O=T.length>0?T[Math.floor(Math.random()*T.length)]:null;S.length>=2&&(!O||Math.random()<.01)&&(O="eraser");let D=!1;if(O==="hexagon"){let $=W.filter(V=>!this.isEdgeAdjacentToHexagonNode(e,V));if($.length>0){let V=$[Math.floor(Math.random()*$.length)];V.type==="h"?e.hEdges[V.r][V.c].type=3:e.vEdges[V.r][V.c].type=3,c++,D=!0}}else if(O==="square"&&S.length>=2){let $=S.pop();e.cells[$.y][$.x].type=1;let V=R.find(F=>e.cells[F.y][F.x].type===1),L=V?e.cells[V.y][V.x].color:void 0;e.cells[$.y][$.x].color=P.find(F=>F!==L)||K.Red,d++,D=!0}else if(O==="star"&&S.length>=2){let $=S.pop();e.cells[$.y][$.x].type=2,e.cells[$.y][$.x].color=P[Math.floor(Math.random()*P.length)],m++,D=!0}else if(O==="tetris"&&S.length>=2){let $=this.generateTiling(R,4,n),V=[];if($&&$.length>0){let L=0;for(let F of $){let Y=this.getShapeArea(F.shape);if(L+Y<R.length)V.push(F),L+=Y;else break}}if(V.length===0&&R.length>1&&(V=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),V.length>0){for(let L of V){if(S.length<2)break;let F=S.pop();e.cells[F.y][F.x].type=L.isRotated?4:3,e.cells[F.y][F.x].shape=L.isRotated?L.displayShape:L.shape;let Y=K.None;f&&Math.random()<.3&&(Y=P[Math.floor(Math.random()*P.length)]),e.cells[F.y][F.x].color=Y,x++}D=!0}}else if(O==="eraser"&&S.length>=2){let $=S.pop();e.cells[$.y][$.x].type=5,e.cells[$.y][$.x].color=b(5,K.White),p++,D=!0}if(!D&&S.length>=2){let $=S.pop();e.cells[$.y][$.x].type=5,e.cells[$.y][$.x].color=b(5,K.White),p++,D=!0}if(D){let $=S.pop();e.cells[$.y][$.x].type=5;let V=b(5,K.White);if(f&&Math.random()<.4){let L=P.filter(F=>F!==V);L.length>0&&(V=L[Math.floor(Math.random()*L.length)])}e.cells[$.y][$.x].color=V,p++}}}if(f){let k=Math.max(1,Math.floor(R.length/8));for(let U=0;U<k;U++)for(let T of P){if(S.length<1)break;if(Math.random()>.3+i*.4)continue;let W=R.filter(O=>e.cells[O.y][O.x].color===T).length;if(W===1){let O=S.pop();e.cells[O.y][O.x].type=2,e.cells[O.y][O.x].color=T,m++}else if(W===0&&S.length>=2)for(let O=0;O<2;O++){let D=S.pop();e.cells[D.y][D.x].type=2,e.cells[D.y][D.x].color=T,m++}}}}if(y&&!f&&H.size<2){for(let N of C)if(N.every(I=>e.cells[I.y][I.x].type===0)){let I=P.find(G=>!H.has(G))||K.White,R=N[Math.floor(Math.random()*N.length)];e.cells[R.y][R.x].type=1,e.cells[R.y][R.x].color=I,H.add(I),d++;break}}}}calculateRegions(e,t,n=[]){let s=[],h=e.rows,o=e.cols,i=new Uint8Array(h*o),u=new Uint8Array((h+1)*o),y=new Uint8Array(h*(o+1)),f=(a,l)=>{a.x===l.x?y[Math.min(a.y,l.y)*(o+1)+a.x]=1:u[a.y*o+Math.min(a.x,l.x)]=1};for(let a=0;a<t.length-1;a++)f(t[a],t[a+1]);for(let a=0;a<n.length-1;a++)f(n[a],n[a+1]);for(let a=0;a<=h;a++)for(let l=0;l<o;l++)e.hEdges[a][l].type===2&&(u[a*o+l]=1);for(let a=0;a<h;a++)for(let l=0;l<=o;l++)e.vEdges[a][l].type===2&&(y[a*(o+1)+l]=1);for(let a=0;a<h;a++)for(let l=0;l<o;l++){let r=a*o+l;if(i[r])continue;let c=[],d=[r];i[r]=1;let m=0;for(;m<d.length;){let x=d[m++],p=x%o,v=Math.floor(x/o);if(c.push({x:p,y:v}),v>0&&!u[v*o+p]){let g=(v-1)*o+p;i[g]||(i[g]=1,d.push(g))}if(v<h-1&&!u[(v+1)*o+p]){let g=(v+1)*o+p;i[g]||(i[g]=1,d.push(g))}if(p>0&&!y[v*(o+1)+p]){let g=v*o+(p-1);i[g]||(i[g]=1,d.push(g))}if(p<o-1&&!y[v*(o+1)+(p+1)]){let g=v*o+(p+1);i[g]||(i[g]=1,d.push(g))}}s.push(c)}return s}isAbsentEdge(e,t,n){if(t.x===n.x){let s=Math.min(t.y,n.y);return e.vEdges[s][t.x].type===2}else{let s=Math.min(t.x,n.x);return e.hEdges[t.y][s].type===2}}getRegionBoundaryEdges(e,t,n,s=[]){let h=new Set;for(let u=0;u<n.length-1;u++)h.add(this.getEdgeKey(n[u],n[u+1]));for(let u=0;u<s.length-1;u++)h.add(this.getEdgeKey(s[u],s[u+1]));let o=[];for(let u of t){let y=[{type:"h",r:u.y,c:u.x},{type:"h",r:u.y+1,c:u.x},{type:"v",r:u.y,c:u.x},{type:"v",r:u.y,c:u.x+1}];for(let f of y){let a=f.type==="h"?{x:f.c,y:f.r}:{x:f.c,y:f.r},l=f.type==="h"?{x:f.c+1,y:f.r}:{x:f.c,y:f.r+1},r=this.getEdgeKey(a,l);!h.has(r)&&!this.isAbsentEdge(e,a,l)&&o.push(f)}}let i=new Map;for(let u of o)i.set(`${u.type},${u.r},${u.c}`,u);return Array.from(i.values())}setEdgeHexagon(e,t,n,s=3){t.x===n.x?e.vEdges[Math.min(t.y,n.y)][t.x].type=s:e.hEdges[t.y][Math.min(t.x,n.x)].type=s}hasIncidentHexagonEdge(e,t){let n=s=>s===3||s===4||s===5;return!!(t.x>0&&n(e.hEdges[t.y][t.x-1].type)||t.x<e.cols&&n(e.hEdges[t.y][t.x].type)||t.y>0&&n(e.vEdges[t.y-1][t.x].type)||t.y<e.rows&&n(e.vEdges[t.y][t.x].type))}isEdgeAdjacentToHexagonNode(e,t){let n=s=>s===3||s===4||s===5;return t.type==="h"?n(e.nodes[t.r][t.c].type)||n(e.nodes[t.r][t.c+1].type):n(e.nodes[t.r][t.c].type)||n(e.nodes[t.r+1][t.c].type)}checkAllRequestedConstraintsPresent(e,t){let n=t.useHexagons??!0,s=t.useSquares??!0,h=t.useStars??!0,o=t.useTetris??!1,i=t.useTetrisNegative??!1,u=t.useEraser??!1;if(t.useBrokenEdges??!1){let f=!1;for(let a=0;a<=e.rows;a++)for(let l=0;l<e.cols;l++)if(e.hEdges[a][l].type===1||e.hEdges[a][l].type===2){f=!0;break}if(!f){for(let a=0;a<e.rows;a++)for(let l=0;l<=e.cols;l++)if(e.vEdges[a][l].type===1||e.vEdges[a][l].type===2){f=!0;break}}if(!f)return!1}if(n){let f=!1,a=r=>r===3||r===4||r===5,l=r=>r===3||r===4||r===5;for(let r=0;r<=e.rows;r++)for(let c=0;c<e.cols;c++)if(a(e.hEdges[r][c].type)){f=!0;break}if(!f){for(let r=0;r<e.rows;r++)for(let c=0;c<=e.cols;c++)if(a(e.vEdges[r][c].type)){f=!0;break}}if(!f){for(let r=0;r<=e.rows;r++)for(let c=0;c<=e.cols;c++)if(l(e.nodes[r][c].type)){f=!0;break}}if(!f)return!1}if(s||h||o||u){let f=!1,a=!1,l=!1,r=!1,c=!1,d=new Set,m=new Set;for(let x=0;x<e.rows;x++)for(let p=0;p<e.cols;p++){let v=e.cells[x][p].type;v===1&&(f=!0,d.add(e.cells[x][p].color)),v===2&&(a=!0,m.add(e.cells[x][p].color)),(v===3||v===4)&&(l=!0),(v===6||v===7)&&(r=!0),v===5&&(c=!0)}if(s&&!f||h&&!a||o&&!l||i&&!r||u&&!c)return!1;if(s&&f&&d.size<2){let x=d.values().next().value;if(x===void 0||!m.has(x))return!1}}return!this.hasIsolatedMark(e)}generateTiling(e,t,n){let s=Math.min(...e.map(a=>a.x)),h=Math.min(...e.map(a=>a.y)),o=Math.max(...e.map(a=>a.x)),i=Math.max(...e.map(a=>a.y)),u=o-s+1,y=i-h+1,f=Array.from({length:y},()=>Array(u).fill(!1));for(let a of e)f[a.y-h][a.x-s]=!0;return this.tilingDfs(f,[],t,n)}tilingDfs(e,t,n,s){let h=-1,o=-1;for(let y=0;y<e.length;y++){for(let f=0;f<e[0].length;f++)if(e[y][f]){h=y,o=f;break}if(h!==-1)break}if(h===-1)return t;if(t.length>=n)return null;let i=s.difficulty??.5,u=[...this.TETRIS_SHAPES];this.shuffleArray(u),i>.6&&u.sort((y,f)=>this.getShapeArea(f)-this.getShapeArea(y));for(let y of u){let f=this.isRotationallyInvariant(y),a=f?[y]:this.getAllRotations(y);this.shuffleArray(a);for(let l of a){let r=[];for(let c=0;c<l.length;c++)for(let d=0;d<l[0].length;d++)l[c][d]&&r.push({r:c,c:d});for(let c of r){let d=h-c.r,m=o-c.c;if(this.canPlace(e,l,d,m)){this.placePiece(e,l,d,m,!1);let x=this.tilingDfs(e,[...t,{shape:l,displayShape:y,isRotated:!f&&Math.random()<.3+i*.6}],n,s);if(x)return x;this.placePiece(e,l,d,m,!0)}}}}return null}getShapeArea(e){let t=0;for(let n of e)for(let s of n)s&&t++;return t}isRotationallyInvariant(e){return this.getAllRotations(e).length===1}getAllRotations(e){let t=[],n=new Set,s=e;for(let h=0;h<4;h++){let o=JSON.stringify(s);n.has(o)||(t.push(s),n.add(o)),s=this.rotate90(s)}return t}rotate90(e){let t=e.length,n=e[0].length,s=Array.from({length:n},()=>Array(t).fill(0));for(let h=0;h<t;h++)for(let o=0;o<n;o++)s[o][t-1-h]=e[h][o];return s}canPlace(e,t,n,s){for(let h=0;h<t.length;h++)for(let o=0;o<t[0].length;o++)if(t[h][o]){let i=n+h,u=s+o;if(i<0||i>=e.length||u<0||u>=e[0].length||!e[i][u])return!1}return!0}placePiece(e,t,n,s,h){for(let o=0;o<t.length;o++)for(let i=0;i<t[0].length;i++)t[o][i]&&(e[n+o][s+i]=h)}isSameShape(e,t){let n=this.getAllRotations(e),s=JSON.stringify(t);return n.some(h=>JSON.stringify(h)===s)}canTilePieceWith(e,t,n){let s=this.getShapeArea(e),h=this.getShapeArea(t),o=this.getShapeArea(n);if(s!==h+o)return!1;let i=this.getAllRotations(t),u=this.getAllRotations(n),y=e.length,f=e[0].length;for(let a of i)for(let l of u){let r=a.length,c=a[0].length,d=l.length,m=l[0].length;for(let x=0;x<=y-r;x++)for(let p=0;p<=f-c;p++)for(let v=0;v<=y-d;v++)for(let g=0;g<=f-m;g++){let C=Array.from({length:y},()=>Array(f).fill(0)),P=!0;for(let E=0;E<r;E++)for(let b=0;b<c;b++)a[E][b]&&(C[x+E][p+b]=1);for(let E=0;E<d;E++){for(let b=0;b<m;b++)if(l[E][b]){if(C[v+E][g+b]){P=!1;break}C[v+E][g+b]=1}if(!P)break}if(P){let E=!0;for(let b=0;b<y;b++){for(let w=0;w<f;w++)if(C[b][w]!==e[b][w]){E=!1;break}if(!E)break}if(E)return!0}}}return!1}findStandardTriple(e){let t=this.getShapeArea(e),n=[...this.TETRIS_SHAPES];this.shuffleArray(n);for(let s of n){let h=this.getShapeArea(s),o=t+h;if(o>5)continue;let i=this.TETRIS_SHAPES.filter(u=>this.getShapeArea(u)===o);for(let u of i)if(this.canTilePieceWith(u,e,s))return{p:u,n:s}}return null}shuffleArray(e){for(let t=e.length-1;t>0;t--){let n=Math.floor(Math.random()*(t+1));[e[t],e[n]]=[e[n],e[t]]}}};var ie=class{bytes=[];cur=0;bit=0;write(e,t){for(let n=0;n<t;n++)e&1<<n&&(this.cur|=1<<this.bit),this.bit++,this.bit===8&&(this.bytes.push(this.cur),this.cur=0,this.bit=0)}finish(){return this.bit>0&&this.bytes.push(this.cur),new Uint8Array(this.bytes)}},re=class{constructor(e){this.buf=e}i=0;bit=0;read(e){let t=0;for(let n=0;n<e;n++)this.buf[this.i]&1<<this.bit&&(t|=1<<n),this.bit++,this.bit===8&&(this.bit=0,this.i++);return t}};function ue(j){let e=new Map;for(let t of j)for(let n of t)if(n.shape){let s=JSON.stringify(n.shape);e.has(s)||e.set(s,n.shape)}return[...e.values()]}var ae=class{static async serialize(e,t){let n=new ie;n.write(e.rows,6),n.write(e.cols,6),n.write(e.symmetry??0,2);let s=ue(e.cells);n.write(s.length,5);for(let f of s){n.write(f.length,4),n.write(f[0].length,4);for(let a of f)for(let l of a)n.write(l,1)}let h=new Map;s.forEach((f,a)=>h.set(JSON.stringify(f),a));for(let f of e.cells)for(let a of f)n.write(a.type,3),n.write(a.color,3),a.shape?(n.write(1,1),n.write(h.get(JSON.stringify(a.shape)),5)):n.write(0,1);for(let f=0;f<e.rows;f++)for(let a=0;a<e.cols+1;a++)n.write(e.vEdges[f][a].type,3);for(let f=0;f<e.rows+1;f++)for(let a=0;a<e.cols;a++)n.write(e.hEdges[f][a].type,3);for(let f=0;f<e.rows+1;f++)for(let a=0;a<e.cols+1;a++)n.write(e.nodes[f][a].type,3);n.write(+!!t.useHexagons,1),n.write(+!!t.useSquares,1),n.write(+!!t.useStars,1),n.write(+!!t.useTetris,1),n.write(+!!t.useTetrisNegative,1),n.write(+!!t.useEraser,1),n.write(+!!t.useBrokenEdges,1),n.write(t.symmetry??0,2),n.write(Math.round((t.complexity??0)*254),8),n.write(Math.round((t.difficulty??0)*254),8),n.write(Math.round((t.pathLength??0)*254),8);let o=n.finish(),i=new Uint8Array(await new Response(new Blob([o.buffer]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()),u=0;for(let f of i)u^=f;let y=new Uint8Array(i.length+1);return y.set(i),y[i.length]=u,btoa(String.fromCharCode(...y)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}static async deserialize(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4;)t+="=";let n=atob(t),s=Uint8Array.from(n,R=>R.charCodeAt(0)),h=0;for(let R=0;R<s.length-1;R++)h^=s[R];if(h!==s.at(-1))throw new Error("Invalid parity data");let o=new Uint8Array(await new Response(new Blob([s.slice(0,-1).buffer]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer()),i=new re(o),u=i.read(6),y=i.read(6),f=i.read(2),a=i.read(5),l=[];for(let R=0;R<a;R++){let G=i.read(4),A=i.read(4),z=[];for(let S=0;S<G;S++){let B=[];for(let X=0;X<A;X++)B.push(i.read(1));z.push(B)}l.push(z)}let r=[];for(let R=0;R<u;R++){let G=[];for(let A=0;A<y;A++){let z=i.read(3),S=i.read(3),B=i.read(1),X={type:z,color:S};B&&(X.shape=l[i.read(5)].map(k=>k.slice())),G.push(X)}r.push(G)}let c=Array.from({length:u},()=>Array.from({length:y+1},()=>({type:i.read(3)}))),d=Array.from({length:u+1},()=>Array.from({length:y},()=>({type:i.read(3)}))),m=Array.from({length:u+1},()=>Array.from({length:y+1},()=>({type:i.read(3)}))),x=()=>{let R=i.read(8);return Math.round(R/254*1e3)/1e3},p={},v=!!i.read(1),g=!!i.read(1),C=!!i.read(1),P=!!i.read(1),E=!!i.read(1),b=!!i.read(1),w=!!i.read(1),H=i.read(2);v&&(p.useHexagons=!0),g&&(p.useSquares=!0),C&&(p.useStars=!0),P&&(p.useTetris=!0),E&&(p.useTetrisNegative=!0),b&&(p.useEraser=!0),w&&(p.useBrokenEdges=!0),p.symmetry=H;let M=x(),N=x(),I=x();return M!==0&&(p.complexity=M),N!==0&&(p.difficulty=N),I!==0&&(p.pathLength=I),{puzzle:{rows:u,cols:y,cells:r,vEdges:c,hEdges:d,nodes:m,symmetry:f},options:p}}};var le=class{canvas;ctx;puzzle=null;options;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;invalidatedCells=[];invalidatedEdges=[];invalidatedNodes=[];errorCells=[];errorEdges=[];errorNodes=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;canvasRect=null;constructor(e,t,n={}){if(typeof e=="string"){if(typeof document>"u")throw new Error("Cannot look up canvas by ID in a non-browser environment.");let h=document.getElementById(e);if(!(h instanceof HTMLCanvasElement))throw new Error(`Element with id "${e}" is not a canvas.`);this.canvas=h}else this.canvas=e;let s=this.canvas.getContext("2d");if(!s)throw new Error("Could not get 2D context.");this.ctx=s,this.ctx.imageSmoothingEnabled=!1,this.options=this.mergeOptions(n),t&&this.setPuzzle(t),this.initEvents(),this.animate()}mergeOptions(e){let t={blinkDuration:e.animations?.blinkDuration??this.options?.animations?.blinkDuration??1e3,fadeDuration:e.animations?.fadeDuration??this.options?.animations?.fadeDuration??1e3,blinkPeriod:e.animations?.blinkPeriod??this.options?.animations?.blinkPeriod??800},n={path:e.colors?.path??this.options?.colors?.path??"#ffcc00",error:e.colors?.error??this.options?.colors?.error??"#ff4444",success:e.colors?.success??this.options?.colors?.success??"#ffcc00",symmetry:e.colors?.symmetry??this.options?.colors?.symmetry??"rgba(255, 255, 255, 0.5)",interrupted:e.colors?.interrupted??this.options?.colors?.interrupted??"#ffcc00",grid:e.colors?.grid??this.options?.colors?.grid??"#555",node:e.colors?.node??this.options?.colors?.node??"#555",hexagon:e.colors?.hexagon??this.options?.colors?.hexagon??"#000",hexagonMain:e.colors?.hexagonMain??this.options?.colors?.hexagonMain??"#00ffff",hexagonSymmetry:e.colors?.hexagonSymmetry??this.options?.colors?.hexagonSymmetry??"#ffff00",colorMap:e.colors?.colorMap??this.options?.colors?.colorMap??{[K.Black]:"#000",[K.White]:"#fff",[K.Red]:"#f00",[K.Blue]:"#00f",[K.Cyan]:"#00ffff",[K.None]:"#ffcc00"},colorList:e.colors?.colorList??this.options?.colors?.colorList};return{gridPadding:e.gridPadding??this.options?.gridPadding??60,cellSize:e.cellSize??this.options?.cellSize??80,nodeRadius:e.nodeRadius??this.options?.nodeRadius??6,startNodeRadius:e.startNodeRadius??this.options?.startNodeRadius??22,pathWidth:e.pathWidth??this.options?.pathWidth??18,exitLength:e.exitLength??this.options?.exitLength??25,autoResize:e.autoResize??this.options?.autoResize??!0,blinkMarksOnError:e.blinkMarksOnError??this.options?.blinkMarksOnError??!0,stayPathOnError:e.stayPathOnError??this.options?.stayPathOnError??!0,animations:t,colors:n,onPathComplete:e.onPathComplete??this.options?.onPathComplete??(()=>{})}}setPuzzle(e){this.puzzle=e,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw()}setOptions(e){this.options=this.mergeOptions({...this.options,...e}),this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}setValidationResult(e,t=[],n=[],s=[],h=[],o=[],i=[]){this.invalidatedCells=t,this.invalidatedEdges=n,this.invalidatedNodes=o,this.errorCells=s,this.errorEdges=h,this.errorNodes=i,this.eraserAnimationStartTime=Date.now(),e?(this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0}resizeCanvas(){!this.puzzle||!this.canvas||(this.canvas.width=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,this.canvas.height=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2)}setCanvasRect(e){this.canvasRect=e}initEvents(){typeof window>"u"||!(this.canvas instanceof HTMLCanvasElement)||(this.canvas.addEventListener("mousedown",e=>this.handleStart(e)),window.addEventListener("mousemove",e=>this.handleMove(e)),window.addEventListener("mouseup",e=>this.handleEnd(e)),this.canvas.addEventListener("touchstart",e=>{this.handleStart(e.touches[0])&&e.preventDefault()},{passive:!1}),window.addEventListener("touchmove",e=>{this.isDrawing&&e.preventDefault(),this.handleMove(e.touches[0])},{passive:!1}),window.addEventListener("touchend",e=>{this.isDrawing&&e.preventDefault(),this.handleEnd(e.changedTouches[0])},{passive:!1}))}getCanvasCoords(e,t){return{x:this.options.gridPadding+e*this.options.cellSize,y:this.options.gridPadding+t*this.options.cellSize}}getExitDir(e,t){return!this.puzzle||this.puzzle.nodes[t]?.[e]?.type!==2?null:e===this.puzzle.cols?{x:1,y:0}:e===0?{x:-1,y:0}:t===0?{x:0,y:-1}:t===this.puzzle.rows?{x:0,y:1}:{x:1,y:0}}handleStart(e){if(!this.puzzle)return!1;let t=this.canvasRect||(this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),n=(e.clientX-t.left)*(this.canvas.width/t.width),s=(e.clientY-t.top)*(this.canvas.height/t.height);for(let h=0;h<=this.puzzle.rows;h++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[h][o].type===1){let i=this.getCanvasCoords(o,h);if(Math.hypot(i.x-n,i.y-s)<this.options.startNodeRadius)return this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.isDrawing=!0,this.path=[{x:o,y:h}],this.currentMousePos=i,this.exitTipPos=null,this.draw(),!0}return!1}handleMove(e){if(!this.puzzle||!this.isDrawing)return;let t=this.canvasRect||(this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),n=(e.clientX-t.left)*(this.canvas.width/t.width),s=(e.clientY-t.top)*(this.canvas.height/t.height),h=this.path[this.path.length-1],o=this.getCanvasCoords(h.x,h.y),i=n-o.x,u=s-o.y,y=this.puzzle.symmetry||0,f=this.getExitDir(h.x,h.y),a=Math.abs(i)>Math.abs(u)?{x:i>0?1:-1,y:0}:{x:0,y:u>0?1:-1};if(f&&a.x===f.x&&a.y===f.y){let d=i*f.x+u*f.y,m=Math.max(0,Math.min(d,this.options.exitLength));this.currentMousePos={x:o.x+f.x*m,y:o.y+f.y*m},this.draw();return}let l=(d,m)=>{let x=this.getEdgeType(h,d);if(d.x<0||d.x>this.puzzle.cols||d.y<0||d.y>this.puzzle.rows||x===2){this.currentMousePos=o;return}let p=x===1?this.options.cellSize*.35:this.options.cellSize,v=this.getEdgeKey(h,d);if(!(this.path.length>=2&&d.x===this.path[this.path.length-2].x&&d.y===this.path[this.path.length-2].y)){for(let P=0;P<this.path.length-1;P++)if(this.getEdgeKey(this.path[P],this.path[P+1])===v){p=0;break}}if(this.path.some(P=>P.x===d.x&&P.y===d.y)&&this.path.length>=2){let P=this.path[this.path.length-2];(d.x!==P.x||d.y!==P.y)&&(p=Math.min(p,this.options.cellSize*.5-this.options.pathWidth*.5))}if(y!==0){let P=this.getSymmetricalPoint(h),E=this.getSymmetricalPoint(d),b=this.getEdgeType(P,E),w=this.getSymmetryPath(this.path),H=this.getEdgeKey(P,E);if(E.x<0||E.x>this.puzzle.cols||E.y<0||E.y>this.puzzle.rows||b===2){this.currentMousePos=o;return}b===1&&(p=Math.min(p,this.options.cellSize*.35));let M=w.some(z=>z.x===d.x&&z.y===d.y),N=this.path.some(z=>z.x===E.x&&z.y===E.y),I=d.x===E.x&&d.y===E.y,R=w.some((z,S)=>S<w.length-1&&this.getEdgeKey(w[S],w[S+1])===v),G=this.path.some((z,S)=>S<this.path.length-1&&this.getEdgeKey(this.path[S],this.path[S+1])===H);(M||N||I||R||G||v===H)&&(p=Math.min(p,this.options.cellSize*.5-this.options.pathWidth*.5))}d.x!==h.x?this.currentMousePos={x:o.x+Math.max(-p,Math.min(p,m)),y:o.y}:this.currentMousePos={x:o.x,y:o.y+Math.max(-p,Math.min(p,m))}};if(Math.abs(i)>Math.abs(u)){let d=i>0?1:-1;l({x:h.x+d,y:h.y},i)}else{let d=u>0?1:-1;l({x:h.x,y:h.y+d},u)}let r=[{x:h.x+1,y:h.y},{x:h.x-1,y:h.y},{x:h.x,y:h.y+1},{x:h.x,y:h.y-1}],c=this.getSymmetryPath(this.path);for(let d of r)if(d.x>=0&&d.x<=this.puzzle.cols&&d.y>=0&&d.y<=this.puzzle.rows){let m=this.getCanvasCoords(d.x,d.y);if(Math.hypot(m.x-this.currentMousePos.x,m.y-this.currentMousePos.y)<this.options.cellSize*.3){let p=this.path.findIndex(v=>v.x===d.x&&v.y===d.y);if(p===-1){if(y!==0){let v=this.getSymmetricalPoint(d);if(d.x===v.x&&d.y===v.y||this.path.some(P=>P.x===v.x&&P.y===v.y)||c.some(P=>P.x===d.x&&P.y===d.y))continue;let g=this.getEdgeKey(h,d),C=this.getEdgeKey(this.getSymmetricalPoint(h),v);if(g===C)continue}this.path.push(d)}else p===this.path.length-2&&this.path.pop()}}this.draw()}handleEnd(e){if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let t=this.path[this.path.length-1],n=this.getCanvasCoords(t.x,t.y),s=this.getExitDir(t.x,t.y);if(s){let h=this.currentMousePos.x-n.x,o=this.currentMousePos.y-n.y;if(h*s.x+o*s.y>0){this.exitTipPos={x:n.x+s.x*this.options.exitLength,y:n.y+s.y*this.options.exitLength},this.options.onPathComplete(this.path);return}}this.exitTipPos=s?{...this.currentMousePos}:null,this.startFade(this.options.colors.interrupted)}getEdgeType(e,t){if(!this.puzzle)return 2;if(e.x===t.x){let n=Math.min(e.y,t.y);return n<0||n>=this.puzzle.rows?2:this.puzzle.vEdges[n][e.x].type}else{let n=Math.min(e.x,t.x);return n<0||n>=this.puzzle.cols?2:this.puzzle.hEdges[e.y][n].type}}startFade(e="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=e,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){let e=Date.now();if(this.isFading){let t=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=t,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0)}this.isInvalidPath&&!this.options.stayPathOnError&&!this.isFading&&this.path.length>0&&this.startFade(this.options.colors.error),this.draw(),typeof requestAnimationFrame<"u"&&requestAnimationFrame(()=>this.animate())}draw(){if(!this.puzzle||!this.ctx)return;let e=this.ctx,t=Date.now();if(e.globalAlpha=1,e.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(e),this.drawConstraints(e),this.drawNodes(e),this.path.length===0&&!this.isDrawing&&this.drawRipples(e),this.isFading){if(this.drawPath(e,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let n=this.getSymmetryPath(this.fadingPath),s=this.options.colors.symmetry;if(this.isInvalidPath){let o=this.colorToRgba(s).a;s=this.setAlpha(this.options.colors.error,o)}let h=null;if(this.fadingTipPos){let o=(this.fadingTipPos.x-this.options.gridPadding)/this.options.cellSize,i=(this.fadingTipPos.y-this.options.gridPadding)/this.options.cellSize,u=this.getSymmetricalPoint({x:o,y:i});h={x:u.x*this.options.cellSize+this.options.gridPadding,y:u.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,n,!1,s,this.fadeOpacity,h)}}else if(this.path.length>0){let n=this.options.colors.path,s=this.colorToRgba(n).a,h=this.options.colors.error,o=this.isInvalidPath?this.setAlpha(h,s):n;this.isSuccessFading&&!this.puzzle.symmetry&&(o=this.setAlpha(this.options.colors.success,s));let i=1;if(!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let u=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),y=this.options.animations.blinkDuration;u<y&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(o=this.options.colors.error,this.options.stayPathOnError||(i=Math.max(0,1-u/this.options.animations.fadeDuration)))}if(this.drawPath(e,this.path,this.isDrawing,o,i,this.isDrawing?this.currentMousePos:this.exitTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let u=this.getSymmetryPath(this.path),y=this.options.colors.symmetry,f=this.colorToRgba(y).a,a=y,l=i;if(this.isInvalidPath&&(a=this.setAlpha(h,f)),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let c=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),d=this.options.animations.blinkDuration;c<d&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(a=this.options.colors.error)}let r=null;if(this.isDrawing||this.exitTipPos){let c=this.isDrawing?this.currentMousePos:this.exitTipPos,d=(c.x-this.options.gridPadding)/this.options.cellSize,m=(c.y-this.options.gridPadding)/this.options.cellSize,x=this.getSymmetricalPoint({x:d,y:m},!0);r={x:x.x*this.options.cellSize+this.options.gridPadding,y:x.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,u,this.isDrawing,a,l,r)}}}drawRipples(e){if(!this.puzzle)return;let t=(Date.now()-this.startTime)/500;for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)if(this.puzzle.nodes[n][s].type===2){let o=this.getCanvasCoords(s,n),i=this.getExitDir(s,n);if(!i)continue;let u={x:o.x+i.x*this.options.exitLength,y:o.y+i.y*this.options.exitLength},y=t%4,f=y*5,a=Math.max(0,1-y/3);e.beginPath(),e.arc(u.x,u.y,f,0,Math.PI*2),e.strokeStyle=`rgba(170, 170, 170, ${a*.4})`,e.lineWidth=2,e.stroke()}}drawGrid(e){if(!this.puzzle||!this.options.colors.grid)return;e.strokeStyle=this.options.colors.grid,e.lineWidth=12,e.lineCap="round";let t=(n,s,h)=>{if(h!==2)if(h===1){let i={x:n.x+(s.x-n.x)*.35,y:n.y+(s.y-n.y)*.35},u={x:n.x+(s.x-n.x)*(.5+.15),y:n.y+(s.y-n.y)*(.5+.15)};e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(i.x,i.y),e.stroke(),e.beginPath(),e.moveTo(u.x,u.y),e.lineTo(s.x,s.y),e.stroke()}else e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(s.x,s.y),e.stroke()};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<this.puzzle.cols;s++)t(this.getCanvasCoords(s,n),this.getCanvasCoords(s+1,n),this.puzzle.hEdges[n][s].type);for(let n=0;n<this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)t(this.getCanvasCoords(s,n),this.getCanvasCoords(s,n+1),this.puzzle.vEdges[n][s].type)}drawConstraints(e){if(!this.puzzle)return;let t=Date.now(),n=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;for(let o=0;o<this.puzzle.rows;o++)for(let i=0;i<this.puzzle.cols;i++){let u=this.puzzle.cells[o][i],y=this.getCanvasCoords(i+.5,o+.5),f=this.invalidatedCells.some(m=>m.x===i&&m.y===o),a=this.errorCells.some(m=>m.x===i&&m.y===o),l=1,r,c=this.getColorCode(u.color),d=this.options.colors.error;if(a&&this.options.blinkMarksOnError&&(r=this.lerpColor(c,d,n)),f){let m=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),x=this.options.animations.blinkDuration;if(m<x){if(this.options.blinkMarksOnError){let p=Math.min(1,m/200),v=m>x*.8?(x-m)/(x*.2):1,g=Math.min(p,v);r=this.lerpColor(c,d,n*g)}}else l=Math.max(.3,1-(m-x)/this.options.animations.fadeDuration)}if(l<1||r){let{canvas:m,ctx:x}=this.prepareOffscreen();this.drawConstraintItem(x,u,y,r),e.save(),e.globalAlpha=l,e.drawImage(m,0,0),e.restore()}else this.drawConstraintItem(e,u,y)}e.lineWidth=2;let s=8,h=o=>o===3||o===3?this.options.colors.hexagon:o===4||o===4?this.options.colors.hexagonMain:o===5||o===5?this.options.colors.hexagonSymmetry:this.options.colors.hexagon;for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<this.puzzle.cols;i++){let u=this.puzzle.hEdges[o][i].type;if(u===3||u===4||u===5){let y=this.getCanvasCoords(i+.5,o);e.save();let f=this.invalidatedEdges.some(r=>r.type==="h"&&r.r===o&&r.c===i),a=this.errorEdges.some(r=>r.type==="h"&&r.r===o&&r.c===i),l=h(u);if(a&&this.options.blinkMarksOnError){let r=this.lerpColor(l,this.options.colors.error,n);this.drawHexagon(e,y.x,y.y,s,r)}else if(f){let r=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),c=this.options.animations.blinkDuration;if(r<c)if(this.options.blinkMarksOnError){let d=Math.min(1,r/200),m=r>c*.8?(c-r)/(c*.2):1,x=Math.min(d,m),p=this.lerpColor(l,this.options.colors.error,n*x);this.drawHexagon(e,y.x,y.y,s,p)}else this.drawHexagon(e,y.x,y.y,s,l);else e.globalAlpha*=Math.max(.3,1-(r-c)/this.options.animations.fadeDuration),this.drawHexagon(e,y.x,y.y,s,l)}else this.drawHexagon(e,y.x,y.y,s,l);e.restore()}}for(let o=0;o<this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++){let u=this.puzzle.vEdges[o][i].type;if(u===3||u===4||u===5){let y=this.getCanvasCoords(i,o+.5);e.save();let f=this.invalidatedEdges.some(r=>r.type==="v"&&r.r===o&&r.c===i),a=this.errorEdges.some(r=>r.type==="v"&&r.r===o&&r.c===i),l=h(u);if(a&&this.options.blinkMarksOnError){let r=this.lerpColor(l,this.options.colors.error,n);this.drawHexagon(e,y.x,y.y,s,r)}else if(f){let r=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),c=this.options.animations.blinkDuration;if(r<c)if(this.options.blinkMarksOnError){let d=Math.min(1,r/200),m=r>c*.8?(c-r)/(c*.2):1,x=Math.min(d,m),p=this.lerpColor(l,this.options.colors.error,n*x);this.drawHexagon(e,y.x,y.y,s,p)}else this.drawHexagon(e,y.x,y.y,s,l);else e.globalAlpha*=Math.max(.3,1-(r-c)/this.options.animations.fadeDuration),this.drawHexagon(e,y.x,y.y,s,l)}else this.drawHexagon(e,y.x,y.y,s,l);e.restore()}}for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++){let u=this.puzzle.nodes[o][i].type;if(u===3||u===4||u===5){let y=this.getCanvasCoords(i,o);e.save();let f=this.invalidatedNodes.some(r=>r.x===i&&r.y===o),a=this.errorNodes.some(r=>r.x===i&&r.y===o),l=h(u);if(a&&this.options.blinkMarksOnError){let r=this.lerpColor(l,this.options.colors.error,n);this.drawHexagon(e,y.x,y.y,s,r)}else if(f){let r=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),c=this.options.animations.blinkDuration;if(r<c)if(this.options.blinkMarksOnError){let d=Math.min(1,r/200),m=r>c*.8?(c-r)/(c*.2):1,x=Math.min(d,m),p=this.lerpColor(l,this.options.colors.error,n*x);this.drawHexagon(e,y.x,y.y,s,p)}else this.drawHexagon(e,y.x,y.y,s,l);else e.globalAlpha*=Math.max(.3,1-(r-c)/this.options.animations.fadeDuration),this.drawHexagon(e,y.x,y.y,s,l)}else this.drawHexagon(e,y.x,y.y,s,l);e.restore()}}}drawConstraintItem(e,t,n,s){t.type===1?(e.fillStyle=s||this.getColorCode(t.color),this.drawRoundedRect(e,n.x-26/2,n.y-26/2,26,26,8)):t.type===2?this.drawStar(e,n.x,n.y,12,16,8,t.color,s):t.type===3||t.type===4?this.drawTetris(e,n.x,n.y,t.shape||[],t.type===4,t.color,!1,s):t.type===6||t.type===7?this.drawTetris(e,n.x,n.y,t.shape||[],t.type===7,t.color,!0,s):t.type===5&&this.drawEraser(e,n.x,n.y,14,3,t.color,s)}drawNodes(e){if(!this.puzzle)return;let t=(n,s)=>{let h=[];return n>0&&h.push(this.puzzle.hEdges[s][n-1].type),n<this.puzzle.cols&&h.push(this.puzzle.hEdges[s][n].type),s>0&&h.push(this.puzzle.vEdges[s-1][n].type),s<this.puzzle.rows&&h.push(this.puzzle.vEdges[s][n].type),h.length>0&&h.every(o=>o===2)};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++){if(t(s,n))continue;let h=this.puzzle.nodes[n][s];if(h.type===3||h.type===4||h.type===5)continue;let o=this.getCanvasCoords(s,n);if(h.type===1)this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill();else if(h.type===2){let i=this.getExitDir(s,n);if(!i)continue;this.options.colors.node&&(e.strokeStyle=this.options.colors.node),e.lineWidth=12,e.lineCap="round",e.beginPath(),e.moveTo(o.x,o.y),e.lineTo(o.x+i.x*this.options.exitLength,o.y+i.y*this.options.exitLength),e.stroke()}else this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.nodeRadius,0,Math.PI*2),e.fill()}}drawPath(e,t,n,s,h,o=null){if(t.length===0||!s||s==="transparent")return;let i=this.colorToRgba(s),u=`rgb(${i.r},${i.g},${i.b})`,y=h*i.a,{canvas:f,ctx:a}=this.prepareOffscreen();this.drawPathInternal(a,t,n,u,o),e.save(),e.globalAlpha=y,e.drawImage(f,0,0),e.restore()}drawPathInternal(e,t,n,s,h=null){e.save(),e.strokeStyle=s,e.fillStyle=s,e.lineWidth=this.options.pathWidth,e.lineCap="round",e.lineJoin="round",e.beginPath();let o=this.getCanvasCoords(t[0].x,t[0].y);e.moveTo(o.x,o.y);for(let u=1;u<t.length;u++){let y=this.getCanvasCoords(t[u].x,t[u].y);e.lineTo(y.x,y.y)}let i=h||this.currentMousePos;(n||h)&&e.lineTo(i.x,i.y),e.stroke(),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill(),(n||h)&&(e.beginPath(),e.arc(i.x,i.y,this.options.pathWidth/2,0,Math.PI*2),e.fill()),e.restore()}drawRoundedRect(e,t,n,s,h,o){e.beginPath(),e.moveTo(t+o,n),e.lineTo(t+s-o,n),e.quadraticCurveTo(t+s,n,t+s,n+o),e.lineTo(t+s,n+h-o),e.quadraticCurveTo(t+s,n+h,t+s-o,n+h),e.lineTo(t+o,n+h),e.quadraticCurveTo(t,n+h,t,n+h-o),e.lineTo(t,n+o),e.quadraticCurveTo(t,n,t+o,n),e.closePath(),e.fill()}drawHexagon(e,t,n,s,h){if(!(!this.options.colors.hexagon&&!h)){e.fillStyle=h||this.options.colors.hexagon,e.beginPath();for(let o=0;o<6;o++){let i=Math.PI/3*o,u=t+s*Math.cos(i),y=n+s*Math.sin(i);o===0?e.moveTo(u,y):e.lineTo(u,y)}e.closePath(),e.fill()}}drawEraser(e,t,n,s,h,o,i){e.strokeStyle=i||this.getColorCode(o),e.lineWidth=s*.5,e.lineCap="butt";let u=.5;e.beginPath();for(let y=0;y<h;y++){let f=Math.PI*2/h*y+u,a=t+s*Math.cos(f),l=n+s*Math.sin(f);e.moveTo(t,n),e.lineTo(a,l)}e.stroke()}drawStar(e,t,n,s,h,o,i,u){e.fillStyle=u||this.getColorCode(i),e.beginPath();for(let y=0;y<o*2;y++){let f=y%2===0?h:s,a=Math.PI/o*y,l=t+f*Math.cos(a),r=n+f*Math.sin(a);y===0?e.moveTo(l,r):e.lineTo(l,r)}e.closePath(),e.fill()}drawTetris(e,t,n,s,h,o,i,u){if(!s||s.length===0)return;let y=12,f=2,a=s[0].length*y+(s[0].length-1)*f,l=s.length*y+(s.length-1)*f;e.save(),e.translate(t,n),h&&e.rotate(Math.PI/8);let r=u||this.getColorCode(o,i?"#00ffff":"#ffcc00");if(i){e.strokeStyle=r,e.lineWidth=2;for(let c=0;c<s.length;c++)for(let d=0;d<s[c].length;d++)if(s[c][d]){let m=d*(y+f)-a/2,x=c*(y+f)-l/2;e.strokeRect(m+1,x+1,y-2,y-2)}}else{e.fillStyle=r;for(let c=0;c<s.length;c++)for(let d=0;d<s[c].length;d++)if(s[c][d]){let m=d*(y+f)-a/2,x=c*(y+f)-l/2;e.fillRect(m,x,y,y)}}e.restore()}getColorCode(e,t="#666"){return this.options.colors.colorList&&this.options.colors.colorList[e]!==void 0?this.options.colors.colorList[e]:this.options.colors.colorMap&&this.options.colors.colorMap[e]!==void 0?this.options.colors.colorMap[e]:t}colorToRgba(e){if(!e||e==="transparent")return{r:0,g:0,b:0,a:0};if(e.startsWith("rgba")||e.startsWith("rgb")){let n=e.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);if(n)return{r:parseInt(n[1]),g:parseInt(n[2]),b:parseInt(n[3]),a:n[4]?parseFloat(n[4]):1}}let t=e.startsWith("#")?e.slice(1):e;if((t.length===3||t.length===4)&&(t=t.split("").map(n=>n+n).join("")),t.length===6){let n=parseInt(t,16);return{r:n>>16&255,g:n>>8&255,b:n&255,a:1}}else if(t.length===8){let n=parseInt(t,16);return{r:n>>24&255,g:n>>16&255,b:n>>8&255,a:(n&255)/255}}return{r:0,g:0,b:0,a:1}}lerpColor(e,t,n){try{let s=this.colorToRgba(e),h=this.colorToRgba(t),o=Math.round(s.r+(h.r-s.r)*n),i=Math.round(s.g+(h.g-s.g)*n),u=Math.round(s.b+(h.b-s.b)*n),y=s.a+(h.a-s.a)*n;return`rgba(${o},${i},${u},${y})`}catch{return e}}setAlpha(e,t){let n=this.colorToRgba(e);return`rgba(${n.r},${n.g},${n.b},${t})`}getSymmetryPath(e){return!this.puzzle||!this.puzzle.symmetry?[]:e.map(t=>this.getSymmetricalPoint(t))}getSymmetricalPoint(e,t=!1){if(!this.puzzle||!this.puzzle.symmetry)return{...e};let{cols:n,rows:s,symmetry:h}=this.puzzle;return h===1?{x:n-e.x,y:e.y}:h===2?{x:e.x,y:s-e.y}:h===3?{x:n-e.x,y:s-e.y}:{...e}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}prepareOffscreen(){if(!this.offscreenCanvas){if(typeof document<"u")this.offscreenCanvas=document.createElement("canvas");else if(typeof OffscreenCanvas<"u")this.offscreenCanvas=new OffscreenCanvas(this.canvas.width,this.canvas.height);else throw new Error("Offscreen canvas not supported in this environment.");this.offscreenCtx=this.offscreenCanvas.getContext("2d")}if((this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),!this.offscreenCtx)throw new Error("Could not get offscreen 2D context.");return this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx}}};var ce=class{generator;validator;constructor(){this.generator=new ne,this.validator=new Z}createPuzzle(e,t,n={}){return this.generator.generate(e,t,n).export()}validateSolution(e,t){let n=_.fromData(e);return this.validator.validate(n,t)}calculateDifficulty(e){let t=_.fromData(e);return this.validator.calculateDifficulty(t)}};export{ee as CellType,K as Color,fe as Direction,te as EdgeType,_ as Grid,se as NodeType,ne as PuzzleGenerator,ae as PuzzleSerializer,Z as PuzzleValidator,oe as SymmetryType,ce as WitnessCore,le as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
