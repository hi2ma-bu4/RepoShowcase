/*!
 * MiniWitness 1.2.2
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var lt=(s=>(s[s.Up=0]="Up",s[s.Right=1]="Right",s[s.Down=2]="Down",s[s.Left=3]="Left",s))(lt||{}),j=(o=>(o[o.None=0]="None",o[o.Square=1]="Square",o[o.Star=2]="Star",o[o.Tetris=3]="Tetris",o[o.TetrisRotated=4]="TetrisRotated",o[o.Eraser=5]="Eraser",o))(j||{}),_=(s=>(s[s.Normal=0]="Normal",s[s.Broken=1]="Broken",s[s.Absent=2]="Absent",s[s.Hexagon=3]="Hexagon",s))(_||{}),Q=(s=>(s[s.Normal=0]="Normal",s[s.Start=1]="Start",s[s.End=2]="End",s[s.Hexagon=3]="Hexagon",s))(Q||{}),tt=(s=>(s[s.None=0]="None",s[s.Horizontal=1]="Horizontal",s[s.Vertical=2]="Vertical",s[s.Rotational=3]="Rotational",s))(tt||{}),$={None:0,Black:1,White:2,Red:3,Blue:4};var U=class X{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];symmetry=0;constructor(t,e){this.rows=t,this.cols=e,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:$.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes,symmetry:this.symmetry}))}static fromData(t){let e=new X(t.rows,t.cols);return e.cells=t.cells,e.vEdges=t.vEdges,e.hEdges=t.hEdges,e.nodes=t.nodes,e.symmetry=t.symmetry||0,e}};var Y=class{validate(t,e,n){let s=e.points;if(s.length<2)return{isValid:!1,errorReason:"Path too short"};let a=t.symmetry||0,o=[];if(a!==0)for(let d of s)o.push(this.getSymmetricalPoint(t,d));let r=s[0],h=s[s.length-1];if(t.nodes[r.y][r.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(t.nodes[h.y][h.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};if(a!==0){let d=o[0],y=o[o.length-1];if(t.nodes[d.y][d.x].type!==1)return{isValid:!1,errorReason:"Symmetrical path must start at Start Node"};if(t.nodes[y.y][y.x].type!==2)return{isValid:!1,errorReason:"Symmetrical path must end at End Node"}}let f=new Set,l=new Set;if(f.add(`${r.x},${r.y}`),a!==0){let d=o[0];if(f.has(`${d.x},${d.y}`))return{isValid:!1,errorReason:"Paths collide at start"};f.add(`${d.x},${d.y}`)}for(let d=0;d<s.length-1;d++){let y=s[d],p=s[d+1];if(Math.abs(y.x-p.x)+Math.abs(y.y-p.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let g=`${p.x},${p.y}`;if(f.has(g))return{isValid:!1,errorReason:"Self-intersecting path or path collision"};if(f.add(g),this.isBrokenEdge(t,y,p))return{isValid:!1,errorReason:"Passed through broken edge"};if(l.add(this.getEdgeKey(y,p)),a!==0){let b=o[d],m=o[d+1],v=`${m.x},${m.y}`;if(f.has(v))return{isValid:!1,errorReason:"Path collision"};if(f.add(v),this.isBrokenEdge(t,b,m))return{isValid:!1,errorReason:"Symmetrical path passed through broken edge"};let P=this.getEdgeKey(b,m);if(l.has(P))return{isValid:!1,errorReason:"Paths cross the same edge"};l.add(P)}}let i=this.calculateRegions(t,s,o,n),c=this.getMissedHexagons(t,s,o),u=this.validateWithErasers(t,i,c.edges,c.nodes);return u.regions=i,u}validateFast(t,e,n,s){let a=this.calculateRegions(t,e,n,s),o=this.getMissedHexagons(t,e,n);return this.validateWithErasers(t,a,o.edges,o.nodes)}isBrokenEdge(t,e,n){let s;if(e.x===n.x){let a=Math.min(e.y,n.y);s=t.vEdges[a][e.x].type}else{let a=Math.min(e.x,n.x);s=t.hEdges[e.y][a].type}return s===1||s===2}isAbsentEdge(t,e,n){if(e.x===n.x){let s=Math.min(e.y,n.y);return t.vEdges[s][e.x].type===2}else{let s=Math.min(e.x,n.x);return t.hEdges[e.y][s].type===2}}getMissedHexagons(t,e,n=[]){let s=new Set,a=new Set;for(let h=0;h<e.length;h++)a.add(`${e[h].x},${e[h].y}`),h<e.length-1&&s.add(this.getEdgeKey(e[h],e[h+1]));for(let h=0;h<n.length;h++)a.add(`${n[h].x},${n[h].y}`),h<n.length-1&&s.add(this.getEdgeKey(n[h],n[h+1]));let o=[];for(let h=0;h<=t.rows;h++)for(let f=0;f<t.cols;f++)if(t.hEdges[h][f].type===3){let l=this.getEdgeKey({x:f,y:h},{x:f+1,y:h});s.has(l)||o.push({type:"h",r:h,c:f})}for(let h=0;h<t.rows;h++)for(let f=0;f<=t.cols;f++)if(t.vEdges[h][f].type===3){let l=this.getEdgeKey({x:f,y:h},{x:f,y:h+1});s.has(l)||o.push({type:"v",r:h,c:f})}let r=[];for(let h=0;h<=t.rows;h++)for(let f=0;f<=t.cols;f++)t.nodes[h][f].type===3&&(a.has(`${f},${h}`)||r.push({x:f,y:h}));return{edges:o,nodes:r}}validateWithErasers(t,e,n,s){let a=[],o=!0;for(let u=0;u<e.length;u++){let d=e[u],y=d.filter(m=>t.cells[m.y][m.x].type===5),p=d.filter(m=>t.cells[m.y][m.x].type!==0&&t.cells[m.y][m.x].type!==5),x=[];for(let m=0;m<n.length;m++)this.isHexagonAdjacentToRegion(t,n[m],d)&&x.push(m);let g=[];for(let m=0;m<s.length;m++)this.isNodeHexagonAdjacentToRegion(t,s[m],d)&&g.push(m);let b=this.getPossibleErasures(t,d,y,p,x,g);if(b.length===0){o=!1;let m=this.getBestEffortErasures(t,d,y,p,x,g);a.push([m])}else b.sort((m,v)=>{let P=m.invalidatedCells.length+m.invalidatedHexagons.length+m.invalidatedNodeHexagons.length,M=v.invalidatedCells.length+v.invalidatedHexagons.length+v.invalidatedNodeHexagons.length;return P-M}),a.push(b)}if(o){let u=this.findGlobalAssignment(a,n.length,s.length);if(u)return{isValid:!0,invalidatedCells:u.invalidatedCells,invalidatedEdges:u.invalidatedHexIndices.map(d=>n[d]),invalidatedNodes:u.invalidatedNodeHexIndices.map(d=>s[d])}}let r=[],h=[],f=new Set,l=new Set;for(let u of a){let d=u[0];r.push(...d.errorCells),h.push(...d.invalidatedCells);for(let y of d.invalidatedHexagons)f.add(y);for(let y of d.invalidatedNodeHexagons)l.add(y)}let i=[];for(let u=0;u<n.length;u++)f.has(u)||i.push(n[u]);let c=[];for(let u=0;u<s.length;u++)l.has(u)||c.push(s[u]);return{isValid:!1,errorReason:"Constraints failed",errorCells:r,errorEdges:i,errorNodes:c,invalidatedCells:h,invalidatedEdges:Array.from(f).map(u=>n[u]),invalidatedNodes:Array.from(l).map(u=>s[u])}}isHexagonAdjacentToRegion(t,e,n){let s=new Set(n.map(a=>`${a.x},${a.y}`));if(e.type==="h"){if(e.r>0&&s.has(`${e.c},${e.r-1}`)||e.r<t.rows&&s.has(`${e.c},${e.r}`))return!0}else if(e.c>0&&s.has(`${e.c-1},${e.r}`)||e.c<t.cols&&s.has(`${e.c},${e.r}`))return!0;return!1}isNodeHexagonAdjacentToRegion(t,e,n){let s=new Set(n.map(o=>`${o.x},${o.y}`)),a=[{x:e.x-1,y:e.y-1},{x:e.x,y:e.y-1},{x:e.x-1,y:e.y},{x:e.x,y:e.y}];for(let o of a)if(o.x>=0&&o.x<t.cols&&o.y>=0&&o.y<t.rows&&s.has(`${o.x},${o.y}`))return!0;return!1}getPossibleErasures(t,e,n,s,a,o){let r=[],h=n.length;if(h===0)return this.getRegionErrors(t,e,[]).length===0&&a.length===0&&o.length===0&&r.push({invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!0,errorCells:[]}),r;let f=[...s.map(i=>({type:"cell",pos:i})),...a.map(i=>({type:"hex",index:i})),...o.map(i=>({type:"nodeHex",index:i}))],l=this.getRegionErrors(t,e,[]).length===0&&a.length===0&&o.length===0;for(let i=0;i<=h;i++){let c=this.getNCombinations(n,i);for(let u of c){let d=new Set(u.map(p=>`${p.x},${p.y}`)),y=n.filter(p=>!d.has(`${p.x},${p.y}`));for(let p=0;p<=f.length;p++){if(y.length!==i+p)continue;let x=this.getNCombinations(f,p);for(let g of x){let b=g.filter(w=>w.type==="cell").map(w=>w.pos),m=g.filter(w=>w.type==="hex").map(w=>w.index),v=g.filter(w=>w.type==="nodeHex").map(w=>w.index);if(this.getRegionErrors(t,e,[...b,...u]).length===0){let w=!0;if(l)p>0&&(w=!1);else for(let H=0;H<g.length;H++){let V=[...g.slice(0,H),...g.slice(H+1)],I=V.filter(A=>A.type==="cell").map(A=>A.pos),D=new Set(V.filter(A=>A.type==="hex").map(A=>A.index)),C=new Set(V.filter(A=>A.type==="nodeHex").map(A=>A.index)),S=a.every(A=>D.has(A)),k=o.every(A=>C.has(A));if(this.getRegionErrors(t,e,I).length===0&&S&&k){w=!1;break}}w&&r.push({invalidatedCells:[...b,...u],invalidatedHexagons:m,invalidatedNodeHexagons:v,isValid:!0,errorCells:[]})}}}}}return r}getBestEffortErasures(t,e,n,s,a,o){let r=this.getRegionErrors(t,e,[]);if(r.length===0&&a.length===0&&o.length===0)return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:[...n]};if(n.length>0){let l=[...s.map(d=>({type:"cell",pos:d})),...a.map(d=>({type:"hex",index:d})),...o.map(d=>({type:"nodeHex",index:d}))],i=null,c=1/0,u=d=>{let y=[],p=[],x=[],g=0;for(let w of d)g<n.length&&(w.type==="cell"?y.push(w.pos):w.type==="hex"?p.push(w.index):x.push(w.index),g++);let b=n.length-g,m=Math.floor(b/2),v=n.slice(g,g+m);g+=m*2;let P=this.getRegionErrors(t,e,[...y,...v]);for(let w=g;w<n.length;w++)P.push(n[w]);let M=P.length;M<c&&(c=M,i={invalidatedCells:[...y,...v],invalidatedHexagons:p,invalidatedNodeHexagons:x,isValid:!1,errorCells:P})};u([...r.map(d=>({type:"cell",pos:d})),...a.map(d=>({type:"hex",index:d})),...o.map(d=>({type:"nodeHex",index:d}))]),u(l);for(let d of r)u([{type:"cell",pos:d}]);if(i)return i}let f=[...r,...n];return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:f}}getNCombinations(t,e){let n=[],s=(a,o)=>{if(o.length===e){n.push([...o]);return}for(let r=a;r<t.length;r++)o.push(t[r]),s(r+1,o),o.pop()};return s(0,[]),n}checkRegionValid(t,e,n){return this.getRegionErrors(t,e,n).length===0}getRegionErrors(t,e,n){let s=new Set(n.map(i=>`${i.x},${i.y}`)),a=new Map,o=new Map,r=new Set,h=new Set,f=[];for(let i of e){if(s.has(`${i.x},${i.y}`))continue;let c=t.cells[i.y][i.x];if(c.type===0)continue;let u=c.color;u!==$.None&&(a.set(u,(a.get(u)||0)+1),o.has(u)||o.set(u,[]),o.get(u).push(i)),c.type===1?h.add(u):c.type===2?r.add(u):(c.type===3||c.type===4)&&c.shape&&f.push({shape:c.shape,rotatable:c.type===4,pos:i})}let l=[];if(h.size>1)for(let i of e)s.has(`${i.x},${i.y}`)||t.cells[i.y][i.x].type===1&&l.push(i);for(let i of r)if(a.get(i)!==2){let c=o.get(i)||[];for(let u of c)t.cells[u.y][u.x].type===2&&l.push(u)}if(f.length>0&&!this.checkTetrisConstraint(e,f.map(i=>({shape:i.shape,rotatable:i.rotatable}))))for(let i of f)l.push(i.pos);return l}findGlobalAssignment(t,e,n){let s=t.length,a=new Array(e).fill(0),o=new Array(n).fill(0),r=[],h=[],f=[],l=i=>{if(i===s)return a.every(c=>c===1)&&o.every(c=>c===1);for(let c of t[i]){let u=!0;for(let d of c.invalidatedHexagons)if(a[d]>0){u=!1;break}if(u){for(let d of c.invalidatedNodeHexagons)if(o[d]>0){u=!1;break}}if(u){for(let d of c.invalidatedHexagons)a[d]++,h.push(d);for(let d of c.invalidatedNodeHexagons)o[d]++,f.push(d);if(r.push(...c.invalidatedCells),l(i+1))return!0;for(let d of c.invalidatedHexagons)a[d]--,h.pop();for(let d of c.invalidatedNodeHexagons)o[d]--,f.pop();for(let d=0;d<c.invalidatedCells.length;d++)r.pop()}}return!1};return l(0)?{invalidatedCells:r,invalidatedHexIndices:h,invalidatedNodeHexIndices:f}:null}checkTetrisConstraint(t,e){if(e.reduce((i,c)=>i+this.getShapeArea(c.shape),0)!==t.length)return!1;let s=Math.min(...t.map(i=>i.x)),a=Math.min(...t.map(i=>i.y)),o=Math.max(...t.map(i=>i.x)),r=Math.max(...t.map(i=>i.y)),h=o-s+1,f=r-a+1,l=Array.from({length:f},()=>Array(h).fill(!1));for(let i of t)l[i.y-a][i.x-s]=!0;return this.canTile(l,e)}getShapeArea(t){let e=0;for(let n of t)for(let s of n)s&&e++;return e}canTile(t,e){let n=-1,s=-1;for(let a=0;a<t.length;a++){for(let o=0;o<t[0].length;o++)if(t[a][o]){n=a,s=o;break}if(n!==-1)break}if(n===-1)return e.length===0;if(e.length===0)return!1;for(let a=0;a<e.length;a++){let o=e[a],r=[...e.slice(0,a),...e.slice(a+1)],h=o.rotatable?this.getAllRotations(o.shape):[o.shape];for(let f of h){let l=[];for(let i=0;i<f.length;i++)for(let c=0;c<f[0].length;c++)f[i][c]&&l.push({r:i,c});for(let i of l){let c=n-i.r,u=s-i.c;if(this.canPlace(t,f,c,u)){if(this.placePiece(t,f,c,u,!1),this.canTile(t,r))return!0;this.placePiece(t,f,c,u,!0)}}}}return!1}canPlace(t,e,n,s){for(let a=0;a<e.length;a++)for(let o=0;o<e[0].length;o++)if(e[a][o]){let r=n+a,h=s+o;if(r<0||r>=t.length||h<0||h>=t[0].length||!t[r][h])return!1}return!0}placePiece(t,e,n,s,a){for(let o=0;o<e.length;o++)for(let r=0;r<e[0].length;r++)e[o][r]&&(t[n+o][s+r]=a)}getAllRotations(t){let e=[],n=new Set,s=t;for(let a=0;a<4;a++){let o=JSON.stringify(s);n.has(o)||(e.push(s),n.add(o)),s=this.rotate90(s)}return e}rotate90(t){let e=t.length,n=t[0].length,s=Array.from({length:n},()=>Array(e).fill(0));for(let a=0;a<e;a++)for(let o=0;o<n;o++)s[o][e-1-a]=t[a][o];return s}calculateRegions(t,e,n=[],s){let a=[],o=t.rows,r=t.cols,h=new Uint8Array(o*r),f=new Uint8Array((o+1)*r),l=new Uint8Array(o*(r+1)),i=(u,d)=>{u.x===d.x?l[Math.min(u.y,d.y)*(r+1)+u.x]=1:f[u.y*r+Math.min(u.x,d.x)]=1};for(let u=0;u<e.length-1;u++)i(e[u],e[u+1]);for(let u=0;u<n.length-1;u++)i(n[u],n[u+1]);for(let u=0;u<=o;u++)for(let d=0;d<r;d++)t.hEdges[u][d].type===2&&(f[u*r+d]=1);for(let u=0;u<o;u++)for(let d=0;d<=r;d++)t.vEdges[u][d].type===2&&(l[u*(r+1)+d]=1);let c=s||this.getExternalCells(t);for(let u=0;u<o;u++)for(let d=0;d<r;d++){let y=u*r+d;if(h[y]||c&&c.has(`${d},${u}`))continue;let p=[],x=[y];h[y]=1;let g=0;for(;g<x.length;){let b=x[g++],m=b%r,v=Math.floor(b/r);if(p.push({x:m,y:v}),v>0&&!f[v*r+m]){let P=(v-1)*r+m;!h[P]&&(!c||!c.has(`${m},${v-1}`))&&(h[P]=1,x.push(P))}if(v<o-1&&!f[(v+1)*r+m]){let P=(v+1)*r+m;!h[P]&&(!c||!c.has(`${m},${v+1}`))&&(h[P]=1,x.push(P))}if(m>0&&!l[v*(r+1)+m]){let P=v*r+(m-1);!h[P]&&(!c||!c.has(`${m-1},${v}`))&&(h[P]=1,x.push(P))}if(m<r-1&&!l[v*(r+1)+(m+1)]){let P=v*r+(m+1);!h[P]&&(!c||!c.has(`${m+1},${v}`))&&(h[P]=1,x.push(P))}}a.push(p)}return a}getExternalCells(t){let e=new Set,n=[];for(let s=0;s<t.cols;s++)t.hEdges[0][s].type===2&&(e.has(`${s},0`)||(e.add(`${s},0`),n.push({x:s,y:0}))),t.hEdges[t.rows][s].type===2&&(e.has(`${s},${t.rows-1}`)||(e.add(`${s},${t.rows-1}`),n.push({x:s,y:t.rows-1})));for(let s=0;s<t.rows;s++)t.vEdges[s][0].type===2&&(e.has(`0,${s}`)||(e.add(`0,${s}`),n.push({x:0,y:s}))),t.vEdges[s][t.cols].type===2&&(e.has(`${t.cols-1},${s}`)||(e.add(`${t.cols-1},${s}`),n.push({x:t.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),a=[{nx:s.x,ny:s.y-1,edge:t.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:t.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:t.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:t.vEdges[s.y][s.x+1]}];for(let o of a)o.nx>=0&&o.nx<t.cols&&o.ny>=0&&o.ny<t.rows&&!e.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(e.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return e}getSymmetricalPoint(t,e){let n=t.symmetry||0;return n===1?{x:t.cols-e.x,y:e.y}:n===2?{x:e.x,y:t.rows-e.y}:n===3?{x:t.cols-e.x,y:t.rows-e.y}:{...e}}getSymmetricalPointIndex(t,e){let n=t.cols+1,s=Math.floor(e/n),a=e%n,o=t.symmetry||0,r=s,h=a;return o===1?h=t.cols-a:o===2?r=t.rows-s:o===3&&(h=t.cols-a,r=t.rows-s),r*n+h}getEdgeKey(t,e){return t.x<e.x||t.x===e.x&&t.y<e.y?`${t.x},${t.y}-${e.x},${e.y}`:`${e.x},${e.y}-${t.x},${t.y}`}calculateDifficulty(t){let e=t.rows,n=t.cols,s=n+1,a=(e+1)*s,o=Array.from({length:a},()=>[]),r=[],h=[],f=new Set,l=new Set;for(let C=0;C<=e;C++)for(let S=0;S<=n;S++){let k=C*s+S;if(t.nodes[C][S].type===1&&r.push(k),t.nodes[C][S].type===2&&h.push(k),t.nodes[C][S].type===3&&l.add(k),S<n){let A=k+1,E=t.hEdges[C][S].type,T=E===3,W=E===1||E===2;o[k].push({next:A,isHexagon:T,isBroken:W}),o[A].push({next:k,isHexagon:T,isBroken:W}),T&&f.add(this.getEdgeKey({x:S,y:C},{x:S+1,y:C}))}if(C<e){let A=k+s,E=t.vEdges[C][S].type,T=E===3,W=E===1||E===2;o[k].push({next:A,isHexagon:T,isBroken:W}),o[A].push({next:k,isHexagon:T,isBroken:W}),T&&f.add(this.getEdgeKey({x:S,y:C},{x:S,y:C+1}))}}let i={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},c=f.size+l.size,u=new Set,d=Math.max(1e3,e*n*200),y=this.getExternalCells(t),p=!1;for(let C=0;C<e;C++){for(let S=0;S<n;S++)if(t.cells[C][S].type!==0){p=!0;break}if(p)break}for(let C of r){let S=l.has(C)?1:0,k=t.symmetry||0,A=1n<<BigInt(C);if(k!==0){let E=this.getSymmetricalPointIndex(t,C);if(E===C)continue;A|=1n<<BigInt(E)}this.exploreSearchSpace(t,C,A,[C],S,c,o,h,u,i,d,y,p)}if(i.solutions===0)return 0;let x=f.size+l.size,g=new Set;f.size>0&&g.add(999);let b=0,m=0;for(let C=0;C<e;C++)for(let S=0;S<n;S++){let k=t.cells[C][S];k.type!==0&&(x++,g.add(k.type),k.type===3?b++:k.type===4&&(b++,m++))}let v=i.branchingPoints/(i.totalNodesVisited||1),P=Math.log10(i.totalNodesVisited+1),M=(v*10+P*1.5)/(Math.log2(i.solutions+1)*.5+1);M-=f.size*.05,M+=l.size*.12,b>0&&(M+=m*.5,M+=(b-m)*.2);let w=e*n,H=x/w,V=H<.25?Math.pow(H/.25,4):1,I=g.size<=1?.5:1;M*=V*I;let D=Math.log2(w)/5;return M*=D,Math.max(.01,Math.min(1,M/4))}exploreSearchSpace(t,e,n,s,a,o,r,h,f,l,i,c,u=!0){if(l.totalNodesVisited++,l.maxDepth=Math.max(l.maxDepth,s.length),l.totalNodesVisited>i)return;let d=t.symmetry||0;if(h.includes(e)){if(a===o){let x=s.map(m=>({x:m%(t.cols+1),y:Math.floor(m/(t.cols+1))})),g={points:x};if(d!==0){let m=this.getSymmetricalPointIndex(t,e),v=t.cols+1;if(t.nodes[Math.floor(m/v)][m%v].type!==2)return}let b=d!==0?x.map(m=>this.getSymmetricalPoint(t,m)):[];if(u){let m=this.validateFast(t,x,b,c);if(m.isValid){let v=this.getFingerprint(t,x,b,m.regions,c);f.has(v)||(f.add(v),l.solutions++)}}else{let m=this.getFingerprint(t,x,b,void 0,c);f.has(m)||(f.add(m),l.solutions++)}}return}if(!this.canReachEndOptimized(e,n,r,h)){l.backtracks++;return}let y=[];for(let x of r[e]){if(x.isBroken||n&1n<<BigInt(x.next))continue;if(d!==0){let b=this.getSymmetricalPointIndex(t,e),m=this.getSymmetricalPointIndex(t,x.next);if(x.next===m||e===m&&x.next===b)continue}let g=!0;for(let b of r[e])if(b.isHexagon){let m=s.length>=2&&b.next===s[s.length-2],v=b.next===x.next;if(!m&&!v){g=!1;break}}g&&y.push(x)}if(y.length>1&&l.branchingPoints++,t.rows*t.cols>30)for(let x=y.length-1;x>0;x--){let g=Math.floor(Math.random()*(x+1));[y[x],y[g]]=[y[g],y[x]]}let p=t.cols+1;for(let x of y){let g=t.nodes[Math.floor(x.next/p)][x.next%p].type===3?1:0;s.push(x.next);let b=n|1n<<BigInt(x.next);if(d!==0){let m=this.getSymmetricalPointIndex(t,x.next);b|=1n<<BigInt(m)}if(this.exploreSearchSpace(t,x.next,b,s,a+(x.isHexagon?1:0)+g,o,r,h,f,l,i,c,u),s.pop(),l.totalNodesVisited>i)return}}countSolutions(t,e=100){let n=t.rows,s=t.cols,a=s+1,o=(n+1)*a,r=Array.from({length:o},()=>[]),h=[],f=[],l=new Set,i=new Set;for(let p=0;p<=n;p++)for(let x=0;x<=s;x++){let g=p*a+x;if(t.nodes[p][x].type===1&&h.push(g),t.nodes[p][x].type===2&&f.push(g),t.nodes[p][x].type===3&&i.add(g),x<s){let b=g+1,m=t.hEdges[p][x].type,v=m===3,P=m===1||m===2;r[g].push({next:b,isHexagon:v,isBroken:P}),r[b].push({next:g,isHexagon:v,isBroken:P}),v&&l.add(this.getEdgeKey({x,y:p},{x:x+1,y:p}))}if(p<n){let b=g+a,m=t.vEdges[p][x].type,v=m===3,P=m===1||m===2;r[g].push({next:b,isHexagon:v,isBroken:P}),r[b].push({next:g,isHexagon:v,isBroken:P}),v&&l.add(this.getEdgeKey({x,y:p},{x,y:p+1}))}}let c=new Set,u=l.size+i.size,d=this.getExternalCells(t),y=!1;for(let p=0;p<n;p++){for(let x=0;x<s;x++)if(t.cells[p][x].type!==0){y=!0;break}if(y)break}for(let p of h){let x=i.has(p)?1:0,g=t.symmetry||0,b=1n<<BigInt(p);if(g!==0){let m=this.getSymmetricalPointIndex(t,p);if(m===p)continue;b|=1n<<BigInt(m)}this.findPathsOptimized(t,p,b,[p],x,u,r,f,c,e,d,y)}return c.size}findPathsOptimized(t,e,n,s,a,o,r,h,f,l,i,c=!0){if(f.size>=l)return;let u=t.symmetry||0;if(h.includes(e)){if(a===o){let d=s.map(p=>({x:p%(t.cols+1),y:Math.floor(p/(t.cols+1))}));if(u!==0){let p=this.getSymmetricalPointIndex(t,e),x=t.cols+1;if(t.nodes[Math.floor(p/x)][p%x].type!==2)return}let y=u!==0?d.map(p=>this.getSymmetricalPoint(t,p)):[];if(!c)f.add(this.getFingerprint(t,d,y,void 0,i));else{let p=this.validateFast(t,d,y,i);p.isValid&&f.add(this.getFingerprint(t,d,y,p.regions,i))}}return}if(this.canReachEndOptimized(e,n,r,h))for(let d of r[e]){if(d.isBroken||n&1n<<BigInt(d.next))continue;if(u!==0){let b=this.getSymmetricalPointIndex(t,e),m=this.getSymmetricalPointIndex(t,d.next);if(d.next===m||e===m&&d.next===b)continue}let y=!0;for(let b of r[e])if(b.isHexagon){let m=s.length>=2&&b.next===s[s.length-2],v=b.next===d.next;if(!m&&!v){y=!1;break}}if(!y)continue;let p=t.cols+1,x=t.nodes[Math.floor(d.next/p)][d.next%p].type===3?1:0;s.push(d.next);let g=n|1n<<BigInt(d.next);if(u!==0){let b=this.getSymmetricalPointIndex(t,d.next);g|=1n<<BigInt(b)}if(this.findPathsOptimized(t,d.next,g,s,a+(d.isHexagon?1:0)+x,o,r,h,f,l,i,c),s.pop(),f.size>=l)return}}canReachEndOptimized(t,e,n,s){let a=[t],o=e,r=0;for(;r<a.length;){let h=a[r++];if(s.includes(h))return!0;for(let f of n[h])!f.isBroken&&!(o&1n<<BigInt(f.next))&&(o|=1n<<BigInt(f.next),a.push(f.next))}return!1}getFingerprint(t,e,n,s,a){let r=(s||this.calculateRegions(t,e,n,a)).map(f=>{let l="",i=[];for(let c of f){let u=t.cells[c.y][c.x];u.type!==0&&i.push(u.type<<8|u.color)}i.sort((c,u)=>c-u);for(let c of i)l+=c.toString(36)+",";return l}).sort(),h="";for(let f of r)f.length>0&&(h+=f+"|");return h||"empty"}};var Z=class{isWorker;constructor(){this.isWorker=typeof self<"u"&&"postMessage"in self&&!("document"in self)}generate(t,e,n={}){let s=n.difficulty??.5,a=new Y,o=null,r=-1,h=this.isWorker?t*e>30?150:120:t*e>30?100:80,f=this.isWorker?8:5,l=n.symmetry||0,i={x:0,y:t},c={x:e,y:0};l===1?c={x:0,y:0}:l===2?c={x:e,y:t}:l===3&&(c={x:e,y:t});let u=null,d=null,y=null;for(let p=0;p<h;p++){if(p%f===0){u=this.generateRandomPath(new U(t,e),i,c,n.pathLength,l);let m=new U(t,e),v=l!==0?u.map(P=>this.getSymmetricalPoint(m,P,l)):[];d=this.calculateRegions(m,u,v),y=d.map(P=>this.getRegionBoundaryEdges(m,P,u,v))}let x=this.generateFromPath(t,e,u,n,d,y);if(!this.checkAllRequestedConstraintsPresent(x,n))continue;let g=a.calculateDifficulty(x);if(g===0)continue;let b=Math.abs(g-s);if((o===null||b<Math.abs(r-s))&&(r=g,o=x),s>.8&&g>.8||b<.01)break}if(!o){let p=this.generateRandomPath(new U(t,e),i,c,n.pathLength,l);return this.generateFromPath(t,e,p,n)}return o}generateFromPath(t,e,n,s,a,o){let r=new U(t,e),h=s.symmetry||0;r.symmetry=h;let f={x:0,y:t},l={x:e,y:0};if(h===1?l={x:0,y:0}:h===2?l={x:e,y:t}:h===3&&(l={x:e,y:t}),r.nodes[f.y][f.x].type=1,r.nodes[l.y][l.x].type=2,h!==0){let c=this.getSymmetricalPoint(r,f,h),u=this.getSymmetricalPoint(r,l,h);r.nodes[c.y][c.x].type=1,r.nodes[u.y][u.x].type=2}let i=h!==0?n.map(c=>this.getSymmetricalPoint(r,c,h)):[];return this.applyConstraintsBasedOnPath(r,n,s,i,a,o),s.useBrokenEdges&&this.applyBrokenEdges(r,n,s),this.cleanGrid(r),r}generateRandomPath(t,e,n,s,a=0){if(s===void 0)return this.generateSingleRandomPath(t,e,n,void 0,a);let o=t.rows+t.cols,r=(t.rows+1)*(t.cols+1)-1,h=o+s*(r-o),f=[],l=1/0,i=t.rows*t.cols>30?30:50;for(let c=0;c<i;c++){let u=this.generateSingleRandomPath(t,e,n,s,a);if(u.length===0)continue;let d=u.length-1,y=Math.abs(d-h);if(y<l&&(l=y,f=u),l<=2)break}return f}generateSingleRandomPath(t,e,n,s,a=0){let o=new Set,r=[],h=0,f=t.rows*t.cols*20,l=i=>{if(h++,h>f)return!1;o.add(`${i.x},${i.y}`);let c=this.getSymmetricalPoint(t,i,a);if(o.add(`${c.x},${c.y}`),r.push(i),i.x===n.x&&i.y===n.y)return!0;let u=this.getValidNeighbors(t,i,o);a!==0&&(u=u.filter(d=>{let y=this.getSymmetricalPoint(t,d,a);if(y.x<0||y.x>t.cols||y.y<0||y.y>t.rows||o.has(`${y.x},${y.y}`)||d.x===y.x&&d.y===y.y)return!1;let p=this.getEdgeKey(i,d),x=this.getEdgeKey(c,y);return p!==x})),s!==void 0?u.sort((d,y)=>{let p=Math.abs(d.x-n.x)+Math.abs(d.y-n.y),x=Math.abs(y.x-n.x)+Math.abs(y.y-n.y);return(p-x)*(1-s*2)+(Math.random()-.5)*1.5}):this.shuffleArray(u);for(let d of u)if(l(d))return!0;return r.pop(),o.delete(`${i.x},${i.y}`),o.delete(`${c.x},${c.y}`),!1};return l(e),r}getValidNeighbors(t,e,n){let s=[],a=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of a){let r=e.x+o.x,h=e.y+o.y;r>=0&&r<=t.cols&&h>=0&&h<=t.rows&&(n.has(`${r},${h}`)||s.push({x:r,y:h}))}return s}applyBrokenEdges(t,e,n){let s=n.complexity??.5,a=n.symmetry??0,o=new Set;for(let i=0;i<e.length-1;i++)if(o.add(this.getEdgeKey(e[i],e[i+1])),a!==0){let c=this.getSymmetricalPoint(t,e[i],a),u=this.getSymmetricalPoint(t,e[i+1],a);o.add(this.getEdgeKey(c,u))}let r=[];for(let i=0;i<=t.rows;i++)for(let c=0;c<t.cols;c++){let u={x:c,y:i},d={x:c+1,y:i};o.has(this.getEdgeKey(u,d))||r.push({type:"h",r:i,c,p1:u,p2:d})}for(let i=0;i<t.rows;i++)for(let c=0;c<=t.cols;c++){let u={x:c,y:i},d={x:c,y:i+1};o.has(this.getEdgeKey(u,d))||r.push({type:"v",r:i,c,p1:u,p2:d})}this.shuffleArray(r);let h=Math.max(1,Math.floor(s*(t.rows*t.cols)/4)),f=0;for(let i of r){if(f>=h)break;i.type==="h"?t.hEdges[i.r][i.c].type=1:t.vEdges[i.r][i.c].type=1,f++}let l=!0;for(;l;){l=!1;for(let i=0;i<=t.rows;i++)for(let c=0;c<t.cols;c++)t.hEdges[i][c].type===1&&this.canBecomeAbsent(t,{type:"h",r:i,c})&&(t.hEdges[i][c].type=2,l=!0);for(let i=0;i<t.rows;i++)for(let c=0;c<=t.cols;c++)t.vEdges[i][c].type===1&&this.canBecomeAbsent(t,{type:"v",r:i,c})&&(t.vEdges[i][c].type=2,l=!0)}for(let i=0;i<=t.rows;i++)for(let c=0;c<=t.cols;c++){let u=[];if(c>0&&u.push({e:t.hEdges[i][c-1],type:"h",r:i,c:c-1}),c<t.cols&&u.push({e:t.hEdges[i][c],type:"h",r:i,c}),i>0&&u.push({e:t.vEdges[i-1][c],type:"v",r:i-1,c}),i<t.rows&&u.push({e:t.vEdges[i][c],type:"v",r:i,c}),u.length>0&&u.every(d=>d.e.type===1||d.e.type===2)&&u.every(d=>!this.isAdjacentToMark(t,d)))for(let d of u)d.e.type=2}}canBecomeAbsent(t,e){if(this.isAdjacentToMark(t,e))return!1;if(e.type==="h"){if(e.r===0||e.r===t.rows)return!0}else if(e.c===0||e.c===t.cols)return!0;let n=e.type==="h"?[{x:e.c,y:e.r},{x:e.c+1,y:e.r}]:[{x:e.c,y:e.r},{x:e.c,y:e.r+1}];for(let s of n){let a=[{type:"h",r:s.y,c:s.x-1},{type:"h",r:s.y,c:s.x},{type:"v",r:s.y-1,c:s.x},{type:"v",r:s.y,c:s.x}];for(let o of a)if(o.c>=0&&o.c<=t.cols&&o.r>=0&&o.r<=t.rows){if(o.type==="h"&&o.c<t.cols){if(t.hEdges[o.r][o.c].type===2)return!0}else if(o.type==="v"&&o.r<t.rows&&t.vEdges[o.r][o.c].type===2)return!0}}return!1}cleanGrid(t){let e=[];for(let o=0;o<=t.rows;o++)for(let r=0;r<=t.cols;r++)t.nodes[o][r].type===1&&e.push({x:r,y:o});let n=new Set,s=[...e];for(let o of e)n.add(`${o.x},${o.y}`);for(;s.length>0;){let o=s.shift(),r=[{nx:o.x,ny:o.y-1,edge:t.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:t.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:t.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:t.hEdges[o.y]?.[o.x]}];for(let h of r)h.edge&&h.edge.type!==2&&(n.has(`${h.nx},${h.ny}`)||(n.add(`${h.nx},${h.ny}`),s.push({x:h.nx,y:h.ny})))}for(let o=0;o<=t.rows;o++)for(let r=0;r<t.cols;r++)(!n.has(`${r},${o}`)||!n.has(`${r+1},${o}`))&&(t.hEdges[o][r].type=2);for(let o=0;o<t.rows;o++)for(let r=0;r<=t.cols;r++)(!n.has(`${r},${o}`)||!n.has(`${r},${o+1}`))&&(t.vEdges[o][r].type=2);let a=this.getExternalCells(t);for(let o of a){let[r,h]=o.split(",").map(Number);t.cells[h][r].type=0}}getExternalCells(t){let e=new Set,n=[];for(let s=0;s<t.cols;s++)t.hEdges[0][s].type===2&&(e.has(`${s},0`)||(e.add(`${s},0`),n.push({x:s,y:0}))),t.hEdges[t.rows][s].type===2&&(e.has(`${s},${t.rows-1}`)||(e.add(`${s},${t.rows-1}`),n.push({x:s,y:t.rows-1})));for(let s=0;s<t.rows;s++)t.vEdges[s][0].type===2&&(e.has(`0,${s}`)||(e.add(`0,${s}`),n.push({x:0,y:s}))),t.vEdges[s][t.cols].type===2&&(e.has(`${t.cols-1},${s}`)||(e.add(`${t.cols-1},${s}`),n.push({x:t.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),a=[{nx:s.x,ny:s.y-1,edge:t.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:t.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:t.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:t.vEdges[s.y][s.x+1]}];for(let o of a)o.nx>=0&&o.nx<t.cols&&o.ny>=0&&o.ny<t.rows&&!e.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(e.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return e}isAdjacentToMark(t,e){if(e.type==="h"){if(e.r>0&&t.cells[e.r-1][e.c].type!==0||e.r<t.rows&&t.cells[e.r][e.c].type!==0)return!0}else if(e.c>0&&t.cells[e.r][e.c-1].type!==0||e.c<t.cols&&t.cells[e.r][e.c].type!==0)return!0;return!1}hasIsolatedMark(t){for(let e=0;e<t.rows;e++)for(let n=0;n<t.cols;n++){if(t.cells[e][n].type===0)continue;if([t.hEdges[e][n],t.hEdges[e+1][n],t.vEdges[e][n],t.vEdges[e][n+1]].every(a=>a.type===1||a.type===2))return!0}return!1}getSymmetricalPoint(t,e,n){return n===1?{x:t.cols-e.x,y:e.y}:n===2?{x:e.x,y:t.rows-e.y}:n===3?{x:t.cols-e.x,y:t.rows-e.y}:{...e}}getEdgeKey(t,e){return t.x<e.x||t.x===e.x&&t.y<e.y?`${t.x},${t.y}-${e.x},${e.y}`:`${e.x},${e.y}-${t.x},${t.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(t,e,n,s=[],a,o){let r=n.complexity??.5,h=n.useHexagons??!0,f=n.useSquares??!0,l=n.useStars??!0,i=n.useTetris??!1,c=n.useEraser??!1,u=0,d=0,y=0,p=0,x=0,g=0,b=Math.floor(t.rows*t.cols*.45);if(h){let m=n.difficulty??.5;for(let v=0;v<e.length-1;v++){let M=this.getValidNeighbors(t,e[v],new Set).length>2,w=r*(m<.4?.6:.3);M&&(w=m<.4?w*1:w*.5),Math.random()<w&&(this.setEdgeHexagon(t,e[v],e[v+1]),u++)}for(let v=0;v<e.length;v++){let P=e[v];if(t.nodes[P.y][P.x].type!==0||this.hasIncidentHexagonEdge(t,P))continue;let M=r*(m>.6?.15:.05);Math.random()<M&&(t.nodes[P.y][P.x].type=3,u++)}if(u===0&&e.length>=2){let v=Math.floor(Math.random()*(e.length-1));this.setEdgeHexagon(t,e[v],e[v+1])}}if(f||l||i||c){let m=a||this.calculateRegions(t,e,s),v=n.availableColors??[$.Black,$.White,$.Red,$.Blue],P=n.defaultColors??{},M=(I,D)=>{if(P[I]!==void 0)return P[I];let C=j[I];return C&&P[C]!==void 0?P[C]:D},w=Array.from({length:m.length},(I,D)=>D);this.shuffleArray(w);let H=new Set,V={square:f,star:l,tetris:i,eraser:c};for(let I=0;I<w.length;I++){let D=w[I],C=m[D],S=w.length-I,k=V.square&&d===0||V.star&&y===0||V.tetris&&p===0||V.eraser&&x===0,A=.2+r*.6;if(k&&S<=3?A=1:k&&S<=6&&(A=.7),Math.random()>A)continue;let E=[...C];this.shuffleArray(E);let T=v[Math.floor(Math.random()*v.length)];if(f&&!l&&S<=2&&H.size===1){let q=v.filter(K=>!H.has(K));q.length>0&&(T=q[Math.floor(Math.random()*q.length)])}let W=f&&Math.random()<.5+r*.3;if(f&&d===0&&S<=2&&(W=!0),f&&!l&&S<=2&&H.size<2&&d>0&&(W=!0),W&&E.length>0){let q=Math.min(E.length,Math.max(4,Math.floor(C.length/4))),K=Math.floor(Math.random()*(q/2))+Math.ceil(q/2);for(let B=0;B<K&&E.length!==0;B++){let F=E.pop();t.cells[F.y][F.x].type=1,t.cells[F.y][F.x].color=T,d++,H.add(T)}}if(i&&g<b){let q=Math.random()<.1+r*.4;p===0&&S<=2&&(q=!0);let K=p===0&&S<=2?6:4;if(q&&E.length>0&&C.length<=K*4&&g+C.length<=b){let B=this.generateTiling(C,K,n);if(B){for(let F of B){if(E.length===0)break;let N=E.pop();t.cells[N.y][N.x].type=F.isRotated?4:3,t.cells[N.y][N.x].shape=F.isRotated?F.displayShape:F.shape;let O=M(3,$.None);if(l&&Math.random()<.5){let z=v.filter(R=>R!==$.Blue&&R!==O);z.length>0&&(O=z[Math.floor(Math.random()*z.length)])}t.cells[N.y][N.x].color=O,p++}g+=C.length}}}if(c&&x<1){let q=.05+r*.2,K=Math.random()<q;if(S<=2&&(K=!0),K&&E.length>=1){let B=[];l&&B.push("star"),f&&B.push("square");let F=[];h&&(F=o?o[D]:this.getRegionBoundaryEdges(t,C,e,s),F.length>0&&B.push("hexagon")),i&&B.push("tetris");let N=B.length>0?B[Math.floor(Math.random()*B.length)]:null;E.length>=2&&(!N||Math.random()<.01)&&(N="eraser");let O=!1;if(N==="hexagon"){let z=F.filter(R=>!this.isEdgeAdjacentToHexagonNode(t,R));if(z.length>0){let R=z[Math.floor(Math.random()*z.length)];R.type==="h"?t.hEdges[R.r][R.c].type=3:t.vEdges[R.r][R.c].type=3,u++,O=!0}}else if(N==="square"&&E.length>=2){let z=E.pop();t.cells[z.y][z.x].type=1;let R=C.find(G=>t.cells[G.y][G.x].type===1),L=R?t.cells[R.y][R.x].color:void 0;t.cells[z.y][z.x].color=v.find(G=>G!==L)||$.Red,d++,O=!0}else if(N==="star"&&E.length>=2){let z=E.pop();t.cells[z.y][z.x].type=2,t.cells[z.y][z.x].color=v[Math.floor(Math.random()*v.length)],y++,O=!0}else if(N==="tetris"&&E.length>=2){let z=this.generateTiling(C,4,n),R=[];if(z&&z.length>0){let L=0;for(let G of z){let J=this.getShapeArea(G.shape);if(L+J<C.length)R.push(G),L+=J;else break}}if(R.length===0&&C.length>1&&(R=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),R.length>0){for(let L of R){if(E.length<2)break;let G=E.pop();t.cells[G.y][G.x].type=L.isRotated?4:3,t.cells[G.y][G.x].shape=L.isRotated?L.displayShape:L.shape;let J=$.None;if(l&&Math.random()<.3){let it=v.filter(at=>at!==$.Blue);J=it[Math.floor(Math.random()*it.length)]}t.cells[G.y][G.x].color=J,p++}O=!0}}else if(N==="eraser"&&E.length>=2){let z=E.pop();t.cells[z.y][z.x].type=5,t.cells[z.y][z.x].color=M(5,$.White),x++,O=!0}if(!O&&E.length>=2){let z=E.pop();t.cells[z.y][z.x].type=5,t.cells[z.y][z.x].color=M(5,$.White),x++,O=!0}if(O){let z=E.pop();t.cells[z.y][z.x].type=5;let R=M(5,$.White);if(l&&Math.random()<.4){let L=v.filter(G=>G!==R);L.length>0&&(R=L[Math.floor(Math.random()*L.length)])}t.cells[z.y][z.x].color=R,x++}}}if(l){let q=Math.max(1,Math.floor(C.length/8));for(let K=0;K<q;K++)for(let B of v){if(E.length<1)break;if(Math.random()>.3+r*.4)continue;let F=C.filter(N=>t.cells[N.y][N.x].color===B).length;if(F===1){let N=E.pop();t.cells[N.y][N.x].type=2,t.cells[N.y][N.x].color=B,y++}else if(F===0&&E.length>=2)for(let N=0;N<2;N++){let O=E.pop();t.cells[O.y][O.x].type=2,t.cells[O.y][O.x].color=B,y++}}}}if(f&&!l&&H.size<2){for(let I of m)if(I.every(D=>t.cells[D.y][D.x].type===0)){let D=v.find(S=>!H.has(S))||$.White,C=I[Math.floor(Math.random()*I.length)];t.cells[C.y][C.x].type=1,t.cells[C.y][C.x].color=D,H.add(D),d++;break}}}}calculateRegions(t,e,n=[]){let s=[],a=t.rows,o=t.cols,r=new Uint8Array(a*o),h=new Uint8Array((a+1)*o),f=new Uint8Array(a*(o+1)),l=(i,c)=>{i.x===c.x?f[Math.min(i.y,c.y)*(o+1)+i.x]=1:h[i.y*o+Math.min(i.x,c.x)]=1};for(let i=0;i<e.length-1;i++)l(e[i],e[i+1]);for(let i=0;i<n.length-1;i++)l(n[i],n[i+1]);for(let i=0;i<=a;i++)for(let c=0;c<o;c++)t.hEdges[i][c].type===2&&(h[i*o+c]=1);for(let i=0;i<a;i++)for(let c=0;c<=o;c++)t.vEdges[i][c].type===2&&(f[i*(o+1)+c]=1);for(let i=0;i<a;i++)for(let c=0;c<o;c++){let u=i*o+c;if(r[u])continue;let d=[],y=[u];r[u]=1;let p=0;for(;p<y.length;){let x=y[p++],g=x%o,b=Math.floor(x/o);if(d.push({x:g,y:b}),b>0&&!h[b*o+g]){let m=(b-1)*o+g;r[m]||(r[m]=1,y.push(m))}if(b<a-1&&!h[(b+1)*o+g]){let m=(b+1)*o+g;r[m]||(r[m]=1,y.push(m))}if(g>0&&!f[b*(o+1)+g]){let m=b*o+(g-1);r[m]||(r[m]=1,y.push(m))}if(g<o-1&&!f[b*(o+1)+(g+1)]){let m=b*o+(g+1);r[m]||(r[m]=1,y.push(m))}}s.push(d)}return s}isAbsentEdge(t,e,n){if(e.x===n.x){let s=Math.min(e.y,n.y);return t.vEdges[s][e.x].type===2}else{let s=Math.min(e.x,n.x);return t.hEdges[e.y][s].type===2}}getRegionBoundaryEdges(t,e,n,s=[]){let a=new Set;for(let h=0;h<n.length-1;h++)a.add(this.getEdgeKey(n[h],n[h+1]));for(let h=0;h<s.length-1;h++)a.add(this.getEdgeKey(s[h],s[h+1]));let o=[];for(let h of e){let f=[{type:"h",r:h.y,c:h.x},{type:"h",r:h.y+1,c:h.x},{type:"v",r:h.y,c:h.x},{type:"v",r:h.y,c:h.x+1}];for(let l of f){let i=l.type==="h"?{x:l.c,y:l.r}:{x:l.c,y:l.r},c=l.type==="h"?{x:l.c+1,y:l.r}:{x:l.c,y:l.r+1},u=this.getEdgeKey(i,c);!a.has(u)&&!this.isAbsentEdge(t,i,c)&&o.push(l)}}let r=new Map;for(let h of o)r.set(`${h.type},${h.r},${h.c}`,h);return Array.from(r.values())}setEdgeHexagon(t,e,n){e.x===n.x?t.vEdges[Math.min(e.y,n.y)][e.x].type=3:t.hEdges[e.y][Math.min(e.x,n.x)].type=3}hasIncidentHexagonEdge(t,e){return e.x>0&&t.hEdges[e.y][e.x-1].type===3||e.x<t.cols&&t.hEdges[e.y][e.x].type===3||e.y>0&&t.vEdges[e.y-1][e.x].type===3||e.y<t.rows&&t.vEdges[e.y][e.x].type===3}isEdgeAdjacentToHexagonNode(t,e){return e.type==="h"?t.nodes[e.r][e.c].type===3||t.nodes[e.r][e.c+1].type===3:t.nodes[e.r][e.c].type===3||t.nodes[e.r+1][e.c].type===3}checkAllRequestedConstraintsPresent(t,e){let n=e.useHexagons??!0,s=e.useSquares??!0,a=e.useStars??!0,o=e.useTetris??!1,r=e.useEraser??!1;if(e.useBrokenEdges??!1){let f=!1;for(let l=0;l<=t.rows;l++)for(let i=0;i<t.cols;i++)if(t.hEdges[l][i].type===1||t.hEdges[l][i].type===2){f=!0;break}if(!f){for(let l=0;l<t.rows;l++)for(let i=0;i<=t.cols;i++)if(t.vEdges[l][i].type===1||t.vEdges[l][i].type===2){f=!0;break}}if(!f)return!1}if(n){let f=!1;for(let l=0;l<=t.rows;l++)for(let i=0;i<t.cols;i++)if(t.hEdges[l][i].type===3){f=!0;break}if(!f){for(let l=0;l<t.rows;l++)for(let i=0;i<=t.cols;i++)if(t.vEdges[l][i].type===3){f=!0;break}}if(!f){for(let l=0;l<=t.rows;l++)for(let i=0;i<=t.cols;i++)if(t.nodes[l][i].type===3){f=!0;break}}if(!f)return!1}if(s||a||o||r){let f=!1,l=!1,i=!1,c=!1,u=new Set;for(let d=0;d<t.rows;d++)for(let y=0;y<t.cols;y++){let p=t.cells[d][y].type;p===1&&(f=!0,u.add(t.cells[d][y].color)),p===2&&(l=!0),(p===3||p===4)&&(i=!0),p===5&&(c=!0)}if(s&&!f||a&&!l||o&&!i||r&&!c||s&&f&&!l&&u.size<2)return!1}return!this.hasIsolatedMark(t)}generateTiling(t,e,n){let s=Math.min(...t.map(i=>i.x)),a=Math.min(...t.map(i=>i.y)),o=Math.max(...t.map(i=>i.x)),r=Math.max(...t.map(i=>i.y)),h=o-s+1,f=r-a+1,l=Array.from({length:f},()=>Array(h).fill(!1));for(let i of t)l[i.y-a][i.x-s]=!0;return this.tilingDfs(l,[],e,n)}tilingDfs(t,e,n,s){let a=-1,o=-1;for(let f=0;f<t.length;f++){for(let l=0;l<t[0].length;l++)if(t[f][l]){a=f,o=l;break}if(a!==-1)break}if(a===-1)return e;if(e.length>=n)return null;let r=s.difficulty??.5,h=[...this.TETRIS_SHAPES];this.shuffleArray(h),r>.6&&h.sort((f,l)=>this.getShapeArea(l)-this.getShapeArea(f));for(let f of h){let l=this.isRotationallyInvariant(f),i=l?[f]:this.getAllRotations(f);this.shuffleArray(i);for(let c of i){let u=[];for(let d=0;d<c.length;d++)for(let y=0;y<c[0].length;y++)c[d][y]&&u.push({r:d,c:y});for(let d of u){let y=a-d.r,p=o-d.c;if(this.canPlace(t,c,y,p)){this.placePiece(t,c,y,p,!1);let x=this.tilingDfs(t,[...e,{shape:c,displayShape:f,isRotated:!l&&Math.random()<.3+r*.6}],n,s);if(x)return x;this.placePiece(t,c,y,p,!0)}}}}return null}getShapeArea(t){let e=0;for(let n of t)for(let s of n)s&&e++;return e}isRotationallyInvariant(t){let e=this.getShapeArea(t);return e===1||e===4&&t.length===2&&t[0].length===2}getAllRotations(t){let e=[],n=new Set,s=t;for(let a=0;a<4;a++){let o=JSON.stringify(s);n.has(o)||(e.push(s),n.add(o)),s=this.rotate90(s)}return e}rotate90(t){let e=t.length,n=t[0].length,s=Array.from({length:n},()=>Array(e).fill(0));for(let a=0;a<e;a++)for(let o=0;o<n;o++)s[o][e-1-a]=t[a][o];return s}canPlace(t,e,n,s){for(let a=0;a<e.length;a++)for(let o=0;o<e[0].length;o++)if(e[a][o]){let r=n+a,h=s+o;if(r<0||r>=t.length||h<0||h>=t[0].length||!t[r][h])return!1}return!0}placePiece(t,e,n,s,a){for(let o=0;o<e.length;o++)for(let r=0;r<e[0].length;r++)e[o][r]&&(t[n+o][s+r]=a)}shuffleArray(t){for(let e=t.length-1;e>0;e--){let n=Math.floor(Math.random()*(e+1));[t[e],t[n]]=[t[n],t[e]]}}};var et=class{bytes=[];cur=0;bit=0;write(t,e){for(let n=0;n<e;n++)t&1<<n&&(this.cur|=1<<this.bit),this.bit++,this.bit===8&&(this.bytes.push(this.cur),this.cur=0,this.bit=0)}finish(){return this.bit>0&&this.bytes.push(this.cur),new Uint8Array(this.bytes)}},st=class{constructor(t){this.buf=t}i=0;bit=0;read(t){let e=0;for(let n=0;n<t;n++)this.buf[this.i]&1<<this.bit&&(e|=1<<n),this.bit++,this.bit===8&&(this.bit=0,this.i++);return e}};function ht(X){let t=new Map;for(let e of X)for(let n of e)if(n.shape){let s=JSON.stringify(n.shape);t.has(s)||t.set(s,n.shape)}return[...t.values()]}var nt=class{static async serialize(t,e){let n=new et;n.write(t.rows,6),n.write(t.cols,6),n.write(t.symmetry??0,2);let s=ht(t.cells);n.write(s.length,5);for(let l of s){n.write(l.length,4),n.write(l[0].length,4);for(let i of l)for(let c of i)n.write(c,1)}let a=new Map;s.forEach((l,i)=>a.set(JSON.stringify(l),i));for(let l of t.cells)for(let i of l)n.write(i.type,3),n.write(i.color,3),i.shape?(n.write(1,1),n.write(a.get(JSON.stringify(i.shape)),5)):n.write(0,1);for(let l=0;l<t.rows;l++)for(let i=0;i<t.cols+1;i++)n.write(t.vEdges[l][i].type,2);for(let l=0;l<t.rows+1;l++)for(let i=0;i<t.cols;i++)n.write(t.hEdges[l][i].type,2);for(let l=0;l<t.rows+1;l++)for(let i=0;i<t.cols+1;i++)n.write(t.nodes[l][i].type,2);n.write(+!!e.useHexagons,1),n.write(+!!e.useSquares,1),n.write(+!!e.useStars,1),n.write(+!!e.useTetris,1),n.write(+!!e.useEraser,1),n.write(+!!e.useBrokenEdges,1),n.write(e.symmetry??0,2),n.write(Math.round((e.complexity??0)*254),8),n.write(Math.round((e.difficulty??0)*254),8),n.write(Math.round((e.pathLength??0)*254),8);let o=n.finish(),r=new Uint8Array(await new Response(new Blob([o.buffer]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()),h=0;for(let l of r)h^=l;let f=new Uint8Array(r.length+1);return f.set(r),f[r.length]=h,btoa(String.fromCharCode(...f)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}static async deserialize(t){let e=t.replace(/-/g,"+").replace(/_/g,"/");for(;e.length%4;)e+="=";let n=atob(e),s=Uint8Array.from(n,C=>C.charCodeAt(0)),a=0;for(let C=0;C<s.length-1;C++)a^=s[C];if(a!==s.at(-1))throw new Error("Invalid parity data");let o=new Uint8Array(await new Response(new Blob([s.slice(0,-1).buffer]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer()),r=new st(o),h=r.read(6),f=r.read(6),l=r.read(2),i=r.read(5),c=[];for(let C=0;C<i;C++){let S=r.read(4),k=r.read(4),A=[];for(let E=0;E<S;E++){let T=[];for(let W=0;W<k;W++)T.push(r.read(1));A.push(T)}c.push(A)}let u=[];for(let C=0;C<h;C++){let S=[];for(let k=0;k<f;k++){let A=r.read(3),E=r.read(3),T=r.read(1),W={type:A,color:E};T&&(W.shape=c[r.read(5)].map(q=>q.slice())),S.push(W)}u.push(S)}let d=Array.from({length:h},()=>Array.from({length:f+1},()=>({type:r.read(2)}))),y=Array.from({length:h+1},()=>Array.from({length:f},()=>({type:r.read(2)}))),p=Array.from({length:h+1},()=>Array.from({length:f+1},()=>({type:r.read(2)}))),x=()=>{let C=r.read(8);return Math.round(C/254*1e3)/1e3},g={},b=!!r.read(1),m=!!r.read(1),v=!!r.read(1),P=!!r.read(1),M=!!r.read(1),w=!!r.read(1),H=r.read(2);b&&(g.useHexagons=!0),m&&(g.useSquares=!0),v&&(g.useStars=!0),P&&(g.useTetris=!0),M&&(g.useEraser=!0),w&&(g.useBrokenEdges=!0),g.symmetry=H;let V=x(),I=x(),D=x();return V!==0&&(g.complexity=V),I!==0&&(g.difficulty=I),D!==0&&(g.pathLength=D),{puzzle:{rows:h,cols:f,cells:u,vEdges:d,hEdges:y,nodes:p,symmetry:l},options:g}}};var ot=class{canvas;ctx;puzzle=null;options;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;invalidatedCells=[];invalidatedEdges=[];invalidatedNodes=[];errorCells=[];errorEdges=[];errorNodes=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;canvasRect=null;constructor(t,e,n={}){if(typeof t=="string"){if(typeof document>"u")throw new Error("Cannot look up canvas by ID in a non-browser environment.");let a=document.getElementById(t);if(!(a instanceof HTMLCanvasElement))throw new Error(`Element with id "${t}" is not a canvas.`);this.canvas=a}else this.canvas=t;let s=this.canvas.getContext("2d");if(!s)throw new Error("Could not get 2D context.");this.ctx=s,this.ctx.imageSmoothingEnabled=!1,this.options=this.mergeOptions(n),e&&this.setPuzzle(e),this.initEvents(),this.animate()}mergeOptions(t){let e={blinkDuration:t.animations?.blinkDuration??this.options?.animations?.blinkDuration??1e3,fadeDuration:t.animations?.fadeDuration??this.options?.animations?.fadeDuration??1e3,blinkPeriod:t.animations?.blinkPeriod??this.options?.animations?.blinkPeriod??800},n={path:t.colors?.path??this.options?.colors?.path??"#ffcc00",error:t.colors?.error??this.options?.colors?.error??"#ff4444",success:t.colors?.success??this.options?.colors?.success??"#ffcc00",symmetry:t.colors?.symmetry??this.options?.colors?.symmetry??"rgba(255, 255, 255, 0.5)",interrupted:t.colors?.interrupted??this.options?.colors?.interrupted??"#ffcc00",grid:t.colors?.grid??this.options?.colors?.grid??"#555",node:t.colors?.node??this.options?.colors?.node??"#555",hexagon:t.colors?.hexagon??this.options?.colors?.hexagon??"#000",colorMap:t.colors?.colorMap??this.options?.colors?.colorMap??{[$.Black]:"#000",[$.White]:"#fff",[$.Red]:"#f00",[$.Blue]:"#00f",[$.None]:"#ffcc00"},colorList:t.colors?.colorList??this.options?.colors?.colorList};return{gridPadding:t.gridPadding??this.options?.gridPadding??60,cellSize:t.cellSize??this.options?.cellSize??80,nodeRadius:t.nodeRadius??this.options?.nodeRadius??6,startNodeRadius:t.startNodeRadius??this.options?.startNodeRadius??22,pathWidth:t.pathWidth??this.options?.pathWidth??18,exitLength:t.exitLength??this.options?.exitLength??25,autoResize:t.autoResize??this.options?.autoResize??!0,animations:e,colors:n,onPathComplete:t.onPathComplete??this.options?.onPathComplete??(()=>{})}}setPuzzle(t){this.puzzle=t,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw()}setOptions(t){this.options=this.mergeOptions({...this.options,...t}),this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}setValidationResult(t,e=[],n=[],s=[],a=[],o=[],r=[]){this.invalidatedCells=e,this.invalidatedEdges=n,this.invalidatedNodes=o,this.errorCells=s,this.errorEdges=a,this.errorNodes=r,this.eraserAnimationStartTime=Date.now(),t?(this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0}resizeCanvas(){!this.puzzle||!this.canvas||(this.canvas.width=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,this.canvas.height=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2)}setCanvasRect(t){this.canvasRect=t}initEvents(){typeof window>"u"||!(this.canvas instanceof HTMLCanvasElement)||(this.canvas.addEventListener("mousedown",t=>this.handleStart(t)),window.addEventListener("mousemove",t=>this.handleMove(t)),window.addEventListener("mouseup",t=>this.handleEnd(t)),this.canvas.addEventListener("touchstart",t=>{this.handleStart(t.touches[0])&&t.preventDefault()},{passive:!1}),window.addEventListener("touchmove",t=>{this.isDrawing&&t.preventDefault(),this.handleMove(t.touches[0])},{passive:!1}),window.addEventListener("touchend",t=>{this.isDrawing&&t.preventDefault(),this.handleEnd(t.changedTouches[0])},{passive:!1}))}getCanvasCoords(t,e){return{x:this.options.gridPadding+t*this.options.cellSize,y:this.options.gridPadding+e*this.options.cellSize}}getExitDir(t,e){return!this.puzzle||this.puzzle.nodes[e]?.[t]?.type!==2?null:t===this.puzzle.cols?{x:1,y:0}:t===0?{x:-1,y:0}:e===0?{x:0,y:-1}:e===this.puzzle.rows?{x:0,y:1}:{x:1,y:0}}handleStart(t){if(!this.puzzle)return!1;let e=this.canvasRect||(this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),n=(t.clientX-e.left)*(this.canvas.width/e.width),s=(t.clientY-e.top)*(this.canvas.height/e.height);for(let a=0;a<=this.puzzle.rows;a++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[a][o].type===1){let r=this.getCanvasCoords(o,a);if(Math.hypot(r.x-n,r.y-s)<this.options.startNodeRadius)return this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.isDrawing=!0,this.path=[{x:o,y:a}],this.currentMousePos=r,this.exitTipPos=null,this.draw(),!0}return!1}handleMove(t){if(!this.puzzle||!this.isDrawing)return;let e=this.canvasRect||(this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),n=(t.clientX-e.left)*(this.canvas.width/e.width),s=(t.clientY-e.top)*(this.canvas.height/e.height),a=this.path[this.path.length-1],o=this.getCanvasCoords(a.x,a.y),r=n-o.x,h=s-o.y,f=this.puzzle.symmetry||0,l=this.getExitDir(a.x,a.y),i=Math.abs(r)>Math.abs(h)?{x:r>0?1:-1,y:0}:{x:0,y:h>0?1:-1};if(l&&i.x===l.x&&i.y===l.y){let y=r*l.x+h*l.y,p=Math.max(0,Math.min(y,this.options.exitLength));this.currentMousePos={x:o.x+l.x*p,y:o.y+l.y*p},this.draw();return}let c=(y,p)=>{let x=this.getEdgeType(a,y);if(y.x<0||y.x>this.puzzle.cols||y.y<0||y.y>this.puzzle.rows||x===2){this.currentMousePos=o;return}let g=x===1?this.options.cellSize*.35:this.options.cellSize,b=this.getEdgeKey(a,y);if(!(this.path.length>=2&&y.x===this.path[this.path.length-2].x&&y.y===this.path[this.path.length-2].y)){for(let P=0;P<this.path.length-1;P++)if(this.getEdgeKey(this.path[P],this.path[P+1])===b){g=0;break}}if(this.path.some(P=>P.x===y.x&&P.y===y.y)&&this.path.length>=2){let P=this.path[this.path.length-2];(y.x!==P.x||y.y!==P.y)&&(g=Math.min(g,this.options.cellSize*.5-this.options.pathWidth*.5))}if(f!==0){let P=this.getSymmetricalPoint(a),M=this.getSymmetricalPoint(y),w=this.getEdgeType(P,M),H=this.getSymmetryPath(this.path),V=this.getEdgeKey(P,M);if(M.x<0||M.x>this.puzzle.cols||M.y<0||M.y>this.puzzle.rows||w===2){this.currentMousePos=o;return}w===1&&(g=Math.min(g,this.options.cellSize*.35));let I=H.some(E=>E.x===y.x&&E.y===y.y),D=this.path.some(E=>E.x===M.x&&E.y===M.y),C=y.x===M.x&&y.y===M.y,S=H.some((E,T)=>T<H.length-1&&this.getEdgeKey(H[T],H[T+1])===b),k=this.path.some((E,T)=>T<this.path.length-1&&this.getEdgeKey(this.path[T],this.path[T+1])===V);(I||D||C||S||k||b===V)&&(g=Math.min(g,this.options.cellSize*.5-this.options.pathWidth*.5))}y.x!==a.x?this.currentMousePos={x:o.x+Math.max(-g,Math.min(g,p)),y:o.y}:this.currentMousePos={x:o.x,y:o.y+Math.max(-g,Math.min(g,p))}};if(Math.abs(r)>Math.abs(h)){let y=r>0?1:-1;c({x:a.x+y,y:a.y},r)}else{let y=h>0?1:-1;c({x:a.x,y:a.y+y},h)}let u=[{x:a.x+1,y:a.y},{x:a.x-1,y:a.y},{x:a.x,y:a.y+1},{x:a.x,y:a.y-1}],d=this.getSymmetryPath(this.path);for(let y of u)if(y.x>=0&&y.x<=this.puzzle.cols&&y.y>=0&&y.y<=this.puzzle.rows){let p=this.getCanvasCoords(y.x,y.y);if(Math.hypot(p.x-this.currentMousePos.x,p.y-this.currentMousePos.y)<this.options.cellSize*.3){let g=this.path.findIndex(b=>b.x===y.x&&b.y===y.y);if(g===-1){if(f!==0){let b=this.getSymmetricalPoint(y);if(y.x===b.x&&y.y===b.y||this.path.some(P=>P.x===b.x&&P.y===b.y)||d.some(P=>P.x===y.x&&P.y===y.y))continue;let m=this.getEdgeKey(a,y),v=this.getEdgeKey(this.getSymmetricalPoint(a),b);if(m===v)continue}this.path.push(y)}else g===this.path.length-2&&this.path.pop()}}this.draw()}handleEnd(t){if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let e=this.path[this.path.length-1],n=this.getCanvasCoords(e.x,e.y),s=this.getExitDir(e.x,e.y);if(s){let a=this.currentMousePos.x-n.x,o=this.currentMousePos.y-n.y;if(a*s.x+o*s.y>0){this.exitTipPos={x:n.x+s.x*this.options.exitLength,y:n.y+s.y*this.options.exitLength},this.options.onPathComplete(this.path);return}}this.exitTipPos=s?{...this.currentMousePos}:null,this.startFade(this.options.colors.interrupted)}getEdgeType(t,e){if(!this.puzzle)return 2;if(t.x===e.x){let n=Math.min(t.y,e.y);return n<0||n>=this.puzzle.rows?2:this.puzzle.vEdges[n][t.x].type}else{let n=Math.min(t.x,e.x);return n<0||n>=this.puzzle.cols?2:this.puzzle.hEdges[t.y][n].type}}startFade(t="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=t,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){if(typeof requestAnimationFrame>"u"){this.draw();return}if(this.draw(),this.isFading){let t=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=t,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0)}requestAnimationFrame(()=>this.animate())}draw(){if(!this.puzzle||!this.ctx)return;let t=this.ctx,e=Date.now();if(t.globalAlpha=1,t.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(t),this.drawConstraints(t),this.drawNodes(t),this.path.length===0&&!this.isDrawing&&this.drawRipples(t),this.isFading){if(this.drawPath(t,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let n=this.getSymmetryPath(this.fadingPath),s=this.options.colors.symmetry,a=null;if(this.fadingTipPos){let o=(this.fadingTipPos.x-this.options.gridPadding)/this.options.cellSize,r=(this.fadingTipPos.y-this.options.gridPadding)/this.options.cellSize,h=this.getSymmetricalPoint({x:o,y:r});a={x:h.x*this.options.cellSize+this.options.gridPadding,y:h.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(t,n,!1,s,this.fadeOpacity,a)}}else if(this.path.length>0){let n=this.options.colors.path,s=this.colorToRgba(n).a,a=this.options.colors.error,o=this.isInvalidPath?this.setAlpha(a,s):n;if(this.isSuccessFading&&!this.puzzle.symmetry&&(o=this.setAlpha(this.options.colors.success,s)),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let r=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),h=this.options.animations.blinkDuration;if(r<h)if(this.isSuccessFading)(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&(o=this.options.colors.error);else{let f=Math.min(1,r/200),l=r>h*.8?(h-r)/(h*.2):1,i=Math.min(f,l),c=(Math.sin(e*Math.PI*2/this.options.animations.blinkPeriod)+1)/2,u=this.setAlpha(a,s);o=this.lerpColor(n,u,c*i)}}if(this.drawPath(t,this.path,this.isDrawing,o,1,this.isDrawing?this.currentMousePos:this.exitTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let r=this.getSymmetryPath(this.path),h=this.options.colors.symmetry,f=this.colorToRgba(h).a,l=h;if(this.isInvalidPath&&(l=this.setAlpha(a,f)),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let c=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),u=this.options.animations.blinkDuration;if(c<u)if(this.isSuccessFading)(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&(l=this.options.colors.error);else{let d=Math.min(1,c/200),y=c>u*.8?(u-c)/(u*.2):1,p=Math.min(d,y),x=(Math.sin(e*Math.PI*2/this.options.animations.blinkPeriod)+1)/2,g=this.setAlpha(a,f);l=this.lerpColor(h,g,x*p)}}let i=null;if(this.isDrawing||this.exitTipPos){let c=this.isDrawing?this.currentMousePos:this.exitTipPos,u=(c.x-this.options.gridPadding)/this.options.cellSize,d=(c.y-this.options.gridPadding)/this.options.cellSize,y=this.getSymmetricalPoint({x:u,y:d},!0);i={x:y.x*this.options.cellSize+this.options.gridPadding,y:y.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(t,r,this.isDrawing,l,1,i)}}}drawRipples(t){if(!this.puzzle)return;let e=(Date.now()-this.startTime)/500;for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)if(this.puzzle.nodes[n][s].type===2){let o=this.getCanvasCoords(s,n),r=this.getExitDir(s,n);if(!r)continue;let h={x:o.x+r.x*this.options.exitLength,y:o.y+r.y*this.options.exitLength},f=e%4,l=f*5,i=Math.max(0,1-f/3);t.beginPath(),t.arc(h.x,h.y,l,0,Math.PI*2),t.strokeStyle=`rgba(170, 170, 170, ${i*.4})`,t.lineWidth=2,t.stroke()}}drawGrid(t){if(!this.puzzle||!this.options.colors.grid)return;t.strokeStyle=this.options.colors.grid,t.lineWidth=12,t.lineCap="round";let e=(n,s,a)=>{if(a!==2)if(a===1){let r={x:n.x+(s.x-n.x)*.35,y:n.y+(s.y-n.y)*.35},h={x:n.x+(s.x-n.x)*(.5+.15),y:n.y+(s.y-n.y)*(.5+.15)};t.beginPath(),t.moveTo(n.x,n.y),t.lineTo(r.x,r.y),t.stroke(),t.beginPath(),t.moveTo(h.x,h.y),t.lineTo(s.x,s.y),t.stroke()}else t.beginPath(),t.moveTo(n.x,n.y),t.lineTo(s.x,s.y),t.stroke()};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<this.puzzle.cols;s++)e(this.getCanvasCoords(s,n),this.getCanvasCoords(s+1,n),this.puzzle.hEdges[n][s].type);for(let n=0;n<this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)e(this.getCanvasCoords(s,n),this.getCanvasCoords(s,n+1),this.puzzle.vEdges[n][s].type)}drawConstraints(t){if(!this.puzzle)return;let e=Date.now(),n=(Math.sin(e*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;for(let a=0;a<this.puzzle.rows;a++)for(let o=0;o<this.puzzle.cols;o++){let r=this.puzzle.cells[a][o],h=this.getCanvasCoords(o+.5,a+.5),f=this.invalidatedCells.some(y=>y.x===o&&y.y===a),l=this.errorCells.some(y=>y.x===o&&y.y===a),i=1,c,u=this.getColorCode(r.color),d=this.options.colors.error;if(l&&(c=this.lerpColor(u,d,n)),f){let y=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),p=this.options.animations.blinkDuration;if(this.isFading)i=this.fadeOpacity;else if(y<p){let x=Math.min(1,y/200),g=y>p*.8?(p-y)/(p*.2):1,b=Math.min(x,g);c=this.lerpColor(u,d,n*b)}else i=Math.max(.3,1-(y-p)/this.options.animations.fadeDuration)}if(i<1||c){let{canvas:y,ctx:p}=this.prepareOffscreen();this.drawConstraintItem(p,r,h,c),t.save(),t.globalAlpha=i,t.drawImage(y,0,0),t.restore()}else this.drawConstraintItem(t,r,h)}t.lineWidth=2;let s=8;for(let a=0;a<=this.puzzle.rows;a++)for(let o=0;o<this.puzzle.cols;o++)if(this.puzzle.hEdges[a][o].type===3){let r=this.getCanvasCoords(o+.5,a);t.save();let h=this.invalidatedEdges.some(l=>l.type==="h"&&l.r===a&&l.c===o);if(this.errorEdges.some(l=>l.type==="h"&&l.r===a&&l.c===o)){let l=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(t,r.x,r.y,s,l)}else if(h){let l=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),i=this.options.animations.blinkDuration;if(this.isFading)t.globalAlpha*=this.fadeOpacity;else if(l<i){let c=Math.min(1,l/200),u=l>i*.8?(i-l)/(i*.2):1,d=Math.min(c,u),y=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*d);this.drawHexagon(t,r.x,r.y,s,y)}else t.globalAlpha*=Math.max(.3,1-(l-i)/this.options.animations.fadeDuration),this.drawHexagon(t,r.x,r.y,s)}else this.drawHexagon(t,r.x,r.y,s);t.restore()}for(let a=0;a<this.puzzle.rows;a++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.vEdges[a][o].type===3){let r=this.getCanvasCoords(o,a+.5);t.save();let h=this.invalidatedEdges.some(l=>l.type==="v"&&l.r===a&&l.c===o);if(this.errorEdges.some(l=>l.type==="v"&&l.r===a&&l.c===o)){let l=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(t,r.x,r.y,s,l)}else if(h){let l=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),i=this.options.animations.blinkDuration;if(this.isFading)t.globalAlpha*=this.fadeOpacity;else if(l<i){let c=Math.min(1,l/200),u=l>i*.8?(i-l)/(i*.2):1,d=Math.min(c,u),y=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*d);this.drawHexagon(t,r.x,r.y,s,y)}else t.globalAlpha*=Math.max(.3,1-(l-i)/this.options.animations.fadeDuration),this.drawHexagon(t,r.x,r.y,s)}else this.drawHexagon(t,r.x,r.y,s);t.restore()}for(let a=0;a<=this.puzzle.rows;a++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[a][o].type===3){let r=this.getCanvasCoords(o,a);t.save();let h=this.invalidatedNodes.some(l=>l.x===o&&l.y===a);if(this.errorNodes.some(l=>l.x===o&&l.y===a)){let l=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(t,r.x,r.y,s,l)}else if(h){let l=e-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),i=this.options.animations.blinkDuration;if(this.isFading)t.globalAlpha*=this.fadeOpacity;else if(l<i){let c=Math.min(1,l/200),u=l>i*.8?(i-l)/(i*.2):1,d=Math.min(c,u),y=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*d);this.drawHexagon(t,r.x,r.y,s,y)}else t.globalAlpha*=Math.max(.3,1-(l-i)/this.options.animations.fadeDuration),this.drawHexagon(t,r.x,r.y,s)}else this.drawHexagon(t,r.x,r.y,s);t.restore()}}drawConstraintItem(t,e,n,s){e.type===1?(t.fillStyle=s||this.getColorCode(e.color),this.drawRoundedRect(t,n.x-26/2,n.y-26/2,26,26,8)):e.type===2?this.drawStar(t,n.x,n.y,12,16,8,e.color,s):e.type===3||e.type===4?this.drawTetris(t,n.x,n.y,e.shape||[],e.type===4,e.color,s):e.type===5&&this.drawEraser(t,n.x,n.y,14,3,e.color,s)}drawNodes(t){if(!this.puzzle)return;let e=(n,s)=>{let a=[];return n>0&&a.push(this.puzzle.hEdges[s][n-1].type),n<this.puzzle.cols&&a.push(this.puzzle.hEdges[s][n].type),s>0&&a.push(this.puzzle.vEdges[s-1][n].type),s<this.puzzle.rows&&a.push(this.puzzle.vEdges[s][n].type),a.length>0&&a.every(o=>o===2)};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++){if(e(s,n))continue;let a=this.puzzle.nodes[n][s];if(a.type===3)continue;let o=this.getCanvasCoords(s,n);if(a.type===1)this.options.colors.node&&(t.fillStyle=this.options.colors.node),t.beginPath(),t.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),t.fill();else if(a.type===2){let r=this.getExitDir(s,n);if(!r)continue;this.options.colors.node&&(t.strokeStyle=this.options.colors.node),t.lineWidth=12,t.lineCap="round",t.beginPath(),t.moveTo(o.x,o.y),t.lineTo(o.x+r.x*this.options.exitLength,o.y+r.y*this.options.exitLength),t.stroke()}else this.options.colors.node&&(t.fillStyle=this.options.colors.node),t.beginPath(),t.arc(o.x,o.y,this.options.nodeRadius,0,Math.PI*2),t.fill()}}drawPath(t,e,n,s,a,o=null){if(e.length===0||!s||s==="transparent")return;let r=this.colorToRgba(s),h=`rgb(${r.r},${r.g},${r.b})`,f=a*r.a,{canvas:l,ctx:i}=this.prepareOffscreen();this.drawPathInternal(i,e,n,h,o),t.save(),t.globalAlpha=f,t.drawImage(l,0,0),t.restore()}drawPathInternal(t,e,n,s,a=null){t.save(),t.strokeStyle=s,t.fillStyle=s,t.lineWidth=this.options.pathWidth,t.lineCap="round",t.lineJoin="round",t.beginPath();let o=this.getCanvasCoords(e[0].x,e[0].y);t.moveTo(o.x,o.y);for(let h=1;h<e.length;h++){let f=this.getCanvasCoords(e[h].x,e[h].y);t.lineTo(f.x,f.y)}let r=a||this.currentMousePos;(n||a)&&t.lineTo(r.x,r.y),t.stroke(),t.beginPath(),t.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),t.fill(),(n||a)&&(t.beginPath(),t.arc(r.x,r.y,this.options.pathWidth/2,0,Math.PI*2),t.fill()),t.restore()}drawRoundedRect(t,e,n,s,a,o){t.beginPath(),t.moveTo(e+o,n),t.lineTo(e+s-o,n),t.quadraticCurveTo(e+s,n,e+s,n+o),t.lineTo(e+s,n+a-o),t.quadraticCurveTo(e+s,n+a,e+s-o,n+a),t.lineTo(e+o,n+a),t.quadraticCurveTo(e,n+a,e,n+a-o),t.lineTo(e,n+o),t.quadraticCurveTo(e,n,e+o,n),t.closePath(),t.fill()}drawHexagon(t,e,n,s,a){if(!(!this.options.colors.hexagon&&!a)){t.fillStyle=a||this.options.colors.hexagon,t.beginPath();for(let o=0;o<6;o++){let r=Math.PI/3*o,h=e+s*Math.cos(r),f=n+s*Math.sin(r);o===0?t.moveTo(h,f):t.lineTo(h,f)}t.closePath(),t.fill()}}drawEraser(t,e,n,s,a,o,r){t.strokeStyle=r||this.getColorCode(o),t.lineWidth=s*.5,t.lineCap="butt";let h=.5;t.beginPath();for(let f=0;f<a;f++){let l=Math.PI*2/a*f+h,i=e+s*Math.cos(l),c=n+s*Math.sin(l);t.moveTo(e,n),t.lineTo(i,c)}t.stroke()}drawStar(t,e,n,s,a,o,r,h){t.fillStyle=h||this.getColorCode(r),t.beginPath();for(let f=0;f<o*2;f++){let l=f%2===0?a:s,i=Math.PI/o*f,c=e+l*Math.cos(i),u=n+l*Math.sin(i);f===0?t.moveTo(c,u):t.lineTo(c,u)}t.closePath(),t.fill()}drawTetris(t,e,n,s,a,o,r){if(!s||s.length===0)return;let h=12,f=2,l=s[0].length*h+(s[0].length-1)*f,i=s.length*h+(s.length-1)*f;t.save(),t.translate(e,n),a&&t.rotate(Math.PI/8),t.fillStyle=r||this.getColorCode(o,"#ffcc00");for(let c=0;c<s.length;c++)for(let u=0;u<s[c].length;u++)if(s[c][u]){let d=u*(h+f)-l/2,y=c*(h+f)-i/2;t.fillRect(d,y,h,h)}t.restore()}getColorCode(t,e="#666"){return this.options.colors.colorList&&this.options.colors.colorList[t]!==void 0?this.options.colors.colorList[t]:this.options.colors.colorMap&&this.options.colors.colorMap[t]!==void 0?this.options.colors.colorMap[t]:e}colorToRgba(t){if(!t||t==="transparent")return{r:0,g:0,b:0,a:0};if(t.startsWith("rgba")||t.startsWith("rgb")){let n=t.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);if(n)return{r:parseInt(n[1]),g:parseInt(n[2]),b:parseInt(n[3]),a:n[4]?parseFloat(n[4]):1}}let e=t.startsWith("#")?t.slice(1):t;if((e.length===3||e.length===4)&&(e=e.split("").map(n=>n+n).join("")),e.length===6){let n=parseInt(e,16);return{r:n>>16&255,g:n>>8&255,b:n&255,a:1}}else if(e.length===8){let n=parseInt(e,16);return{r:n>>24&255,g:n>>16&255,b:n>>8&255,a:(n&255)/255}}return{r:0,g:0,b:0,a:1}}lerpColor(t,e,n){try{let s=this.colorToRgba(t),a=this.colorToRgba(e),o=Math.round(s.r+(a.r-s.r)*n),r=Math.round(s.g+(a.g-s.g)*n),h=Math.round(s.b+(a.b-s.b)*n),f=s.a+(a.a-s.a)*n;return`rgba(${o},${r},${h},${f})`}catch{return t}}setAlpha(t,e){let n=this.colorToRgba(t);return`rgba(${n.r},${n.g},${n.b},${e})`}getSymmetryPath(t){return!this.puzzle||!this.puzzle.symmetry?[]:t.map(e=>this.getSymmetricalPoint(e))}getSymmetricalPoint(t,e=!1){if(!this.puzzle||!this.puzzle.symmetry)return{...t};let{cols:n,rows:s,symmetry:a}=this.puzzle;return a===1?{x:n-t.x,y:t.y}:a===2?{x:t.x,y:s-t.y}:a===3?{x:n-t.x,y:s-t.y}:{...t}}getEdgeKey(t,e){return t.x<e.x||t.x===e.x&&t.y<e.y?`${t.x},${t.y}-${e.x},${e.y}`:`${e.x},${e.y}-${t.x},${t.y}`}prepareOffscreen(){if(!this.offscreenCanvas){if(typeof document<"u")this.offscreenCanvas=document.createElement("canvas");else if(typeof OffscreenCanvas<"u")this.offscreenCanvas=new OffscreenCanvas(this.canvas.width,this.canvas.height);else throw new Error("Offscreen canvas not supported in this environment.");this.offscreenCtx=this.offscreenCanvas.getContext("2d")}if((this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),!this.offscreenCtx)throw new Error("Could not get offscreen 2D context.");return this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx}}};var rt=class{generator;validator;constructor(){this.generator=new Z,this.validator=new Y}createPuzzle(t,e,n={}){return this.generator.generate(t,e,n).export()}validateSolution(t,e){let n=U.fromData(t);return this.validator.validate(n,e)}calculateDifficulty(t){let e=U.fromData(t);return this.validator.calculateDifficulty(e)}};export{j as CellType,$ as Color,lt as Direction,_ as EdgeType,U as Grid,Q as NodeType,Z as PuzzleGenerator,nt as PuzzleSerializer,Y as PuzzleValidator,tt as SymmetryType,rt as WitnessCore,ot as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
