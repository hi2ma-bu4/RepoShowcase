/*!
 * MiniWitness 1.2.5
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var ce=(s=>(s[s.Up=0]="Up",s[s.Right=1]="Right",s[s.Down=2]="Down",s[s.Left=3]="Left",s))(ce||{}),j=(u=>(u[u.None=0]="None",u[u.Square=1]="Square",u[u.Star=2]="Star",u[u.Tetris=3]="Tetris",u[u.TetrisRotated=4]="TetrisRotated",u[u.Eraser=5]="Eraser",u[u.TetrisNegative=6]="TetrisNegative",u[u.TetrisNegativeRotated=7]="TetrisNegativeRotated",u))(j||{}),Z=(o=>(o[o.Normal=0]="Normal",o[o.Broken=1]="Broken",o[o.Absent=2]="Absent",o[o.Hexagon=3]="Hexagon",o[o.HexagonMain=4]="HexagonMain",o[o.HexagonSymmetry=5]="HexagonSymmetry",o))(Z||{}),ee=(o=>(o[o.Normal=0]="Normal",o[o.Start=1]="Start",o[o.End=2]="End",o[o.Hexagon=3]="Hexagon",o[o.HexagonMain=4]="HexagonMain",o[o.HexagonSymmetry=5]="HexagonSymmetry",o))(ee||{}),ne=(s=>(s[s.None=0]="None",s[s.Horizontal=1]="Horizontal",s[s.Vertical=2]="Vertical",s[s.Rotational=3]="Rotational",s))(ne||{}),q={None:0,Black:1,White:2,Red:3,Blue:4,Cyan:5};var Y=class J{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];symmetry=0;constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:q.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes,symmetry:this.symmetry}))}static fromData(e){let t=new J(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t.symmetry=e.symmetry||0,t}};var _=class{validate(e,t,n){let s=t.points;if(s.length<2)return{isValid:!1,errorReason:"Path too short"};let h=e.symmetry||0,o=[];if(h!==0)for(let f of s)o.push(this.getSymmetricalPoint(e,f));let i=s[0],u=s[s.length-1];if(e.nodes[i.y][i.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[u.y][u.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};if(h!==0){let f=o[0],d=o[o.length-1];if(e.nodes[f.y][f.x].type!==1)return{isValid:!1,errorReason:"Symmetrical path must start at Start Node"};if(e.nodes[d.y][d.x].type!==2)return{isValid:!1,errorReason:"Symmetrical path must end at End Node"}}let y=new Set,c=new Set;if(y.add(`${i.x},${i.y}`),h!==0){let f=o[0];if(y.has(`${f.x},${f.y}`))return{isValid:!1,errorReason:"Paths collide at start"};y.add(`${f.x},${f.y}`)}for(let f=0;f<s.length-1;f++){let d=s[f],x=s[f+1];if(Math.abs(d.x-x.x)+Math.abs(d.y-x.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let p=`${x.x},${x.y}`;if(y.has(p))return{isValid:!1,errorReason:"Self-intersecting path or path collision"};if(y.add(p),this.isBrokenEdge(e,d,x))return{isValid:!1,errorReason:"Passed through broken edge"};if(c.add(this.getEdgeKey(d,x)),h!==0){let b=o[f],g=o[f+1],C=`${g.x},${g.y}`;if(y.has(C))return{isValid:!1,errorReason:"Path collision"};if(y.add(C),this.isBrokenEdge(e,b,g))return{isValid:!1,errorReason:"Symmetrical path passed through broken edge"};let v=this.getEdgeKey(b,g);if(c.has(v))return{isValid:!1,errorReason:"Paths cross the same edge"};c.add(v)}}let r=this.calculateRegions(e,s,o,n),l=this.getMissedHexagons(e,s,o),a=this.validateWithErasers(e,r,l.edges,l.nodes);return a.regions=r,a}validateFast(e,t,n,s){let h=this.calculateRegions(e,t,n,s),o=this.getMissedHexagons(e,t,n);return this.validateWithErasers(e,h,o.edges,o.nodes)}isBrokenEdge(e,t,n){let s;if(t.x===n.x){let h=Math.min(t.y,n.y);s=e.vEdges[h][t.x].type}else{let h=Math.min(t.x,n.x);s=e.hEdges[t.y][h].type}return s===1||s===2}isAbsentEdge(e,t,n){if(t.x===n.x){let s=Math.min(t.y,n.y);return e.vEdges[s][t.x].type===2}else{let s=Math.min(t.x,n.x);return e.hEdges[t.y][s].type===2}}getMissedHexagons(e,t,n=[]){let s=new Set,h=new Set;for(let c=0;c<t.length;c++)h.add(`${t[c].x},${t[c].y}`),c<t.length-1&&s.add(this.getEdgeKey(t[c],t[c+1]));let o=new Set,i=new Set;for(let c=0;c<n.length;c++)i.add(`${n[c].x},${n[c].y}`),c<n.length-1&&o.add(this.getEdgeKey(n[c],n[c+1]));let u=[];for(let c=0;c<=e.rows;c++)for(let r=0;r<e.cols;r++){let l=e.hEdges[c][r].type;if(l===3||l===4||l===5){let a=this.getEdgeKey({x:r,y:c},{x:r+1,y:c}),f=!1;l===3?f=s.has(a)||o.has(a):l===4?f=s.has(a):l===5&&(f=o.has(a)),f||u.push({type:"h",r:c,c:r})}}for(let c=0;c<e.rows;c++)for(let r=0;r<=e.cols;r++){let l=e.vEdges[c][r].type;if(l===3||l===4||l===5){let a=this.getEdgeKey({x:r,y:c},{x:r,y:c+1}),f=!1;l===3?f=s.has(a)||o.has(a):l===4?f=s.has(a):l===5&&(f=o.has(a)),f||u.push({type:"v",r:c,c:r})}}let y=[];for(let c=0;c<=e.rows;c++)for(let r=0;r<=e.cols;r++){let l=e.nodes[c][r].type;if(l===3||l===4||l===5){let a=`${r},${c}`,f=!1;l===3?f=h.has(a)||i.has(a):l===4?f=h.has(a):l===5&&(f=i.has(a)),f||y.push({x:r,y:c})}}return{edges:u,nodes:y}}validateWithErasers(e,t,n,s){let h=[],o=!0;for(let a=0;a<t.length;a++){let f=t[a],d=f.filter(g=>e.cells[g.y][g.x].type===5),x=f.filter(g=>e.cells[g.y][g.x].type!==0&&e.cells[g.y][g.x].type!==5),m=[];for(let g=0;g<n.length;g++)this.isHexagonAdjacentToRegion(e,n[g],f)&&m.push(g);let p=[];for(let g=0;g<s.length;g++)this.isNodeHexagonAdjacentToRegion(e,s[g],f)&&p.push(g);let b=this.getPossibleErasures(e,f,d,x,m,p);if(b.length===0){o=!1;let g=this.getBestEffortErasures(e,f,d,x,m,p);h.push([g])}else b.sort((g,C)=>{let v=g.invalidatedCells.length+g.invalidatedHexagons.length+g.invalidatedNodeHexagons.length,S=C.invalidatedCells.length+C.invalidatedHexagons.length+C.invalidatedNodeHexagons.length;return v-S}),h.push(b)}if(o){let a=this.findGlobalAssignment(h,n.length,s.length);if(a)return{isValid:!0,invalidatedCells:a.invalidatedCells,invalidatedEdges:a.invalidatedHexIndices.map(f=>n[f]),invalidatedNodes:a.invalidatedNodeHexIndices.map(f=>s[f])}}let i=[],u=[],y=new Set,c=new Set;for(let a of h){let f=a[0];i.push(...f.errorCells),u.push(...f.invalidatedCells);for(let d of f.invalidatedHexagons)y.add(d);for(let d of f.invalidatedNodeHexagons)c.add(d)}let r=[];for(let a=0;a<n.length;a++)y.has(a)||r.push(n[a]);let l=[];for(let a=0;a<s.length;a++)c.has(a)||l.push(s[a]);return{isValid:!1,errorReason:"Constraints failed",errorCells:i,errorEdges:r,errorNodes:l,invalidatedCells:u,invalidatedEdges:Array.from(y).map(a=>n[a]),invalidatedNodes:Array.from(c).map(a=>s[a])}}isHexagonAdjacentToRegion(e,t,n){let s=new Set(n.map(h=>`${h.x},${h.y}`));if(t.type==="h"){if(t.r>0&&s.has(`${t.c},${t.r-1}`)||t.r<e.rows&&s.has(`${t.c},${t.r}`))return!0}else if(t.c>0&&s.has(`${t.c-1},${t.r}`)||t.c<e.cols&&s.has(`${t.c},${t.r}`))return!0;return!1}isNodeHexagonAdjacentToRegion(e,t,n){let s=new Set(n.map(o=>`${o.x},${o.y}`)),h=[{x:t.x-1,y:t.y-1},{x:t.x,y:t.y-1},{x:t.x-1,y:t.y},{x:t.x,y:t.y}];for(let o of h)if(o.x>=0&&o.x<e.cols&&o.y>=0&&o.y<e.rows&&s.has(`${o.x},${o.y}`))return!0;return!1}getPossibleErasures(e,t,n,s,h,o){let i=[],u=n.length;if(u===0)return this.getRegionErrors(e,t,[]).length===0&&h.length===0&&o.length===0&&i.push({invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!0,errorCells:[]}),i;let y=[...s.map(r=>({type:"cell",pos:r})),...h.map(r=>({type:"hex",index:r})),...o.map(r=>({type:"nodeHex",index:r}))],c=this.getRegionErrors(e,t,[]).length===0&&h.length===0&&o.length===0;for(let r=0;r<=u;r++){let l=this.getNCombinations(n,r);for(let a of l){let f=new Set(a.map(x=>`${x.x},${x.y}`)),d=n.filter(x=>!f.has(`${x.x},${x.y}`));for(let x=0;x<=y.length;x++){if(d.length!==r+x)continue;let m=this.getNCombinations(y,x);for(let p of m){let b=p.filter(P=>P.type==="cell").map(P=>P.pos),g=p.filter(P=>P.type==="hex").map(P=>P.index),C=p.filter(P=>P.type==="nodeHex").map(P=>P.index);if(this.getRegionErrors(e,t,[...b,...a]).length===0){let P=!0;if(c)x>0&&(P=!1);else for(let w=0;w<p.length;w++){let T=[...p.slice(0,w),...p.slice(w+1)],z=T.filter(A=>A.type==="cell").map(A=>A.pos),N=new Set(T.filter(A=>A.type==="hex").map(A=>A.index)),$=new Set(T.filter(A=>A.type==="nodeHex").map(A=>A.index)),H=h.every(A=>N.has(A)),O=o.every(A=>$.has(A));if(this.getRegionErrors(e,t,z).length===0&&H&&O){P=!1;break}}P&&i.push({invalidatedCells:[...b,...a],invalidatedHexagons:g,invalidatedNodeHexagons:C,isValid:!0,errorCells:[]})}}}}}return i}getBestEffortErasures(e,t,n,s,h,o){let i=this.getRegionErrors(e,t,[]);if(i.length===0&&h.length===0&&o.length===0)return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:[...n]};if(n.length>0){let c=[...s.map(f=>({type:"cell",pos:f})),...h.map(f=>({type:"hex",index:f})),...o.map(f=>({type:"nodeHex",index:f}))],r=null,l=1/0,a=f=>{let d=[],x=[],m=[],p=0;for(let P of f)p<n.length&&(P.type==="cell"?d.push(P.pos):P.type==="hex"?x.push(P.index):m.push(P.index),p++);let b=n.length-p,g=Math.floor(b/2),C=n.slice(p,p+g);p+=g*2;let v=this.getRegionErrors(e,t,[...d,...C]);for(let P=p;P<n.length;P++)v.push(n[P]);let S=v.length;S<l&&(l=S,r={invalidatedCells:[...d,...C],invalidatedHexagons:x,invalidatedNodeHexagons:m,isValid:!1,errorCells:v})};a([...i.map(f=>({type:"cell",pos:f})),...h.map(f=>({type:"hex",index:f})),...o.map(f=>({type:"nodeHex",index:f}))]),a(c);for(let f of i)a([{type:"cell",pos:f}]);if(r)return r}let y=[...i,...n];return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:y}}getNCombinations(e,t){let n=[],s=(h,o)=>{if(o.length===t){n.push([...o]);return}for(let i=h;i<e.length;i++)o.push(e[i]),s(i+1,o),o.pop()};return s(0,[]),n}checkRegionValid(e,t,n){return this.getRegionErrors(e,t,n).length===0}getRegionErrors(e,t,n){let s=new Set(n.map(l=>`${l.x},${l.y}`)),h=new Map,o=new Map,i=new Set,u=new Set,y=[],c=[];for(let l of t){if(s.has(`${l.x},${l.y}`))continue;let a=e.cells[l.y][l.x];if(a.type===0)continue;let f=a.color;f!==q.None&&(h.set(f,(h.get(f)||0)+1),o.has(f)||o.set(f,[]),o.get(f).push(l)),a.type===1?u.add(f):a.type===2?i.add(f):a.type===3||a.type===4?a.shape&&y.push({shape:a.shape,rotatable:a.type===4,pos:l}):(a.type===6||a.type===7)&&a.shape&&c.push({shape:a.shape,rotatable:a.type===7,pos:l})}let r=[];if(u.size>1)for(let l of t)s.has(`${l.x},${l.y}`)||e.cells[l.y][l.x].type===1&&r.push(l);for(let l of i)if(h.get(l)!==2){let a=o.get(l)||[];for(let f of a)e.cells[f.y][f.x].type===2&&r.push(f)}if((y.length>0||c.length>0)&&!this.checkTetrisConstraint(e,t,y.map(l=>({shape:l.shape,rotatable:l.rotatable})),c.map(l=>({shape:l.shape,rotatable:l.rotatable})))){for(let l of y)r.push(l.pos);for(let l of c)r.push(l.pos)}return r}findGlobalAssignment(e,t,n){let s=e.length,h=new Array(t).fill(0),o=new Array(n).fill(0),i=[],u=[],y=[],c=r=>{if(r===s)return h.every(l=>l===1)&&o.every(l=>l===1);for(let l of e[r]){let a=!0;for(let f of l.invalidatedHexagons)if(h[f]>0){a=!1;break}if(a){for(let f of l.invalidatedNodeHexagons)if(o[f]>0){a=!1;break}}if(a){for(let f of l.invalidatedHexagons)h[f]++,u.push(f);for(let f of l.invalidatedNodeHexagons)o[f]++,y.push(f);if(i.push(...l.invalidatedCells),c(r+1))return!0;for(let f of l.invalidatedHexagons)h[f]--,u.pop();for(let f of l.invalidatedNodeHexagons)o[f]--,y.pop();for(let f=0;f<l.invalidatedCells.length;f++)i.pop()}}return!1};return c(0)?{invalidatedCells:i,invalidatedHexIndices:u,invalidatedNodeHexIndices:y}:null}checkTetrisConstraint(e,t,n,s=[]){let h=n.reduce((m,p)=>m+this.getShapeArea(p.shape),0),o=s.reduce((m,p)=>m+this.getShapeArea(p.shape),0),i=h-o;if(i<0)return!1;if(i===0)return!0;if(i!==t.length)return!1;let u=e.rows,y=e.cols,c=new Int8Array(u*y);for(let m of t)c[m.y*y+m.x]=1;let r=new Int8Array(u*y),l=[...n.map(m=>({shape:m.shape,rotatable:m.rotatable,sign:1,area:this.getShapeArea(m.shape)})),...s.map(m=>({shape:m.shape,rotatable:m.rotatable,sign:-1,area:this.getShapeArea(m.shape)}))],a=o,f=a,d=h,x=m=>{if(m===l.length){for(let g=0;g<c.length;g++)if(r[g]!==c[g])return!1;return!0}let p=l[m];p.sign===-1?f-=p.area:d-=p.area;let b=p.rotatable?this.getAllRotations(p.shape):[p.shape];for(let g of b){let C=g.length,v=g[0].length;for(let S=0;S<=u-C;S++)for(let P=0;P<=y-v;P++){let w=!0,T=[];for(let z=0;z<C;z++){for(let N=0;N<v;N++)if(g[z][N]){let $=(S+z)*y+(P+N);r[$]+=p.sign,T.push($),r[$]<0&&(w=!1),p.sign===1&&r[$]>1+a&&(w=!1)}if(!w)break}if(w&&x(m+1))return!0;for(let z of T)r[z]-=p.sign}}return p.sign===-1?f+=p.area:d+=p.area,!1};return x(0)}getShapeArea(e){let t=0;for(let n of e)for(let s of n)s&&t++;return t}getAllRotations(e){let t=[],n=new Set,s=e;for(let h=0;h<4;h++){let o=JSON.stringify(s);n.has(o)||(t.push(s),n.add(o)),s=this.rotate90(s)}return t}rotate90(e){let t=e.length,n=e[0].length,s=Array.from({length:n},()=>Array(t).fill(0));for(let h=0;h<t;h++)for(let o=0;o<n;o++)s[o][t-1-h]=e[h][o];return s}calculateRegions(e,t,n=[],s){let h=[],o=e.rows,i=e.cols,u=new Uint8Array(o*i),y=new Uint8Array((o+1)*i),c=new Uint8Array(o*(i+1)),r=(a,f)=>{a.x===f.x?c[Math.min(a.y,f.y)*(i+1)+a.x]=1:y[a.y*i+Math.min(a.x,f.x)]=1};for(let a=0;a<t.length-1;a++)r(t[a],t[a+1]);for(let a=0;a<n.length-1;a++)r(n[a],n[a+1]);for(let a=0;a<=o;a++)for(let f=0;f<i;f++)e.hEdges[a][f].type===2&&(y[a*i+f]=1);for(let a=0;a<o;a++)for(let f=0;f<=i;f++)e.vEdges[a][f].type===2&&(c[a*(i+1)+f]=1);let l=s||this.getExternalCells(e);for(let a=0;a<o;a++)for(let f=0;f<i;f++){let d=a*i+f;if(u[d]||l&&l.has(`${f},${a}`))continue;let x=[],m=[d];u[d]=1;let p=0;for(;p<m.length;){let b=m[p++],g=b%i,C=Math.floor(b/i);if(x.push({x:g,y:C}),C>0&&!y[C*i+g]){let v=(C-1)*i+g;!u[v]&&(!l||!l.has(`${g},${C-1}`))&&(u[v]=1,m.push(v))}if(C<o-1&&!y[(C+1)*i+g]){let v=(C+1)*i+g;!u[v]&&(!l||!l.has(`${g},${C+1}`))&&(u[v]=1,m.push(v))}if(g>0&&!c[C*(i+1)+g]){let v=C*i+(g-1);!u[v]&&(!l||!l.has(`${g-1},${C}`))&&(u[v]=1,m.push(v))}if(g<i-1&&!c[C*(i+1)+(g+1)]){let v=C*i+(g+1);!u[v]&&(!l||!l.has(`${g+1},${C}`))&&(u[v]=1,m.push(v))}}h.push(x)}return h}getExternalCells(e){let t=new Set,n=[];for(let s=0;s<e.cols;s++)e.hEdges[0][s].type===2&&(t.has(`${s},0`)||(t.add(`${s},0`),n.push({x:s,y:0}))),e.hEdges[e.rows][s].type===2&&(t.has(`${s},${e.rows-1}`)||(t.add(`${s},${e.rows-1}`),n.push({x:s,y:e.rows-1})));for(let s=0;s<e.rows;s++)e.vEdges[s][0].type===2&&(t.has(`0,${s}`)||(t.add(`0,${s}`),n.push({x:0,y:s}))),e.vEdges[s][e.cols].type===2&&(t.has(`${e.cols-1},${s}`)||(t.add(`${e.cols-1},${s}`),n.push({x:e.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),h=[{nx:s.x,ny:s.y-1,edge:e.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:e.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:e.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:e.vEdges[s.y][s.x+1]}];for(let o of h)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return t}getSymmetricalPoint(e,t){let n=e.symmetry||0;return n===1?{x:e.cols-t.x,y:t.y}:n===2?{x:t.x,y:e.rows-t.y}:n===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getSymmetricalPointIndex(e,t){let n=e.cols+1,s=Math.floor(t/n),h=t%n,o=e.symmetry||0,i=s,u=h;return o===1?u=e.cols-h:o===2?i=e.rows-s:o===3&&(u=e.cols-h,i=e.rows-s),i*n+u}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}calculateDifficulty(e){let t=e.rows,n=e.cols,s=n+1,h=(t+1)*s,o=Array.from({length:h},()=>[]),i=[],u=[],y=new Map,c=0,r=new Set,l=new Set;for(let M=0;M<=t;M++)for(let E=0;E<=n;E++){let R=M*s+E;if(e.nodes[M][E].type===1&&i.push(R),e.nodes[M][E].type===2&&u.push(R),(e.nodes[M][E].type===3||e.nodes[M][E].type===4||e.nodes[M][E].type===5)&&(y.set(`n${E},${M}`,c++),l.add(R)),E<n){let K=R+1,I=e.hEdges[M][E].type,U=I===3||I===4||I===5,B=I===1||I===2;o[R].push({next:K,hexType:I,isBroken:B}),o[K].push({next:R,hexType:I,isBroken:B}),U&&(y.set(`eh${E},${M}`,c++),r.add(this.getEdgeKey({x:E,y:M},{x:E+1,y:M})))}if(M<t){let K=R+s,I=e.vEdges[M][E].type,U=I===3||I===4||I===5,B=I===1||I===2;o[R].push({next:K,hexType:I,isBroken:B}),o[K].push({next:R,hexType:I,isBroken:B}),U&&(y.set(`ev${E},${M}`,c++),r.add(this.getEdgeKey({x:E,y:M},{x:E,y:M+1})))}}let a={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},f=c,d=new Set,x=Math.max(1e3,t*n*200),m=this.getExternalCells(e),p=!1;for(let M=0;M<t;M++){for(let E=0;E<n;E++)if(e.cells[M][E].type!==0){p=!0;break}if(p)break}for(let M of i){let E=e.cols+1,R=Math.floor(M/E),K=M%E,I=0n,U=e.nodes[R][K].type;(U===3||U===4)&&(I|=1n<<BigInt(y.get(`n${K},${R}`)));let B=e.symmetry||0;if(B!==0){let V=this.getSymmetricalPointIndex(e,M),G=Math.floor(V/E),k=V%E,D=e.nodes[G][k].type;(D===3||D===5)&&(I|=1n<<BigInt(y.get(`n${k},${G}`)))}let X=1n<<BigInt(M);if(B!==0){let V=this.getSymmetricalPointIndex(e,M);if(V===M)continue;X|=1n<<BigInt(V)}this.exploreSearchSpace(e,M,X,[M],I,f,o,u,d,a,x,m,p,y)}if(a.solutions===0)return 0;let b=r.size+l.size,g=new Set;r.size>0&&g.add(999);let C=0,v=0;for(let M=0;M<t;M++)for(let E=0;E<n;E++){let R=e.cells[M][E];R.type!==0&&(b++,g.add(R.type),R.type===3?C++:R.type===4&&(C++,v++))}let S=a.branchingPoints/(a.totalNodesVisited||1),P=Math.log10(a.totalNodesVisited+1),w=(S*10+P*1.5)/(Math.log2(a.solutions+1)*.5+1);w-=r.size*.05,w+=l.size*.12,C>0&&(w+=(C-v)*.5,w+=v*.2);let T=0,z=0;for(let M=0;M<t;M++)for(let E=0;E<n;E++){let R=e.cells[M][E];R.type===6?T++:R.type===7&&(T++,z++)}T>0&&(w+=(T-z)*.6,w+=z*.3);let N=t*n,$=b/N,H=$<.25?Math.pow($/.25,4):1,O=g.size<=1?.5:1;w*=H*O;let A=Math.log2(N)/5;return w*=A,Math.max(.01,Math.min(1,w/4))}exploreSearchSpace(e,t,n,s,h,o,i,u,y,c,r,l,a=!0,f){if(c.totalNodesVisited++,c.maxDepth=Math.max(c.maxDepth,s.length),c.totalNodesVisited>r)return;let d=e.symmetry||0;if(u.includes(t)){let p=0,b=h;for(;b>0n;)b&1n&&p++,b>>=1n;if(p===o){let g=s.map(S=>({x:S%(e.cols+1),y:Math.floor(S/(e.cols+1))})),C={points:g};if(d!==0){let S=this.getSymmetricalPointIndex(e,t),P=e.cols+1;if(e.nodes[Math.floor(S/P)][S%P].type!==2)return}let v=d!==0?g.map(S=>this.getSymmetricalPoint(e,S)):[];if(a){let S=this.validateFast(e,g,v,l);if(S.isValid){let P=this.getFingerprint(e,g,v,S.regions,l);y.has(P)||(y.add(P),c.solutions++)}}else{let S=this.getFingerprint(e,g,v,void 0,l);y.has(S)||(y.add(S),c.solutions++)}}return}if(!this.canReachEndOptimized(t,n,i,u)){c.backtracks++;return}let x=[];for(let p of i[t]){if(p.isBroken||n&1n<<BigInt(p.next))continue;if(d!==0){let g=this.getSymmetricalPointIndex(e,t),C=this.getSymmetricalPointIndex(e,p.next);if(p.next===C||t===C&&p.next===g)continue}let b=!0;for(let g of i[t])if(g.hexType===3||g.hexType===4){let v=s.length>=2&&g.next===s[s.length-2],S=g.next===p.next;if(!v&&!S){b=!1;break}}if(b){if(d!==0){let g=this.getSymmetricalPointIndex(e,t),C=this.getSymmetricalPointIndex(e,p.next);for(let v of i[g])if(v.hexType===3||v.hexType===5){let P=s.length>=2?this.getSymmetricalPointIndex(e,s[s.length-2]):-1,w=v.next===P,T=v.next===C;if(!w&&!T){b=!1;break}}}b&&x.push(p)}}if(x.length>1&&c.branchingPoints++,e.rows*e.cols>30)for(let p=x.length-1;p>0;p--){let b=Math.floor(Math.random()*(p+1));[x[p],x[b]]=[x[b],x[p]]}let m=e.cols+1;for(let p of x){let b=h,g=Math.floor(p.next/m),C=p.next%m,v=e.nodes[g][C].type;(v===3||v===4)&&(b|=1n<<BigInt(f.get(`n${C},${g}`)));let S=s[s.length-1],P=Math.floor(S/m),w=S%m;if(P===g){let z=Math.min(w,C);(p.hexType===3||p.hexType===4)&&(b|=1n<<BigInt(f.get(`eh${z},${g}`)))}else{let z=Math.min(P,g);(p.hexType===3||p.hexType===4)&&(b|=1n<<BigInt(f.get(`ev${C},${z}`)))}if(d!==0){let z=this.getSymmetricalPointIndex(e,p.next),N=Math.floor(z/m),$=z%m,H=e.nodes[N][$].type;(H===3||H===5)&&(b|=1n<<BigInt(f.get(`n${$},${N}`)));let O=this.getSymmetricalPointIndex(e,S),A=Math.floor(O/m),M=O%m;if(A===N){let E=Math.min(M,$),R=e.hEdges[N][E].type;(R===3||R===5)&&(b|=1n<<BigInt(f.get(`eh${E},${N}`)))}else{let E=Math.min(A,N),R=e.vEdges[E][$].type;(R===3||R===5)&&(b|=1n<<BigInt(f.get(`ev${$},${E}`)))}}s.push(p.next);let T=n|1n<<BigInt(p.next);if(d!==0){let z=this.getSymmetricalPointIndex(e,p.next);T|=1n<<BigInt(z)}if(this.exploreSearchSpace(e,p.next,T,s,b,o,i,u,y,c,r,l,a,f),s.pop(),c.totalNodesVisited>r)return}}countSolutions(e,t=100){let n=e.rows,s=e.cols,h=s+1,o=(n+1)*h,i=Array.from({length:o},()=>[]),u=[],y=[],c=new Map,r=0;for(let x=0;x<=n;x++)for(let m=0;m<=s;m++){let p=x*h+m;if(e.nodes[x][m].type===1&&u.push(p),e.nodes[x][m].type===2&&y.push(p),(e.nodes[x][m].type===3||e.nodes[x][m].type===4||e.nodes[x][m].type===5)&&c.set(`n${m},${x}`,r++),m<s){let b=p+1,g=e.hEdges[x][m].type,C=g===3||g===4||g===5,v=g===1||g===2;i[p].push({next:b,hexType:g,isBroken:v}),i[b].push({next:p,hexType:g,isBroken:v}),C&&c.set(`eh${m},${x}`,r++)}if(x<n){let b=p+h,g=e.vEdges[x][m].type,C=g===3||g===4||g===5,v=g===1||g===2;i[p].push({next:b,hexType:g,isBroken:v}),i[b].push({next:p,hexType:g,isBroken:v}),C&&c.set(`ev${m},${x}`,r++)}}let l=new Set,a=r,f=this.getExternalCells(e),d=!1;for(let x=0;x<n;x++){for(let m=0;m<s;m++)if(e.cells[x][m].type!==0){d=!0;break}if(d)break}for(let x of u){let m=e.cols+1,p=Math.floor(x/m),b=x%m,g=0n,C=e.nodes[p][b].type;(C===3||C===4)&&(g|=1n<<BigInt(c.get(`n${b},${p}`)));let v=e.symmetry||0;if(v!==0){let P=this.getSymmetricalPointIndex(e,x),w=Math.floor(P/m),T=P%m,z=e.nodes[w][T].type;(z===3||z===5)&&(g|=1n<<BigInt(c.get(`n${T},${w}`)))}let S=1n<<BigInt(x);if(v!==0){let P=this.getSymmetricalPointIndex(e,x);if(P===x)continue;S|=1n<<BigInt(P)}this.findPathsOptimized(e,x,S,[x],g,a,i,y,l,t,f,d,c)}return l.size}findPathsOptimized(e,t,n,s,h,o,i,u,y,c,r,l=!0,a){if(y.size>=c)return;let f=e.symmetry||0;if(u.includes(t)){let d=0,x=h;for(;x>0n;)x&1n&&d++,x>>=1n;if(d===o){let m=s.map(b=>({x:b%(e.cols+1),y:Math.floor(b/(e.cols+1))}));if(f!==0){let b=this.getSymmetricalPointIndex(e,t),g=e.cols+1;if(e.nodes[Math.floor(b/g)][b%g].type!==2)return}let p=f!==0?m.map(b=>this.getSymmetricalPoint(e,b)):[];if(!l)y.add(this.getFingerprint(e,m,p,void 0,r));else{let b=this.validateFast(e,m,p,r);b.isValid&&y.add(this.getFingerprint(e,m,p,b.regions,r))}}return}if(this.canReachEndOptimized(t,n,i,u))for(let d of i[t]){if(d.isBroken||n&1n<<BigInt(d.next))continue;if(f!==0){let w=this.getSymmetricalPointIndex(e,t),T=this.getSymmetricalPointIndex(e,d.next);if(d.next===T||t===T&&d.next===w)continue}let x=!0;for(let w of i[t])if(w.hexType===3||w.hexType===4){let z=s.length>=2&&w.next===s[s.length-2],N=w.next===d.next;if(!z&&!N){x=!1;break}}if(!x)continue;if(f!==0){let w=this.getSymmetricalPointIndex(e,t),T=this.getSymmetricalPointIndex(e,d.next);for(let z of i[w])if(z.hexType===3||z.hexType===5){let $=s.length>=2?this.getSymmetricalPointIndex(e,s[s.length-2]):-1,H=z.next===$,O=z.next===T;if(!H&&!O){x=!1;break}}}if(!x)continue;let m=e.cols+1,p=h,b=Math.floor(d.next/m),g=d.next%m,C=e.nodes[b][g].type;(C===3||C===4)&&(p|=1n<<BigInt(a.get(`n${g},${b}`)));let v=Math.floor(t/m),S=t%m;if(v===b){let w=Math.min(S,g);(d.hexType===3||d.hexType===4)&&(p|=1n<<BigInt(a.get(`eh${w},${b}`)))}else{let w=Math.min(v,b);(d.hexType===3||d.hexType===4)&&(p|=1n<<BigInt(a.get(`ev${g},${w}`)))}if(f!==0){let w=this.getSymmetricalPointIndex(e,d.next),T=Math.floor(w/m),z=w%m,N=e.nodes[T][z].type;(N===3||N===5)&&(p|=1n<<BigInt(a.get(`n${z},${T}`)));let $=this.getSymmetricalPointIndex(e,t),H=Math.floor($/m),O=$%m;if(H===T){let A=Math.min(O,z),M=e.hEdges[T][A].type;(M===3||M===5)&&(p|=1n<<BigInt(a.get(`eh${A},${T}`)))}else{let A=Math.min(H,T),M=e.vEdges[A][z].type;(M===3||M===5)&&(p|=1n<<BigInt(a.get(`ev${z},${A}`)))}}s.push(d.next);let P=n|1n<<BigInt(d.next);if(f!==0){let w=this.getSymmetricalPointIndex(e,d.next);P|=1n<<BigInt(w)}if(this.findPathsOptimized(e,d.next,P,s,p,o,i,u,y,c,r,l,a),s.pop(),y.size>=c)return}}canReachEndOptimized(e,t,n,s){let h=[e],o=t,i=0;for(;i<h.length;){let u=h[i++];if(s.includes(u))return!0;for(let y of n[u])!y.isBroken&&!(o&1n<<BigInt(y.next))&&(o|=1n<<BigInt(y.next),h.push(y.next))}return!1}getFingerprint(e,t,n,s,h){let i=(s||this.calculateRegions(e,t,n,h)).map(y=>{let c="",r=[];for(let l of y){let a=e.cells[l.y][l.x];a.type!==0&&r.push(a.type<<8|a.color)}r.sort((l,a)=>l-a);for(let l of r)c+=l.toString(36)+",";return c}).sort(),u="";for(let y of i)y.length>0&&(u+=y+"|");return u||"empty"}};var te=class{isWorker;constructor(){this.isWorker=typeof self<"u"&&"postMessage"in self&&!("document"in self)}generate(e,t,n={}){let s=n.difficulty??.5,h=new _,o=null,i=-1,u=this.isWorker?e*t>30?150:120:e*t>30?100:80,y=this.isWorker?8:5,c=n.symmetry||0,r={x:0,y:e},l={x:t,y:0};c===1?l={x:0,y:0}:c===2?l={x:t,y:e}:c===3&&(l={x:t,y:e});let a=null,f=null,d=null;for(let x=0;x<u;x++){if(x%y===0){a=this.generateRandomPath(new Y(e,t),r,l,n.pathLength,c);let g=new Y(e,t),C=c!==0?a.map(v=>this.getSymmetricalPoint(g,v,c)):[];f=this.calculateRegions(g,a,C),d=f.map(v=>this.getRegionBoundaryEdges(g,v,a,C))}let m=this.generateFromPath(e,t,a,n,f,d);if(!this.checkAllRequestedConstraintsPresent(m,n))continue;let p=h.calculateDifficulty(m);if(p===0)continue;let b=Math.abs(p-s);if((o===null||b<Math.abs(i-s))&&(i=p,o=m),s>.8&&p>.8||b<.01)break}if(!o){let x=this.generateRandomPath(new Y(e,t),r,l,n.pathLength,c);return this.generateFromPath(e,t,x,n)}return o}generateFromPath(e,t,n,s,h,o){let i=new Y(e,t),u=s.symmetry||0;i.symmetry=u;let y={x:0,y:e},c={x:t,y:0};if(u===1?c={x:0,y:0}:u===2?c={x:t,y:e}:u===3&&(c={x:t,y:e}),i.nodes[y.y][y.x].type=1,i.nodes[c.y][c.x].type=2,u!==0){let l=this.getSymmetricalPoint(i,y,u),a=this.getSymmetricalPoint(i,c,u);i.nodes[l.y][l.x].type=1,i.nodes[a.y][a.x].type=2}let r=u!==0?n.map(l=>this.getSymmetricalPoint(i,l,u)):[];return this.applyConstraintsBasedOnPath(i,n,s,r,h,o),s.useBrokenEdges&&this.applyBrokenEdges(i,n,s),this.cleanGrid(i),i}generateRandomPath(e,t,n,s,h=0){if(s===void 0)return this.generateSingleRandomPath(e,t,n,void 0,h);let o=e.rows+e.cols,i=(e.rows+1)*(e.cols+1)-1,u=o+s*(i-o),y=[],c=1/0,r=e.rows*e.cols>30?30:50;for(let l=0;l<r;l++){let a=this.generateSingleRandomPath(e,t,n,s,h);if(a.length===0)continue;let f=a.length-1,d=Math.abs(f-u);if(d<c&&(c=d,y=a),c<=2)break}return y}generateSingleRandomPath(e,t,n,s,h=0){let o=new Set,i=[],u=0,y=e.rows*e.cols*200,c=r=>{if(u++,u>y)return!1;o.add(`${r.x},${r.y}`);let l=this.getSymmetricalPoint(e,r,h);if(o.add(`${l.x},${l.y}`),i.push(r),r.x===n.x&&r.y===n.y)return!0;let a=this.getValidNeighbors(e,r,o);h!==0&&(a=a.filter(f=>{let d=this.getSymmetricalPoint(e,f,h);if(d.x<0||d.x>e.cols||d.y<0||d.y>e.rows||o.has(`${d.x},${d.y}`)||f.x===d.x&&f.y===d.y)return!1;let x=this.getEdgeKey(r,f),m=this.getEdgeKey(l,d);return x!==m})),s!==void 0?a.sort((f,d)=>{let x=Math.abs(f.x-n.x)+Math.abs(f.y-n.y),m=Math.abs(d.x-n.x)+Math.abs(d.y-n.y);return(x-m)*(1-s*2)+(Math.random()-.5)*1.5}):this.shuffleArray(a);for(let f of a)if(c(f))return!0;return i.pop(),o.delete(`${r.x},${r.y}`),o.delete(`${l.x},${l.y}`),!1};return c(t),i}getValidNeighbors(e,t,n){let s=[],h=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of h){let i=t.x+o.x,u=t.y+o.y;i>=0&&i<=e.cols&&u>=0&&u<=e.rows&&(n.has(`${i},${u}`)||s.push({x:i,y:u}))}return s}applyBrokenEdges(e,t,n){let s=n.complexity??.5,h=n.symmetry??0,o=new Set;for(let r=0;r<t.length-1;r++)if(o.add(this.getEdgeKey(t[r],t[r+1])),h!==0){let l=this.getSymmetricalPoint(e,t[r],h),a=this.getSymmetricalPoint(e,t[r+1],h);o.add(this.getEdgeKey(l,a))}let i=[];for(let r=0;r<=e.rows;r++)for(let l=0;l<e.cols;l++){let a={x:l,y:r},f={x:l+1,y:r};o.has(this.getEdgeKey(a,f))||i.push({type:"h",r,c:l,p1:a,p2:f})}for(let r=0;r<e.rows;r++)for(let l=0;l<=e.cols;l++){let a={x:l,y:r},f={x:l,y:r+1};o.has(this.getEdgeKey(a,f))||i.push({type:"v",r,c:l,p1:a,p2:f})}this.shuffleArray(i);let u=Math.max(1,Math.floor(s*(e.rows*e.cols)/4)),y=0;for(let r of i){if(y>=u)break;r.type==="h"?e.hEdges[r.r][r.c].type=1:e.vEdges[r.r][r.c].type=1,y++}let c=!0;for(;c;){c=!1;for(let r=0;r<=e.rows;r++)for(let l=0;l<e.cols;l++)e.hEdges[r][l].type===1&&this.canBecomeAbsent(e,{type:"h",r,c:l})&&(e.hEdges[r][l].type=2,c=!0);for(let r=0;r<e.rows;r++)for(let l=0;l<=e.cols;l++)e.vEdges[r][l].type===1&&this.canBecomeAbsent(e,{type:"v",r,c:l})&&(e.vEdges[r][l].type=2,c=!0)}for(let r=0;r<=e.rows;r++)for(let l=0;l<=e.cols;l++){let a=[];if(l>0&&a.push({e:e.hEdges[r][l-1],type:"h",r,c:l-1}),l<e.cols&&a.push({e:e.hEdges[r][l],type:"h",r,c:l}),r>0&&a.push({e:e.vEdges[r-1][l],type:"v",r:r-1,c:l}),r<e.rows&&a.push({e:e.vEdges[r][l],type:"v",r,c:l}),a.length>0&&a.every(f=>f.e.type===1||f.e.type===2)&&a.every(f=>!this.isAdjacentToMark(e,f)))for(let f of a)f.e.type=2}}canBecomeAbsent(e,t){if(this.isAdjacentToMark(e,t))return!1;if(t.type==="h"){if(t.r===0||t.r===e.rows)return!0}else if(t.c===0||t.c===e.cols)return!0;let n=t.type==="h"?[{x:t.c,y:t.r},{x:t.c+1,y:t.r}]:[{x:t.c,y:t.r},{x:t.c,y:t.r+1}];for(let s of n){let h=[{type:"h",r:s.y,c:s.x-1},{type:"h",r:s.y,c:s.x},{type:"v",r:s.y-1,c:s.x},{type:"v",r:s.y,c:s.x}];for(let o of h)if(o.c>=0&&o.c<=e.cols&&o.r>=0&&o.r<=e.rows){if(o.type==="h"&&o.c<e.cols){if(e.hEdges[o.r][o.c].type===2)return!0}else if(o.type==="v"&&o.r<e.rows&&e.vEdges[o.r][o.c].type===2)return!0}}return!1}cleanGrid(e){let t=[];for(let o=0;o<=e.rows;o++)for(let i=0;i<=e.cols;i++)e.nodes[o][i].type===1&&t.push({x:i,y:o});let n=new Set,s=[...t];for(let o of t)n.add(`${o.x},${o.y}`);for(;s.length>0;){let o=s.shift(),i=[{nx:o.x,ny:o.y-1,edge:e.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:e.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:e.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:e.hEdges[o.y]?.[o.x]}];for(let u of i)u.edge&&u.edge.type!==2&&(n.has(`${u.nx},${u.ny}`)||(n.add(`${u.nx},${u.ny}`),s.push({x:u.nx,y:u.ny})))}for(let o=0;o<=e.rows;o++)for(let i=0;i<e.cols;i++)(!n.has(`${i},${o}`)||!n.has(`${i+1},${o}`))&&(e.hEdges[o][i].type=2);for(let o=0;o<e.rows;o++)for(let i=0;i<=e.cols;i++)(!n.has(`${i},${o}`)||!n.has(`${i},${o+1}`))&&(e.vEdges[o][i].type=2);let h=this.getExternalCells(e);for(let o of h){let[i,u]=o.split(",").map(Number);e.cells[u][i].type=0}}getExternalCells(e){let t=new Set,n=[];for(let s=0;s<e.cols;s++)e.hEdges[0][s].type===2&&(t.has(`${s},0`)||(t.add(`${s},0`),n.push({x:s,y:0}))),e.hEdges[e.rows][s].type===2&&(t.has(`${s},${e.rows-1}`)||(t.add(`${s},${e.rows-1}`),n.push({x:s,y:e.rows-1})));for(let s=0;s<e.rows;s++)e.vEdges[s][0].type===2&&(t.has(`0,${s}`)||(t.add(`0,${s}`),n.push({x:0,y:s}))),e.vEdges[s][e.cols].type===2&&(t.has(`${e.cols-1},${s}`)||(t.add(`${e.cols-1},${s}`),n.push({x:e.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),h=[{nx:s.x,ny:s.y-1,edge:e.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:e.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:e.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:e.vEdges[s.y][s.x+1]}];for(let o of h)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return t}isAdjacentToMark(e,t){if(t.type==="h"){if(t.r>0&&e.cells[t.r-1][t.c].type!==0||t.r<e.rows&&e.cells[t.r][t.c].type!==0)return!0}else if(t.c>0&&e.cells[t.r][t.c-1].type!==0||t.c<e.cols&&e.cells[t.r][t.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let t=0;t<e.rows;t++)for(let n=0;n<e.cols;n++){if(e.cells[t][n].type===0)continue;if([e.hEdges[t][n],e.hEdges[t+1][n],e.vEdges[t][n],e.vEdges[t][n+1]].every(h=>h.type===1||h.type===2))return!0}return!1}getSymmetricalPoint(e,t,n){return n===1?{x:e.cols-t.x,y:t.y}:n===2?{x:t.x,y:e.rows-t.y}:n===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,t,n,s=[],h,o){let i=n.complexity??.5,u=n.useHexagons??!0,y=n.useSquares??!0,c=n.useStars??!0,r=n.useTetris??!1,l=n.useTetrisNegative??!1,a=n.useEraser??!1,f=0,d=0,x=0,m=0,p=0,b=0,g=Math.floor(e.rows*e.cols*.45);if(u){let C=n.difficulty??.5,v=n.symmetry||0;for(let S=0;S<t.length-1;S++){let w=this.getValidNeighbors(e,t[S],new Set).length>2,T=i*(C<.4?.6:.3);if(w&&(T=C<.4?T*1:T*.5),Math.random()<T){let z=3,N=t[S],$=t[S+1];if(v!==0){let H=Math.random();H<.3?z=4:H<.6&&(z=5,N=this.getSymmetricalPoint(e,t[S],v),$=this.getSymmetricalPoint(e,t[S+1],v))}this.setEdgeHexagon(e,N,$,z),f++}}for(let S=0;S<t.length;S++){let P=t[S];if(e.nodes[P.y][P.x].type!==0||this.hasIncidentHexagonEdge(e,P))continue;let w=i*(C>.6?.15:.05);if(Math.random()<w){let T=3,z=P;if(v!==0){let N=Math.random();N<.3?T=4:N<.6&&(T=5,z=this.getSymmetricalPoint(e,P,v))}e.nodes[z.y][z.x].type=T,f++}}if(f===0&&t.length>=2){let S=Math.floor(Math.random()*(t.length-1)),P=n.symmetry||0,w=3,T=t[S],z=t[S+1];if(P!==0){let N=Math.random();N<.3?w=4:N<.6&&(w=5,T=this.getSymmetricalPoint(e,t[S],P),z=this.getSymmetricalPoint(e,t[S+1],P))}this.setEdgeHexagon(e,T,z,w)}}if(y||c||r||a){let C=h||this.calculateRegions(e,t,s),v=n.availableColors??[q.Black,q.White,q.Red,q.Blue],S=n.defaultColors??{},P=(N,$)=>{if(S[N]!==void 0)return S[N];let H=j[N];return H&&S[H]!==void 0?S[H]:$},w=Array.from({length:C.length},(N,$)=>$);this.shuffleArray(w);let T=new Set,z={square:y,star:c,tetris:r,eraser:a};for(let N=0;N<w.length;N++){let $=w[N],H=C[$],O=w.length-N,A=z.square&&d===0||z.star&&x===0||z.tetris&&m===0||z.eraser&&p===0,M=.2+i*.6;if(A&&O<=3?M=1:A&&O<=6&&(M=.7),Math.random()>M)continue;let E=[...H];this.shuffleArray(E);let R=v[Math.floor(Math.random()*v.length)];if(y&&!c&&O<=2&&T.size===1){let I=v.filter(U=>!T.has(U));I.length>0&&(R=I[Math.floor(Math.random()*I.length)])}let K=y&&Math.random()<.5+i*.3;if(y&&d===0&&O<=2&&(K=!0),y&&!c&&O<=2&&T.size<2&&d>0&&(K=!0),K&&E.length>0){let I=Math.min(E.length,Math.max(4,Math.floor(H.length/4))),U=Math.floor(Math.random()*(I/2))+Math.ceil(I/2);for(let B=0;B<U&&E.length!==0;B++){let X=E.pop();e.cells[X.y][X.x].type=1,e.cells[X.y][X.x].color=R,d++,T.add(R)}}if((r||l)&&b<g){let I=Math.random()<.1+i*.4;m===0&&O<=2&&(I=!0);let U=m===0&&O<=2?6:4;if(I&&E.length>0&&b+H.length<=g){let B=this.generateTiling(H,U,n);if(B){let X=[];if(l&&Math.random()<.4+i*.4){let G=n.difficulty??.5;if(Math.random()<.2&&E.length>=2){let D=3+Math.floor(Math.random()*2),W=this.TETRIS_SHAPES.filter(L=>this.getShapeArea(L)===D);this.shuffleArray(W);let F=!1;for(let L=0;L<W.length&&!F;L++)for(let se=L+1;se<W.length&&!F;se++){let Q=W[L],oe=W[se];this.isSameShape(Q,oe)||(B.push({shape:Q,displayShape:Q,isRotated:Math.random()<G*.7,isNegative:!1}),X.push({shape:oe,displayShape:oe,isRotated:Math.random()<G*.7,isNegative:!0}),F=!0)}}else if(B.length>0){let D=Math.random()<.3?2:1;for(let W=0;W<D&&!(E.length<1);W++){let F=Math.floor(Math.random()*B.length),L=this.findStandardTriple(B[F].shape);L&&(B.some(Q=>this.isSameShape(Q.shape,L.n))||(B[F]={shape:L.p,displayShape:L.p,isRotated:Math.random()<G*.7,isNegative:!1},X.push({shape:L.n,displayShape:L.n,isRotated:Math.random()<G*.7,isNegative:!0})))}}}let V=[...B,...X];for(let G of V){if(E.length===0)break;let k=E.pop();if(G.isNegative)e.cells[k.y][k.x].type=G.isRotated?7:6,e.cells[k.y][k.x].color=P(6,q.Cyan);else{e.cells[k.y][k.x].type=G.isRotated?4:3;let W=P(3,q.None);if(c&&Math.random()<.5){let F=v.filter(L=>L!==W);F.length>0&&(W=F[Math.floor(Math.random()*F.length)])}e.cells[k.y][k.x].color=W}e.cells[k.y][k.x].shape=G.isRotated?G.displayShape:G.shape,m++}b+=H.length}}}if(a&&p<1){let I=.05+i*.2,U=Math.random()<I;if(O<=2&&(U=!0),U&&E.length>=1){let B=[];c&&B.push("star"),y&&B.push("square");let X=[];u&&(X=o?o[$]:this.getRegionBoundaryEdges(e,H,t,s),X.length>0&&B.push("hexagon")),r&&B.push("tetris");let V=B.length>0?B[Math.floor(Math.random()*B.length)]:null;E.length>=2&&(!V||Math.random()<.01)&&(V="eraser");let G=!1;if(V==="hexagon"){let k=X.filter(D=>!this.isEdgeAdjacentToHexagonNode(e,D));if(k.length>0){let D=k[Math.floor(Math.random()*k.length)];D.type==="h"?e.hEdges[D.r][D.c].type=3:e.vEdges[D.r][D.c].type=3,f++,G=!0}}else if(V==="square"&&E.length>=2){let k=E.pop();e.cells[k.y][k.x].type=1;let D=H.find(F=>e.cells[F.y][F.x].type===1),W=D?e.cells[D.y][D.x].color:void 0;e.cells[k.y][k.x].color=v.find(F=>F!==W)||q.Red,d++,G=!0}else if(V==="star"&&E.length>=2){let k=E.pop();e.cells[k.y][k.x].type=2,e.cells[k.y][k.x].color=v[Math.floor(Math.random()*v.length)],x++,G=!0}else if(V==="tetris"&&E.length>=2){let k=this.generateTiling(H,4,n),D=[];if(k&&k.length>0){let W=0;for(let F of k){let L=this.getShapeArea(F.shape);if(W+L<H.length)D.push(F),W+=L;else break}}if(D.length===0&&H.length>1&&(D=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),D.length>0){for(let W of D){if(E.length<2)break;let F=E.pop();e.cells[F.y][F.x].type=W.isRotated?4:3,e.cells[F.y][F.x].shape=W.isRotated?W.displayShape:W.shape;let L=q.None;c&&Math.random()<.3&&(L=v[Math.floor(Math.random()*v.length)]),e.cells[F.y][F.x].color=L,m++}G=!0}}else if(V==="eraser"&&E.length>=2){let k=E.pop();e.cells[k.y][k.x].type=5,e.cells[k.y][k.x].color=P(5,q.White),p++,G=!0}if(!G&&E.length>=2){let k=E.pop();e.cells[k.y][k.x].type=5,e.cells[k.y][k.x].color=P(5,q.White),p++,G=!0}if(G){let k=E.pop();e.cells[k.y][k.x].type=5;let D=P(5,q.White);if(c&&Math.random()<.4){let W=v.filter(F=>F!==D);W.length>0&&(D=W[Math.floor(Math.random()*W.length)])}e.cells[k.y][k.x].color=D,p++}}}if(c){let I=Math.max(1,Math.floor(H.length/8));for(let U=0;U<I;U++)for(let B of v){if(E.length<1)break;if(Math.random()>.3+i*.4)continue;let X=H.filter(V=>e.cells[V.y][V.x].color===B).length;if(X===1){let V=E.pop();e.cells[V.y][V.x].type=2,e.cells[V.y][V.x].color=B,x++}else if(X===0&&E.length>=2)for(let V=0;V<2;V++){let G=E.pop();e.cells[G.y][G.x].type=2,e.cells[G.y][G.x].color=B,x++}}}}if(y&&!c&&T.size<2){for(let N of C)if(N.every($=>e.cells[$.y][$.x].type===0)){let $=v.find(O=>!T.has(O))||q.White,H=N[Math.floor(Math.random()*N.length)];e.cells[H.y][H.x].type=1,e.cells[H.y][H.x].color=$,T.add($),d++;break}}}}calculateRegions(e,t,n=[]){let s=[],h=e.rows,o=e.cols,i=new Uint8Array(h*o),u=new Uint8Array((h+1)*o),y=new Uint8Array(h*(o+1)),c=(r,l)=>{r.x===l.x?y[Math.min(r.y,l.y)*(o+1)+r.x]=1:u[r.y*o+Math.min(r.x,l.x)]=1};for(let r=0;r<t.length-1;r++)c(t[r],t[r+1]);for(let r=0;r<n.length-1;r++)c(n[r],n[r+1]);for(let r=0;r<=h;r++)for(let l=0;l<o;l++)e.hEdges[r][l].type===2&&(u[r*o+l]=1);for(let r=0;r<h;r++)for(let l=0;l<=o;l++)e.vEdges[r][l].type===2&&(y[r*(o+1)+l]=1);for(let r=0;r<h;r++)for(let l=0;l<o;l++){let a=r*o+l;if(i[a])continue;let f=[],d=[a];i[a]=1;let x=0;for(;x<d.length;){let m=d[x++],p=m%o,b=Math.floor(m/o);if(f.push({x:p,y:b}),b>0&&!u[b*o+p]){let g=(b-1)*o+p;i[g]||(i[g]=1,d.push(g))}if(b<h-1&&!u[(b+1)*o+p]){let g=(b+1)*o+p;i[g]||(i[g]=1,d.push(g))}if(p>0&&!y[b*(o+1)+p]){let g=b*o+(p-1);i[g]||(i[g]=1,d.push(g))}if(p<o-1&&!y[b*(o+1)+(p+1)]){let g=b*o+(p+1);i[g]||(i[g]=1,d.push(g))}}s.push(f)}return s}isAbsentEdge(e,t,n){if(t.x===n.x){let s=Math.min(t.y,n.y);return e.vEdges[s][t.x].type===2}else{let s=Math.min(t.x,n.x);return e.hEdges[t.y][s].type===2}}getRegionBoundaryEdges(e,t,n,s=[]){let h=new Set;for(let u=0;u<n.length-1;u++)h.add(this.getEdgeKey(n[u],n[u+1]));for(let u=0;u<s.length-1;u++)h.add(this.getEdgeKey(s[u],s[u+1]));let o=[];for(let u of t){let y=[{type:"h",r:u.y,c:u.x},{type:"h",r:u.y+1,c:u.x},{type:"v",r:u.y,c:u.x},{type:"v",r:u.y,c:u.x+1}];for(let c of y){let r=c.type==="h"?{x:c.c,y:c.r}:{x:c.c,y:c.r},l=c.type==="h"?{x:c.c+1,y:c.r}:{x:c.c,y:c.r+1},a=this.getEdgeKey(r,l);!h.has(a)&&!this.isAbsentEdge(e,r,l)&&o.push(c)}}let i=new Map;for(let u of o)i.set(`${u.type},${u.r},${u.c}`,u);return Array.from(i.values())}setEdgeHexagon(e,t,n,s=3){t.x===n.x?e.vEdges[Math.min(t.y,n.y)][t.x].type=s:e.hEdges[t.y][Math.min(t.x,n.x)].type=s}hasIncidentHexagonEdge(e,t){let n=s=>s===3||s===4||s===5;return!!(t.x>0&&n(e.hEdges[t.y][t.x-1].type)||t.x<e.cols&&n(e.hEdges[t.y][t.x].type)||t.y>0&&n(e.vEdges[t.y-1][t.x].type)||t.y<e.rows&&n(e.vEdges[t.y][t.x].type))}isEdgeAdjacentToHexagonNode(e,t){let n=s=>s===3||s===4||s===5;return t.type==="h"?n(e.nodes[t.r][t.c].type)||n(e.nodes[t.r][t.c+1].type):n(e.nodes[t.r][t.c].type)||n(e.nodes[t.r+1][t.c].type)}checkAllRequestedConstraintsPresent(e,t){let n=t.useHexagons??!0,s=t.useSquares??!0,h=t.useStars??!0,o=t.useTetris??!1,i=t.useTetrisNegative??!1,u=t.useEraser??!1;if(t.useBrokenEdges??!1){let c=!1;for(let r=0;r<=e.rows;r++)for(let l=0;l<e.cols;l++)if(e.hEdges[r][l].type===1||e.hEdges[r][l].type===2){c=!0;break}if(!c){for(let r=0;r<e.rows;r++)for(let l=0;l<=e.cols;l++)if(e.vEdges[r][l].type===1||e.vEdges[r][l].type===2){c=!0;break}}if(!c)return!1}if(n){let c=!1,r=a=>a===3||a===4||a===5,l=a=>a===3||a===4||a===5;for(let a=0;a<=e.rows;a++)for(let f=0;f<e.cols;f++)if(r(e.hEdges[a][f].type)){c=!0;break}if(!c){for(let a=0;a<e.rows;a++)for(let f=0;f<=e.cols;f++)if(r(e.vEdges[a][f].type)){c=!0;break}}if(!c){for(let a=0;a<=e.rows;a++)for(let f=0;f<=e.cols;f++)if(l(e.nodes[a][f].type)){c=!0;break}}if(!c)return!1}if(s||h||o||u){let c=!1,r=!1,l=!1,a=!1,f=!1,d=new Set,x=new Set;for(let m=0;m<e.rows;m++)for(let p=0;p<e.cols;p++){let b=e.cells[m][p].type;b===1&&(c=!0,d.add(e.cells[m][p].color)),b===2&&(r=!0,x.add(e.cells[m][p].color)),(b===3||b===4)&&(l=!0),(b===6||b===7)&&(a=!0),b===5&&(f=!0)}if(s&&!c||h&&!r||o&&!l||i&&!a||u&&!f)return!1;if(s&&c&&d.size<2){let m=d.values().next().value;if(m===void 0||!x.has(m))return!1}}return!this.hasIsolatedMark(e)}generateTiling(e,t,n){let s=Math.min(...e.map(r=>r.x)),h=Math.min(...e.map(r=>r.y)),o=Math.max(...e.map(r=>r.x)),i=Math.max(...e.map(r=>r.y)),u=o-s+1,y=i-h+1,c=Array.from({length:y},()=>Array(u).fill(!1));for(let r of e)c[r.y-h][r.x-s]=!0;return this.tilingDfs(c,[],t,n)}tilingDfs(e,t,n,s){let h=-1,o=-1;for(let y=0;y<e.length;y++){for(let c=0;c<e[0].length;c++)if(e[y][c]){h=y,o=c;break}if(h!==-1)break}if(h===-1)return t;if(t.length>=n)return null;let i=s.difficulty??.5,u=[...this.TETRIS_SHAPES];this.shuffleArray(u),i>.6&&u.sort((y,c)=>this.getShapeArea(c)-this.getShapeArea(y));for(let y of u){let c=this.isRotationallyInvariant(y),r=c?[y]:this.getAllRotations(y);this.shuffleArray(r);for(let l of r){let a=[];for(let f=0;f<l.length;f++)for(let d=0;d<l[0].length;d++)l[f][d]&&a.push({r:f,c:d});for(let f of a){let d=h-f.r,x=o-f.c;if(this.canPlace(e,l,d,x)){this.placePiece(e,l,d,x,!1);let m=this.tilingDfs(e,[...t,{shape:l,displayShape:y,isRotated:!c&&Math.random()<.3+i*.6}],n,s);if(m)return m;this.placePiece(e,l,d,x,!0)}}}}return null}getShapeArea(e){let t=0;for(let n of e)for(let s of n)s&&t++;return t}isRotationallyInvariant(e){let t=this.getShapeArea(e);return t===1||t===4&&e.length===2&&e[0].length===2}getAllRotations(e){let t=[],n=new Set,s=e;for(let h=0;h<4;h++){let o=JSON.stringify(s);n.has(o)||(t.push(s),n.add(o)),s=this.rotate90(s)}return t}rotate90(e){let t=e.length,n=e[0].length,s=Array.from({length:n},()=>Array(t).fill(0));for(let h=0;h<t;h++)for(let o=0;o<n;o++)s[o][t-1-h]=e[h][o];return s}canPlace(e,t,n,s){for(let h=0;h<t.length;h++)for(let o=0;o<t[0].length;o++)if(t[h][o]){let i=n+h,u=s+o;if(i<0||i>=e.length||u<0||u>=e[0].length||!e[i][u])return!1}return!0}placePiece(e,t,n,s,h){for(let o=0;o<t.length;o++)for(let i=0;i<t[0].length;i++)t[o][i]&&(e[n+o][s+i]=h)}isSameShape(e,t){let n=this.getAllRotations(e),s=JSON.stringify(t);return n.some(h=>JSON.stringify(h)===s)}canTilePieceWith(e,t,n){let s=this.getShapeArea(e),h=this.getShapeArea(t),o=this.getShapeArea(n);if(s!==h+o)return!1;let i=this.getAllRotations(t),u=this.getAllRotations(n),y=e.length,c=e[0].length;for(let r of i)for(let l of u){let a=r.length,f=r[0].length,d=l.length,x=l[0].length;for(let m=0;m<=y-a;m++)for(let p=0;p<=c-f;p++)for(let b=0;b<=y-d;b++)for(let g=0;g<=c-x;g++){let C=Array.from({length:y},()=>Array(c).fill(0)),v=!0;for(let S=0;S<a;S++)for(let P=0;P<f;P++)r[S][P]&&(C[m+S][p+P]=1);for(let S=0;S<d;S++){for(let P=0;P<x;P++)if(l[S][P]){if(C[b+S][g+P]){v=!1;break}C[b+S][g+P]=1}if(!v)break}if(v){let S=!0;for(let P=0;P<y;P++){for(let w=0;w<c;w++)if(C[P][w]!==e[P][w]){S=!1;break}if(!S)break}if(S)return!0}}}return!1}findStandardTriple(e){let t=this.getShapeArea(e),n=[...this.TETRIS_SHAPES];this.shuffleArray(n);for(let s of n){let h=this.getShapeArea(s),o=t+h;if(o>5)continue;let i=this.TETRIS_SHAPES.filter(u=>this.getShapeArea(u)===o);for(let u of i)if(this.canTilePieceWith(u,e,s))return{p:u,n:s}}return null}shuffleArray(e){for(let t=e.length-1;t>0;t--){let n=Math.floor(Math.random()*(t+1));[e[t],e[n]]=[e[n],e[t]]}}};var ie=class{bytes=[];cur=0;bit=0;write(e,t){for(let n=0;n<t;n++)e&1<<n&&(this.cur|=1<<this.bit),this.bit++,this.bit===8&&(this.bytes.push(this.cur),this.cur=0,this.bit=0)}finish(){return this.bit>0&&this.bytes.push(this.cur),new Uint8Array(this.bytes)}},re=class{constructor(e){this.buf=e}i=0;bit=0;read(e){let t=0;for(let n=0;n<e;n++)this.buf[this.i]&1<<this.bit&&(t|=1<<n),this.bit++,this.bit===8&&(this.bit=0,this.i++);return t}};function fe(J){let e=new Map;for(let t of J)for(let n of t)if(n.shape){let s=JSON.stringify(n.shape);e.has(s)||e.set(s,n.shape)}return[...e.values()]}var ae=class{static async serialize(e,t){let n=new ie;n.write(e.rows,6),n.write(e.cols,6),n.write(e.symmetry??0,2);let s=fe(e.cells);n.write(s.length,5);for(let c of s){n.write(c.length,4),n.write(c[0].length,4);for(let r of c)for(let l of r)n.write(l,1)}let h=new Map;s.forEach((c,r)=>h.set(JSON.stringify(c),r));for(let c of e.cells)for(let r of c)n.write(r.type,3),n.write(r.color,3),r.shape?(n.write(1,1),n.write(h.get(JSON.stringify(r.shape)),5)):n.write(0,1);for(let c=0;c<e.rows;c++)for(let r=0;r<e.cols+1;r++)n.write(e.vEdges[c][r].type,3);for(let c=0;c<e.rows+1;c++)for(let r=0;r<e.cols;r++)n.write(e.hEdges[c][r].type,3);for(let c=0;c<e.rows+1;c++)for(let r=0;r<e.cols+1;r++)n.write(e.nodes[c][r].type,3);n.write(+!!t.useHexagons,1),n.write(+!!t.useSquares,1),n.write(+!!t.useStars,1),n.write(+!!t.useTetris,1),n.write(+!!t.useTetrisNegative,1),n.write(+!!t.useEraser,1),n.write(+!!t.useBrokenEdges,1),n.write(t.symmetry??0,2),n.write(Math.round((t.complexity??0)*254),8),n.write(Math.round((t.difficulty??0)*254),8),n.write(Math.round((t.pathLength??0)*254),8);let o=n.finish(),i=new Uint8Array(await new Response(new Blob([o.buffer]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()),u=0;for(let c of i)u^=c;let y=new Uint8Array(i.length+1);return y.set(i),y[i.length]=u,btoa(String.fromCharCode(...y)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}static async deserialize(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4;)t+="=";let n=atob(t),s=Uint8Array.from(n,H=>H.charCodeAt(0)),h=0;for(let H=0;H<s.length-1;H++)h^=s[H];if(h!==s.at(-1))throw new Error("Invalid parity data");let o=new Uint8Array(await new Response(new Blob([s.slice(0,-1).buffer]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer()),i=new re(o),u=i.read(6),y=i.read(6),c=i.read(2),r=i.read(5),l=[];for(let H=0;H<r;H++){let O=i.read(4),A=i.read(4),M=[];for(let E=0;E<O;E++){let R=[];for(let K=0;K<A;K++)R.push(i.read(1));M.push(R)}l.push(M)}let a=[];for(let H=0;H<u;H++){let O=[];for(let A=0;A<y;A++){let M=i.read(3),E=i.read(3),R=i.read(1),K={type:M,color:E};R&&(K.shape=l[i.read(5)].map(I=>I.slice())),O.push(K)}a.push(O)}let f=Array.from({length:u},()=>Array.from({length:y+1},()=>({type:i.read(3)}))),d=Array.from({length:u+1},()=>Array.from({length:y},()=>({type:i.read(3)}))),x=Array.from({length:u+1},()=>Array.from({length:y+1},()=>({type:i.read(3)}))),m=()=>{let H=i.read(8);return Math.round(H/254*1e3)/1e3},p={},b=!!i.read(1),g=!!i.read(1),C=!!i.read(1),v=!!i.read(1),S=!!i.read(1),P=!!i.read(1),w=!!i.read(1),T=i.read(2);b&&(p.useHexagons=!0),g&&(p.useSquares=!0),C&&(p.useStars=!0),v&&(p.useTetris=!0),S&&(p.useTetrisNegative=!0),P&&(p.useEraser=!0),w&&(p.useBrokenEdges=!0),p.symmetry=T;let z=m(),N=m(),$=m();return z!==0&&(p.complexity=z),N!==0&&(p.difficulty=N),$!==0&&(p.pathLength=$),{puzzle:{rows:u,cols:y,cells:a,vEdges:f,hEdges:d,nodes:x,symmetry:c},options:p}}};var le=class{canvas;ctx;puzzle=null;options;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;invalidatedCells=[];invalidatedEdges=[];invalidatedNodes=[];errorCells=[];errorEdges=[];errorNodes=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;canvasRect=null;constructor(e,t,n={}){if(typeof e=="string"){if(typeof document>"u")throw new Error("Cannot look up canvas by ID in a non-browser environment.");let h=document.getElementById(e);if(!(h instanceof HTMLCanvasElement))throw new Error(`Element with id "${e}" is not a canvas.`);this.canvas=h}else this.canvas=e;let s=this.canvas.getContext("2d");if(!s)throw new Error("Could not get 2D context.");this.ctx=s,this.ctx.imageSmoothingEnabled=!1,this.options=this.mergeOptions(n),t&&this.setPuzzle(t),this.initEvents(),this.animate()}mergeOptions(e){let t={blinkDuration:e.animations?.blinkDuration??this.options?.animations?.blinkDuration??1e3,fadeDuration:e.animations?.fadeDuration??this.options?.animations?.fadeDuration??1e3,blinkPeriod:e.animations?.blinkPeriod??this.options?.animations?.blinkPeriod??800},n={path:e.colors?.path??this.options?.colors?.path??"#ffcc00",error:e.colors?.error??this.options?.colors?.error??"#ff4444",success:e.colors?.success??this.options?.colors?.success??"#ffcc00",symmetry:e.colors?.symmetry??this.options?.colors?.symmetry??"rgba(255, 255, 255, 0.5)",interrupted:e.colors?.interrupted??this.options?.colors?.interrupted??"#ffcc00",grid:e.colors?.grid??this.options?.colors?.grid??"#555",node:e.colors?.node??this.options?.colors?.node??"#555",hexagon:e.colors?.hexagon??this.options?.colors?.hexagon??"#000",hexagonMain:e.colors?.hexagonMain??this.options?.colors?.hexagonMain??"#00ffff",hexagonSymmetry:e.colors?.hexagonSymmetry??this.options?.colors?.hexagonSymmetry??"#ffff00",colorMap:e.colors?.colorMap??this.options?.colors?.colorMap??{[q.Black]:"#000",[q.White]:"#fff",[q.Red]:"#f00",[q.Blue]:"#00f",[q.Cyan]:"#00ffff",[q.None]:"#ffcc00"},colorList:e.colors?.colorList??this.options?.colors?.colorList};return{gridPadding:e.gridPadding??this.options?.gridPadding??60,cellSize:e.cellSize??this.options?.cellSize??80,nodeRadius:e.nodeRadius??this.options?.nodeRadius??6,startNodeRadius:e.startNodeRadius??this.options?.startNodeRadius??22,pathWidth:e.pathWidth??this.options?.pathWidth??18,exitLength:e.exitLength??this.options?.exitLength??25,autoResize:e.autoResize??this.options?.autoResize??!0,blinkMarksOnError:e.blinkMarksOnError??this.options?.blinkMarksOnError??!0,stayPathOnError:e.stayPathOnError??this.options?.stayPathOnError??!0,animations:t,colors:n,onPathComplete:e.onPathComplete??this.options?.onPathComplete??(()=>{})}}setPuzzle(e){this.puzzle=e,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw()}setOptions(e){this.options=this.mergeOptions({...this.options,...e}),this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}setValidationResult(e,t=[],n=[],s=[],h=[],o=[],i=[]){this.invalidatedCells=t,this.invalidatedEdges=n,this.invalidatedNodes=o,this.errorCells=s,this.errorEdges=h,this.errorNodes=i,this.eraserAnimationStartTime=Date.now(),e?(this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0}resizeCanvas(){!this.puzzle||!this.canvas||(this.canvas.width=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,this.canvas.height=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2)}setCanvasRect(e){this.canvasRect=e}initEvents(){typeof window>"u"||!(this.canvas instanceof HTMLCanvasElement)||(this.canvas.addEventListener("mousedown",e=>this.handleStart(e)),window.addEventListener("mousemove",e=>this.handleMove(e)),window.addEventListener("mouseup",e=>this.handleEnd(e)),this.canvas.addEventListener("touchstart",e=>{this.handleStart(e.touches[0])&&e.preventDefault()},{passive:!1}),window.addEventListener("touchmove",e=>{this.isDrawing&&e.preventDefault(),this.handleMove(e.touches[0])},{passive:!1}),window.addEventListener("touchend",e=>{this.isDrawing&&e.preventDefault(),this.handleEnd(e.changedTouches[0])},{passive:!1}))}getCanvasCoords(e,t){return{x:this.options.gridPadding+e*this.options.cellSize,y:this.options.gridPadding+t*this.options.cellSize}}getExitDir(e,t){return!this.puzzle||this.puzzle.nodes[t]?.[e]?.type!==2?null:e===this.puzzle.cols?{x:1,y:0}:e===0?{x:-1,y:0}:t===0?{x:0,y:-1}:t===this.puzzle.rows?{x:0,y:1}:{x:1,y:0}}handleStart(e){if(!this.puzzle)return!1;let t=this.canvasRect||(this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),n=(e.clientX-t.left)*(this.canvas.width/t.width),s=(e.clientY-t.top)*(this.canvas.height/t.height);for(let h=0;h<=this.puzzle.rows;h++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[h][o].type===1){let i=this.getCanvasCoords(o,h);if(Math.hypot(i.x-n,i.y-s)<this.options.startNodeRadius)return this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.isDrawing=!0,this.path=[{x:o,y:h}],this.currentMousePos=i,this.exitTipPos=null,this.draw(),!0}return!1}handleMove(e){if(!this.puzzle||!this.isDrawing)return;let t=this.canvasRect||(this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width,height:this.canvas.height}),n=(e.clientX-t.left)*(this.canvas.width/t.width),s=(e.clientY-t.top)*(this.canvas.height/t.height),h=this.path[this.path.length-1],o=this.getCanvasCoords(h.x,h.y),i=n-o.x,u=s-o.y,y=this.puzzle.symmetry||0,c=this.getExitDir(h.x,h.y),r=Math.abs(i)>Math.abs(u)?{x:i>0?1:-1,y:0}:{x:0,y:u>0?1:-1};if(c&&r.x===c.x&&r.y===c.y){let d=i*c.x+u*c.y,x=Math.max(0,Math.min(d,this.options.exitLength));this.currentMousePos={x:o.x+c.x*x,y:o.y+c.y*x},this.draw();return}let l=(d,x)=>{let m=this.getEdgeType(h,d);if(d.x<0||d.x>this.puzzle.cols||d.y<0||d.y>this.puzzle.rows||m===2){this.currentMousePos=o;return}let p=m===1?this.options.cellSize*.35:this.options.cellSize,b=this.getEdgeKey(h,d);if(!(this.path.length>=2&&d.x===this.path[this.path.length-2].x&&d.y===this.path[this.path.length-2].y)){for(let v=0;v<this.path.length-1;v++)if(this.getEdgeKey(this.path[v],this.path[v+1])===b){p=0;break}}if(this.path.some(v=>v.x===d.x&&v.y===d.y)&&this.path.length>=2){let v=this.path[this.path.length-2];(d.x!==v.x||d.y!==v.y)&&(p=Math.min(p,this.options.cellSize*.5-this.options.pathWidth*.5))}if(y!==0){let v=this.getSymmetricalPoint(h),S=this.getSymmetricalPoint(d),P=this.getEdgeType(v,S),w=this.getSymmetryPath(this.path),T=this.getEdgeKey(v,S);if(S.x<0||S.x>this.puzzle.cols||S.y<0||S.y>this.puzzle.rows||P===2){this.currentMousePos=o;return}P===1&&(p=Math.min(p,this.options.cellSize*.35));let z=w.some(M=>M.x===d.x&&M.y===d.y),N=this.path.some(M=>M.x===S.x&&M.y===S.y),$=d.x===S.x&&d.y===S.y,H=w.some((M,E)=>E<w.length-1&&this.getEdgeKey(w[E],w[E+1])===b),O=this.path.some((M,E)=>E<this.path.length-1&&this.getEdgeKey(this.path[E],this.path[E+1])===T);(z||N||$||H||O||b===T)&&(p=Math.min(p,this.options.cellSize*.5-this.options.pathWidth*.5))}d.x!==h.x?this.currentMousePos={x:o.x+Math.max(-p,Math.min(p,x)),y:o.y}:this.currentMousePos={x:o.x,y:o.y+Math.max(-p,Math.min(p,x))}};if(Math.abs(i)>Math.abs(u)){let d=i>0?1:-1;l({x:h.x+d,y:h.y},i)}else{let d=u>0?1:-1;l({x:h.x,y:h.y+d},u)}let a=[{x:h.x+1,y:h.y},{x:h.x-1,y:h.y},{x:h.x,y:h.y+1},{x:h.x,y:h.y-1}],f=this.getSymmetryPath(this.path);for(let d of a)if(d.x>=0&&d.x<=this.puzzle.cols&&d.y>=0&&d.y<=this.puzzle.rows){let x=this.getCanvasCoords(d.x,d.y);if(Math.hypot(x.x-this.currentMousePos.x,x.y-this.currentMousePos.y)<this.options.cellSize*.3){let p=this.path.findIndex(b=>b.x===d.x&&b.y===d.y);if(p===-1){if(y!==0){let b=this.getSymmetricalPoint(d);if(d.x===b.x&&d.y===b.y||this.path.some(v=>v.x===b.x&&v.y===b.y)||f.some(v=>v.x===d.x&&v.y===d.y))continue;let g=this.getEdgeKey(h,d),C=this.getEdgeKey(this.getSymmetricalPoint(h),b);if(g===C)continue}this.path.push(d)}else p===this.path.length-2&&this.path.pop()}}this.draw()}handleEnd(e){if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let t=this.path[this.path.length-1],n=this.getCanvasCoords(t.x,t.y),s=this.getExitDir(t.x,t.y);if(s){let h=this.currentMousePos.x-n.x,o=this.currentMousePos.y-n.y;if(h*s.x+o*s.y>0){this.exitTipPos={x:n.x+s.x*this.options.exitLength,y:n.y+s.y*this.options.exitLength},this.options.onPathComplete(this.path);return}}this.exitTipPos=s?{...this.currentMousePos}:null,this.startFade(this.options.colors.interrupted)}getEdgeType(e,t){if(!this.puzzle)return 2;if(e.x===t.x){let n=Math.min(e.y,t.y);return n<0||n>=this.puzzle.rows?2:this.puzzle.vEdges[n][e.x].type}else{let n=Math.min(e.x,t.x);return n<0||n>=this.puzzle.cols?2:this.puzzle.hEdges[e.y][n].type}}startFade(e="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=e,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){let e=Date.now();if(this.isFading){let t=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=t,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0)}this.isInvalidPath&&!this.options.stayPathOnError&&!this.isFading&&this.path.length>0&&this.startFade(this.options.colors.error),this.draw(),typeof requestAnimationFrame<"u"&&requestAnimationFrame(()=>this.animate())}draw(){if(!this.puzzle||!this.ctx)return;let e=this.ctx,t=Date.now();if(e.globalAlpha=1,e.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(e),this.drawConstraints(e),this.drawNodes(e),this.path.length===0&&!this.isDrawing&&this.drawRipples(e),this.isFading){if(this.drawPath(e,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let n=this.getSymmetryPath(this.fadingPath),s=this.options.colors.symmetry;if(this.isInvalidPath){let o=this.colorToRgba(s).a;s=this.setAlpha(this.options.colors.error,o)}let h=null;if(this.fadingTipPos){let o=(this.fadingTipPos.x-this.options.gridPadding)/this.options.cellSize,i=(this.fadingTipPos.y-this.options.gridPadding)/this.options.cellSize,u=this.getSymmetricalPoint({x:o,y:i});h={x:u.x*this.options.cellSize+this.options.gridPadding,y:u.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,n,!1,s,this.fadeOpacity,h)}}else if(this.path.length>0){let n=this.options.colors.path,s=this.colorToRgba(n).a,h=this.options.colors.error,o=this.isInvalidPath?this.setAlpha(h,s):n;this.isSuccessFading&&!this.puzzle.symmetry&&(o=this.setAlpha(this.options.colors.success,s));let i=1;if(!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let u=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),y=this.options.animations.blinkDuration;u<y&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(o=this.options.colors.error,this.options.stayPathOnError||(i=Math.max(0,1-u/this.options.animations.fadeDuration)))}if(this.drawPath(e,this.path,this.isDrawing,o,i,this.isDrawing?this.currentMousePos:this.exitTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let u=this.getSymmetryPath(this.path),y=this.options.colors.symmetry,c=this.colorToRgba(y).a,r=y,l=i;if(this.isInvalidPath&&(r=this.setAlpha(h,c)),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let f=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),d=this.options.animations.blinkDuration;f<d&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(r=this.options.colors.error)}let a=null;if(this.isDrawing||this.exitTipPos){let f=this.isDrawing?this.currentMousePos:this.exitTipPos,d=(f.x-this.options.gridPadding)/this.options.cellSize,x=(f.y-this.options.gridPadding)/this.options.cellSize,m=this.getSymmetricalPoint({x:d,y:x},!0);a={x:m.x*this.options.cellSize+this.options.gridPadding,y:m.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,u,this.isDrawing,r,l,a)}}}drawRipples(e){if(!this.puzzle)return;let t=(Date.now()-this.startTime)/500;for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)if(this.puzzle.nodes[n][s].type===2){let o=this.getCanvasCoords(s,n),i=this.getExitDir(s,n);if(!i)continue;let u={x:o.x+i.x*this.options.exitLength,y:o.y+i.y*this.options.exitLength},y=t%4,c=y*5,r=Math.max(0,1-y/3);e.beginPath(),e.arc(u.x,u.y,c,0,Math.PI*2),e.strokeStyle=`rgba(170, 170, 170, ${r*.4})`,e.lineWidth=2,e.stroke()}}drawGrid(e){if(!this.puzzle||!this.options.colors.grid)return;e.strokeStyle=this.options.colors.grid,e.lineWidth=12,e.lineCap="round";let t=(n,s,h)=>{if(h!==2)if(h===1){let i={x:n.x+(s.x-n.x)*.35,y:n.y+(s.y-n.y)*.35},u={x:n.x+(s.x-n.x)*(.5+.15),y:n.y+(s.y-n.y)*(.5+.15)};e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(i.x,i.y),e.stroke(),e.beginPath(),e.moveTo(u.x,u.y),e.lineTo(s.x,s.y),e.stroke()}else e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(s.x,s.y),e.stroke()};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<this.puzzle.cols;s++)t(this.getCanvasCoords(s,n),this.getCanvasCoords(s+1,n),this.puzzle.hEdges[n][s].type);for(let n=0;n<this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)t(this.getCanvasCoords(s,n),this.getCanvasCoords(s,n+1),this.puzzle.vEdges[n][s].type)}drawConstraints(e){if(!this.puzzle)return;let t=Date.now(),n=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;for(let o=0;o<this.puzzle.rows;o++)for(let i=0;i<this.puzzle.cols;i++){let u=this.puzzle.cells[o][i],y=this.getCanvasCoords(i+.5,o+.5),c=this.invalidatedCells.some(x=>x.x===i&&x.y===o),r=this.errorCells.some(x=>x.x===i&&x.y===o),l=1,a,f=this.getColorCode(u.color),d=this.options.colors.error;if(r&&this.options.blinkMarksOnError&&(a=this.lerpColor(f,d,n)),c){let x=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),m=this.options.animations.blinkDuration;if(x<m){if(this.options.blinkMarksOnError){let p=Math.min(1,x/200),b=x>m*.8?(m-x)/(m*.2):1,g=Math.min(p,b);a=this.lerpColor(f,d,n*g)}}else l=Math.max(.3,1-(x-m)/this.options.animations.fadeDuration)}if(l<1||a){let{canvas:x,ctx:m}=this.prepareOffscreen();this.drawConstraintItem(m,u,y,a),e.save(),e.globalAlpha=l,e.drawImage(x,0,0),e.restore()}else this.drawConstraintItem(e,u,y)}e.lineWidth=2;let s=8,h=o=>o===3||o===3?this.options.colors.hexagon:o===4||o===4?this.options.colors.hexagonMain:o===5||o===5?this.options.colors.hexagonSymmetry:this.options.colors.hexagon;for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<this.puzzle.cols;i++){let u=this.puzzle.hEdges[o][i].type;if(u===3||u===4||u===5){let y=this.getCanvasCoords(i+.5,o);e.save();let c=this.invalidatedEdges.some(a=>a.type==="h"&&a.r===o&&a.c===i),r=this.errorEdges.some(a=>a.type==="h"&&a.r===o&&a.c===i),l=h(u);if(r&&this.options.blinkMarksOnError){let a=this.lerpColor(l,this.options.colors.error,n);this.drawHexagon(e,y.x,y.y,s,a)}else if(c){let a=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),f=this.options.animations.blinkDuration;if(a<f)if(this.options.blinkMarksOnError){let d=Math.min(1,a/200),x=a>f*.8?(f-a)/(f*.2):1,m=Math.min(d,x),p=this.lerpColor(l,this.options.colors.error,n*m);this.drawHexagon(e,y.x,y.y,s,p)}else this.drawHexagon(e,y.x,y.y,s,l);else e.globalAlpha*=Math.max(.3,1-(a-f)/this.options.animations.fadeDuration),this.drawHexagon(e,y.x,y.y,s,l)}else this.drawHexagon(e,y.x,y.y,s,l);e.restore()}}for(let o=0;o<this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++){let u=this.puzzle.vEdges[o][i].type;if(u===3||u===4||u===5){let y=this.getCanvasCoords(i,o+.5);e.save();let c=this.invalidatedEdges.some(a=>a.type==="v"&&a.r===o&&a.c===i),r=this.errorEdges.some(a=>a.type==="v"&&a.r===o&&a.c===i),l=h(u);if(r&&this.options.blinkMarksOnError){let a=this.lerpColor(l,this.options.colors.error,n);this.drawHexagon(e,y.x,y.y,s,a)}else if(c){let a=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),f=this.options.animations.blinkDuration;if(a<f)if(this.options.blinkMarksOnError){let d=Math.min(1,a/200),x=a>f*.8?(f-a)/(f*.2):1,m=Math.min(d,x),p=this.lerpColor(l,this.options.colors.error,n*m);this.drawHexagon(e,y.x,y.y,s,p)}else this.drawHexagon(e,y.x,y.y,s,l);else e.globalAlpha*=Math.max(.3,1-(a-f)/this.options.animations.fadeDuration),this.drawHexagon(e,y.x,y.y,s,l)}else this.drawHexagon(e,y.x,y.y,s,l);e.restore()}}for(let o=0;o<=this.puzzle.rows;o++)for(let i=0;i<=this.puzzle.cols;i++){let u=this.puzzle.nodes[o][i].type;if(u===3||u===4||u===5){let y=this.getCanvasCoords(i,o);e.save();let c=this.invalidatedNodes.some(a=>a.x===i&&a.y===o),r=this.errorNodes.some(a=>a.x===i&&a.y===o),l=h(u);if(r&&this.options.blinkMarksOnError){let a=this.lerpColor(l,this.options.colors.error,n);this.drawHexagon(e,y.x,y.y,s,a)}else if(c){let a=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),f=this.options.animations.blinkDuration;if(a<f)if(this.options.blinkMarksOnError){let d=Math.min(1,a/200),x=a>f*.8?(f-a)/(f*.2):1,m=Math.min(d,x),p=this.lerpColor(l,this.options.colors.error,n*m);this.drawHexagon(e,y.x,y.y,s,p)}else this.drawHexagon(e,y.x,y.y,s,l);else e.globalAlpha*=Math.max(.3,1-(a-f)/this.options.animations.fadeDuration),this.drawHexagon(e,y.x,y.y,s,l)}else this.drawHexagon(e,y.x,y.y,s,l);e.restore()}}}drawConstraintItem(e,t,n,s){t.type===1?(e.fillStyle=s||this.getColorCode(t.color),this.drawRoundedRect(e,n.x-26/2,n.y-26/2,26,26,8)):t.type===2?this.drawStar(e,n.x,n.y,12,16,8,t.color,s):t.type===3||t.type===4?this.drawTetris(e,n.x,n.y,t.shape||[],t.type===4,t.color,!1,s):t.type===6||t.type===7?this.drawTetris(e,n.x,n.y,t.shape||[],t.type===7,t.color,!0,s):t.type===5&&this.drawEraser(e,n.x,n.y,14,3,t.color,s)}drawNodes(e){if(!this.puzzle)return;let t=(n,s)=>{let h=[];return n>0&&h.push(this.puzzle.hEdges[s][n-1].type),n<this.puzzle.cols&&h.push(this.puzzle.hEdges[s][n].type),s>0&&h.push(this.puzzle.vEdges[s-1][n].type),s<this.puzzle.rows&&h.push(this.puzzle.vEdges[s][n].type),h.length>0&&h.every(o=>o===2)};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++){if(t(s,n))continue;let h=this.puzzle.nodes[n][s];if(h.type===3||h.type===4||h.type===5)continue;let o=this.getCanvasCoords(s,n);if(h.type===1)this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill();else if(h.type===2){let i=this.getExitDir(s,n);if(!i)continue;this.options.colors.node&&(e.strokeStyle=this.options.colors.node),e.lineWidth=12,e.lineCap="round",e.beginPath(),e.moveTo(o.x,o.y),e.lineTo(o.x+i.x*this.options.exitLength,o.y+i.y*this.options.exitLength),e.stroke()}else this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.nodeRadius,0,Math.PI*2),e.fill()}}drawPath(e,t,n,s,h,o=null){if(t.length===0||!s||s==="transparent")return;let i=this.colorToRgba(s),u=`rgb(${i.r},${i.g},${i.b})`,y=h*i.a,{canvas:c,ctx:r}=this.prepareOffscreen();this.drawPathInternal(r,t,n,u,o),e.save(),e.globalAlpha=y,e.drawImage(c,0,0),e.restore()}drawPathInternal(e,t,n,s,h=null){e.save(),e.strokeStyle=s,e.fillStyle=s,e.lineWidth=this.options.pathWidth,e.lineCap="round",e.lineJoin="round",e.beginPath();let o=this.getCanvasCoords(t[0].x,t[0].y);e.moveTo(o.x,o.y);for(let u=1;u<t.length;u++){let y=this.getCanvasCoords(t[u].x,t[u].y);e.lineTo(y.x,y.y)}let i=h||this.currentMousePos;(n||h)&&e.lineTo(i.x,i.y),e.stroke(),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill(),(n||h)&&(e.beginPath(),e.arc(i.x,i.y,this.options.pathWidth/2,0,Math.PI*2),e.fill()),e.restore()}drawRoundedRect(e,t,n,s,h,o){e.beginPath(),e.moveTo(t+o,n),e.lineTo(t+s-o,n),e.quadraticCurveTo(t+s,n,t+s,n+o),e.lineTo(t+s,n+h-o),e.quadraticCurveTo(t+s,n+h,t+s-o,n+h),e.lineTo(t+o,n+h),e.quadraticCurveTo(t,n+h,t,n+h-o),e.lineTo(t,n+o),e.quadraticCurveTo(t,n,t+o,n),e.closePath(),e.fill()}drawHexagon(e,t,n,s,h){if(!(!this.options.colors.hexagon&&!h)){e.fillStyle=h||this.options.colors.hexagon,e.beginPath();for(let o=0;o<6;o++){let i=Math.PI/3*o,u=t+s*Math.cos(i),y=n+s*Math.sin(i);o===0?e.moveTo(u,y):e.lineTo(u,y)}e.closePath(),e.fill()}}drawEraser(e,t,n,s,h,o,i){e.strokeStyle=i||this.getColorCode(o),e.lineWidth=s*.5,e.lineCap="butt";let u=.5;e.beginPath();for(let y=0;y<h;y++){let c=Math.PI*2/h*y+u,r=t+s*Math.cos(c),l=n+s*Math.sin(c);e.moveTo(t,n),e.lineTo(r,l)}e.stroke()}drawStar(e,t,n,s,h,o,i,u){e.fillStyle=u||this.getColorCode(i),e.beginPath();for(let y=0;y<o*2;y++){let c=y%2===0?h:s,r=Math.PI/o*y,l=t+c*Math.cos(r),a=n+c*Math.sin(r);y===0?e.moveTo(l,a):e.lineTo(l,a)}e.closePath(),e.fill()}drawTetris(e,t,n,s,h,o,i,u){if(!s||s.length===0)return;let y=12,c=2,r=s[0].length*y+(s[0].length-1)*c,l=s.length*y+(s.length-1)*c;e.save(),e.translate(t,n),h&&e.rotate(Math.PI/8);let a=u||this.getColorCode(o,i?"#00ffff":"#ffcc00");if(i){e.strokeStyle=a,e.lineWidth=2;for(let f=0;f<s.length;f++)for(let d=0;d<s[f].length;d++)if(s[f][d]){let x=d*(y+c)-r/2,m=f*(y+c)-l/2;e.strokeRect(x+1,m+1,y-2,y-2)}}else{e.fillStyle=a;for(let f=0;f<s.length;f++)for(let d=0;d<s[f].length;d++)if(s[f][d]){let x=d*(y+c)-r/2,m=f*(y+c)-l/2;e.fillRect(x,m,y,y)}}e.restore()}getColorCode(e,t="#666"){return this.options.colors.colorList&&this.options.colors.colorList[e]!==void 0?this.options.colors.colorList[e]:this.options.colors.colorMap&&this.options.colors.colorMap[e]!==void 0?this.options.colors.colorMap[e]:t}colorToRgba(e){if(!e||e==="transparent")return{r:0,g:0,b:0,a:0};if(e.startsWith("rgba")||e.startsWith("rgb")){let n=e.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);if(n)return{r:parseInt(n[1]),g:parseInt(n[2]),b:parseInt(n[3]),a:n[4]?parseFloat(n[4]):1}}let t=e.startsWith("#")?e.slice(1):e;if((t.length===3||t.length===4)&&(t=t.split("").map(n=>n+n).join("")),t.length===6){let n=parseInt(t,16);return{r:n>>16&255,g:n>>8&255,b:n&255,a:1}}else if(t.length===8){let n=parseInt(t,16);return{r:n>>24&255,g:n>>16&255,b:n>>8&255,a:(n&255)/255}}return{r:0,g:0,b:0,a:1}}lerpColor(e,t,n){try{let s=this.colorToRgba(e),h=this.colorToRgba(t),o=Math.round(s.r+(h.r-s.r)*n),i=Math.round(s.g+(h.g-s.g)*n),u=Math.round(s.b+(h.b-s.b)*n),y=s.a+(h.a-s.a)*n;return`rgba(${o},${i},${u},${y})`}catch{return e}}setAlpha(e,t){let n=this.colorToRgba(e);return`rgba(${n.r},${n.g},${n.b},${t})`}getSymmetryPath(e){return!this.puzzle||!this.puzzle.symmetry?[]:e.map(t=>this.getSymmetricalPoint(t))}getSymmetricalPoint(e,t=!1){if(!this.puzzle||!this.puzzle.symmetry)return{...e};let{cols:n,rows:s,symmetry:h}=this.puzzle;return h===1?{x:n-e.x,y:e.y}:h===2?{x:e.x,y:s-e.y}:h===3?{x:n-e.x,y:s-e.y}:{...e}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}prepareOffscreen(){if(!this.offscreenCanvas){if(typeof document<"u")this.offscreenCanvas=document.createElement("canvas");else if(typeof OffscreenCanvas<"u")this.offscreenCanvas=new OffscreenCanvas(this.canvas.width,this.canvas.height);else throw new Error("Offscreen canvas not supported in this environment.");this.offscreenCtx=this.offscreenCanvas.getContext("2d")}if((this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),!this.offscreenCtx)throw new Error("Could not get offscreen 2D context.");return this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx}}};var he=class{generator;validator;constructor(){this.generator=new te,this.validator=new _}createPuzzle(e,t,n={}){return this.generator.generate(e,t,n).export()}validateSolution(e,t){let n=Y.fromData(e);return this.validator.validate(n,t)}calculateDifficulty(e){let t=Y.fromData(e);return this.validator.calculateDifficulty(t)}};export{j as CellType,q as Color,ce as Direction,Z as EdgeType,Y as Grid,ee as NodeType,te as PuzzleGenerator,ae as PuzzleSerializer,_ as PuzzleValidator,ne as SymmetryType,he as WitnessCore,le as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
