/*!
 * MiniWitness 1.1.6
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var le=(s=>(s[s.Up=0]="Up",s[s.Right=1]="Right",s[s.Down=2]="Down",s[s.Left=3]="Left",s))(le||{}),j=(o=>(o[o.None=0]="None",o[o.Square=1]="Square",o[o.Star=2]="Star",o[o.Tetris=3]="Tetris",o[o.TetrisRotated=4]="TetrisRotated",o[o.Eraser=5]="Eraser",o))(j||{}),_=(s=>(s[s.Normal=0]="Normal",s[s.Broken=1]="Broken",s[s.Absent=2]="Absent",s[s.Hexagon=3]="Hexagon",s))(_||{}),Q=(s=>(s[s.Normal=0]="Normal",s[s.Start=1]="Start",s[s.End=2]="End",s[s.Hexagon=3]="Hexagon",s))(Q||{}),ee=(s=>(s[s.None=0]="None",s[s.Horizontal=1]="Horizontal",s[s.Vertical=2]="Vertical",s[s.Rotational=3]="Rotational",s))(ee||{}),A={None:0,Black:1,White:2,Red:3,Blue:4};var U=class X{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];symmetry=0;constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:A.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes,symmetry:this.symmetry}))}static fromData(e){let t=new X(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t.symmetry=e.symmetry||0,t}};var Y=class{validate(e,t,n){let s=t.points;if(s.length<2)return{isValid:!1,errorReason:"Path too short"};let r=e.symmetry||0,o=[];if(r!==0)for(let d of s)o.push(this.getSymmetricalPoint(e,d));let a=s[0],h=s[s.length-1];if(e.nodes[a.y][a.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[h.y][h.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};if(r!==0){let d=o[0],u=o[o.length-1];if(e.nodes[d.y][d.x].type!==1)return{isValid:!1,errorReason:"Symmetrical path must start at Start Node"};if(e.nodes[u.y][u.x].type!==2)return{isValid:!1,errorReason:"Symmetrical path must end at End Node"}}let c=new Set,i=new Set;if(c.add(`${a.x},${a.y}`),r!==0){let d=o[0];if(c.has(`${d.x},${d.y}`))return{isValid:!1,errorReason:"Paths collide at start"};c.add(`${d.x},${d.y}`)}for(let d=0;d<s.length-1;d++){let u=s[d],p=s[d+1];if(Math.abs(u.x-p.x)+Math.abs(u.y-p.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let g=`${p.x},${p.y}`;if(c.has(g))return{isValid:!1,errorReason:"Self-intersecting path or path collision"};if(c.add(g),this.isBrokenEdge(e,u,p))return{isValid:!1,errorReason:"Passed through broken edge"};if(i.add(this.getEdgeKey(u,p)),r!==0){let b=o[d],x=o[d+1],P=`${x.x},${x.y}`;if(c.has(P))return{isValid:!1,errorReason:"Path collision"};if(c.add(P),this.isBrokenEdge(e,b,x))return{isValid:!1,errorReason:"Symmetrical path passed through broken edge"};let E=this.getEdgeKey(b,x);if(i.has(E))return{isValid:!1,errorReason:"Paths cross the same edge"};i.add(E)}}let l=this.calculateRegions(e,s,o,n),y=this.getMissedHexagons(e,s,o),f=this.validateWithErasers(e,l,y.edges,y.nodes);return f.regions=l,f}isBrokenEdge(e,t,n){let s;if(t.x===n.x){let r=Math.min(t.y,n.y);s=e.vEdges[r][t.x].type}else{let r=Math.min(t.x,n.x);s=e.hEdges[t.y][r].type}return s===1||s===2}isAbsentEdge(e,t,n){if(t.x===n.x){let s=Math.min(t.y,n.y);return e.vEdges[s][t.x].type===2}else{let s=Math.min(t.x,n.x);return e.hEdges[t.y][s].type===2}}getMissedHexagons(e,t,n=[]){let s=new Set,r=new Set;for(let h=0;h<t.length;h++)r.add(`${t[h].x},${t[h].y}`),h<t.length-1&&s.add(this.getEdgeKey(t[h],t[h+1]));for(let h=0;h<n.length;h++)r.add(`${n[h].x},${n[h].y}`),h<n.length-1&&s.add(this.getEdgeKey(n[h],n[h+1]));let o=[];for(let h=0;h<=e.rows;h++)for(let c=0;c<e.cols;c++)if(e.hEdges[h][c].type===3){let i=this.getEdgeKey({x:c,y:h},{x:c+1,y:h});s.has(i)||o.push({type:"h",r:h,c})}for(let h=0;h<e.rows;h++)for(let c=0;c<=e.cols;c++)if(e.vEdges[h][c].type===3){let i=this.getEdgeKey({x:c,y:h},{x:c,y:h+1});s.has(i)||o.push({type:"v",r:h,c})}let a=[];for(let h=0;h<=e.rows;h++)for(let c=0;c<=e.cols;c++)e.nodes[h][c].type===3&&(r.has(`${c},${h}`)||a.push({x:c,y:h}));return{edges:o,nodes:a}}validateWithErasers(e,t,n,s){let r=[],o=!0;for(let f=0;f<t.length;f++){let d=t[f],u=d.filter(x=>e.cells[x.y][x.x].type===5),p=d.filter(x=>e.cells[x.y][x.x].type!==0&&e.cells[x.y][x.x].type!==5),m=[];for(let x=0;x<n.length;x++)this.isHexagonAdjacentToRegion(e,n[x],d)&&m.push(x);let g=[];for(let x=0;x<s.length;x++)this.isNodeHexagonAdjacentToRegion(e,s[x],d)&&g.push(x);let b=this.getPossibleErasures(e,d,u,p,m,g);if(b.length===0){o=!1;let x=this.getBestEffortErasures(e,d,u,p,m,g);r.push([x])}else b.sort((x,P)=>{let E=x.invalidatedCells.length+x.invalidatedHexagons.length+x.invalidatedNodeHexagons.length,M=P.invalidatedCells.length+P.invalidatedHexagons.length+P.invalidatedNodeHexagons.length;return E-M}),r.push(b)}if(o){let f=this.findGlobalAssignment(r,n.length,s.length);if(f)return{isValid:!0,invalidatedCells:f.invalidatedCells,invalidatedEdges:f.invalidatedHexIndices.map(d=>n[d]),invalidatedNodes:f.invalidatedNodeHexIndices.map(d=>s[d])}}let a=[],h=[],c=new Set,i=new Set;for(let f of r){let d=f[0];a.push(...d.errorCells),h.push(...d.invalidatedCells);for(let u of d.invalidatedHexagons)c.add(u);for(let u of d.invalidatedNodeHexagons)i.add(u)}let l=[];for(let f=0;f<n.length;f++)c.has(f)||l.push(n[f]);let y=[];for(let f=0;f<s.length;f++)i.has(f)||y.push(s[f]);return{isValid:!1,errorReason:"Constraints failed",errorCells:a,errorEdges:l,errorNodes:y,invalidatedCells:h,invalidatedEdges:Array.from(c).map(f=>n[f]),invalidatedNodes:Array.from(i).map(f=>s[f])}}isHexagonAdjacentToRegion(e,t,n){let s=new Set(n.map(r=>`${r.x},${r.y}`));if(t.type==="h"){if(t.r>0&&s.has(`${t.c},${t.r-1}`)||t.r<e.rows&&s.has(`${t.c},${t.r}`))return!0}else if(t.c>0&&s.has(`${t.c-1},${t.r}`)||t.c<e.cols&&s.has(`${t.c},${t.r}`))return!0;return!1}isNodeHexagonAdjacentToRegion(e,t,n){let s=new Set(n.map(o=>`${o.x},${o.y}`)),r=[{x:t.x-1,y:t.y-1},{x:t.x,y:t.y-1},{x:t.x-1,y:t.y},{x:t.x,y:t.y}];for(let o of r)if(o.x>=0&&o.x<e.cols&&o.y>=0&&o.y<e.rows&&s.has(`${o.x},${o.y}`))return!0;return!1}getPossibleErasures(e,t,n,s,r,o){let a=[],h=n.length;if(h===0)return this.getRegionErrors(e,t,[]).length===0&&r.length===0&&o.length===0&&a.push({invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!0,errorCells:[]}),a;let c=[...s.map(l=>({type:"cell",pos:l})),...r.map(l=>({type:"hex",index:l})),...o.map(l=>({type:"nodeHex",index:l}))],i=this.getRegionErrors(e,t,[]).length===0&&r.length===0&&o.length===0;for(let l=0;l<=h;l++){let y=this.getNCombinations(n,l);for(let f of y){let d=new Set(f.map(p=>`${p.x},${p.y}`)),u=n.filter(p=>!d.has(`${p.x},${p.y}`));for(let p=0;p<=c.length;p++){if(u.length!==l+p)continue;let m=this.getNCombinations(c,p);for(let g of m){let b=g.filter(w=>w.type==="cell").map(w=>w.pos),x=g.filter(w=>w.type==="hex").map(w=>w.index),P=g.filter(w=>w.type==="nodeHex").map(w=>w.index);if(this.getRegionErrors(e,t,[...b,...f]).length===0){let w=!0;if(i)p>0&&(w=!1);else for(let H=0;H<g.length;H++){let O=[...g.slice(0,H),...g.slice(H+1)],I=O.filter(R=>R.type==="cell").map(R=>R.pos),D=new Set(O.filter(R=>R.type==="hex").map(R=>R.index)),v=new Set(O.filter(R=>R.type==="nodeHex").map(R=>R.index)),S=r.every(R=>D.has(R)),N=o.every(R=>v.has(R));if(this.getRegionErrors(e,t,I).length===0&&S&&N){w=!1;break}}w&&a.push({invalidatedCells:[...b,...f],invalidatedHexagons:x,invalidatedNodeHexagons:P,isValid:!0,errorCells:[]})}}}}}return a}getBestEffortErasures(e,t,n,s,r,o){let a=this.getRegionErrors(e,t,[]);if(a.length===0&&r.length===0&&o.length===0)return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:[...n]};if(n.length>0){let i=[...s.map(d=>({type:"cell",pos:d})),...r.map(d=>({type:"hex",index:d})),...o.map(d=>({type:"nodeHex",index:d}))],l=null,y=1/0,f=d=>{let u=[],p=[],m=[],g=0;for(let w of d)g<n.length&&(w.type==="cell"?u.push(w.pos):w.type==="hex"?p.push(w.index):m.push(w.index),g++);let b=n.length-g,x=Math.floor(b/2),P=n.slice(g,g+x);g+=x*2;let E=this.getRegionErrors(e,t,[...u,...P]);for(let w=g;w<n.length;w++)E.push(n[w]);let M=E.length;M<y&&(y=M,l={invalidatedCells:[...u,...P],invalidatedHexagons:p,invalidatedNodeHexagons:m,isValid:!1,errorCells:E})};f([...a.map(d=>({type:"cell",pos:d})),...r.map(d=>({type:"hex",index:d})),...o.map(d=>({type:"nodeHex",index:d}))]),f(i);for(let d of a)f([{type:"cell",pos:d}]);if(l)return l}let c=[...a,...n];return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:c}}getNCombinations(e,t){let n=[],s=(r,o)=>{if(o.length===t){n.push([...o]);return}for(let a=r;a<e.length;a++)o.push(e[a]),s(a+1,o),o.pop()};return s(0,[]),n}checkRegionValid(e,t,n){return this.getRegionErrors(e,t,n).length===0}getRegionErrors(e,t,n){let s=new Set(n.map(l=>`${l.x},${l.y}`)),r=new Map,o=new Map,a=new Set,h=new Set,c=[];for(let l of t){if(s.has(`${l.x},${l.y}`))continue;let y=e.cells[l.y][l.x];if(y.type===0)continue;let f=y.color;f!==A.None&&(r.set(f,(r.get(f)||0)+1),o.has(f)||o.set(f,[]),o.get(f).push(l)),y.type===1?h.add(f):y.type===2?a.add(f):(y.type===3||y.type===4)&&y.shape&&c.push({shape:y.shape,rotatable:y.type===4,pos:l})}let i=[];if(h.size>1)for(let l of t)s.has(`${l.x},${l.y}`)||e.cells[l.y][l.x].type===1&&i.push(l);for(let l of a)if(r.get(l)!==2){let y=o.get(l)||[];for(let f of y)e.cells[f.y][f.x].type===2&&i.push(f)}if(c.length>0&&!this.checkTetrisConstraint(t,c.map(l=>({shape:l.shape,rotatable:l.rotatable}))))for(let l of c)i.push(l.pos);return i}findGlobalAssignment(e,t,n){let s=e.length,r=new Array(t).fill(0),o=new Array(n).fill(0),a=[],h=[],c=[],i=l=>{if(l===s)return r.every(y=>y===1)&&o.every(y=>y===1);for(let y of e[l]){let f=!0;for(let d of y.invalidatedHexagons)if(r[d]>0){f=!1;break}if(f){for(let d of y.invalidatedNodeHexagons)if(o[d]>0){f=!1;break}}if(f){for(let d of y.invalidatedHexagons)r[d]++,h.push(d);for(let d of y.invalidatedNodeHexagons)o[d]++,c.push(d);if(a.push(...y.invalidatedCells),i(l+1))return!0;for(let d of y.invalidatedHexagons)r[d]--,h.pop();for(let d of y.invalidatedNodeHexagons)o[d]--,c.pop();for(let d=0;d<y.invalidatedCells.length;d++)a.pop()}}return!1};return i(0)?{invalidatedCells:a,invalidatedHexIndices:h,invalidatedNodeHexIndices:c}:null}checkTetrisConstraint(e,t){if(t.reduce((l,y)=>l+this.getShapeArea(y.shape),0)!==e.length)return!1;let s=Math.min(...e.map(l=>l.x)),r=Math.min(...e.map(l=>l.y)),o=Math.max(...e.map(l=>l.x)),a=Math.max(...e.map(l=>l.y)),h=o-s+1,c=a-r+1,i=Array.from({length:c},()=>Array(h).fill(!1));for(let l of e)i[l.y-r][l.x-s]=!0;return this.canTile(i,t)}getShapeArea(e){let t=0;for(let n of e)for(let s of n)s&&t++;return t}canTile(e,t){let n=-1,s=-1;for(let r=0;r<e.length;r++){for(let o=0;o<e[0].length;o++)if(e[r][o]){n=r,s=o;break}if(n!==-1)break}if(n===-1)return t.length===0;if(t.length===0)return!1;for(let r=0;r<t.length;r++){let o=t[r],a=[...t.slice(0,r),...t.slice(r+1)],h=o.rotatable?this.getAllRotations(o.shape):[o.shape];for(let c of h){let i=[];for(let l=0;l<c.length;l++)for(let y=0;y<c[0].length;y++)c[l][y]&&i.push({r:l,c:y});for(let l of i){let y=n-l.r,f=s-l.c;if(this.canPlace(e,c,y,f)){if(this.placePiece(e,c,y,f,!1),this.canTile(e,a))return!0;this.placePiece(e,c,y,f,!0)}}}}return!1}canPlace(e,t,n,s){for(let r=0;r<t.length;r++)for(let o=0;o<t[0].length;o++)if(t[r][o]){let a=n+r,h=s+o;if(a<0||a>=e.length||h<0||h>=e[0].length||!e[a][h])return!1}return!0}placePiece(e,t,n,s,r){for(let o=0;o<t.length;o++)for(let a=0;a<t[0].length;a++)t[o][a]&&(e[n+o][s+a]=r)}getAllRotations(e){let t=[],n=new Set,s=e;for(let r=0;r<4;r++){let o=JSON.stringify(s);n.has(o)||(t.push(s),n.add(o)),s=this.rotate90(s)}return t}rotate90(e){let t=e.length,n=e[0].length,s=Array.from({length:n},()=>Array(t).fill(0));for(let r=0;r<t;r++)for(let o=0;o<n;o++)s[o][t-1-r]=e[r][o];return s}calculateRegions(e,t,n=[],s){let r=[],o=new Set,a=new Set;for(let c=0;c<t.length-1;c++)a.add(this.getEdgeKey(t[c],t[c+1]));for(let c=0;c<n.length-1;c++)a.add(this.getEdgeKey(n[c],n[c+1]));let h=s||this.getExternalCells(e);for(let c=0;c<e.rows;c++)for(let i=0;i<e.cols;i++){if(o.has(`${i},${c}`)||h&&h.has(`${i},${c}`))continue;let l=[],y=[{x:i,y:c}];for(o.add(`${i},${c}`);y.length>0;){let f=y.shift();l.push(f);let d=[{nx:f.x,ny:f.y-1,p1:{x:f.x,y:f.y},p2:{x:f.x+1,y:f.y}},{nx:f.x,ny:f.y+1,p1:{x:f.x,y:f.y+1},p2:{x:f.x+1,y:f.y+1}},{nx:f.x-1,ny:f.y,p1:{x:f.x,y:f.y},p2:{x:f.x,y:f.y+1}},{nx:f.x+1,ny:f.y,p1:{x:f.x+1,y:f.y},p2:{x:f.x+1,y:f.y+1}}];for(let u of d)if(u.nx>=0&&u.nx<e.cols&&u.ny>=0&&u.ny<e.rows){let p=`${u.nx},${u.ny}`;if(!o.has(p)&&!h.has(p)){let m=this.getEdgeKey(u.p1,u.p2);!a.has(m)&&!this.isAbsentEdge(e,u.p1,u.p2)&&(o.add(p),y.push({x:u.nx,y:u.ny}))}}}r.push(l)}return r}getExternalCells(e){let t=new Set,n=[];for(let s=0;s<e.cols;s++)e.hEdges[0][s].type===2&&(t.has(`${s},0`)||(t.add(`${s},0`),n.push({x:s,y:0}))),e.hEdges[e.rows][s].type===2&&(t.has(`${s},${e.rows-1}`)||(t.add(`${s},${e.rows-1}`),n.push({x:s,y:e.rows-1})));for(let s=0;s<e.rows;s++)e.vEdges[s][0].type===2&&(t.has(`0,${s}`)||(t.add(`0,${s}`),n.push({x:0,y:s}))),e.vEdges[s][e.cols].type===2&&(t.has(`${e.cols-1},${s}`)||(t.add(`${e.cols-1},${s}`),n.push({x:e.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),r=[{nx:s.x,ny:s.y-1,edge:e.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:e.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:e.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:e.vEdges[s.y][s.x+1]}];for(let o of r)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return t}getSymmetricalPoint(e,t){let n=e.symmetry||0;return n===1?{x:e.cols-t.x,y:t.y}:n===2?{x:t.x,y:e.rows-t.y}:n===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getSymmetricalPointIndex(e,t){let n=e.cols+1,s=Math.floor(t/n),r=t%n,o=e.symmetry||0,a=s,h=r;return o===1?h=e.cols-r:o===2?a=e.rows-s:o===3&&(h=e.cols-r,a=e.rows-s),a*n+h}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}calculateDifficulty(e){let t=e.rows,n=e.cols,s=n+1,r=(t+1)*s,o=Array.from({length:r},()=>[]),a=[],h=[],c=new Set,i=new Set;for(let v=0;v<=t;v++)for(let S=0;S<=n;S++){let N=v*s+S;if(e.nodes[v][S].type===1&&a.push(N),e.nodes[v][S].type===2&&h.push(N),e.nodes[v][S].type===3&&i.add(N),S<n){let R=N+1,C=e.hEdges[v][S].type,T=C===3,q=C===1||C===2;o[N].push({next:R,isHexagon:T,isBroken:q}),o[R].push({next:N,isHexagon:T,isBroken:q}),T&&c.add(this.getEdgeKey({x:S,y:v},{x:S+1,y:v}))}if(v<t){let R=N+s,C=e.vEdges[v][S].type,T=C===3,q=C===1||C===2;o[N].push({next:R,isHexagon:T,isBroken:q}),o[R].push({next:N,isHexagon:T,isBroken:q}),T&&c.add(this.getEdgeKey({x:S,y:v},{x:S,y:v+1}))}}let l={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},y=c.size+i.size,f=new Set,d=Math.max(1e3,t*n*200),u=this.getExternalCells(e),p=!1;for(let v=0;v<t;v++){for(let S=0;S<n;S++)if(e.cells[v][S].type!==0){p=!0;break}if(p)break}for(let v of a){let S=i.has(v)?1:0,N=e.symmetry||0,R=1n<<BigInt(v);if(N!==0){let C=this.getSymmetricalPointIndex(e,v);if(C===v)continue;R|=1n<<BigInt(C)}this.exploreSearchSpace(e,v,R,[v],S,y,o,h,f,l,d,u,p)}if(l.solutions===0)return 0;let m=c.size+i.size,g=new Set;c.size>0&&g.add(999);let b=0,x=0;for(let v=0;v<t;v++)for(let S=0;S<n;S++){let N=e.cells[v][S];N.type!==0&&(m++,g.add(N.type),N.type===3?b++:N.type===4&&(b++,x++))}let P=l.branchingPoints/(l.totalNodesVisited||1),E=Math.log10(l.totalNodesVisited+1),M=(P*10+E*1.5)/(Math.log2(l.solutions+1)*.5+1);M-=c.size*.05,M+=i.size*.12,b>0&&(M+=x*.5,M+=(b-x)*.2);let w=t*n,H=m/w,O=H<.25?Math.pow(H/.25,4):1,I=g.size<=1?.5:1;M*=O*I;let D=Math.log2(w)/5;return M*=D,Math.max(.01,Math.min(1,M/4))}exploreSearchSpace(e,t,n,s,r,o,a,h,c,i,l,y,f=!0){if(i.totalNodesVisited++,i.maxDepth=Math.max(i.maxDepth,s.length),i.totalNodesVisited>l)return;let d=e.symmetry||0;if(h.includes(t)){if(r===o){let m=s.map(b=>({x:b%(e.cols+1),y:Math.floor(b/(e.cols+1))})),g={points:m};if(d!==0){let b=this.getSymmetricalPointIndex(e,t),x=e.cols+1;if(e.nodes[Math.floor(b/x)][b%x].type!==2)return}if(f){let b=this.validate(e,g,y);if(b.isValid){let x=this.getFingerprint(e,m,b.regions,y);c.has(x)||(c.add(x),i.solutions++)}}else{let b=this.getFingerprint(e,m,void 0,y);c.has(b)||(c.add(b),i.solutions++)}}return}if(!this.canReachEndOptimized(t,n,a,h)){i.backtracks++;return}let u=[];for(let m of a[t]){if(m.isBroken||n&1n<<BigInt(m.next))continue;if(d!==0){let b=this.getSymmetricalPointIndex(e,t),x=this.getSymmetricalPointIndex(e,m.next);if(m.next===x||t===x&&m.next===b)continue}let g=!0;for(let b of a[t])if(b.isHexagon){let x=s.length>=2&&b.next===s[s.length-2],P=b.next===m.next;if(!x&&!P){g=!1;break}}g&&u.push(m)}if(u.length>1&&i.branchingPoints++,e.rows*e.cols>30)for(let m=u.length-1;m>0;m--){let g=Math.floor(Math.random()*(m+1));[u[m],u[g]]=[u[g],u[m]]}let p=e.cols+1;for(let m of u){let g=e.nodes[Math.floor(m.next/p)][m.next%p].type===3?1:0;s.push(m.next);let b=n|1n<<BigInt(m.next);if(d!==0){let x=this.getSymmetricalPointIndex(e,m.next);b|=1n<<BigInt(x)}if(this.exploreSearchSpace(e,m.next,b,s,r+(m.isHexagon?1:0)+g,o,a,h,c,i,l,y,f),s.pop(),i.totalNodesVisited>l)return}}countSolutions(e,t=100){let n=e.rows,s=e.cols,r=s+1,o=(n+1)*r,a=Array.from({length:o},()=>[]),h=[],c=[],i=new Set,l=new Set;for(let p=0;p<=n;p++)for(let m=0;m<=s;m++){let g=p*r+m;if(e.nodes[p][m].type===1&&h.push(g),e.nodes[p][m].type===2&&c.push(g),e.nodes[p][m].type===3&&l.add(g),m<s){let b=g+1,x=e.hEdges[p][m].type,P=x===3,E=x===1||x===2;a[g].push({next:b,isHexagon:P,isBroken:E}),a[b].push({next:g,isHexagon:P,isBroken:E}),P&&i.add(this.getEdgeKey({x:m,y:p},{x:m+1,y:p}))}if(p<n){let b=g+r,x=e.vEdges[p][m].type,P=x===3,E=x===1||x===2;a[g].push({next:b,isHexagon:P,isBroken:E}),a[b].push({next:g,isHexagon:P,isBroken:E}),P&&i.add(this.getEdgeKey({x:m,y:p},{x:m,y:p+1}))}}let y=new Set,f=i.size+l.size,d=this.getExternalCells(e),u=!1;for(let p=0;p<n;p++){for(let m=0;m<s;m++)if(e.cells[p][m].type!==0){u=!0;break}if(u)break}for(let p of h){let m=l.has(p)?1:0,g=e.symmetry||0,b=1n<<BigInt(p);if(g!==0){let x=this.getSymmetricalPointIndex(e,p);if(x===p)continue;b|=1n<<BigInt(x)}this.findPathsOptimized(e,p,b,[p],m,f,a,c,y,t,d,u)}return y.size}findPathsOptimized(e,t,n,s,r,o,a,h,c,i,l,y=!0){if(c.size>=i)return;let f=e.symmetry||0;if(h.includes(t)){if(r===o){let d=s.map(u=>({x:u%(e.cols+1),y:Math.floor(u/(e.cols+1))}));if(f!==0){let u=this.getSymmetricalPointIndex(e,t),p=e.cols+1;if(e.nodes[Math.floor(u/p)][u%p].type!==2)return}if(!y)c.add(this.getFingerprint(e,d,void 0,l));else{let u={points:d},p=this.validate(e,u,l);p.isValid&&c.add(this.getFingerprint(e,d,p.regions,l))}}return}if(this.canReachEndOptimized(t,n,a,h))for(let d of a[t]){if(d.isBroken||n&1n<<BigInt(d.next))continue;if(f!==0){let b=this.getSymmetricalPointIndex(e,t),x=this.getSymmetricalPointIndex(e,d.next);if(d.next===x||t===x&&d.next===b)continue}let u=!0;for(let b of a[t])if(b.isHexagon){let x=s.length>=2&&b.next===s[s.length-2],P=b.next===d.next;if(!x&&!P){u=!1;break}}if(!u)continue;let p=e.cols+1,m=e.nodes[Math.floor(d.next/p)][d.next%p].type===3?1:0;s.push(d.next);let g=n|1n<<BigInt(d.next);if(f!==0){let b=this.getSymmetricalPointIndex(e,d.next);g|=1n<<BigInt(b)}if(this.findPathsOptimized(e,d.next,g,s,r+(d.isHexagon?1:0)+m,o,a,h,c,i,l,y),s.pop(),c.size>=i)return}}canReachEndOptimized(e,t,n,s){let r=[e],o=t,a=0;for(;a<r.length;){let h=r[a++];if(s.includes(h))return!0;for(let c of n[h])!c.isBroken&&!(o&1n<<BigInt(c.next))&&(o|=1n<<BigInt(c.next),r.push(c.next))}return!1}getFingerprint(e,t,n,s){return(n||this.calculateRegions(e,t,[],s)).map(a=>a.map(c=>e.cells[c.y][c.x]).filter(c=>c.type!==0).map(c=>`${c.type}:${c.color}`).sort().join(",")).sort().filter(a=>a.length>0).join("|")||"empty"}};var Z=class{generate(e,t,n={}){let s=n.difficulty??.5,r=new Y,o=null,a=-1,h=e*t>30?100:80,c=5,i=n.symmetry||0,l={x:0,y:e},y={x:t,y:0};i===1?y={x:0,y:0}:i===2?y={x:t,y:e}:i===3&&(y={x:t,y:e});let f=null,d=null,u=null;for(let p=0;p<h;p++){if(p%c===0){f=this.generateRandomPath(new U(e,t),l,y,n.pathLength,i);let x=new U(e,t),P=i!==0?f.map(E=>this.getSymmetricalPoint(x,E,i)):[];d=this.calculateRegions(x,f,P),u=d.map(E=>this.getRegionBoundaryEdges(x,E,f,P))}let m=this.generateFromPath(e,t,f,n,d,u);if(!this.checkAllRequestedConstraintsPresent(m,n))continue;let g=r.calculateDifficulty(m);if(g===0)continue;let b=Math.abs(g-s);if((o===null||b<Math.abs(a-s))&&(a=g,o=m),s>.8&&g>.8||b<.01)break}if(!o){let p=this.generateRandomPath(new U(e,t),l,y,n.pathLength,i);return this.generateFromPath(e,t,p,n)}return o}generateFromPath(e,t,n,s,r,o){let a=new U(e,t),h=s.symmetry||0;a.symmetry=h;let c={x:0,y:e},i={x:t,y:0};if(h===1?i={x:0,y:0}:h===2?i={x:t,y:e}:h===3&&(i={x:t,y:e}),a.nodes[c.y][c.x].type=1,a.nodes[i.y][i.x].type=2,h!==0){let y=this.getSymmetricalPoint(a,c,h),f=this.getSymmetricalPoint(a,i,h);a.nodes[y.y][y.x].type=1,a.nodes[f.y][f.x].type=2}let l=h!==0?n.map(y=>this.getSymmetricalPoint(a,y,h)):[];return this.applyConstraintsBasedOnPath(a,n,s,l,r,o),s.useBrokenEdges&&this.applyBrokenEdges(a,n,s),this.cleanGrid(a),a}generateRandomPath(e,t,n,s,r=0){if(s===void 0)return this.generateSingleRandomPath(e,t,n,void 0,r);let o=e.rows+e.cols,a=(e.rows+1)*(e.cols+1)-1,h=o+s*(a-o),c=[],i=1/0,l=e.rows*e.cols>30?30:50;for(let y=0;y<l;y++){let f=this.generateSingleRandomPath(e,t,n,s,r);if(f.length===0)continue;let d=f.length-1,u=Math.abs(d-h);if(u<i&&(i=u,c=f),i<=2)break}return c}generateSingleRandomPath(e,t,n,s,r=0){let o=new Set,a=[],h=0,c=e.rows*e.cols*20,i=l=>{if(h++,h>c)return!1;o.add(`${l.x},${l.y}`);let y=this.getSymmetricalPoint(e,l,r);if(o.add(`${y.x},${y.y}`),a.push(l),l.x===n.x&&l.y===n.y)return!0;let f=this.getValidNeighbors(e,l,o);r!==0&&(f=f.filter(d=>{let u=this.getSymmetricalPoint(e,d,r);if(u.x<0||u.x>e.cols||u.y<0||u.y>e.rows||o.has(`${u.x},${u.y}`)||d.x===u.x&&d.y===u.y)return!1;let p=this.getEdgeKey(l,d),m=this.getEdgeKey(y,u);return p!==m})),s!==void 0?f.sort((d,u)=>{let p=Math.abs(d.x-n.x)+Math.abs(d.y-n.y),m=Math.abs(u.x-n.x)+Math.abs(u.y-n.y);return(p-m)*(1-s*2)+(Math.random()-.5)*1.5}):this.shuffleArray(f);for(let d of f)if(i(d))return!0;return a.pop(),o.delete(`${l.x},${l.y}`),o.delete(`${y.x},${y.y}`),!1};return i(t),a}getValidNeighbors(e,t,n){let s=[],r=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of r){let a=t.x+o.x,h=t.y+o.y;a>=0&&a<=e.cols&&h>=0&&h<=e.rows&&(n.has(`${a},${h}`)||s.push({x:a,y:h}))}return s}applyBrokenEdges(e,t,n){let s=n.complexity??.5,r=new Set;for(let i=0;i<t.length-1;i++)r.add(this.getEdgeKey(t[i],t[i+1]));let o=[];for(let i=0;i<=e.rows;i++)for(let l=0;l<e.cols;l++){let y={x:l,y:i},f={x:l+1,y:i};r.has(this.getEdgeKey(y,f))||o.push({type:"h",r:i,c:l,p1:y,p2:f})}for(let i=0;i<e.rows;i++)for(let l=0;l<=e.cols;l++){let y={x:l,y:i},f={x:l,y:i+1};r.has(this.getEdgeKey(y,f))||o.push({type:"v",r:i,c:l,p1:y,p2:f})}this.shuffleArray(o);let a=Math.max(1,Math.floor(s*(e.rows*e.cols)/4)),h=0;for(let i of o){if(h>=a)break;i.type==="h"?e.hEdges[i.r][i.c].type=1:e.vEdges[i.r][i.c].type=1,h++}let c=!0;for(;c;){c=!1;for(let i=0;i<=e.rows;i++)for(let l=0;l<e.cols;l++)e.hEdges[i][l].type===1&&this.canBecomeAbsent(e,{type:"h",r:i,c:l})&&(e.hEdges[i][l].type=2,c=!0);for(let i=0;i<e.rows;i++)for(let l=0;l<=e.cols;l++)e.vEdges[i][l].type===1&&this.canBecomeAbsent(e,{type:"v",r:i,c:l})&&(e.vEdges[i][l].type=2,c=!0)}for(let i=0;i<=e.rows;i++)for(let l=0;l<=e.cols;l++){let y=[];if(l>0&&y.push({e:e.hEdges[i][l-1],type:"h",r:i,c:l-1}),l<e.cols&&y.push({e:e.hEdges[i][l],type:"h",r:i,c:l}),i>0&&y.push({e:e.vEdges[i-1][l],type:"v",r:i-1,c:l}),i<e.rows&&y.push({e:e.vEdges[i][l],type:"v",r:i,c:l}),y.length>0&&y.every(f=>f.e.type===1||f.e.type===2)&&y.every(f=>!this.isAdjacentToMark(e,f)))for(let f of y)f.e.type=2}}canBecomeAbsent(e,t){if(this.isAdjacentToMark(e,t))return!1;if(t.type==="h"){if(t.r===0||t.r===e.rows)return!0}else if(t.c===0||t.c===e.cols)return!0;let n=t.type==="h"?[{x:t.c,y:t.r},{x:t.c+1,y:t.r}]:[{x:t.c,y:t.r},{x:t.c,y:t.r+1}];for(let s of n){let r=[{type:"h",r:s.y,c:s.x-1},{type:"h",r:s.y,c:s.x},{type:"v",r:s.y-1,c:s.x},{type:"v",r:s.y,c:s.x}];for(let o of r)if(o.c>=0&&o.c<=e.cols&&o.r>=0&&o.r<=e.rows){if(o.type==="h"&&o.c<e.cols){if(e.hEdges[o.r][o.c].type===2)return!0}else if(o.type==="v"&&o.r<e.rows&&e.vEdges[o.r][o.c].type===2)return!0}}return!1}cleanGrid(e){let t=[];for(let o=0;o<=e.rows;o++)for(let a=0;a<=e.cols;a++)e.nodes[o][a].type===1&&t.push({x:a,y:o});let n=new Set,s=[...t];for(let o of t)n.add(`${o.x},${o.y}`);for(;s.length>0;){let o=s.shift(),a=[{nx:o.x,ny:o.y-1,edge:e.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:e.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:e.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:e.hEdges[o.y]?.[o.x]}];for(let h of a)h.edge&&h.edge.type!==2&&(n.has(`${h.nx},${h.ny}`)||(n.add(`${h.nx},${h.ny}`),s.push({x:h.nx,y:h.ny})))}for(let o=0;o<=e.rows;o++)for(let a=0;a<e.cols;a++)(!n.has(`${a},${o}`)||!n.has(`${a+1},${o}`))&&(e.hEdges[o][a].type=2);for(let o=0;o<e.rows;o++)for(let a=0;a<=e.cols;a++)(!n.has(`${a},${o}`)||!n.has(`${a},${o+1}`))&&(e.vEdges[o][a].type=2);let r=this.getExternalCells(e);for(let o of r){let[a,h]=o.split(",").map(Number);e.cells[h][a].type=0}}getExternalCells(e){let t=new Set,n=[];for(let s=0;s<e.cols;s++)e.hEdges[0][s].type===2&&(t.has(`${s},0`)||(t.add(`${s},0`),n.push({x:s,y:0}))),e.hEdges[e.rows][s].type===2&&(t.has(`${s},${e.rows-1}`)||(t.add(`${s},${e.rows-1}`),n.push({x:s,y:e.rows-1})));for(let s=0;s<e.rows;s++)e.vEdges[s][0].type===2&&(t.has(`0,${s}`)||(t.add(`0,${s}`),n.push({x:0,y:s}))),e.vEdges[s][e.cols].type===2&&(t.has(`${e.cols-1},${s}`)||(t.add(`${e.cols-1},${s}`),n.push({x:e.cols-1,y:s})));for(;n.length>0;){let s=n.shift(),r=[{nx:s.x,ny:s.y-1,edge:e.hEdges[s.y][s.x]},{nx:s.x,ny:s.y+1,edge:e.hEdges[s.y+1][s.x]},{nx:s.x-1,ny:s.y,edge:e.vEdges[s.y][s.x]},{nx:s.x+1,ny:s.y,edge:e.vEdges[s.y][s.x+1]}];for(let o of r)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!t.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(t.add(`${o.nx},${o.ny}`),n.push({x:o.nx,y:o.ny}))}return t}isAdjacentToMark(e,t){if(t.type==="h"){if(t.r>0&&e.cells[t.r-1][t.c].type!==0||t.r<e.rows&&e.cells[t.r][t.c].type!==0)return!0}else if(t.c>0&&e.cells[t.r][t.c-1].type!==0||t.c<e.cols&&e.cells[t.r][t.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let t=0;t<e.rows;t++)for(let n=0;n<e.cols;n++){if(e.cells[t][n].type===0)continue;if([e.hEdges[t][n],e.hEdges[t+1][n],e.vEdges[t][n],e.vEdges[t][n+1]].every(r=>r.type===1||r.type===2))return!0}return!1}getSymmetricalPoint(e,t,n){return n===1?{x:e.cols-t.x,y:t.y}:n===2?{x:t.x,y:e.rows-t.y}:n===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,t,n,s=[],r,o){let a=n.complexity??.5,h=n.useHexagons??!0,c=n.useSquares??!0,i=n.useStars??!0,l=n.useTetris??!1,y=n.useEraser??!1,f=0,d=0,u=0,p=0,m=0,g=0,b=Math.floor(e.rows*e.cols*.45);if(h){let x=n.difficulty??.5;for(let P=0;P<t.length-1;P++){let M=this.getValidNeighbors(e,t[P],new Set).length>2,w=a*(x<.4?.6:.3);M&&(w=x<.4?w*1:w*.5),Math.random()<w&&(this.setEdgeHexagon(e,t[P],t[P+1]),f++)}for(let P=0;P<t.length;P++){let E=t[P];if(e.nodes[E.y][E.x].type!==0||this.hasIncidentHexagonEdge(e,E))continue;let M=a*(x>.6?.15:.05);Math.random()<M&&(e.nodes[E.y][E.x].type=3,f++)}if(f===0&&t.length>=2){let P=Math.floor(Math.random()*(t.length-1));this.setEdgeHexagon(e,t[P],t[P+1])}}if(c||i||l||y){let x=r||this.calculateRegions(e,t,s),P=n.availableColors??[A.Black,A.White,A.Red,A.Blue],E=n.defaultColors??{},M=(I,D)=>{if(E[I]!==void 0)return E[I];let v=j[I];return v&&E[v]!==void 0?E[v]:D},w=Array.from({length:x.length},(I,D)=>D);this.shuffleArray(w);let H=new Set,O={square:c,star:i,tetris:l,eraser:y};for(let I=0;I<w.length;I++){let D=w[I],v=x[D],S=w.length-I,N=O.square&&d===0||O.star&&u===0||O.tetris&&p===0||O.eraser&&m===0,R=.2+a*.6;if(N&&S<=3?R=1:N&&S<=6&&(R=.7),Math.random()>R)continue;let C=[...v];this.shuffleArray(C);let T=P[Math.floor(Math.random()*P.length)];if(c&&!i&&S<=2&&H.size===1){let K=P.filter(W=>!H.has(W));K.length>0&&(T=K[Math.floor(Math.random()*K.length)])}let q=c&&Math.random()<.5+a*.3;if(c&&d===0&&S<=2&&(q=!0),c&&!i&&S<=2&&H.size<2&&d>0&&(q=!0),q&&C.length>0){let K=Math.min(C.length,Math.max(4,Math.floor(v.length/4))),W=Math.floor(Math.random()*(K/2))+Math.ceil(K/2);for(let B=0;B<W&&C.length!==0;B++){let F=C.pop();e.cells[F.y][F.x].type=1,e.cells[F.y][F.x].color=T,d++,H.add(T)}}if(l&&g<b){let K=Math.random()<.1+a*.4;p===0&&S<=2&&(K=!0);let W=p===0&&S<=2?6:4;if(K&&C.length>0&&v.length<=W*4&&g+v.length<=b){let B=this.generateTiling(v,W,n);if(B){for(let F of B){if(C.length===0)break;let k=C.pop();e.cells[k.y][k.x].type=F.isRotated?4:3,e.cells[k.y][k.x].shape=F.isRotated?F.displayShape:F.shape;let V=M(3,A.None);if(i&&Math.random()<.5){let z=P.filter($=>$!==A.Blue&&$!==V);z.length>0&&(V=z[Math.floor(Math.random()*z.length)])}e.cells[k.y][k.x].color=V,p++}g+=v.length}}}if(y&&m<1){let K=.05+a*.2,W=Math.random()<K;if(S<=2&&(W=!0),W&&C.length>=1){let B=[];i&&B.push("star"),c&&B.push("square");let F=[];h&&(F=o?o[D]:this.getRegionBoundaryEdges(e,v,t,s),F.length>0&&B.push("hexagon")),l&&B.push("tetris");let k=B.length>0?B[Math.floor(Math.random()*B.length)]:null;C.length>=2&&(!k||Math.random()<.01)&&(k="eraser");let V=!1;if(k==="hexagon"){let z=F.filter($=>!this.isEdgeAdjacentToHexagonNode(e,$));if(z.length>0){let $=z[Math.floor(Math.random()*z.length)];$.type==="h"?e.hEdges[$.r][$.c].type=3:e.vEdges[$.r][$.c].type=3,f++,V=!0}}else if(k==="square"&&C.length>=2){let z=C.pop();e.cells[z.y][z.x].type=1;let $=v.find(G=>e.cells[G.y][G.x].type===1),L=$?e.cells[$.y][$.x].color:void 0;e.cells[z.y][z.x].color=P.find(G=>G!==L)||A.Red,d++,V=!0}else if(k==="star"&&C.length>=2){let z=C.pop();e.cells[z.y][z.x].type=2,e.cells[z.y][z.x].color=P[Math.floor(Math.random()*P.length)],u++,V=!0}else if(k==="tetris"&&C.length>=2){let z=this.generateTiling(v,4,n),$=[];if(z&&z.length>0){let L=0;for(let G of z){let J=this.getShapeArea(G.shape);if(L+J<v.length)$.push(G),L+=J;else break}}if($.length===0&&v.length>1&&($=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),$.length>0){for(let L of $){if(C.length<2)break;let G=C.pop();e.cells[G.y][G.x].type=L.isRotated?4:3,e.cells[G.y][G.x].shape=L.isRotated?L.displayShape:L.shape;let J=A.None;if(i&&Math.random()<.3){let ie=P.filter(ae=>ae!==A.Blue);J=ie[Math.floor(Math.random()*ie.length)]}e.cells[G.y][G.x].color=J,p++}V=!0}}else if(k==="eraser"&&C.length>=2){let z=C.pop();e.cells[z.y][z.x].type=5,e.cells[z.y][z.x].color=M(5,A.White),m++,V=!0}if(!V&&C.length>=2){let z=C.pop();e.cells[z.y][z.x].type=5,e.cells[z.y][z.x].color=M(5,A.White),m++,V=!0}if(V){let z=C.pop();e.cells[z.y][z.x].type=5;let $=M(5,A.White);if(i&&Math.random()<.4){let L=P.filter(G=>G!==$);L.length>0&&($=L[Math.floor(Math.random()*L.length)])}e.cells[z.y][z.x].color=$,m++}}}if(i){let K=Math.max(1,Math.floor(v.length/8));for(let W=0;W<K;W++)for(let B of P){if(C.length<1)break;if(Math.random()>.3+a*.4)continue;let F=v.filter(k=>e.cells[k.y][k.x].color===B).length;if(F===1){let k=C.pop();e.cells[k.y][k.x].type=2,e.cells[k.y][k.x].color=B,u++}else if(F===0&&C.length>=2)for(let k=0;k<2;k++){let V=C.pop();e.cells[V.y][V.x].type=2,e.cells[V.y][V.x].color=B,u++}}}}if(c&&!i&&H.size<2){for(let I of x)if(I.every(D=>e.cells[D.y][D.x].type===0)){let D=P.find(S=>!H.has(S))||A.White,v=I[Math.floor(Math.random()*I.length)];e.cells[v.y][v.x].type=1,e.cells[v.y][v.x].color=D,H.add(D),d++;break}}}}calculateRegions(e,t,n=[]){let s=[],r=new Set,o=new Set;for(let a=0;a<t.length-1;a++)o.add(this.getEdgeKey(t[a],t[a+1]));for(let a=0;a<n.length-1;a++)o.add(this.getEdgeKey(n[a],n[a+1]));for(let a=0;a<e.rows;a++)for(let h=0;h<e.cols;h++){if(r.has(`${h},${a}`))continue;let c=[],i=[{x:h,y:a}];for(r.add(`${h},${a}`);i.length>0;){let l=i.shift();c.push(l);let y=[{dx:0,dy:-1,p1:{x:l.x,y:l.y},p2:{x:l.x+1,y:l.y}},{dx:0,dy:1,p1:{x:l.x,y:l.y+1},p2:{x:l.x+1,y:l.y+1}},{dx:-1,dy:0,p1:{x:l.x,y:l.y},p2:{x:l.x,y:l.y+1}},{dx:1,dy:0,p1:{x:l.x+1,y:l.y},p2:{x:l.x+1,y:l.y+1}}];for(let f of y){let d=l.x+f.dx,u=l.y+f.dy;d>=0&&d<e.cols&&u>=0&&u<e.rows&&!r.has(`${d},${u}`)&&!o.has(this.getEdgeKey(f.p1,f.p2))&&!this.isAbsentEdge(e,f.p1,f.p2)&&(r.add(`${d},${u}`),i.push({x:d,y:u}))}}s.push(c)}return s}isAbsentEdge(e,t,n){if(t.x===n.x){let s=Math.min(t.y,n.y);return e.vEdges[s][t.x].type===2}else{let s=Math.min(t.x,n.x);return e.hEdges[t.y][s].type===2}}getRegionBoundaryEdges(e,t,n,s=[]){let r=new Set;for(let h=0;h<n.length-1;h++)r.add(this.getEdgeKey(n[h],n[h+1]));for(let h=0;h<s.length-1;h++)r.add(this.getEdgeKey(s[h],s[h+1]));let o=[];for(let h of t){let c=[{type:"h",r:h.y,c:h.x},{type:"h",r:h.y+1,c:h.x},{type:"v",r:h.y,c:h.x},{type:"v",r:h.y,c:h.x+1}];for(let i of c){let l=i.type==="h"?{x:i.c,y:i.r}:{x:i.c,y:i.r},y=i.type==="h"?{x:i.c+1,y:i.r}:{x:i.c,y:i.r+1},f=this.getEdgeKey(l,y);!r.has(f)&&!this.isAbsentEdge(e,l,y)&&o.push(i)}}let a=new Map;for(let h of o)a.set(`${h.type},${h.r},${h.c}`,h);return Array.from(a.values())}setEdgeHexagon(e,t,n){t.x===n.x?e.vEdges[Math.min(t.y,n.y)][t.x].type=3:e.hEdges[t.y][Math.min(t.x,n.x)].type=3}hasIncidentHexagonEdge(e,t){return t.x>0&&e.hEdges[t.y][t.x-1].type===3||t.x<e.cols&&e.hEdges[t.y][t.x].type===3||t.y>0&&e.vEdges[t.y-1][t.x].type===3||t.y<e.rows&&e.vEdges[t.y][t.x].type===3}isEdgeAdjacentToHexagonNode(e,t){return t.type==="h"?e.nodes[t.r][t.c].type===3||e.nodes[t.r][t.c+1].type===3:e.nodes[t.r][t.c].type===3||e.nodes[t.r+1][t.c].type===3}checkAllRequestedConstraintsPresent(e,t){let n=t.useHexagons??!0,s=t.useSquares??!0,r=t.useStars??!0,o=t.useTetris??!1,a=t.useEraser??!1;if(t.useBrokenEdges??!1){let c=!1;for(let i=0;i<=e.rows;i++)for(let l=0;l<e.cols;l++)if(e.hEdges[i][l].type===1||e.hEdges[i][l].type===2){c=!0;break}if(!c){for(let i=0;i<e.rows;i++)for(let l=0;l<=e.cols;l++)if(e.vEdges[i][l].type===1||e.vEdges[i][l].type===2){c=!0;break}}if(!c)return!1}if(n){let c=!1;for(let i=0;i<=e.rows;i++)for(let l=0;l<e.cols;l++)if(e.hEdges[i][l].type===3){c=!0;break}if(!c){for(let i=0;i<e.rows;i++)for(let l=0;l<=e.cols;l++)if(e.vEdges[i][l].type===3){c=!0;break}}if(!c){for(let i=0;i<=e.rows;i++)for(let l=0;l<=e.cols;l++)if(e.nodes[i][l].type===3){c=!0;break}}if(!c)return!1}if(s||r||o||a){let c=!1,i=!1,l=!1,y=!1,f=new Set;for(let d=0;d<e.rows;d++)for(let u=0;u<e.cols;u++){let p=e.cells[d][u].type;p===1&&(c=!0,f.add(e.cells[d][u].color)),p===2&&(i=!0),(p===3||p===4)&&(l=!0),p===5&&(y=!0)}if(s&&!c||r&&!i||o&&!l||a&&!y||s&&c&&!i&&f.size<2)return!1}return!this.hasIsolatedMark(e)}generateTiling(e,t,n){let s=Math.min(...e.map(l=>l.x)),r=Math.min(...e.map(l=>l.y)),o=Math.max(...e.map(l=>l.x)),a=Math.max(...e.map(l=>l.y)),h=o-s+1,c=a-r+1,i=Array.from({length:c},()=>Array(h).fill(!1));for(let l of e)i[l.y-r][l.x-s]=!0;return this.tilingDfs(i,[],t,n)}tilingDfs(e,t,n,s){let r=-1,o=-1;for(let c=0;c<e.length;c++){for(let i=0;i<e[0].length;i++)if(e[c][i]){r=c,o=i;break}if(r!==-1)break}if(r===-1)return t;if(t.length>=n)return null;let a=s.difficulty??.5,h=[...this.TETRIS_SHAPES];this.shuffleArray(h),a>.6&&h.sort((c,i)=>this.getShapeArea(i)-this.getShapeArea(c));for(let c of h){let i=this.isRotationallyInvariant(c),l=i?[c]:this.getAllRotations(c);this.shuffleArray(l);for(let y of l){let f=[];for(let d=0;d<y.length;d++)for(let u=0;u<y[0].length;u++)y[d][u]&&f.push({r:d,c:u});for(let d of f){let u=r-d.r,p=o-d.c;if(this.canPlace(e,y,u,p)){this.placePiece(e,y,u,p,!1);let m=this.tilingDfs(e,[...t,{shape:y,displayShape:c,isRotated:!i&&Math.random()<.3+a*.6}],n,s);if(m)return m;this.placePiece(e,y,u,p,!0)}}}}return null}getShapeArea(e){let t=0;for(let n of e)for(let s of n)s&&t++;return t}isRotationallyInvariant(e){let t=this.getShapeArea(e);return t===1||t===4&&e.length===2&&e[0].length===2}getAllRotations(e){let t=[],n=new Set,s=e;for(let r=0;r<4;r++){let o=JSON.stringify(s);n.has(o)||(t.push(s),n.add(o)),s=this.rotate90(s)}return t}rotate90(e){let t=e.length,n=e[0].length,s=Array.from({length:n},()=>Array(t).fill(0));for(let r=0;r<t;r++)for(let o=0;o<n;o++)s[o][t-1-r]=e[r][o];return s}canPlace(e,t,n,s){for(let r=0;r<t.length;r++)for(let o=0;o<t[0].length;o++)if(t[r][o]){let a=n+r,h=s+o;if(a<0||a>=e.length||h<0||h>=e[0].length||!e[a][h])return!1}return!0}placePiece(e,t,n,s,r){for(let o=0;o<t.length;o++)for(let a=0;a<t[0].length;a++)t[o][a]&&(e[n+o][s+a]=r)}shuffleArray(e){for(let t=e.length-1;t>0;t--){let n=Math.floor(Math.random()*(t+1));[e[t],e[n]]=[e[n],e[t]]}}};var te=class{bytes=[];cur=0;bit=0;write(e,t){for(let n=0;n<t;n++)e&1<<n&&(this.cur|=1<<this.bit),this.bit++,this.bit===8&&(this.bytes.push(this.cur),this.cur=0,this.bit=0)}finish(){return this.bit>0&&this.bytes.push(this.cur),new Uint8Array(this.bytes)}},se=class{constructor(e){this.buf=e}i=0;bit=0;read(e){let t=0;for(let n=0;n<e;n++)this.buf[this.i]&1<<this.bit&&(t|=1<<n),this.bit++,this.bit===8&&(this.bit=0,this.i++);return t}};function he(X){let e=new Map;for(let t of X)for(let n of t)if(n.shape){let s=JSON.stringify(n.shape);e.has(s)||e.set(s,n.shape)}return[...e.values()]}var ne=class{static async serialize(e,t){let n=new te;n.write(e.rows,6),n.write(e.cols,6),n.write(e.symmetry??0,2);let s=he(e.cells);n.write(s.length,5);for(let i of s){n.write(i.length,4),n.write(i[0].length,4);for(let l of i)for(let y of l)n.write(y,1)}let r=new Map;s.forEach((i,l)=>r.set(JSON.stringify(i),l));for(let i of e.cells)for(let l of i)n.write(l.type,3),n.write(l.color,3),l.shape?(n.write(1,1),n.write(r.get(JSON.stringify(l.shape)),5)):n.write(0,1);for(let i=0;i<e.rows;i++)for(let l=0;l<e.cols+1;l++)n.write(e.vEdges[i][l].type,2);for(let i=0;i<e.rows+1;i++)for(let l=0;l<e.cols;l++)n.write(e.hEdges[i][l].type,2);for(let i=0;i<e.rows+1;i++)for(let l=0;l<e.cols+1;l++)n.write(e.nodes[i][l].type,2);n.write(+!!t.useHexagons,1),n.write(+!!t.useSquares,1),n.write(+!!t.useStars,1),n.write(+!!t.useTetris,1),n.write(+!!t.useEraser,1),n.write(+!!t.useBrokenEdges,1),n.write(t.symmetry??0,2),n.write(Math.round((t.complexity??0)*254),8),n.write(Math.round((t.difficulty??0)*254),8),n.write(Math.round((t.pathLength??0)*254),8);let o=n.finish(),a=new Uint8Array(await new Response(new Blob([o.buffer]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()),h=0;for(let i of a)h^=i;let c=new Uint8Array(a.length+1);return c.set(a),c[a.length]=h,btoa(String.fromCharCode(...c)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}static async deserialize(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4;)t+="=";let n=atob(t),s=Uint8Array.from(n,v=>v.charCodeAt(0)),r=0;for(let v=0;v<s.length-1;v++)r^=s[v];if(r!==s.at(-1))throw new Error("Invalid parity data");let o=new Uint8Array(await new Response(new Blob([s.slice(0,-1).buffer]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer()),a=new se(o),h=a.read(6),c=a.read(6),i=a.read(2),l=a.read(5),y=[];for(let v=0;v<l;v++){let S=a.read(4),N=a.read(4),R=[];for(let C=0;C<S;C++){let T=[];for(let q=0;q<N;q++)T.push(a.read(1));R.push(T)}y.push(R)}let f=[];for(let v=0;v<h;v++){let S=[];for(let N=0;N<c;N++){let R=a.read(3),C=a.read(3),T=a.read(1),q={type:R,color:C};T&&(q.shape=y[a.read(5)].map(K=>K.slice())),S.push(q)}f.push(S)}let d=Array.from({length:h},()=>Array.from({length:c+1},()=>({type:a.read(2)}))),u=Array.from({length:h+1},()=>Array.from({length:c},()=>({type:a.read(2)}))),p=Array.from({length:h+1},()=>Array.from({length:c+1},()=>({type:a.read(2)}))),m=()=>{let v=a.read(8);return Math.round(v/254*1e3)/1e3},g={},b=!!a.read(1),x=!!a.read(1),P=!!a.read(1),E=!!a.read(1),M=!!a.read(1),w=!!a.read(1),H=a.read(2);b&&(g.useHexagons=!0),x&&(g.useSquares=!0),P&&(g.useStars=!0),E&&(g.useTetris=!0),M&&(g.useEraser=!0),w&&(g.useBrokenEdges=!0),g.symmetry=H;let O=m(),I=m(),D=m();return O!==0&&(g.complexity=O),I!==0&&(g.difficulty=I),D!==0&&(g.pathLength=D),{puzzle:{rows:h,cols:c,cells:f,vEdges:d,hEdges:u,nodes:p,symmetry:i},options:g}}};var oe=class{canvas;ctx;puzzle=null;options;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;invalidatedCells=[];invalidatedEdges=[];invalidatedNodes=[];errorCells=[];errorEdges=[];errorNodes=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;constructor(e,t,n={}){if(typeof window>"u"){this.canvas={},this.ctx={},this.options=this.mergeOptions(n);return}if(typeof e=="string"){let r=document.getElementById(e);if(!(r instanceof HTMLCanvasElement))throw new Error(`Element with id "${e}" is not a canvas.`);this.canvas=r}else this.canvas=e;let s=this.canvas.getContext("2d");if(!s)throw new Error("Could not get 2D context.");this.ctx=s,this.ctx.imageSmoothingEnabled=!1,this.options=this.mergeOptions(n),t&&this.setPuzzle(t),this.initEvents(),this.animate()}mergeOptions(e){let t={blinkDuration:e.animations?.blinkDuration??this.options?.animations?.blinkDuration??1e3,fadeDuration:e.animations?.fadeDuration??this.options?.animations?.fadeDuration??1e3,blinkPeriod:e.animations?.blinkPeriod??this.options?.animations?.blinkPeriod??800},n={path:e.colors?.path??this.options?.colors?.path??"#ffcc00",error:e.colors?.error??this.options?.colors?.error??"#ff4444",success:e.colors?.success??this.options?.colors?.success??"#ffcc00",symmetry:e.colors?.symmetry??this.options?.colors?.symmetry??"rgba(255, 255, 255, 0.5)",interrupted:e.colors?.interrupted??this.options?.colors?.interrupted??"#ffcc00",grid:e.colors?.grid??this.options?.colors?.grid??"#555",node:e.colors?.node??this.options?.colors?.node??"#555",hexagon:e.colors?.hexagon??this.options?.colors?.hexagon??"#000",colorMap:e.colors?.colorMap??this.options?.colors?.colorMap??{[A.Black]:"#000",[A.White]:"#fff",[A.Red]:"#f00",[A.Blue]:"#00f",[A.None]:"#ffcc00"},colorList:e.colors?.colorList??this.options?.colors?.colorList};return{gridPadding:e.gridPadding??this.options?.gridPadding??60,cellSize:e.cellSize??this.options?.cellSize??80,nodeRadius:e.nodeRadius??this.options?.nodeRadius??6,startNodeRadius:e.startNodeRadius??this.options?.startNodeRadius??22,pathWidth:e.pathWidth??this.options?.pathWidth??18,exitLength:e.exitLength??this.options?.exitLength??25,autoResize:e.autoResize??this.options?.autoResize??!0,animations:t,colors:n,onPathComplete:e.onPathComplete??this.options?.onPathComplete??(()=>{})}}setPuzzle(e){this.puzzle=e,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw()}setOptions(e){this.options=this.mergeOptions({...this.options,...e}),this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}setValidationResult(e,t=[],n=[],s=[],r=[],o=[],a=[]){this.invalidatedCells=t,this.invalidatedEdges=n,this.invalidatedNodes=o,this.errorCells=s,this.errorEdges=r,this.errorNodes=a,this.eraserAnimationStartTime=Date.now(),e?(this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0}resizeCanvas(){!this.puzzle||!this.canvas||(this.canvas.width=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,this.canvas.height=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2)}initEvents(){typeof window>"u"||(this.canvas.addEventListener("mousedown",e=>this.handleStart(e)),window.addEventListener("mousemove",e=>this.handleMove(e)),window.addEventListener("mouseup",e=>this.handleEnd(e)),this.canvas.addEventListener("touchstart",e=>{this.handleStart(e.touches[0])&&e.preventDefault()},{passive:!1}),window.addEventListener("touchmove",e=>{this.isDrawing&&e.preventDefault(),this.handleMove(e.touches[0])},{passive:!1}),window.addEventListener("touchend",e=>{this.isDrawing&&e.preventDefault(),this.handleEnd(e.changedTouches[0])},{passive:!1}))}getCanvasCoords(e,t){return{x:this.options.gridPadding+e*this.options.cellSize,y:this.options.gridPadding+t*this.options.cellSize}}getExitDir(e,t){return!this.puzzle||this.puzzle.nodes[t]?.[e]?.type!==2?null:e===this.puzzle.cols?{x:1,y:0}:e===0?{x:-1,y:0}:t===0?{x:0,y:-1}:t===this.puzzle.rows?{x:0,y:1}:{x:1,y:0}}handleStart(e){if(!this.puzzle)return!1;let t=this.canvas.getBoundingClientRect(),n=(e.clientX-t.left)*(this.canvas.width/t.width),s=(e.clientY-t.top)*(this.canvas.height/t.height);for(let r=0;r<=this.puzzle.rows;r++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[r][o].type===1){let a=this.getCanvasCoords(o,r);if(Math.hypot(a.x-n,a.y-s)<this.options.startNodeRadius)return this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.isDrawing=!0,this.path=[{x:o,y:r}],this.currentMousePos=a,this.exitTipPos=null,this.draw(),!0}return!1}handleMove(e){if(!this.puzzle||!this.isDrawing)return;let t=this.canvas.getBoundingClientRect(),n=(e.clientX-t.left)*(this.canvas.width/t.width),s=(e.clientY-t.top)*(this.canvas.height/t.height),r=this.path[this.path.length-1],o=this.getCanvasCoords(r.x,r.y),a=n-o.x,h=s-o.y,c=this.puzzle.symmetry||0,i=this.getExitDir(r.x,r.y),l=Math.abs(a)>Math.abs(h)?{x:a>0?1:-1,y:0}:{x:0,y:h>0?1:-1};if(i&&l.x===i.x&&l.y===i.y){let u=a*i.x+h*i.y,p=Math.max(0,Math.min(u,this.options.exitLength));this.currentMousePos={x:o.x+i.x*p,y:o.y+i.y*p},this.draw();return}let y=(u,p)=>{let m=this.getEdgeType(r,u);if(u.x<0||u.x>this.puzzle.cols||u.y<0||u.y>this.puzzle.rows||m===2){this.currentMousePos=o;return}let g=m===1?this.options.cellSize*.35:this.options.cellSize,b=this.getEdgeKey(r,u);if(!(this.path.length>=2&&u.x===this.path[this.path.length-2].x&&u.y===this.path[this.path.length-2].y)){for(let E=0;E<this.path.length-1;E++)if(this.getEdgeKey(this.path[E],this.path[E+1])===b){g=0;break}}if(this.path.some(E=>E.x===u.x&&E.y===u.y)&&this.path.length>=2){let E=this.path[this.path.length-2];(u.x!==E.x||u.y!==E.y)&&(g=Math.min(g,this.options.cellSize*.5-this.options.pathWidth*.5))}if(c!==0){let E=this.getSymmetricalPoint(r),M=this.getSymmetricalPoint(u),w=this.getEdgeType(E,M),H=this.getSymmetryPath(this.path),O=this.getEdgeKey(E,M);if(M.x<0||M.x>this.puzzle.cols||M.y<0||M.y>this.puzzle.rows||w===2){this.currentMousePos=o;return}w===1&&(g=Math.min(g,this.options.cellSize*.35));let I=H.some(C=>C.x===u.x&&C.y===u.y),D=this.path.some(C=>C.x===M.x&&C.y===M.y),v=u.x===M.x&&u.y===M.y,S=H.some((C,T)=>T<H.length-1&&this.getEdgeKey(H[T],H[T+1])===b),N=this.path.some((C,T)=>T<this.path.length-1&&this.getEdgeKey(this.path[T],this.path[T+1])===O);(I||D||v||S||N||b===O)&&(g=Math.min(g,this.options.cellSize*.5-this.options.pathWidth*.5))}u.x!==r.x?this.currentMousePos={x:o.x+Math.max(-g,Math.min(g,p)),y:o.y}:this.currentMousePos={x:o.x,y:o.y+Math.max(-g,Math.min(g,p))}};if(Math.abs(a)>Math.abs(h)){let u=a>0?1:-1;y({x:r.x+u,y:r.y},a)}else{let u=h>0?1:-1;y({x:r.x,y:r.y+u},h)}let f=[{x:r.x+1,y:r.y},{x:r.x-1,y:r.y},{x:r.x,y:r.y+1},{x:r.x,y:r.y-1}],d=this.getSymmetryPath(this.path);for(let u of f)if(u.x>=0&&u.x<=this.puzzle.cols&&u.y>=0&&u.y<=this.puzzle.rows){let p=this.getCanvasCoords(u.x,u.y);if(Math.hypot(p.x-this.currentMousePos.x,p.y-this.currentMousePos.y)<this.options.cellSize*.3){let g=this.path.findIndex(b=>b.x===u.x&&b.y===u.y);if(g===-1){if(c!==0){let b=this.getSymmetricalPoint(u);if(u.x===b.x&&u.y===b.y||this.path.some(E=>E.x===b.x&&E.y===b.y)||d.some(E=>E.x===u.x&&E.y===u.y))continue;let x=this.getEdgeKey(r,u),P=this.getEdgeKey(this.getSymmetricalPoint(r),b);if(x===P)continue}this.path.push(u)}else g===this.path.length-2&&this.path.pop()}}this.draw()}handleEnd(e){if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let t=this.path[this.path.length-1],n=this.getCanvasCoords(t.x,t.y),s=this.getExitDir(t.x,t.y);if(s){let r=this.currentMousePos.x-n.x,o=this.currentMousePos.y-n.y;if(r*s.x+o*s.y>0){this.exitTipPos={x:n.x+s.x*this.options.exitLength,y:n.y+s.y*this.options.exitLength},this.options.onPathComplete(this.path);return}}this.exitTipPos=s?{...this.currentMousePos}:null,this.startFade(this.options.colors.interrupted)}getEdgeType(e,t){if(!this.puzzle)return 2;if(e.x===t.x){let n=Math.min(e.y,t.y);return n<0||n>=this.puzzle.rows?2:this.puzzle.vEdges[n][e.x].type}else{let n=Math.min(e.x,t.x);return n<0||n>=this.puzzle.cols?2:this.puzzle.hEdges[e.y][n].type}}startFade(e="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=e,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){if(!(typeof window>"u")){if(this.draw(),this.isFading){let e=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=e,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0)}requestAnimationFrame(()=>this.animate())}}draw(){if(!this.puzzle||!this.ctx)return;let e=this.ctx,t=Date.now();if(e.globalAlpha=1,e.clearRect(0,0,this.canvas.width,this.canvas.height),this.drawGrid(e),this.drawConstraints(e),this.drawNodes(e),this.path.length===0&&!this.isDrawing&&this.drawRipples(e),this.isFading){if(this.drawPath(e,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let n=this.getSymmetryPath(this.fadingPath),s=this.options.colors.symmetry,r=null;if(this.fadingTipPos){let o=(this.fadingTipPos.x-this.options.gridPadding)/this.options.cellSize,a=(this.fadingTipPos.y-this.options.gridPadding)/this.options.cellSize,h=this.getSymmetricalPoint({x:o,y:a});r={x:h.x*this.options.cellSize+this.options.gridPadding,y:h.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,n,!1,s,this.fadeOpacity,r)}}else if(this.path.length>0){let n=this.isInvalidPath?this.options.colors.error:this.options.colors.path;if(this.isSuccessFading&&!this.puzzle.symmetry&&(n=this.options.colors.success),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let s=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),r=this.options.animations.blinkDuration;if(s<r)if(this.isSuccessFading)(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&(n=this.options.colors.error);else{let o=Math.min(1,s/200),a=s>r*.8?(r-s)/(r*.2):1,h=Math.min(o,a),c=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;n=this.lerpColor(this.options.colors.path,this.options.colors.error,c*h)}}if(this.drawPath(e,this.path,this.isDrawing,n,1,this.isDrawing?this.currentMousePos:this.exitTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let s=this.getSymmetryPath(this.path),r=this.options.colors.symmetry;if(this.isInvalidPath&&(r=this.options.colors.error),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let a=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),h=this.options.animations.blinkDuration;if(a<h)if(this.isSuccessFading)(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&(r=this.options.colors.error);else{let c=Math.min(1,a/200),i=a>h*.8?(h-a)/(h*.2):1,l=Math.min(c,i),y=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;r=this.lerpColor(this.options.colors.symmetry,this.options.colors.error,y*l)}}let o=null;if(this.isDrawing||this.exitTipPos){let a=this.isDrawing?this.currentMousePos:this.exitTipPos,h=(a.x-this.options.gridPadding)/this.options.cellSize,c=(a.y-this.options.gridPadding)/this.options.cellSize,i=this.getSymmetricalPoint({x:h,y:c},!0);o={x:i.x*this.options.cellSize+this.options.gridPadding,y:i.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,s,this.isDrawing,r,1,o)}}}drawRipples(e){if(!this.puzzle)return;let t=(Date.now()-this.startTime)/500;for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)if(this.puzzle.nodes[n][s].type===2){let o=this.getCanvasCoords(s,n),a=this.getExitDir(s,n);if(!a)continue;let h={x:o.x+a.x*this.options.exitLength,y:o.y+a.y*this.options.exitLength},c=t%4,i=c*5,l=Math.max(0,1-c/3);e.beginPath(),e.arc(h.x,h.y,i,0,Math.PI*2),e.strokeStyle=`rgba(170, 170, 170, ${l*.4})`,e.lineWidth=2,e.stroke()}}drawGrid(e){if(!this.puzzle||!this.options.colors.grid)return;e.strokeStyle=this.options.colors.grid,e.lineWidth=12,e.lineCap="round";let t=(n,s,r)=>{if(r!==2)if(r===1){let a={x:n.x+(s.x-n.x)*.35,y:n.y+(s.y-n.y)*.35},h={x:n.x+(s.x-n.x)*(.5+.15),y:n.y+(s.y-n.y)*(.5+.15)};e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(a.x,a.y),e.stroke(),e.beginPath(),e.moveTo(h.x,h.y),e.lineTo(s.x,s.y),e.stroke()}else e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(s.x,s.y),e.stroke()};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<this.puzzle.cols;s++)t(this.getCanvasCoords(s,n),this.getCanvasCoords(s+1,n),this.puzzle.hEdges[n][s].type);for(let n=0;n<this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++)t(this.getCanvasCoords(s,n),this.getCanvasCoords(s,n+1),this.puzzle.vEdges[n][s].type)}drawConstraints(e){if(!this.puzzle)return;let t=Date.now(),n=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2;for(let r=0;r<this.puzzle.rows;r++)for(let o=0;o<this.puzzle.cols;o++){let a=this.puzzle.cells[r][o],h=this.getCanvasCoords(o+.5,r+.5),c=this.invalidatedCells.some(u=>u.x===o&&u.y===r),i=this.errorCells.some(u=>u.x===o&&u.y===r),l=1,y,f=this.getColorCode(a.color),d=this.options.colors.error;if(i&&(y=this.lerpColor(f,d,n)),c){let u=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),p=this.options.animations.blinkDuration;if(this.isFading)l=this.fadeOpacity;else if(u<p){let m=Math.min(1,u/200),g=u>p*.8?(p-u)/(p*.2):1,b=Math.min(m,g);y=this.lerpColor(f,d,n*b)}else l=Math.max(.3,1-(u-p)/this.options.animations.fadeDuration)}if(l<1||y){let{canvas:u,ctx:p}=this.prepareOffscreen();this.drawConstraintItem(p,a,h,y),e.save(),e.globalAlpha=l,e.drawImage(u,0,0),e.restore()}else this.drawConstraintItem(e,a,h)}e.lineWidth=2;let s=8;for(let r=0;r<=this.puzzle.rows;r++)for(let o=0;o<this.puzzle.cols;o++)if(this.puzzle.hEdges[r][o].type===3){let a=this.getCanvasCoords(o+.5,r);e.save();let h=this.invalidatedEdges.some(i=>i.type==="h"&&i.r===r&&i.c===o);if(this.errorEdges.some(i=>i.type==="h"&&i.r===r&&i.c===o)){let i=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(e,a.x,a.y,s,i)}else if(h){let i=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),l=this.options.animations.blinkDuration;if(this.isFading)e.globalAlpha*=this.fadeOpacity;else if(i<l){let y=Math.min(1,i/200),f=i>l*.8?(l-i)/(l*.2):1,d=Math.min(y,f),u=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*d);this.drawHexagon(e,a.x,a.y,s,u)}else e.globalAlpha*=Math.max(.3,1-(i-l)/this.options.animations.fadeDuration),this.drawHexagon(e,a.x,a.y,s)}else this.drawHexagon(e,a.x,a.y,s);e.restore()}for(let r=0;r<this.puzzle.rows;r++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.vEdges[r][o].type===3){let a=this.getCanvasCoords(o,r+.5);e.save();let h=this.invalidatedEdges.some(i=>i.type==="v"&&i.r===r&&i.c===o);if(this.errorEdges.some(i=>i.type==="v"&&i.r===r&&i.c===o)){let i=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(e,a.x,a.y,s,i)}else if(h){let i=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),l=this.options.animations.blinkDuration;if(this.isFading)e.globalAlpha*=this.fadeOpacity;else if(i<l){let y=Math.min(1,i/200),f=i>l*.8?(l-i)/(l*.2):1,d=Math.min(y,f),u=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*d);this.drawHexagon(e,a.x,a.y,s,u)}else e.globalAlpha*=Math.max(.3,1-(i-l)/this.options.animations.fadeDuration),this.drawHexagon(e,a.x,a.y,s)}else this.drawHexagon(e,a.x,a.y,s);e.restore()}for(let r=0;r<=this.puzzle.rows;r++)for(let o=0;o<=this.puzzle.cols;o++)if(this.puzzle.nodes[r][o].type===3){let a=this.getCanvasCoords(o,r);e.save();let h=this.invalidatedNodes.some(i=>i.x===o&&i.y===r);if(this.errorNodes.some(i=>i.x===o&&i.y===r)){let i=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n);this.drawHexagon(e,a.x,a.y,s,i)}else if(h){let i=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),l=this.options.animations.blinkDuration;if(this.isFading)e.globalAlpha*=this.fadeOpacity;else if(i<l){let y=Math.min(1,i/200),f=i>l*.8?(l-i)/(l*.2):1,d=Math.min(y,f),u=this.lerpColor(this.options.colors.hexagon,this.options.colors.error,n*d);this.drawHexagon(e,a.x,a.y,s,u)}else e.globalAlpha*=Math.max(.3,1-(i-l)/this.options.animations.fadeDuration),this.drawHexagon(e,a.x,a.y,s)}else this.drawHexagon(e,a.x,a.y,s);e.restore()}}drawConstraintItem(e,t,n,s){t.type===1?(e.fillStyle=s||this.getColorCode(t.color),this.drawRoundedRect(e,n.x-26/2,n.y-26/2,26,26,8)):t.type===2?this.drawStar(e,n.x,n.y,12,16,8,t.color,s):t.type===3||t.type===4?this.drawTetris(e,n.x,n.y,t.shape||[],t.type===4,t.color,s):t.type===5&&this.drawEraser(e,n.x,n.y,14,3,t.color,s)}drawNodes(e){if(!this.puzzle)return;let t=(n,s)=>{let r=[];return n>0&&r.push(this.puzzle.hEdges[s][n-1].type),n<this.puzzle.cols&&r.push(this.puzzle.hEdges[s][n].type),s>0&&r.push(this.puzzle.vEdges[s-1][n].type),s<this.puzzle.rows&&r.push(this.puzzle.vEdges[s][n].type),r.length>0&&r.every(o=>o===2)};for(let n=0;n<=this.puzzle.rows;n++)for(let s=0;s<=this.puzzle.cols;s++){if(t(s,n))continue;let r=this.puzzle.nodes[n][s];if(r.type===3)continue;let o=this.getCanvasCoords(s,n);if(r.type===1)this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill();else if(r.type===2){let a=this.getExitDir(s,n);if(!a)continue;this.options.colors.node&&(e.strokeStyle=this.options.colors.node),e.lineWidth=12,e.lineCap="round",e.beginPath(),e.moveTo(o.x,o.y),e.lineTo(o.x+a.x*this.options.exitLength,o.y+a.y*this.options.exitLength),e.stroke()}else this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(o.x,o.y,this.options.nodeRadius,0,Math.PI*2),e.fill()}}drawPath(e,t,n,s,r,o=null){if(t.length===0||!s)return;let a=r,h=s;if(s.startsWith("rgba")){let l=s.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);if(l){let y=l[1],f=l[2],d=l[3],u=l[4]?parseFloat(l[4]):1;h=`rgb(${y},${f},${d})`,a*=u}}else if(s==="transparent")return;let{canvas:c,ctx:i}=this.prepareOffscreen();this.drawPathInternal(i,t,n,h,o),e.save(),e.globalAlpha=a,e.drawImage(c,0,0),e.restore()}drawPathInternal(e,t,n,s,r=null){e.save(),e.strokeStyle=s,e.fillStyle=s,e.lineWidth=this.options.pathWidth,e.lineCap="round",e.lineJoin="round",e.beginPath();let o=this.getCanvasCoords(t[0].x,t[0].y);e.moveTo(o.x,o.y);for(let h=1;h<t.length;h++){let c=this.getCanvasCoords(t[h].x,t[h].y);e.lineTo(c.x,c.y)}let a=r||this.currentMousePos;(n||r)&&e.lineTo(a.x,a.y),e.stroke(),e.beginPath(),e.arc(o.x,o.y,this.options.startNodeRadius,0,Math.PI*2),e.fill(),(n||r)&&(e.beginPath(),e.arc(a.x,a.y,this.options.pathWidth/2,0,Math.PI*2),e.fill()),e.restore()}drawRoundedRect(e,t,n,s,r,o){e.beginPath(),e.moveTo(t+o,n),e.lineTo(t+s-o,n),e.quadraticCurveTo(t+s,n,t+s,n+o),e.lineTo(t+s,n+r-o),e.quadraticCurveTo(t+s,n+r,t+s-o,n+r),e.lineTo(t+o,n+r),e.quadraticCurveTo(t,n+r,t,n+r-o),e.lineTo(t,n+o),e.quadraticCurveTo(t,n,t+o,n),e.closePath(),e.fill()}drawHexagon(e,t,n,s,r){if(!(!this.options.colors.hexagon&&!r)){e.fillStyle=r||this.options.colors.hexagon,e.beginPath();for(let o=0;o<6;o++){let a=Math.PI/3*o,h=t+s*Math.cos(a),c=n+s*Math.sin(a);o===0?e.moveTo(h,c):e.lineTo(h,c)}e.closePath(),e.fill()}}drawEraser(e,t,n,s,r,o,a){e.strokeStyle=a||this.getColorCode(o),e.lineWidth=s*.5,e.lineCap="butt";let h=.5;e.beginPath();for(let c=0;c<r;c++){let i=Math.PI*2/r*c+h,l=t+s*Math.cos(i),y=n+s*Math.sin(i);e.moveTo(t,n),e.lineTo(l,y)}e.stroke()}drawStar(e,t,n,s,r,o,a,h){e.fillStyle=h||this.getColorCode(a),e.beginPath();for(let c=0;c<o*2;c++){let i=c%2===0?r:s,l=Math.PI/o*c,y=t+i*Math.cos(l),f=n+i*Math.sin(l);c===0?e.moveTo(y,f):e.lineTo(y,f)}e.closePath(),e.fill()}drawTetris(e,t,n,s,r,o,a){if(!s||s.length===0)return;let h=12,c=2,i=s[0].length*h+(s[0].length-1)*c,l=s.length*h+(s.length-1)*c;e.save(),e.translate(t,n),r&&e.rotate(Math.PI/8),e.fillStyle=a||this.getColorCode(o,"#ffcc00");for(let y=0;y<s.length;y++)for(let f=0;f<s[y].length;f++)if(s[y][f]){let d=f*(h+c)-i/2,u=y*(h+c)-l/2;e.fillRect(d,u,h,h)}e.restore()}getColorCode(e,t="#666"){return this.options.colors.colorList&&this.options.colors.colorList[e]!==void 0?this.options.colors.colorList[e]:this.options.colors.colorMap&&this.options.colors.colorMap[e]!==void 0?this.options.colors.colorMap[e]:t}hexToRgb(e){let t=e.startsWith("#")?e.slice(1):e;t.length===3&&(t=t.split("").map(s=>s+s).join(""));let n=parseInt(t,16);return{r:n>>16&255,g:n>>8&255,b:n&255}}rgbToHex(e,t,n){return"#"+((1<<24)+(e<<16)+(t<<8)+n).toString(16).slice(1)}lerpColor(e,t,n){try{let s=this.hexToRgb(e),r=this.hexToRgb(t);return this.rgbToHex(Math.round(s.r+(r.r-s.r)*n),Math.round(s.g+(r.g-s.g)*n),Math.round(s.b+(r.b-s.b)*n))}catch{return e}}getSymmetryPath(e){return!this.puzzle||!this.puzzle.symmetry?[]:e.map(t=>this.getSymmetricalPoint(t))}getSymmetricalPoint(e,t=!1){if(!this.puzzle||!this.puzzle.symmetry)return{...e};let{cols:n,rows:s,symmetry:r}=this.puzzle;return r===1?{x:n-e.x,y:e.y}:r===2?{x:e.x,y:s-e.y}:r===3?{x:n-e.x,y:s-e.y}:{...e}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}prepareOffscreen(){return typeof document>"u"?{canvas:{},ctx:{}}:(this.offscreenCanvas||(this.offscreenCanvas=document.createElement("canvas"),this.offscreenCtx=this.offscreenCanvas.getContext("2d")),(this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx})}};var re=class{generator;validator;constructor(){this.generator=new Z,this.validator=new Y}createPuzzle(e,t,n={}){return this.generator.generate(e,t,n).export()}validateSolution(e,t){let n=U.fromData(e);return this.validator.validate(n,t)}calculateDifficulty(e){let t=U.fromData(e);return this.validator.calculateDifficulty(t)}};export{j as CellType,A as Color,le as Direction,_ as EdgeType,U as Grid,Q as NodeType,Z as PuzzleGenerator,ne as PuzzleSerializer,Y as PuzzleValidator,ee as SymmetryType,re as WitnessCore,oe as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
