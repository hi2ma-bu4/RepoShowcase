/*!
 * MiniWitness 1.3.9
 * Copyright 2026 hi2ma-bu4
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
var Me=(n=>(n[n.Up=0]="Up",n[n.Right=1]="Right",n[n.Down=2]="Down",n[n.Left=3]="Left",n))(Me||{}),re=(f=>(f[f.None=0]="None",f[f.Square=1]="Square",f[f.Star=2]="Star",f[f.Tetris=3]="Tetris",f[f.TetrisRotated=4]="TetrisRotated",f[f.TetrisNegative=5]="TetrisNegative",f[f.TetrisNegativeRotated=6]="TetrisNegativeRotated",f[f.Eraser=7]="Eraser",f[f.Triangle=8]="Triangle",f))(re||{}),le=(i=>(i[i.Normal=0]="Normal",i[i.Broken=1]="Broken",i[i.Absent=2]="Absent",i[i.Hexagon=3]="Hexagon",i[i.HexagonMain=4]="HexagonMain",i[i.HexagonSymmetry=5]="HexagonSymmetry",i))(le||{}),he=(i=>(i[i.Normal=0]="Normal",i[i.Start=1]="Start",i[i.End=2]="End",i[i.Hexagon=3]="Hexagon",i[i.HexagonMain=4]="HexagonMain",i[i.HexagonSymmetry=5]="HexagonSymmetry",i))(he||{}),de=(n=>(n[n.None=0]="None",n[n.Horizontal=1]="Horizontal",n[n.Vertical=2]="Vertical",n[n.Rotational=3]="Rotational",n))(de||{}),Y={None:0,Black:1,White:2,Red:3,Blue:4},Ce=(s=>(s[s.Mulberry32=0]="Mulberry32",s[s.XorShift128Plus=1]="XorShift128Plus",s[s.MathRandom=2]="MathRandom",s))(Ce||{});var ie=class G{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];symmetry=0;seed;constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:Y.None}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes,symmetry:this.symmetry,seed:this.seed}))}static fromData(e){let t=new G(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t.symmetry=e.symmetry||0,t.seed=e.seed,t}};var ye=class{state;constructor(e){this.state=e>>>0}next(){let e=(this.state+=1831565813)|0;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}},me=class{s0;s1;constructor(e,t){this.s0=e>>>0,this.s1=t>>>0,this.s0===0&&this.s1===0&&(this.s1=1)}next(){let e=this.s0,t=this.s1;return this.s0=t,e^=e<<23,this.s1=e^t^e>>>17^t>>>26,(this.s1+t>>>0)/4294967296}},xe=class{next(){return Math.random()}};function pe(G,e){switch(G){case 0:return new ye(Number(e&0xffffffffn));case 1:return new me(Number(e&0xffffffffn),Number(e>>32n&0xffffffffn));case 2:return new xe;default:return new ye(Number(e&0xffffffffn))}}var ae=class{tetrisCache=new Map;reachabilityCache=new Map;rng=null;setRng(e){this.rng=e}validate(e,t,s){let n=t.points;if(n.length<2)return{isValid:!1,errorReason:"Path too short"};let r=e.symmetry||0,i=[];if(r!==0)for(let u of n)i.push(this.getSymmetricalPoint(e,u));let o=n[0],c=n[n.length-1];if(e.nodes[o.y][o.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[c.y][c.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};if(r!==0){let u=i[0],m=i[i.length-1];if(e.nodes[u.y][u.x].type!==1)return{isValid:!1,errorReason:"Symmetrical path must start at Start Node"};if(e.nodes[m.y][m.x].type!==2)return{isValid:!1,errorReason:"Symmetrical path must end at End Node"}}let f=new Set,d=new Set;if(f.add(`${o.x},${o.y}`),r!==0){let u=i[0];if(f.has(`${u.x},${u.y}`))return{isValid:!1,errorReason:"Paths collide at start"};f.add(`${u.x},${u.y}`)}for(let u=0;u<n.length-1;u++){let m=n[u],P=n[u+1];if(Math.abs(m.x-P.x)+Math.abs(m.y-P.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let p=`${P.x},${P.y}`;if(f.has(p))return{isValid:!1,errorReason:"Self-intersecting path or path collision"};if(f.add(p),this.isBrokenEdge(e,m,P))return{isValid:!1,errorReason:"Passed through broken edge"};if(d.add(this.getEdgeKey(m,P)),r!==0){let g=i[u],x=i[u+1],w=`${x.x},${x.y}`;if(f.has(w))return{isValid:!1,errorReason:"Path collision"};if(f.add(w),this.isBrokenEdge(e,g,x))return{isValid:!1,errorReason:"Symmetrical path passed through broken edge"};let b=this.getEdgeKey(g,x);if(d.has(b))return{isValid:!1,errorReason:"Paths cross the same edge"};d.add(b)}}let h=this.calculateRegions(e,n,i,s),a=this.getMissedHexagons(e,n,i),y=new Set;for(let u=0;u<n.length-1;u++)y.add(this.getEdgeKey(n[u],n[u+1]));if(r!==0)for(let u=0;u<i.length-1;u++)y.add(this.getEdgeKey(i[u],i[u+1]));let l=this.validateWithErasers(e,h,a.edges,a.nodes,y);return l.regions=h,l}validateFast(e,t,s,n){let r=this.calculateRegions(e,t,s,n),i=this.getMissedHexagons(e,t,s),o=new Set;for(let f=0;f<t.length-1;f++)o.add(this.getEdgeKey(t[f],t[f+1]));if((e.symmetry||0)!==0)for(let f=0;f<s.length-1;f++)o.add(this.getEdgeKey(s[f],s[f+1]));return this.validateWithErasers(e,r,i.edges,i.nodes,o)}isBrokenEdge(e,t,s){let n;if(t.x===s.x){let r=Math.min(t.y,s.y);n=e.vEdges[r][t.x].type}else{let r=Math.min(t.x,s.x);n=e.hEdges[t.y][r].type}return n===1||n===2}isAbsentEdge(e,t,s){if(t.x===s.x){let n=Math.min(t.y,s.y);return e.vEdges[n][t.x].type===2}else{let n=Math.min(t.x,s.x);return e.hEdges[t.y][n].type===2}}getMissedHexagons(e,t,s=[]){let n=new Set,r=new Set;for(let d=0;d<t.length;d++)r.add(`${t[d].x},${t[d].y}`),d<t.length-1&&n.add(this.getEdgeKey(t[d],t[d+1]));let i=new Set,o=new Set;for(let d=0;d<s.length;d++)o.add(`${s[d].x},${s[d].y}`),d<s.length-1&&i.add(this.getEdgeKey(s[d],s[d+1]));let c=[];for(let d=0;d<=e.rows;d++)for(let h=0;h<e.cols;h++){let a=e.hEdges[d][h].type;if(a===3||a===4||a===5){let y=this.getEdgeKey({x:h,y:d},{x:h+1,y:d}),l=!1;a===3?l=n.has(y)||i.has(y):a===4?l=n.has(y):a===5&&(l=i.has(y)),l||c.push({type:"h",r:d,c:h})}}for(let d=0;d<e.rows;d++)for(let h=0;h<=e.cols;h++){let a=e.vEdges[d][h].type;if(a===3||a===4||a===5){let y=this.getEdgeKey({x:h,y:d},{x:h,y:d+1}),l=!1;a===3?l=n.has(y)||i.has(y):a===4?l=n.has(y):a===5&&(l=i.has(y)),l||c.push({type:"v",r:d,c:h})}}let f=[];for(let d=0;d<=e.rows;d++)for(let h=0;h<=e.cols;h++){let a=e.nodes[d][h].type;if(a===3||a===4||a===5){let y=`${h},${d}`,l=!1;a===3?l=r.has(y)||o.has(y):a===4?l=r.has(y):a===5&&(l=o.has(y)),l||f.push({x:h,y:d})}}return{edges:c,nodes:f}}validateWithErasers(e,t,s,n,r){let i=[],o=!0;for(let l=0;l<t.length;l++){let u=t[l],m=u.filter(x=>e.cells[x.y][x.x].type===7),P=u.filter(x=>e.cells[x.y][x.x].type!==0&&e.cells[x.y][x.x].type!==7),E=[];for(let x=0;x<s.length;x++)this.isHexagonAdjacentToRegion(e,s[x],u)&&E.push(x);let p=[];for(let x=0;x<n.length;x++)this.isNodeHexagonAdjacentToRegion(e,n[x],u)&&p.push(x);let g=this.getPossibleErasures(e,u,m,P,E,p,r);if(g.length===0){o=!1;let x=this.getBestEffortErasures(e,u,m,P,E,p,r);i.push([x])}else g.sort((x,w)=>{let b=x.invalidatedCells.length+x.invalidatedHexagons.length+x.invalidatedNodeHexagons.length,v=w.invalidatedCells.length+w.invalidatedHexagons.length+w.invalidatedNodeHexagons.length;if(b!==v)return b-v;let S=x.invalidatedHexagons.length+x.invalidatedNodeHexagons.length,T=w.invalidatedHexagons.length+w.invalidatedNodeHexagons.length;return S!==T?T-S:x.invalidatedCells.length-w.invalidatedCells.length}),i.push(g)}if(o){let l=this.findGlobalAssignment(i,s.length,n.length);if(l)return{isValid:!0,invalidatedCells:l.invalidatedCells,invalidatedEdges:l.invalidatedHexIndices.map(u=>s[u]),invalidatedNodes:l.invalidatedNodeHexIndices.map(u=>n[u])}}let c=[],f=[],d=new Set,h=new Set;for(let l of i){let u=l[0];c.push(...u.errorCells),f.push(...u.invalidatedCells);for(let m of u.invalidatedHexagons)d.add(m);for(let m of u.invalidatedNodeHexagons)h.add(m)}let a=[];for(let l=0;l<s.length;l++)d.has(l)||a.push(s[l]);let y=[];for(let l=0;l<n.length;l++)h.has(l)||y.push(n[l]);return{isValid:!1,errorReason:"Constraints failed",errorCells:c,errorEdges:a,errorNodes:y,invalidatedCells:f,invalidatedEdges:Array.from(d).map(l=>s[l]),invalidatedNodes:Array.from(h).map(l=>n[l])}}isHexagonAdjacentToRegion(e,t,s){let n=new Set(s.map(r=>`${r.x},${r.y}`));if(t.type==="h"){if(t.r>0&&n.has(`${t.c},${t.r-1}`)||t.r<e.rows&&n.has(`${t.c},${t.r}`))return!0}else if(t.c>0&&n.has(`${t.c-1},${t.r}`)||t.c<e.cols&&n.has(`${t.c},${t.r}`))return!0;return!1}isNodeHexagonAdjacentToRegion(e,t,s){let n=new Set(s.map(i=>`${i.x},${i.y}`)),r=[{x:t.x-1,y:t.y-1},{x:t.x,y:t.y-1},{x:t.x-1,y:t.y},{x:t.x,y:t.y}];for(let i of r)if(i.x>=0&&i.x<e.cols&&i.y>=0&&i.y<e.rows&&n.has(`${i.x},${i.y}`))return!0;return!1}getPossibleErasures(e,t,s,n,r,i,o){let c=[],f=s.length;if(f===0)return this.getRegionErrors(e,t,[],o).length===0&&r.length===0&&i.length===0&&c.push({invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!0,errorCells:[]}),c;let d=[...n.map(a=>({type:"cell",pos:a})),...r.map(a=>({type:"hex",index:a})),...i.map(a=>({type:"nodeHex",index:a}))],h=this.getRegionErrors(e,t,[],o).length===0&&r.length===0&&i.length===0;for(let a=0;a<=f;a++){let y=this.getNCombinations(s,a);for(let l of y){let u=new Set(l.map(P=>`${P.x},${P.y}`)),m=s.filter(P=>!u.has(`${P.x},${P.y}`));for(let P=0;P<=d.length;P++){if(m.length!==a+P)continue;let E=this.getNCombinations(d,P);for(let p of E){let g=p.filter(S=>S.type==="cell").map(S=>S.pos),x=p.filter(S=>S.type==="hex").map(S=>S.index),w=p.filter(S=>S.type==="nodeHex").map(S=>S.index);if(this.getRegionErrors(e,t,[...g,...l],o).length===0){let S=!0;if(h)P>0&&(S=!1);else for(let T=0;T<p.length;T++){let C=[...p.slice(0,T),...p.slice(T+1)],N=C.filter(V=>V.type==="cell").map(V=>V.pos),$=new Set(C.filter(V=>V.type==="hex").map(V=>V.index)),O=new Set(C.filter(V=>V.type==="nodeHex").map(V=>V.index)),K=r.every(V=>$.has(V)),D=i.every(V=>O.has(V));if(this.getRegionErrors(e,t,N,o).length===0&&K&&D){S=!1;break}}S&&c.push({invalidatedCells:[...g,...l],invalidatedHexagons:x,invalidatedNodeHexagons:w,isValid:!0,errorCells:[]})}}}}}return c}getBestEffortErasures(e,t,s,n,r,i,o){let c=this.getRegionErrors(e,t,[],o);if(c.length===0&&r.length===0&&i.length===0)return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:[...s]};if(s.length>0){let h=[...n.map(u=>({type:"cell",pos:u})),...r.map(u=>({type:"hex",index:u})),...i.map(u=>({type:"nodeHex",index:u}))],a=null,y=1/0,l=u=>{let m=[],P=[],E=[],p=0;for(let C of u)p<s.length&&(C.type==="cell"?m.push(C.pos):C.type==="hex"?P.push(C.index):E.push(C.index),p++);let g=s.length-p,x=Math.floor(g/2),w=s.slice(p,p+x);p+=x*2;let b=this.getRegionErrors(e,t,[...m,...w],o);for(let C=p;C<s.length;C++)b.push(s[C]);let v=Math.max(0,r.length-P.length),S=Math.max(0,i.length-E.length),T=b.length+v+S;T<y&&(y=T,a={invalidatedCells:[...m,...w],invalidatedHexagons:P,invalidatedNodeHexagons:E,isValid:!1,errorCells:b})};l([...c.map(u=>({type:"cell",pos:u})),...r.map(u=>({type:"hex",index:u})),...i.map(u=>({type:"nodeHex",index:u}))]),l(h);for(let u of c)l([{type:"cell",pos:u}]);if(a)return a}let d=[...c,...s];return{invalidatedCells:[],invalidatedHexagons:[],invalidatedNodeHexagons:[],isValid:!1,errorCells:d}}getNCombinations(e,t){let s=[],n=(r,i)=>{if(i.length===t){s.push([...i]);return}for(let o=r;o<e.length;o++)i.push(e[o]),n(o+1,i),i.pop()};return n(0,[]),s}checkRegionValid(e,t,s,n){return this.getRegionErrors(e,t,s,n).length===0}getRegionErrors(e,t,s,n){let r=new Set(s.map(l=>`${l.x},${l.y}`)),i=new Map,o=new Map,c=new Set,f=new Set,d=[],h=[],a=[];for(let l of t){if(r.has(`${l.x},${l.y}`))continue;let u=e.cells[l.y][l.x];if(u.type===0)continue;let m=u.color;m!==Y.None&&(i.set(m,(i.get(m)||0)+1),o.has(m)||o.set(m,[]),o.get(m).push(l)),u.type===1?f.add(m):u.type===2?c.add(m):u.type===3||u.type===4?u.shape&&d.push({shape:u.shape,rotatable:u.type===4,pos:l}):u.type===5||u.type===6?u.shape&&h.push({shape:u.shape,rotatable:u.type===6,pos:l}):u.type===8&&a.push({count:u.count||0,pos:l})}let y=[];if(f.size>1)for(let l of t)r.has(`${l.x},${l.y}`)||e.cells[l.y][l.x].type===1&&y.push(l);for(let l of c)if(i.get(l)!==2){let u=o.get(l)||[];for(let m of u)e.cells[m.y][m.x].type===2&&y.push(m)}for(let l of a){let u=0,m=[this.getEdgeKey({x:l.pos.x,y:l.pos.y},{x:l.pos.x+1,y:l.pos.y}),this.getEdgeKey({x:l.pos.x,y:l.pos.y+1},{x:l.pos.x+1,y:l.pos.y+1}),this.getEdgeKey({x:l.pos.x,y:l.pos.y},{x:l.pos.x,y:l.pos.y+1}),this.getEdgeKey({x:l.pos.x+1,y:l.pos.y},{x:l.pos.x+1,y:l.pos.y+1})];for(let P of m)n.has(P)&&u++;u!==l.count&&y.push(l.pos)}if((d.length>0||h.length>0)&&!this.checkTetrisConstraint(e,t,d.map(l=>({shape:l.shape,rotatable:l.rotatable})),h.map(l=>({shape:l.shape,rotatable:l.rotatable})))){for(let l of d)y.push(l.pos);for(let l of h)y.push(l.pos)}return y}findGlobalAssignment(e,t,s){let n=e.length,r=new Array(t).fill(0),i=new Array(s).fill(0),o=[],c=[],f=[],d=h=>{if(h===n)return r.every(a=>a===1)&&i.every(a=>a===1);for(let a of e[h]){let y=!0;for(let l of a.invalidatedHexagons)if(r[l]>0){y=!1;break}if(y){for(let l of a.invalidatedNodeHexagons)if(i[l]>0){y=!1;break}}if(y){for(let l of a.invalidatedHexagons)r[l]++,c.push(l);for(let l of a.invalidatedNodeHexagons)i[l]++,f.push(l);if(o.push(...a.invalidatedCells),d(h+1))return!0;for(let l of a.invalidatedHexagons)r[l]--,c.pop();for(let l of a.invalidatedNodeHexagons)i[l]--,f.pop();for(let l=0;l<a.invalidatedCells.length;l++)o.pop()}}return!1};return d(0)?{invalidatedCells:o,invalidatedHexIndices:c,invalidatedNodeHexIndices:f}:null}checkTetrisConstraint(e,t,s,n=[]){let r=s.reduce((v,S)=>v+this.getShapeArea(S.shape),0),i=n.reduce((v,S)=>v+this.getShapeArea(S.shape),0),o=r-i;if(o<0||o!==0&&o!==t.length)return!1;let c=e.rows,f=e.cols;this.tetrisCache.size>1e4&&this.tetrisCache.clear();let d=new Uint8Array(c*f);for(let v of t)d[v.y*f+v.x]=1;let h=(v,S)=>`${this.getShapeKey(v.shape)}-${v.rotatable}-${S}`,a=[...s.map(v=>h(v,1)),...n.map(v=>h(v,-1))].sort().join("|"),y=`${c}x${f}:${d.join("")}:${a}`;if(this.tetrisCache.has(y))return this.tetrisCache.get(y);let l=new Int8Array(c*f);if(o>0)for(let v=0;v<d.length;v++)l[v]=d[v];let u=new Int8Array(c*f),m=[],P=[...s.map(v=>({...v,sign:1})),...n.map(v=>({...v,sign:-1}))];for(let v of P){let S=v.rotatable?this.getAllRotations(v.shape):[v.shape],T=this.getShapeKey(S[0]),C=m.find(N=>N.sign===v.sign&&(v.rotatable?N.rotations.length>1:N.rotations.length===1)&&this.getShapeKey(N.rotations[0].shape)===T);C?C.count++:m.push({rotations:S.map(N=>({shape:N,h:N.length,w:N[0].length})),sign:v.sign,area:this.getShapeArea(v.shape),count:1})}m.sort((v,S)=>S.sign-v.sign||S.area-v.area);let E=o>0?t.length:0,p=0,g=r,x=i,w=(v,S,T)=>{if(E>g||p>x)return!1;if(v===m.length)return E===0&&p===0;let C=m[v],N=S+1,$=N===C.count;C.sign===1?g-=C.area:x-=C.area;for(let O of C.rotations){let K=O.h,D=O.w,V=S===0?0:T;for(let k=V;k<=c*f-(K>0?(K-1)*f+D:0);k++){let W=Math.floor(k/f),F=k%f;if(W>c-K||F>f-D)continue;let R=!0,M=[];for(let A=0;A<K;A++){for(let Z=0;Z<D;Z++)if(O.shape[A][Z]){let U=(W+A)*f+(F+Z);C.sign===1?u[U]<l[U]?E--:p++:u[U]<=l[U]?E++:p--,u[U]+=C.sign,M.push(U),u[U]<0&&(R=!1),C.sign===1&&u[U]>1+i&&(R=!1)}if(!R)break}if(R){if($){if(w(v+1,0,0)){for(let A of M)u[A]-=C.sign,C.sign===1?u[A]<l[A]?E++:p--:u[A]<=l[A]?E--:p++;return C.sign===1?g+=C.area:x+=C.area,!0}}else if(w(v,N,k)){for(let A of M)u[A]-=C.sign,C.sign===1?u[A]<l[A]?E++:p--:u[A]<=l[A]?E--:p++;return C.sign===1?g+=C.area:x+=C.area,!0}}for(let A of M)u[A]-=C.sign,C.sign===1?u[A]<l[A]?E++:p--:u[A]<=l[A]?E--:p++}}return C.sign===1?g+=C.area:x+=C.area,!1},b=w(0,0,0);return this.tetrisCache.set(y,b),b}getShapeArea(e){let t=0;for(let s of e)for(let n of s)n&&t++;return t}getShapeKey(e){return JSON.stringify(e)}getAllRotations(e){let t=[],s=new Set,n=e;for(let r=0;r<4;r++){let i=this.getShapeKey(n);s.has(i)||(t.push(n),s.add(i)),n=this.rotate90(n)}return t}rotate90(e){let t=e.length,s=e[0].length,n=Array.from({length:s},()=>Array(t).fill(0));for(let r=0;r<t;r++)for(let i=0;i<s;i++)n[i][t-1-r]=e[r][i];return n}calculateRegions(e,t,s=[],n){let r=[],i=e.rows,o=e.cols,c=new Uint8Array(i*o),f=new Uint8Array((i+1)*o),d=new Uint8Array(i*(o+1)),h=(y,l)=>{y.x===l.x?d[Math.min(y.y,l.y)*(o+1)+y.x]=1:f[y.y*o+Math.min(y.x,l.x)]=1};for(let y=0;y<t.length-1;y++)h(t[y],t[y+1]);for(let y=0;y<s.length-1;y++)h(s[y],s[y+1]);for(let y=0;y<=i;y++)for(let l=0;l<o;l++)e.hEdges[y][l].type===2&&(f[y*o+l]=1);for(let y=0;y<i;y++)for(let l=0;l<=o;l++)e.vEdges[y][l].type===2&&(d[y*(o+1)+l]=1);let a=n||this.getExternalCells(e);for(let y=0;y<i;y++)for(let l=0;l<o;l++){let u=y*o+l;if(c[u]||a&&a.has(`${l},${y}`))continue;let m=[],P=[u];c[u]=1;let E=0;for(;E<P.length;){let p=P[E++],g=p%o,x=Math.floor(p/o);if(m.push({x:g,y:x}),x>0&&!f[x*o+g]){let w=(x-1)*o+g;!c[w]&&(!a||!a.has(`${g},${x-1}`))&&(c[w]=1,P.push(w))}if(x<i-1&&!f[(x+1)*o+g]){let w=(x+1)*o+g;!c[w]&&(!a||!a.has(`${g},${x+1}`))&&(c[w]=1,P.push(w))}if(g>0&&!d[x*(o+1)+g]){let w=x*o+(g-1);!c[w]&&(!a||!a.has(`${g-1},${x}`))&&(c[w]=1,P.push(w))}if(g<o-1&&!d[x*(o+1)+(g+1)]){let w=x*o+(g+1);!c[w]&&(!a||!a.has(`${g+1},${x}`))&&(c[w]=1,P.push(w))}}r.push(m)}return r}getExternalCells(e){let t=new Set,s=[];for(let n=0;n<e.cols;n++)e.hEdges[0][n].type===2&&(t.has(`${n},0`)||(t.add(`${n},0`),s.push({x:n,y:0}))),e.hEdges[e.rows][n].type===2&&(t.has(`${n},${e.rows-1}`)||(t.add(`${n},${e.rows-1}`),s.push({x:n,y:e.rows-1})));for(let n=0;n<e.rows;n++)e.vEdges[n][0].type===2&&(t.has(`0,${n}`)||(t.add(`0,${n}`),s.push({x:0,y:n}))),e.vEdges[n][e.cols].type===2&&(t.has(`${e.cols-1},${n}`)||(t.add(`${e.cols-1},${n}`),s.push({x:e.cols-1,y:n})));for(;s.length>0;){let n=s.shift(),r=[{nx:n.x,ny:n.y-1,edge:e.hEdges[n.y][n.x]},{nx:n.x,ny:n.y+1,edge:e.hEdges[n.y+1][n.x]},{nx:n.x-1,ny:n.y,edge:e.vEdges[n.y][n.x]},{nx:n.x+1,ny:n.y,edge:e.vEdges[n.y][n.x+1]}];for(let i of r)i.nx>=0&&i.nx<e.cols&&i.ny>=0&&i.ny<e.rows&&!t.has(`${i.nx},${i.ny}`)&&i.edge.type===2&&(t.add(`${i.nx},${i.ny}`),s.push({x:i.nx,y:i.ny}))}return t}getSymmetricalPoint(e,t){let s=e.symmetry||0;return s===1?{x:e.cols-t.x,y:t.y}:s===2?{x:t.x,y:e.rows-t.y}:s===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getSymmetricalPointIndex(e,t){let s=e.cols+1,n=Math.floor(t/s),r=t%s,i=e.symmetry||0,o=n,c=r;return i===1?c=e.cols-r:i===2?o=e.rows-n:i===3&&(c=e.cols-r,o=e.rows-n),o*s+c}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}calculateDifficulty(e,t){let s=e.rows,n=e.cols,r=n+1,i=(s+1)*r,o=Array.from({length:i},()=>[]),c=[],f=[],d=Array(i).fill(!1),h=new Map,a=0,y=new Set,l=new Set;for(let R=0;R<=s;R++)for(let M=0;M<=n;M++){let A=R*r+M;if(e.nodes[R][M].type===1&&c.push(A),e.nodes[R][M].type===2&&(f.push(A),d[A]=!0),(e.nodes[R][M].type===3||e.nodes[R][M].type===4||e.nodes[R][M].type===5)&&(h.set(`n${M},${R}`,a++),l.add(A)),M<n){let Z=A+1,U=e.hEdges[R][M].type,J=U===3||U===4||U===5,X=U===1||U===2;o[A].push({next:Z,hexType:U,isBroken:X}),o[Z].push({next:A,hexType:U,isBroken:X}),J&&(h.set(`eh${M},${R}`,a++),y.add(this.getEdgeKey({x:M,y:R},{x:M+1,y:R})))}if(R<s){let Z=A+r,U=e.vEdges[R][M].type,J=U===3||U===4||U===5,X=U===1||U===2;o[A].push({next:Z,hexType:U,isBroken:X}),o[Z].push({next:A,hexType:U,isBroken:X}),J&&(h.set(`ev${M},${R}`,a++),y.add(this.getEdgeKey({x:M,y:R},{x:M,y:R+1})))}}let u={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},m=a,P=new Set,E=Math.max(1e3,s*n*200),p=this.getExternalCells(e),g=!1;for(let R=0;R<s;R++){for(let M=0;M<n;M++)if(e.cells[R][M].type!==0){g=!0;break}if(g)break}this.tetrisCache.clear(),this.reachabilityCache.clear();let x=t?t.map(R=>R.y*r+R.x):c;for(let R of x){let M=e.cols+1,A=Math.floor(R/M),Z=R%M,U=0n,J=e.nodes[A][Z].type;(J===3||J===4)&&(U|=1n<<BigInt(h.get(`n${Z},${A}`)));let X=e.symmetry||0;if(X!==0){let B=this.getSymmetricalPointIndex(e,R),I=Math.floor(B/M),j=B%M,z=e.nodes[I][j].type;(z===3||z===5)&&(U|=1n<<BigInt(h.get(`n${j},${I}`)))}let Q=1n<<BigInt(R);if(X!==0){let B=this.getSymmetricalPointIndex(e,R);if(B===R)continue;Q|=1n<<BigInt(B)}this.exploreSearchSpace(e,R,Q,[R],U,m,o,f,d,P,u,E,p,g,h)}if(u.solutions===0)return 0;let w=y.size+l.size,b=new Set;y.size>0&&b.add(999);let v=0,S=0,T=0;for(let R=0;R<s;R++)for(let M=0;M<n;M++){let A=e.cells[R][M];A.type!==0&&(w++,b.add(A.type),A.type===3?v++:A.type===4?(v++,S++):A.type===8&&T++)}let C=u.branchingPoints/(u.totalNodesVisited||1),N=Math.log10(u.totalNodesVisited+1),$=(C*10+N*1.5)/(Math.log2(u.solutions+1)*.5+1);$-=y.size*.05,$+=l.size*.12,v>0&&($+=(v-S)*.5,$+=S*.2);let O=0,K=0;for(let R=0;R<s;R++)for(let M=0;M<n;M++){let A=e.cells[R][M];A.type===5?O++:A.type===6&&(O++,K++)}O>0&&($+=(O-K)*.6,$+=K*.3),T>0&&($+=T*.25);let D=s*n,V=w/D,k=V<.25?Math.pow(V/.25,4):1,W=b.size<=1?.5:1;$*=k*W;let F=Math.log2(D)/5;return $*=F,Math.max(.01,Math.min(1,$/4))}exploreSearchSpace(e,t,s,n,r,i,o,c,f,d,h,a,y,l=!0,u){if(h.totalNodesVisited++,h.maxDepth=Math.max(h.maxDepth,n.length),h.totalNodesVisited>a)return;let m=e.symmetry||0;if(f[t]){let p=0,g=r;for(;g>0n;)g&1n&&p++,g>>=1n;if(p===i){let x=n.map(v=>({x:v%(e.cols+1),y:Math.floor(v/(e.cols+1))})),w={points:x};if(m!==0){let v=this.getSymmetricalPointIndex(e,t),S=e.cols+1;if(e.nodes[Math.floor(v/S)][v%S].type!==2)return}let b=m!==0?x.map(v=>this.getSymmetricalPoint(e,v)):[];if(l){let v=this.validateFast(e,x,b,y);if(v.isValid){let S=this.getFingerprint(e,x,b,v.regions,y);d.has(S)||(d.add(S),h.solutions++)}}else{let v=this.getFingerprint(e,x,b,void 0,y);d.has(v)||(d.add(v),h.solutions++)}}return}if(!this.canReachEndOptimized(t,s,o,f)){h.backtracks++;return}let P=[];for(let p of o[t]){if(p.isBroken||s&1n<<BigInt(p.next))continue;if(m!==0){let x=this.getSymmetricalPointIndex(e,t),w=this.getSymmetricalPointIndex(e,p.next);if(p.next===w||t===w&&p.next===x)continue}let g=!0;for(let x of o[t])if(x.hexType===3||x.hexType===4){let b=n.length>=2&&x.next===n[n.length-2],v=x.next===p.next;if(!b&&!v){g=!1;break}}if(g){if(m!==0){let x=this.getSymmetricalPointIndex(e,t),w=this.getSymmetricalPointIndex(e,p.next);for(let b of o[x])if(b.hexType===3||b.hexType===5){let S=n.length>=2?this.getSymmetricalPointIndex(e,n[n.length-2]):-1,T=b.next===S,C=b.next===w;if(!T&&!C){g=!1;break}}}g&&P.push(p)}}if(P.length>1&&h.branchingPoints++,e.rows*e.cols>30)for(let p=P.length-1;p>0;p--){let g=this.rng?this.rng.next():Math.random(),x=Math.floor(g*(p+1));[P[p],P[x]]=[P[x],P[p]]}let E=e.cols+1;for(let p of P){let g=r,x=Math.floor(p.next/E),w=p.next%E,b=e.nodes[x][w].type;(b===3||b===4)&&(g|=1n<<BigInt(u.get(`n${w},${x}`)));let v=n[n.length-1],S=Math.floor(v/E),T=v%E;if(S===x){let N=Math.min(T,w);(p.hexType===3||p.hexType===4)&&(g|=1n<<BigInt(u.get(`eh${N},${x}`)))}else{let N=Math.min(S,x);(p.hexType===3||p.hexType===4)&&(g|=1n<<BigInt(u.get(`ev${w},${N}`)))}if(m!==0){let N=this.getSymmetricalPointIndex(e,p.next),$=Math.floor(N/E),O=N%E,K=e.nodes[$][O].type;(K===3||K===5)&&(g|=1n<<BigInt(u.get(`n${O},${$}`)));let D=this.getSymmetricalPointIndex(e,v),V=Math.floor(D/E),k=D%E;if(V===$){let W=Math.min(k,O),F=e.hEdges[$][W].type;(F===3||F===5)&&(g|=1n<<BigInt(u.get(`eh${W},${$}`)))}else{let W=Math.min(V,$),F=e.vEdges[W][O].type;(F===3||F===5)&&(g|=1n<<BigInt(u.get(`ev${O},${W}`)))}}n.push(p.next);let C=s|1n<<BigInt(p.next);if(m!==0){let N=this.getSymmetricalPointIndex(e,p.next);C|=1n<<BigInt(N)}if(this.exploreSearchSpace(e,p.next,C,n,g,i,o,c,f,d,h,a,y,l,u),n.pop(),h.totalNodesVisited>a)return}}countSolutions(e,t=100,s){let n=e.rows,r=e.cols,i=r+1,o=(n+1)*i,c=Array.from({length:o},()=>[]),f=[],d=[],h=Array(o).fill(!1),a=new Map,y=0;for(let p=0;p<=n;p++)for(let g=0;g<=r;g++){let x=p*i+g;if(e.nodes[p][g].type===1&&f.push(x),e.nodes[p][g].type===2&&(d.push(x),h[x]=!0),(e.nodes[p][g].type===3||e.nodes[p][g].type===4||e.nodes[p][g].type===5)&&a.set(`n${g},${p}`,y++),g<r){let w=x+1,b=e.hEdges[p][g].type,v=b===3||b===4||b===5,S=b===1||b===2;c[x].push({next:w,hexType:b,isBroken:S}),c[w].push({next:x,hexType:b,isBroken:S}),v&&a.set(`eh${g},${p}`,y++)}if(p<n){let w=x+i,b=e.vEdges[p][g].type,v=b===3||b===4||b===5,S=b===1||b===2;c[x].push({next:w,hexType:b,isBroken:S}),c[w].push({next:x,hexType:b,isBroken:S}),v&&a.set(`ev${g},${p}`,y++)}}let l=new Set,u=y,m=this.getExternalCells(e),P=!1;for(let p=0;p<n;p++){for(let g=0;g<r;g++)if(e.cells[p][g].type!==0){P=!0;break}if(P)break}this.tetrisCache.clear(),this.reachabilityCache.clear();let E=s?s.map(p=>p.y*i+p.x):f;for(let p of E){let g=e.cols+1,x=Math.floor(p/g),w=p%g,b=0n,v=e.nodes[x][w].type;(v===3||v===4)&&(b|=1n<<BigInt(a.get(`n${w},${x}`)));let S=e.symmetry||0;if(S!==0){let C=this.getSymmetricalPointIndex(e,p),N=Math.floor(C/g),$=C%g,O=e.nodes[N][$].type;(O===3||O===5)&&(b|=1n<<BigInt(a.get(`n${$},${N}`)))}let T=1n<<BigInt(p);if(S!==0){let C=this.getSymmetricalPointIndex(e,p);if(C===p)continue;T|=1n<<BigInt(C)}this.findPathsOptimized(e,p,T,[p],b,u,c,d,h,l,t,m,P,a)}return l.size}findPathsOptimized(e,t,s,n,r,i,o,c,f,d,h,a,y=!0,l){if(d.size>=h)return;let u=e.symmetry||0;if(f[t]){let m=0,P=r;for(;P>0n;)P&1n&&m++,P>>=1n;if(m===i){let E=n.map(g=>({x:g%(e.cols+1),y:Math.floor(g/(e.cols+1))}));if(u!==0){let g=this.getSymmetricalPointIndex(e,t),x=e.cols+1;if(e.nodes[Math.floor(g/x)][g%x].type!==2)return}let p=u!==0?E.map(g=>this.getSymmetricalPoint(e,g)):[];if(!y)d.add(this.getFingerprint(e,E,p,void 0,a));else{let g=this.validateFast(e,E,p,a);g.isValid&&d.add(this.getFingerprint(e,E,p,g.regions,a))}}return}if(this.canReachEndOptimized(t,s,o,f))for(let m of o[t]){if(m.isBroken||s&1n<<BigInt(m.next))continue;if(u!==0){let T=this.getSymmetricalPointIndex(e,t),C=this.getSymmetricalPointIndex(e,m.next);if(m.next===C||t===C&&m.next===T)continue}let P=!0;for(let T of o[t])if(T.hexType===3||T.hexType===4){let N=n.length>=2&&T.next===n[n.length-2],$=T.next===m.next;if(!N&&!$){P=!1;break}}if(!P)continue;if(u!==0){let T=this.getSymmetricalPointIndex(e,t),C=this.getSymmetricalPointIndex(e,m.next);for(let N of o[T])if(N.hexType===3||N.hexType===5){let O=n.length>=2?this.getSymmetricalPointIndex(e,n[n.length-2]):-1,K=N.next===O,D=N.next===C;if(!K&&!D){P=!1;break}}}if(!P)continue;let E=e.cols+1,p=r,g=Math.floor(m.next/E),x=m.next%E,w=e.nodes[g][x].type;(w===3||w===4)&&(p|=1n<<BigInt(l.get(`n${x},${g}`)));let b=Math.floor(t/E),v=t%E;if(b===g){let T=Math.min(v,x);(m.hexType===3||m.hexType===4)&&(p|=1n<<BigInt(l.get(`eh${T},${g}`)))}else{let T=Math.min(b,g);(m.hexType===3||m.hexType===4)&&(p|=1n<<BigInt(l.get(`ev${x},${T}`)))}if(u!==0){let T=this.getSymmetricalPointIndex(e,m.next),C=Math.floor(T/E),N=T%E,$=e.nodes[C][N].type;($===3||$===5)&&(p|=1n<<BigInt(l.get(`n${N},${C}`)));let O=this.getSymmetricalPointIndex(e,t),K=Math.floor(O/E),D=O%E;if(K===C){let V=Math.min(D,N),k=e.hEdges[C][V].type;(k===3||k===5)&&(p|=1n<<BigInt(l.get(`eh${V},${C}`)))}else{let V=Math.min(K,C),k=e.vEdges[V][N].type;(k===3||k===5)&&(p|=1n<<BigInt(l.get(`ev${N},${V}`)))}}n.push(m.next);let S=s|1n<<BigInt(m.next);if(u!==0){let T=this.getSymmetricalPointIndex(e,m.next);S|=1n<<BigInt(T)}if(this.findPathsOptimized(e,m.next,S,n,p,i,o,c,f,d,h,a,y,l),n.pop(),d.size>=h)return}}canReachEndOptimized(e,t,s,n){let r=`${e}:${t.toString()}`,i=this.reachabilityCache.get(r);if(i!==void 0)return i;let o=[e],c=t,f=0;for(;f<o.length;){let d=o[f++];if(n[d])return this.reachabilityCache.set(r,!0),!0;for(let h of s[d])!h.isBroken&&!(c&1n<<BigInt(h.next))&&(c|=1n<<BigInt(h.next),o.push(h.next))}return this.reachabilityCache.set(r,!1),!1}getFingerprint(e,t,s,n,r){let o=(n||this.calculateRegions(e,t,s,r)).map(f=>{let d="",h=[];for(let a of f){let y=e.cells[a.y][a.x];y.type!==0&&h.push(y.type<<8|y.color)}h.sort((a,y)=>a-y);for(let a of h)d+=a.toString(36)+",";return d}).sort(),c="";for(let f of o)f.length>0&&(c+=f+"|");return c||"empty"}};var ce=class{isWorker;TETRIS_SHAPES_WITH_ROTATIONS=[];rng=null;constructor(){this.isWorker=typeof self<"u"&&"postMessage"in self&&!("document"in self);for(let e of this.TETRIS_SHAPES)this.TETRIS_SHAPES_WITH_ROTATIONS.push(this.getAllRotations(e))}stringToSeed(e){try{if(/^[0-9a-fA-F]+$/.test(e))return BigInt("0x"+e)}catch{}let t=0n;for(let s=0;s<e.length;s++)t=(t<<5n)-t+BigInt(e.charCodeAt(s));return t}generate(e,t,s={}){let n=s.rngType??0,r=s.seed;r||(r=Math.floor(Math.random()*4294967295).toString(16));let i=r,o=this.stringToSeed(r),c=s.difficulty??.5,f=new ae,d=null,h=-1,a=e*t<=16,y=this.isWorker?e*t>30?120:a?250:150:e*t>30?80:a?200:100,l=this.isWorker?8:a?12:6,u=s.symmetry||0,m=s.starts?[...s.starts]:[{x:0,y:e}];if(u!==0){let x=[];for(let w of m){let b=this.getSymmetricalPoint({rows:e,cols:t},w,u);m.some(v=>v.x===b.x&&v.y===b.y)||x.push(b)}m.push(...x)}let P=s.ends?[...s.ends]:[];if(P.length===0&&(u===1?P=[{x:0,y:0}]:u===2?P=[{x:t,y:e}]:u===3?P=[{x:t,y:e}]:P=[{x:t,y:0}]),u!==0){let x=[];for(let w of P){let b=this.getSymmetricalPoint({rows:e,cols:t},w,u);P.some(v=>v.x===b.x&&v.y===b.y)||x.push(b)}P.push(...x)}let E=null,p=null,g=null;for(let x=0;x<y;x++){let w=(o^0x5deece66dn)+0xbn;if(this.rng=pe(n,o^0x5deece66dn),f.setRng(this.rng),x%l===0){E=this.generateRandomPath(new ie(e,t),m,P,s.pathLength,u);let O=new ie(e,t),K=u!==0?E.map(D=>this.getSymmetricalPoint(O,D,u)):[];p=this.calculateRegions(O,E,K),g=p.map(D=>this.getRegionBoundaryEdges(O,D,E,K))}let b=this.generateFromPath(e,t,E,s,m,P,p,g);if(!f.validate(b,{points:E}).isValid){o=w;continue}let S=E[0],T=[S];if(u!==0){let O=this.getSymmetricalPoint(b,S,u);(O.x!==S.x||O.y!==S.y)&&T.push(O)}let C=m.filter(O=>!T.some(K=>K.x===O.x&&K.y===O.y));if(C.length>0&&f.countSolutions(b,10,C)>2){o=w;continue}if(!this.checkAllRequestedConstraintsPresent(b,s)){o=w;continue}let N=f.calculateDifficulty(b);if(N===0){o=w;continue}let $=Math.abs(N-c);if((d===null||$<Math.abs(h-c))&&(h=N,d=b,d.seed=i),c>.8&&N>.8){d.seed=i;break}if($<.01){d.seed=i;break}o=w}if(!d){for(let b=0;b<50;b++){this.rng=pe(n,o),f.setRng(this.rng);let v=this.generateRandomPath(new ie(e,t),m,P,s.pathLength,u),S=this.generateFromPath(e,t,v,s,m,P);if(f.validate(S,{points:v}).isValid)return S.seed=i,S;o=(o^0x5deece66dn)+0xbn}this.rng=pe(n,o),f.setRng(this.rng);let x=this.generateRandomPath(new ie(e,t),m,P,s.pathLength,u),w=this.generateFromPath(e,t,x,s,m,P);return w.seed=i,w}return d}generateFromPath(e,t,s,n,r,i,o,c){let f=new ie(e,t),d=n.symmetry||0;f.symmetry=d;for(let a of r)f.nodes[a.y][a.x].type=1;for(let a of i)f.nodes[a.y][a.x].type=2;let h=d!==0?s.map(a=>this.getSymmetricalPoint(f,a,d)):[];return this.applyConstraintsBasedOnPath(f,s,n,h,o,c),n.useBrokenEdges&&this.applyBrokenEdges(f,s,n),this.cleanGrid(f),f}generateRandomPath(e,t,s,n,r=0){if(n===void 0)return this.generateSingleRandomPath(e,t,s,void 0,r);let i=e.rows+e.cols,o=(e.rows+1)*(e.cols+1)-1,c=i+n*(o-i),f=[],d=1/0,h=e.rows*e.cols>30?30:50;for(let a=0;a<h;a++){let y=this.generateSingleRandomPath(e,t,s,n,r);if(y.length===0)continue;let l=y.length-1,u=Math.abs(l-c);if(u<d&&(d=u,f=y),d<=2)break}return f}generateSingleRandomPath(e,t,s,n,r=0){let i=(e.rows+1)*(e.cols+1),o=new Array(i).fill(!1),c=[],f=0,d=e.rows*e.cols*200,h=t[Math.floor(this.rng.next()*t.length)],a=new Array(i).fill(!1);for(let l of s)a[this.toPointIndex(e,l.x,l.y)]=!0;let y=l=>{if(f++,f>d)return!1;let u=this.toPointIndex(e,l.x,l.y);o[u]=!0;let m=this.getSymmetricalPoint(e,l,r),P=this.toPointIndex(e,m.x,m.y);if(o[P]=!0,c.push(l),a[u])if(r!==0){if(a[P])return!0}else return!0;let E=this.getValidNeighbors(e,l,o);r!==0&&(E=E.filter(p=>{let g=this.getSymmetricalPoint(e,p,r);if(g.x<0||g.x>e.cols||g.y<0||g.y>e.rows||o[this.toPointIndex(e,g.x,g.y)]||p.x===g.x&&p.y===g.y)return!1;let x=this.getEdgeKey(l,p),w=this.getEdgeKey(m,g);return x!==w})),n!==void 0?E.sort((p,g)=>{let x=S=>Math.min(...s.map(T=>Math.abs(S.x-T.x)+Math.abs(S.y-T.y))),w=x(p),b=x(g);return(w-b)*(1-n*2)+(this.rng.next()-.5)*1.5}):this.shuffleArray(E);for(let p of E)if(y(p))return!0;return c.pop(),o[u]=!1,o[P]=!1,!1};return y(h),c}toPointIndex(e,t,s){return s*(e.cols+1)+t}getValidNeighbors(e,t,s){let n=[],r=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let i of r){let o=t.x+i.x,c=t.y+i.y;o>=0&&o<=e.cols&&c>=0&&c<=e.rows&&(!s||!s[this.toPointIndex(e,o,c)])&&n.push({x:o,y:c})}return n}applyBrokenEdges(e,t,s){let n=s.complexity??.5,r=s.symmetry??0,i=new Set;for(let h=0;h<t.length-1;h++)if(i.add(this.getEdgeKey(t[h],t[h+1])),r!==0){let a=this.getSymmetricalPoint(e,t[h],r),y=this.getSymmetricalPoint(e,t[h+1],r);i.add(this.getEdgeKey(a,y))}let o=[];for(let h=0;h<=e.rows;h++)for(let a=0;a<e.cols;a++){let y={x:a,y:h},l={x:a+1,y:h};i.has(this.getEdgeKey(y,l))||o.push({type:"h",r:h,c:a,p1:y,p2:l})}for(let h=0;h<e.rows;h++)for(let a=0;a<=e.cols;a++){let y={x:a,y:h},l={x:a,y:h+1};i.has(this.getEdgeKey(y,l))||o.push({type:"v",r:h,c:a,p1:y,p2:l})}this.shuffleArray(o);let c=Math.max(1,Math.floor(n*(e.rows*e.cols)/4)),f=0;for(let h of o){if(f>=c)break;h.type==="h"?e.hEdges[h.r][h.c].type=1:e.vEdges[h.r][h.c].type=1,f++}let d=!0;for(;d;){d=!1;for(let h=0;h<=e.rows;h++)for(let a=0;a<e.cols;a++)e.hEdges[h][a].type===1&&this.canBecomeAbsent(e,{type:"h",r:h,c:a})&&(e.hEdges[h][a].type=2,d=!0);for(let h=0;h<e.rows;h++)for(let a=0;a<=e.cols;a++)e.vEdges[h][a].type===1&&this.canBecomeAbsent(e,{type:"v",r:h,c:a})&&(e.vEdges[h][a].type=2,d=!0)}for(let h=0;h<=e.rows;h++)for(let a=0;a<=e.cols;a++){let y=[];if(a>0&&y.push({e:e.hEdges[h][a-1],type:"h",r:h,c:a-1}),a<e.cols&&y.push({e:e.hEdges[h][a],type:"h",r:h,c:a}),h>0&&y.push({e:e.vEdges[h-1][a],type:"v",r:h-1,c:a}),h<e.rows&&y.push({e:e.vEdges[h][a],type:"v",r:h,c:a}),y.length>0&&y.every(l=>l.e.type===1||l.e.type===2)&&y.every(l=>!this.isAdjacentToMark(e,l)))for(let l of y)l.e.type=2}}canBecomeAbsent(e,t){if(this.isAdjacentToMark(e,t))return!1;if(t.type==="h"){if(t.r===0||t.r===e.rows)return!0}else if(t.c===0||t.c===e.cols)return!0;let s=t.type==="h"?[{x:t.c,y:t.r},{x:t.c+1,y:t.r}]:[{x:t.c,y:t.r},{x:t.c,y:t.r+1}];for(let n of s){let r=[{type:"h",r:n.y,c:n.x-1},{type:"h",r:n.y,c:n.x},{type:"v",r:n.y-1,c:n.x},{type:"v",r:n.y,c:n.x}];for(let i of r)if(i.c>=0&&i.c<=e.cols&&i.r>=0&&i.r<=e.rows){if(i.type==="h"&&i.c<e.cols){if(e.hEdges[i.r][i.c].type===2)return!0}else if(i.type==="v"&&i.r<e.rows&&e.vEdges[i.r][i.c].type===2)return!0}}return!1}cleanGrid(e){let t=[];for(let i=0;i<=e.rows;i++)for(let o=0;o<=e.cols;o++)e.nodes[i][o].type===1&&t.push({x:o,y:i});let s=new Set,n=[...t];for(let i of t)s.add(`${i.x},${i.y}`);for(;n.length>0;){let i=n.shift(),o=[{nx:i.x,ny:i.y-1,edge:e.vEdges[i.y-1]?.[i.x]},{nx:i.x,ny:i.y+1,edge:e.vEdges[i.y]?.[i.x]},{nx:i.x-1,ny:i.y,edge:e.hEdges[i.y]?.[i.x-1]},{nx:i.x+1,ny:i.y,edge:e.hEdges[i.y]?.[i.x]}];for(let c of o)c.edge&&c.edge.type!==2&&(s.has(`${c.nx},${c.ny}`)||(s.add(`${c.nx},${c.ny}`),n.push({x:c.nx,y:c.ny})))}for(let i=0;i<=e.rows;i++)for(let o=0;o<e.cols;o++)(!s.has(`${o},${i}`)||!s.has(`${o+1},${i}`))&&(e.hEdges[i][o].type=2);for(let i=0;i<e.rows;i++)for(let o=0;o<=e.cols;o++)(!s.has(`${o},${i}`)||!s.has(`${o},${i+1}`))&&(e.vEdges[i][o].type=2);let r=this.getExternalCells(e);for(let i of r){let[o,c]=i.split(",").map(Number);e.cells[c][o].type=0}}getExternalCells(e){let t=new Set,s=[];for(let n=0;n<e.cols;n++)e.hEdges[0][n].type===2&&(t.has(`${n},0`)||(t.add(`${n},0`),s.push({x:n,y:0}))),e.hEdges[e.rows][n].type===2&&(t.has(`${n},${e.rows-1}`)||(t.add(`${n},${e.rows-1}`),s.push({x:n,y:e.rows-1})));for(let n=0;n<e.rows;n++)e.vEdges[n][0].type===2&&(t.has(`0,${n}`)||(t.add(`0,${n}`),s.push({x:0,y:n}))),e.vEdges[n][e.cols].type===2&&(t.has(`${e.cols-1},${n}`)||(t.add(`${e.cols-1},${n}`),s.push({x:e.cols-1,y:n})));for(;s.length>0;){let n=s.shift(),r=[{nx:n.x,ny:n.y-1,edge:e.hEdges[n.y][n.x]},{nx:n.x,ny:n.y+1,edge:e.hEdges[n.y+1][n.x]},{nx:n.x-1,ny:n.y,edge:e.vEdges[n.y][n.x]},{nx:n.x+1,ny:n.y,edge:e.vEdges[n.y][n.x+1]}];for(let i of r)i.nx>=0&&i.nx<e.cols&&i.ny>=0&&i.ny<e.rows&&!t.has(`${i.nx},${i.ny}`)&&i.edge.type===2&&(t.add(`${i.nx},${i.ny}`),s.push({x:i.nx,y:i.ny}))}return t}isAdjacentToMark(e,t){if(t.type==="h"){if(t.r>0&&e.cells[t.r-1][t.c].type!==0||t.r<e.rows&&e.cells[t.r][t.c].type!==0)return!0}else if(t.c>0&&e.cells[t.r][t.c-1].type!==0||t.c<e.cols&&e.cells[t.r][t.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let t=0;t<e.rows;t++)for(let s=0;s<e.cols;s++){if(e.cells[t][s].type===0)continue;if([e.hEdges[t][s],e.hEdges[t+1][s],e.vEdges[t][s],e.vEdges[t][s+1]].every(r=>r.type===1||r.type===2))return!0}return!1}getSymmetricalPoint(e,t,s){return s===1?{x:e.cols-t.x,y:t.y}:s===2?{x:t.x,y:e.rows-t.y}:s===3?{x:e.cols-t.x,y:e.rows-t.y}:{...t}}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,t,s,n=[],r,i){let o=s.complexity??.5,c=s.useHexagons??!0,f=s.useSquares??!0,d=s.useStars??!0,h=s.useTetris??!1,a=s.useTetrisNegative??!1,y=s.useEraser??!1,l=s.useTriangles??!1,u=0,m=0,P=0,E=0,p=0,g=0,x=Math.floor(e.rows*e.cols*.6);if(c){let w=s.difficulty??.5,b=s.symmetry||0;for(let v=0;v<t.length-1;v++){let T=this.getValidNeighbors(e,t[v]).length>2,C=o*(w<.4?.6:.3);if(T&&(C=w<.4?C*1:C*.5),this.rng.next()<C){let N=3,$=t[v],O=t[v+1];if(b!==0){let K=this.rng.next();K<.3?N=4:K<.6&&(N=5,$=this.getSymmetricalPoint(e,t[v],b),O=this.getSymmetricalPoint(e,t[v+1],b))}this.setEdgeHexagon(e,$,O,N),u++}}for(let v=0;v<t.length;v++){let S=t[v];if(e.nodes[S.y][S.x].type!==0||this.hasIncidentHexagonEdge(e,S))continue;let T=o*(w>.6?.15:.05);if(this.rng.next()<T){let C=3,N=S;if(b!==0){let $=this.rng.next();$<.3?C=4:$<.6&&(C=5,N=this.getSymmetricalPoint(e,S,b))}e.nodes[N.y][N.x].type=C,u++}}if(u===0&&t.length>=2){let v=Math.floor(this.rng.next()*(t.length-1)),S=s.symmetry||0,T=3,C=t[v],N=t[v+1];if(S!==0){let $=this.rng.next();$<.3?T=4:$<.6&&(T=5,C=this.getSymmetricalPoint(e,t[v],S),N=this.getSymmetricalPoint(e,t[v+1],S))}this.setEdgeHexagon(e,C,N,T)}}if(f||d||h||y||l){let w=r||this.calculateRegions(e,t,n),b=s.availableColors??[Y.Black,Y.White,Y.Red,Y.Blue],v=s.defaultColors??{},S=(D,V)=>{if(v[D]!==void 0)return v[D];let k=re[D];return k&&v[k]!==void 0?v[k]:D===4?S(3,V):D===6?S(5,V):V},T=Array.from({length:w.length},(D,V)=>V);this.shuffleArray(T);let C=new Set,N={square:f,star:d,tetris:h,tetrisNegative:a,eraser:y,triangle:l},$=0,O=0,K=new Set;for(let D=0;D<t.length-1;D++)K.add(this.getEdgeKey(t[D],t[D+1]));for(let D=0;D<n.length-1;D++)K.add(this.getEdgeKey(n[D],n[D+1]));for(let D=0;D<T.length;D++){let V=T[D],k=w[V],W=T.length-D,F=N.square&&m===0||N.star&&P===0||N.tetris&&E===0||N.tetrisNegative&&$===0||N.eraser&&p===0||N.triangle&&O===0,R=.2+o*.6;if(F&&W<=3?R=1:F&&W<=6&&(R=.7),this.rng.next()>R)continue;let M=[...k];this.shuffleArray(M);let A=new Set,Z=b[Math.floor(this.rng.next()*b.length)];if(f&&C.size<2){let J=b.filter(X=>!C.has(X));J.length>0&&(Z=J[Math.floor(this.rng.next()*J.length)])}let U=f&&this.rng.next()<.5+o*.3;if(f&&m===0&&W<=2&&(U=!0),f&&!d&&W<=2&&C.size<2&&m>0&&(U=!0),U&&M.length>0){let J=Math.min(M.length,Math.max(4,Math.floor(k.length/4))),X=Math.floor(this.rng.next()*(J/2))+Math.ceil(J/2);for(let Q=0;Q<X&&M.length!==0;Q++){let B=M.pop();e.cells[B.y][B.x].type=1,e.cells[B.y][B.x].color=Z,m++,C.add(Z),A.add(Z)}}if(h||a){let J=this.rng.next()<.1+o*.4;E===0&&W<=3&&(J=!0),a&&$===0&&W<=2&&(J=!0);let X=E===0&&W<=2?6:4,Q=g+k.length<=x||F&&h&&E===0&&k.length<=30||F&&a&&$===0&&k.length<=30;if(J&&M.length>0&&Q){let B=k.length<=25?this.generateTiling(k,X,s):null;if(B){let I=[],j=.2+o*.3;if(a&&$===0&&W<=3&&(j=.9),a&&this.rng.next()<j){let H=s.difficulty??.5;if(this.rng.next()<.1&&M.length>=2){let L=!1;if(M.length>=3&&this.rng.next()<.8){let ee=this.rng.next()<.5,ne=1+Math.floor(this.rng.next()*2),se=this.TETRIS_SHAPES.filter(oe=>this.getShapeArea(oe)===ne),te=se[Math.floor(this.rng.next()*se.length)],_=this.findStandardTriple(te);_&&(ee?(B.push({shape:te,displayShape:te,isRotated:!this.isRotationallyInvariant(te)&&this.rng.next()<H*.7,isNegative:!1}),B.push({shape:_.n,displayShape:_.n,isRotated:!this.isRotationallyInvariant(_.n)&&this.rng.next()<H*.7,isNegative:!1}),I.push({shape:_.p,displayShape:_.p,isRotated:!this.isRotationallyInvariant(_.p)&&this.rng.next()<H*.7,isNegative:!0})):(B.push({shape:_.p,displayShape:_.p,isRotated:!this.isRotationallyInvariant(_.p)&&this.rng.next()<H*.7,isNegative:!1}),I.push({shape:te,displayShape:te,isRotated:!this.isRotationallyInvariant(te)&&this.rng.next()<H*.7,isNegative:!0}),I.push({shape:_.n,displayShape:_.n,isRotated:!this.isRotationallyInvariant(_.n)&&this.rng.next()<H*.7,isNegative:!0})),L=!0)}if(!L){let ee=3+Math.floor(this.rng.next()*2),ne=this.TETRIS_SHAPES.filter(se=>this.getShapeArea(se)===ee);if(this.shuffleArray(ne),ne.length>0){let se=ne[0],te=ne[0];B.push({shape:se,displayShape:se,isRotated:!this.isRotationallyInvariant(se)&&this.rng.next()<H*.7,isNegative:!1}),I.push({shape:te,displayShape:te,isRotated:!this.isRotationallyInvariant(te)&&this.rng.next()<H*.7,isNegative:!0})}}}else if(B.length>0){let L=this.rng.next()<.3?2:1;for(let ee=0;ee<L&&!(M.length<1);ee++){let ne=Math.floor(this.rng.next()*B.length),se=B[ne];if(se.isNegative)continue;let te=!1;if(M.length>=2&&this.rng.next()<.2){let _=this.findStandardTriple(se.shape);if(_){let oe=this.findStandardTriple(_.p);oe&&(B[ne]={shape:oe.p,displayShape:oe.p,isRotated:!this.isRotationallyInvariant(oe.p)&&this.rng.next()<H*.7,isNegative:!1},I.push({shape:_.n,displayShape:_.n,isRotated:!this.isRotationallyInvariant(_.n)&&this.rng.next()<H*.7,isNegative:!0}),I.push({shape:oe.n,displayShape:oe.n,isRotated:!this.isRotationallyInvariant(oe.n)&&this.rng.next()<H*.7,isNegative:!0}),te=!0)}}if(!te){let _=this.findStandardTriple(se.shape);_&&(B.some(we=>!we.isNegative&&this.isSameShape(we.shape,_.n))||(B[ne]={shape:_.p,displayShape:_.p,isRotated:!this.isRotationallyInvariant(_.p)&&this.rng.next()<H*.7,isNegative:!1},I.push({shape:_.n,displayShape:_.n,isRotated:!this.isRotationallyInvariant(_.n)&&this.rng.next()<H*.7,isNegative:!0})))}}}}let z=[...B,...I];if(z.length>M.length)continue;for(let H of z){if(M.length===0)break;let q=M.pop();if(H.isNegative)e.cells[q.y][q.x].type=H.isRotated?6:5,e.cells[q.y][q.x].color=S(5,Y.None),$++;else{e.cells[q.y][q.x].type=H.isRotated?4:3;let ee=S(3,Y.None),ne=ee;if(d&&this.rng.next()<.3){let se=b.filter(te=>te!==ee&&!A.has(te));se.length>0&&(ne=se[Math.floor(this.rng.next()*se.length)],A.add(ne))}e.cells[q.y][q.x].color=ne}e.cells[q.y][q.x].shape=H.isRotated?H.displayShape:H.shape,E++}g+=k.length}}}if(l){let J=this.rng.next()<.2+o*.5;if(O===0&&W<=2&&(J=!0),J&&M.length>0){this.shuffleArray(M);let X=Math.min(M.length,Math.max(1,Math.floor(k.length/3))),Q=0;for(let B=0;B<M.length&&Q<X;B++){let I=M[B],j=[this.getEdgeKey({x:I.x,y:I.y},{x:I.x+1,y:I.y}),this.getEdgeKey({x:I.x,y:I.y+1},{x:I.x+1,y:I.y+1}),this.getEdgeKey({x:I.x,y:I.y},{x:I.x,y:I.y+1}),this.getEdgeKey({x:I.x+1,y:I.y},{x:I.x+1,y:I.y+1})],z=0;for(let H of j)K.has(H)&&z++;if(z>=1&&z<=3){e.cells[I.y][I.x].type=8,e.cells[I.y][I.x].count=z;let H=S(8,Y.None),q=H;if(d&&this.rng.next()<.3){let L=b.filter(ee=>ee!==H&&!A.has(ee));L.length>0&&(q=L[Math.floor(this.rng.next()*L.length)],A.add(q))}e.cells[I.y][I.x].color=q,M.splice(B,1),B--,O++,Q++}}}}if(y&&p<1){let J=.05+o*.2,X=this.rng.next()<J;if(W<=2&&(X=!0),X&&M.length>=1){let Q=[];d&&Q.push("star"),f&&Q.push("square");let B=[];c&&(B=i?i[V]:this.getRegionBoundaryEdges(e,k,t,n),B.length>0&&Q.push("hexagon")),h&&Q.push("tetris"),a&&Q.push("tetrisNegative"),l&&Q.push("triangle"),this.shuffleArray(Q),M.length>=2&&Q.push("eraser");let I=!1;for(let j of Q){if(I)break;if(j==="hexagon"){let z=B.filter(H=>!this.isEdgeAdjacentToHexagonNode(e,H));if(z.length>0){let H=z[Math.floor(this.rng.next()*z.length)];H.type==="h"?e.hEdges[H.r][H.c].type=3:e.vEdges[H.r][H.c].type=3,u++,I=!0}}else if(j==="square"&&M.length>=2){let z=M.pop();e.cells[z.y][z.x].type=1;let H=k.find(L=>e.cells[L.y][L.x].type===1),q=H?e.cells[H.y][H.x].color:void 0;e.cells[z.y][z.x].color=b.find(L=>L!==q)||Y.Red,m++,I=!0}else if(j==="star"&&M.length>=2){let z=M.pop();e.cells[z.y][z.x].type=2,e.cells[z.y][z.x].color=b[Math.floor(this.rng.next()*b.length)],P++,I=!0}else if(j==="tetris"&&M.length>=2){let z=this.generateTiling(k,4,s),H=[];if(z&&z.length>0){let q=0;for(let L of z){let ee=this.getShapeArea(L.shape);if(q+ee<k.length)H.push(L),q+=ee;else break}}if(H.length===0&&k.length>1&&(H=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),H.length>0){for(let q of H){if(M.length<2)break;let L=M.pop();e.cells[L.y][L.x].type=q.isRotated?4:3,e.cells[L.y][L.x].shape=q.isRotated?q.displayShape:q.shape,e.cells[L.y][L.x].color=S(e.cells[L.y][L.x].type,Y.None),E++}I=!0}}else if(j==="tetrisNegative"&&this.canPlaceGeneratedTetrisNegative(e,k,M)){if(!this.hasRegionTetrisSymbol(e,k)){let H=M.pop();e.cells[H.y][H.x].type=3,e.cells[H.y][H.x].shape=[[1]],e.cells[H.y][H.x].color=S(3,Y.None),E++}let z=M.pop();e.cells[z.y][z.x].type=5,e.cells[z.y][z.x].shape=[[1]],e.cells[z.y][z.x].color=S(5,Y.None),$++}else if(j==="triangle"&&M.length>=2){let z=M.pop();e.cells[z.y][z.x].type=8;let H=[this.getEdgeKey({x:z.x,y:z.y},{x:z.x+1,y:z.y}),this.getEdgeKey({x:z.x,y:z.y+1},{x:z.x+1,y:z.y+1}),this.getEdgeKey({x:z.x,y:z.y},{x:z.x,y:z.y+1}),this.getEdgeKey({x:z.x+1,y:z.y},{x:z.x+1,y:z.y+1})],q=0;for(let ee of H)K.has(ee)&&q++;let L=(q+1)%4;L===0&&(L=1),e.cells[z.y][z.x].count=L,e.cells[z.y][z.x].color=S(8,Y.None),O++,I=!0}else if(j==="eraser"&&this.canPlaceGeneratedEraser(e,k,M)){let z=M.pop();e.cells[z.y][z.x].type=7,e.cells[z.y][z.x].color=S(7,Y.White),p++,I=!0}}if(I&&this.canPlaceGeneratedEraser(e,k,M)){let j=M.pop();e.cells[j.y][j.x].type=7;let z=S(7,Y.White),H=z;if(d&&this.rng.next()<.3){let q=b.filter(L=>L!==z&&!A.has(L));q.length>0&&(H=q[Math.floor(this.rng.next()*q.length)],A.add(H))}e.cells[j.y][j.x].color=H,p++}}}if(d){for(let X of b){if(M.length<1)break;if(k.filter(B=>e.cells[B.y][B.x].color===X).length===1&&(X!==Y.White||A.has(X))){let B=M.pop();e.cells[B.y][B.x].type=2,e.cells[B.y][B.x].color=X,P++}}let J=Math.max(1,Math.floor(k.length/8));for(let X=0;X<J&&!(M.length<2);X++)for(let Q of b){if(M.length<2)break;if(this.rng.next()>.3+o*.4)continue;if(k.filter(I=>e.cells[I.y][I.x].color===Q).length===0)for(let I=0;I<2;I++){let j=M.pop();e.cells[j.y][j.x].type=2,e.cells[j.y][j.x].color=Q,P++}}}}if(f&&C.size<2){let D=C.values().next().value;if(!(D!==void 0&&P>0&&Array.from({length:e.rows*e.cols}).some((k,W)=>{let F=Math.floor(W/e.cols),R=W%e.cols;return e.cells[F][R].type===2&&e.cells[F][R].color===D}))){for(let k of w){if(C.size>=2)break;if(k.some(F=>e.cells[F.y][F.x].type===1))continue;let W=k.filter(F=>e.cells[F.y][F.x].type===0);if(W.length>0){let F=b.find(M=>!C.has(M))||Y.White,R=W[Math.floor(this.rng.next()*W.length)];e.cells[R.y][R.x].type=1,e.cells[R.y][R.x].color=F,C.add(F),m++}}if(C.size<2&&d&&D!==void 0)for(let k of w){let W=k.filter(F=>e.cells[F.y][F.x].type===0);if(W.length>0){let F=W[Math.floor(this.rng.next()*W.length)];e.cells[F.y][F.x].type=2,e.cells[F.y][F.x].color=D,P++;break}}}}}}calculateRegions(e,t,s=[]){let n=[],r=e.rows,i=e.cols,o=new Uint8Array(r*i),c=new Uint8Array((r+1)*i),f=new Uint8Array(r*(i+1)),d=(h,a)=>{h.x===a.x?f[Math.min(h.y,a.y)*(i+1)+h.x]=1:c[h.y*i+Math.min(h.x,a.x)]=1};for(let h=0;h<t.length-1;h++)d(t[h],t[h+1]);for(let h=0;h<s.length-1;h++)d(s[h],s[h+1]);for(let h=0;h<=r;h++)for(let a=0;a<i;a++)e.hEdges[h][a].type===2&&(c[h*i+a]=1);for(let h=0;h<r;h++)for(let a=0;a<=i;a++)e.vEdges[h][a].type===2&&(f[h*(i+1)+a]=1);for(let h=0;h<r;h++)for(let a=0;a<i;a++){let y=h*i+a;if(o[y])continue;let l=[],u=[y];o[y]=1;let m=0;for(;m<u.length;){let P=u[m++],E=P%i,p=Math.floor(P/i);if(l.push({x:E,y:p}),p>0&&!c[p*i+E]){let g=(p-1)*i+E;o[g]||(o[g]=1,u.push(g))}if(p<r-1&&!c[(p+1)*i+E]){let g=(p+1)*i+E;o[g]||(o[g]=1,u.push(g))}if(E>0&&!f[p*(i+1)+E]){let g=p*i+(E-1);o[g]||(o[g]=1,u.push(g))}if(E<i-1&&!f[p*(i+1)+(E+1)]){let g=p*i+(E+1);o[g]||(o[g]=1,u.push(g))}}n.push(l)}return n}isAbsentEdge(e,t,s){if(t.x===s.x){let n=Math.min(t.y,s.y);return e.vEdges[n][t.x].type===2}else{let n=Math.min(t.x,s.x);return e.hEdges[t.y][n].type===2}}getRegionBoundaryEdges(e,t,s,n=[]){let r=new Set;for(let c=0;c<s.length-1;c++)r.add(this.getEdgeKey(s[c],s[c+1]));for(let c=0;c<n.length-1;c++)r.add(this.getEdgeKey(n[c],n[c+1]));let i=[];for(let c of t){let f=[{type:"h",r:c.y,c:c.x},{type:"h",r:c.y+1,c:c.x},{type:"v",r:c.y,c:c.x},{type:"v",r:c.y,c:c.x+1}];for(let d of f){let h=d.type==="h"?{x:d.c,y:d.r}:{x:d.c,y:d.r},a=d.type==="h"?{x:d.c+1,y:d.r}:{x:d.c,y:d.r+1},y=this.getEdgeKey(h,a);!r.has(y)&&!this.isAbsentEdge(e,h,a)&&i.push(d)}}let o=new Map;for(let c of i)o.set(`${c.type},${c.r},${c.c}`,c);return Array.from(o.values())}setEdgeHexagon(e,t,s,n=3){t.x===s.x?e.vEdges[Math.min(t.y,s.y)][t.x].type=n:e.hEdges[t.y][Math.min(t.x,s.x)].type=n}hasIncidentHexagonEdge(e,t){let s=n=>n===3||n===4||n===5;return!!(t.x>0&&s(e.hEdges[t.y][t.x-1].type)||t.x<e.cols&&s(e.hEdges[t.y][t.x].type)||t.y>0&&s(e.vEdges[t.y-1][t.x].type)||t.y<e.rows&&s(e.vEdges[t.y][t.x].type))}isEdgeAdjacentToHexagonNode(e,t){let s=n=>n===3||n===4||n===5;return t.type==="h"?s(e.nodes[t.r][t.c].type)||s(e.nodes[t.r][t.c+1].type):s(e.nodes[t.r][t.c].type)||s(e.nodes[t.r+1][t.c].type)}checkAllRequestedConstraintsPresent(e,t){let s=t.useHexagons??!0,n=t.useSquares??!0,r=t.useStars??!0,i=t.useTetris??!1,o=t.useTetrisNegative??!1,c=t.useEraser??!1,f=t.useTriangles??!1;if(t.useBrokenEdges??!1){let h=!1;for(let a=0;a<=e.rows;a++)for(let y=0;y<e.cols;y++)if(e.hEdges[a][y].type===1||e.hEdges[a][y].type===2){h=!0;break}if(!h){for(let a=0;a<e.rows;a++)for(let y=0;y<=e.cols;y++)if(e.vEdges[a][y].type===1||e.vEdges[a][y].type===2){h=!0;break}}if(!h)return!1}if(s){let h=!1,a=l=>l===3||l===4||l===5,y=l=>l===3||l===4||l===5;for(let l=0;l<=e.rows;l++)for(let u=0;u<e.cols;u++)if(a(e.hEdges[l][u].type)){h=!0;break}if(!h){for(let l=0;l<e.rows;l++)for(let u=0;u<=e.cols;u++)if(a(e.vEdges[l][u].type)){h=!0;break}}if(!h){for(let l=0;l<=e.rows;l++)for(let u=0;u<=e.cols;u++)if(y(e.nodes[l][u].type)){h=!0;break}}if(!h)return!1}if(n||r||i||c){let h=!1,a=!1,y=!1,l=!1,u=!1,m=!1,P=new Set,E=new Set;for(let p=0;p<e.rows;p++)for(let g=0;g<e.cols;g++){let x=e.cells[p][g].type;x===1&&(h=!0,P.add(e.cells[p][g].color)),x===2&&(a=!0,E.add(e.cells[p][g].color)),(x===3||x===4)&&(y=!0),(x===5||x===6)&&(l=!0),x===7&&(u=!0),x===8&&(m=!0)}if(n&&!h||r&&!a||i&&!y||o&&!l||c&&!u||f&&!m)return!1;if(n&&h&&P.size<2){let p=P.values().next().value;if(p===void 0||!E.has(p))return!1}}return!this.hasIsolatedMark(e)}generateTiling(e,t,s){let n=Math.min(...e.map(h=>h.x)),r=Math.min(...e.map(h=>h.y)),i=Math.max(...e.map(h=>h.x)),o=Math.max(...e.map(h=>h.y)),c=i-n+1,f=o-r+1,d=Array.from({length:f},()=>Array(c).fill(!1));for(let h of e)d[h.y-r][h.x-n]=!0;return this.tilingDfs(d,[],t,s)}tilingDfs(e,t,s,n){let r=-1,i=-1;for(let f=0;f<e.length;f++){for(let d=0;d<e[0].length;d++)if(e[f][d]){r=f,i=d;break}if(r!==-1)break}if(r===-1)return t;if(t.length>=s)return null;let o=n.difficulty??.5,c=Array.from({length:this.TETRIS_SHAPES.length},(f,d)=>d);this.shuffleArray(c),o>.6&&c.sort((f,d)=>this.getShapeArea(this.TETRIS_SHAPES[d])-this.getShapeArea(this.TETRIS_SHAPES[f]));for(let f of c){let d=this.TETRIS_SHAPES[f],h=this.TETRIS_SHAPES_WITH_ROTATIONS[f],a=Array.from({length:h.length},(y,l)=>l);this.shuffleArray(a);for(let y of a){let l=h[y],u=[];for(let m=0;m<l.length;m++)for(let P=0;P<l[0].length;P++)l[m][P]&&u.push({r:m,c:P});for(let m of u){let P=r-m.r,E=i-m.c;if(this.canPlace(e,l,P,E)){this.placePiece(e,l,P,E,!1);let p=h.length>1&&this.rng.next()<.3+o*.6,g=this.tilingDfs(e,[...t,{shape:l,displayShape:d,isRotated:p}],s,n);if(g)return g;this.placePiece(e,l,P,E,!0)}}}}return null}getShapeArea(e){let t=0;for(let s of e)for(let n of s)n&&t++;return t}isRotationallyInvariant(e){return this.getAllRotations(e).length===1}getAllRotations(e){let t=[],s=new Set,n=e;for(let r=0;r<4;r++){let i=JSON.stringify(n);s.has(i)||(t.push(n),s.add(i)),n=this.rotate90(n)}return t}rotate90(e){let t=e.length,s=e[0].length,n=Array.from({length:s},()=>Array(t).fill(0));for(let r=0;r<t;r++)for(let i=0;i<s;i++)n[i][t-1-r]=e[r][i];return n}canPlace(e,t,s,n){for(let r=0;r<t.length;r++)for(let i=0;i<t[0].length;i++)if(t[r][i]){let o=s+r,c=n+i;if(o<0||o>=e.length||c<0||c>=e[0].length||!e[o][c])return!1}return!0}placePiece(e,t,s,n,r){for(let i=0;i<t.length;i++)for(let o=0;o<t[0].length;o++)t[i][o]&&(e[s+i][n+o]=r)}isSameShape(e,t){let s=this.getAllRotations(e),n=JSON.stringify(t);return s.some(r=>JSON.stringify(r)===n)}countRegionNonEraserSymbols(e,t){let s=0;for(let n of t){let r=e.cells[n.y][n.x].type;r!==0&&r!==7&&s++}return s}hasRegionTetrisSymbol(e,t){for(let s of t){let n=e.cells[s.y][s.x].type;if(n===3||n===4)return!0}return!1}canPlaceGeneratedTetrisNegative(e,t,s){return s.length<1?!1:this.hasRegionTetrisSymbol(e,t)?!0:s.length>=2}canPlaceGeneratedEraser(e,t,s){return s.length<1?!1:this.countRegionNonEraserSymbols(e,t)>0?!0:s.length>=2}canTilePieceWith(e,t,s){let n=this.getShapeArea(e),r=this.getShapeArea(t),i=this.getShapeArea(s);if(n!==r+i)return!1;let o=this.getAllRotations(t),c=this.getAllRotations(s),f=e.length,d=e[0].length;for(let h of o)for(let a of c){let y=h.length,l=h[0].length,u=a.length,m=a[0].length;for(let P=0;P<=f-y;P++)for(let E=0;E<=d-l;E++)for(let p=0;p<=f-u;p++)for(let g=0;g<=d-m;g++){let x=Array.from({length:f},()=>Array(d).fill(0)),w=!0;for(let b=0;b<y;b++)for(let v=0;v<l;v++)h[b][v]&&(x[P+b][E+v]=1);for(let b=0;b<u;b++){for(let v=0;v<m;v++)if(a[b][v]){if(x[p+b][g+v]){w=!1;break}x[p+b][g+v]=1}if(!w)break}if(w){let b=!0;for(let v=0;v<f;v++){for(let S=0;S<d;S++)if(x[v][S]!==e[v][S]){b=!1;break}if(!b)break}if(b)return!0}}}return!1}findStandardTriple(e){let t=this.getShapeArea(e),s=[...this.TETRIS_SHAPES];this.shuffleArray(s);for(let n of s){let r=this.getShapeArea(n),i=t+r;if(i>5)continue;let o=this.TETRIS_SHAPES.filter(c=>this.getShapeArea(c)===i);for(let c of o)if(this.canTilePieceWith(c,e,n))return{p:c,n}}return null}shuffleArray(e){for(let t=e.length-1;t>0;t--){let s=Math.floor(this.rng.next()*(t+1));[e[t],e[s]]=[e[s],e[t]]}}};var fe=class{canvas;ctx=null;worker=null;puzzle=null;options;listeners=new Map;path=[];isDrawing=!1;currentMousePos={x:0,y:0};exitTipPos=null;isInvalidPath=!1;isValidPath=!1;invalidatedCells=[];invalidatedEdges=[];invalidatedNodes=[];errorCells=[];errorEdges=[];errorNodes=[];eraserAnimationStartTime=0;isFading=!1;fadeOpacity=1;fadeColor="#ff4444";fadingPath=[];fadingTipPos=null;isSuccessFading=!1;successFadeStartTime=0;startTime=Date.now();offscreenCanvas=null;offscreenCtx=null;canvasRect=null;isDestroyed=!1;animationFrameId=null;timeoutId=null;boundMouseDown=null;boundMouseMove=null;boundMouseUp=null;boundTouchStart=null;boundTouchMove=null;boundTouchEnd=null;boundUpdateRect=null;constructor(e,t,s={}){if(typeof e=="string"){if(typeof document>"u")throw new Error("Cannot look up canvas by ID in a non-browser environment.");let n=document.getElementById(e);if(!(n instanceof HTMLCanvasElement))throw new Error(`Element with id "${e}" is not a canvas.`);this.canvas=n}else this.canvas=e;if(this.options=this.mergeOptions(s),this.options.useWorker&&typeof window<"u"&&this.canvas instanceof HTMLCanvasElement&&this.canvas.transferControlToOffscreen){let n=this.options.workerScript??import.meta.url;if(n){this.worker=new Worker(n,{type:"module"});let r=this.canvas.transferControlToOffscreen(),i=this.sanitizeOptions(this.options);this.worker.postMessage({type:"init",payload:{canvas:r,options:i}},[r]),this.worker.addEventListener("message",o=>{let{type:c,payload:f}=o.data;c==="drawingStarted"?this.isDrawing=f!==!1:c==="drawingEnded"?this.isDrawing=!1:c==="pathComplete"?this.emit("path:complete",{path:f}):c==="puzzleCreated"?(f?.puzzle&&this.setPuzzle(f.puzzle),this.emit("puzzle:generated",f)):c==="validationResult"?this.emit("goal:validated",{result:f}):c==="uiEvent"&&this.emit(f.type,f.data)})}}if(!this.worker){let n=this.canvas.getContext("2d");if(!n)throw new Error("Could not get 2D context.");this.ctx=n,this.ctx.imageSmoothingEnabled=!1,this.animate()}t&&this.setPuzzle(t),this.initEvents()}mergeOptions(e){let t={blinkDuration:e.animations?.blinkDuration??this.options?.animations?.blinkDuration??1e3,fadeDuration:e.animations?.fadeDuration??this.options?.animations?.fadeDuration??1e3,blinkPeriod:e.animations?.blinkPeriod??this.options?.animations?.blinkPeriod??800},s={path:e.colors?.path??this.options?.colors?.path??"#ffcc00",error:e.colors?.error??this.options?.colors?.error??"#ff4444",success:e.colors?.success??this.options?.colors?.success??"#ffcc00",symmetry:e.colors?.symmetry??this.options?.colors?.symmetry??"rgba(255, 255, 255, 0.5)",interrupted:e.colors?.interrupted??this.options?.colors?.interrupted??"#ffcc00",grid:e.colors?.grid??this.options?.colors?.grid??"#555",node:e.colors?.node??this.options?.colors?.node??"#555",hexagon:e.colors?.hexagon??this.options?.colors?.hexagon??"#000",hexagonMain:e.colors?.hexagonMain??this.options?.colors?.hexagonMain??"#00ffff",hexagonSymmetry:e.colors?.hexagonSymmetry??this.options?.colors?.hexagonSymmetry??"#ffff00",colorMap:e.colors?.colorMap??this.options?.colors?.colorMap??{[Y.Black]:"#000",[Y.White]:"#fff",[Y.Red]:"#f00",[Y.Blue]:"#00f",[Y.None]:"#ffcc00"},colorList:e.colors?.colorList??this.options?.colors?.colorList};return{gridPadding:e.gridPadding??this.options?.gridPadding??60,cellSize:e.cellSize??this.options?.cellSize??80,nodeRadius:e.nodeRadius??this.options?.nodeRadius??6,startNodeRadius:e.startNodeRadius??this.options?.startNodeRadius??22,pathWidth:e.pathWidth??this.options?.pathWidth??18,exitLength:e.exitLength??this.options?.exitLength??25,autoResize:e.autoResize??this.options?.autoResize??!0,blinkMarksOnError:e.blinkMarksOnError??this.options?.blinkMarksOnError??!0,stayPathOnError:e.stayPathOnError??this.options?.stayPathOnError??!0,autoValidate:e.autoValidate??this.options?.autoValidate??!1,useWorker:e.useWorker??this.options?.useWorker??!1,workerScript:e.workerScript??this.options?.workerScript,animations:t,colors:s,pixelRatio:e.pixelRatio??this.options?.pixelRatio??(typeof window<"u"?window.devicePixelRatio:1)}}setPuzzle(e){if(this.worker){this.puzzle=e,this.options.autoResize&&this.resizeCanvas(),this.worker.postMessage({type:"setPuzzle",payload:{puzzle:e}}),this.emit("puzzle:created",{puzzle:e});return}this.puzzle=e,this.path=[],this.isDrawing=!1,this.exitTipPos=null,this.isInvalidPath=!1,this.isValidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.cancelFade(),this.options.autoResize&&this.resizeCanvas(),this.draw(),this.emit("puzzle:created",{puzzle:e})}setPath(e){if(this.worker){this.worker.postMessage({type:"setPath",payload:{path:e}});return}if(this.cancelFade(),this.isInvalidPath=!1,this.isValidPath=!1,this.isSuccessFading=!1,e.length>0){this.path=[...e];let t=this.path[this.path.length-1],s=this.getCanvasCoords(t.x,t.y),n=this.getExitDir(t.x,t.y);n?this.exitTipPos={x:s.x+n.x*this.options.exitLength,y:s.y+n.y*this.options.exitLength}:this.exitTipPos=null,this.currentMousePos=s}else this.path=[],this.exitTipPos=null;this.draw()}setOptions(e){if(this.options=this.mergeOptions({...this.options,...e}),this.worker){this.options.autoResize&&this.puzzle&&this.resizeCanvas();let t=this.sanitizeOptions(e);this.worker.postMessage({type:"setOptions",payload:t});return}this.options.autoResize&&this.puzzle&&this.resizeCanvas(),this.draw()}addEventListener(e,t){this.listeners.has(e)||this.listeners.set(e,new Set),this.listeners.get(e).add(t)}removeEventListener(e,t){let s=this.listeners.get(e);s&&s.delete(t)}on(e,t){return this.addEventListener(e,t),this}off(e,t){return this.removeEventListener(e,t),this}emit(e,t){let s=this.listeners.get(e);if(s&&s.forEach(n=>n(t)),typeof self<"u"&&self.postMessage&&!this.worker&&typeof OffscreenCanvas<"u"&&this.canvas instanceof OffscreenCanvas){let r=["render:before","render:after"],i=["path:complete","puzzle:created","goal:validated"];if(!r.includes(e)&&!i.includes(e))try{self.postMessage({type:"uiEvent",payload:{type:e,data:t}})}catch{}}}setValidationResult(e,t=[],s=[],n=[],r=[],i=[],o=[]){if(this.worker){this.worker.postMessage({type:"setValidationResult",payload:{isValid:e,invalidatedCells:t,invalidatedEdges:s,errorCells:n,errorEdges:r,invalidatedNodes:i,errorNodes:o}});return}this.invalidatedCells=t,this.invalidatedEdges=s,this.invalidatedNodes=i,this.errorCells=n,this.errorEdges=r,this.errorNodes=o,this.eraserAnimationStartTime=Date.now(),e?(this.isValidPath=!0,this.isSuccessFading=!0,this.successFadeStartTime=Date.now()):this.isInvalidPath=!0,this.emit("goal:reached",{path:this.path,isValid:e})}resizeCanvas(){if(!this.puzzle||!this.canvas)return;let e=this.puzzle.cols*this.options.cellSize+this.options.gridPadding*2,t=this.puzzle.rows*this.options.cellSize+this.options.gridPadding*2,s=this.options.pixelRatio;if(typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement)try{this.canvas.width=e*s,this.canvas.height=t*s}catch{}else this.canvas.width=e*s,this.canvas.height=t*s;this.worker&&this.boundUpdateRect&&this.boundUpdateRect()}setCanvasRect(e){let t={left:e.left,top:e.top,width:e.width,height:e.height};this.canvasRect=t,this.worker&&this.worker.postMessage({type:"setCanvasRect",payload:t})}createPuzzle(e,t,s){this.worker&&this.worker.postMessage({type:"createPuzzle",payload:{rows:e,cols:t,genOptions:s}})}initEvents(){typeof window>"u"||typeof HTMLCanvasElement>"u"||!(this.canvas instanceof HTMLCanvasElement)||(this.boundMouseDown=e=>{this.handleStart(e)&&e.cancelable&&e.preventDefault()},this.boundMouseMove=e=>{this.isDrawing&&e.cancelable&&e.preventDefault(),this.handleMove(e)},this.boundMouseUp=e=>{this.isDrawing&&e.cancelable&&e.preventDefault(),this.handleEnd(e)},this.boundTouchStart=e=>{this.handleStart(e.touches[0])&&e.cancelable&&e.preventDefault()},this.boundTouchMove=e=>{this.isDrawing&&(e.cancelable&&e.preventDefault(),this.handleMove(e.touches[0]))},this.boundTouchEnd=e=>{this.isDrawing&&(e.cancelable&&e.preventDefault(),this.handleEnd(e.changedTouches[0]))},this.canvas.addEventListener("mousedown",this.boundMouseDown),window.addEventListener("mousemove",this.boundMouseMove,{passive:!1}),window.addEventListener("mouseup",this.boundMouseUp,{passive:!1}),this.canvas.addEventListener("touchstart",this.boundTouchStart,{passive:!1}),window.addEventListener("touchmove",this.boundTouchMove,{passive:!1}),window.addEventListener("touchend",this.boundTouchEnd,{passive:!1}),this.worker&&(this.boundUpdateRect=()=>{if(this.canvas instanceof HTMLCanvasElement){let e=this.canvas.getBoundingClientRect();this.setCanvasRect(e)}},window.addEventListener("resize",this.boundUpdateRect),window.addEventListener("scroll",this.boundUpdateRect),this.boundUpdateRect()))}destroy(){this.isDestroyed=!0,this.worker&&(this.worker.terminate(),this.worker=null),this.animationFrameId!==null&&typeof cancelAnimationFrame<"u"&&cancelAnimationFrame(this.animationFrameId),this.timeoutId!==null&&clearTimeout(this.timeoutId),!(typeof window>"u"||typeof HTMLCanvasElement>"u"||!(this.canvas instanceof HTMLCanvasElement))&&(this.boundMouseDown&&this.canvas.removeEventListener("mousedown",this.boundMouseDown),this.boundMouseMove&&window.removeEventListener("mousemove",this.boundMouseMove),this.boundMouseUp&&window.removeEventListener("mouseup",this.boundMouseUp),this.boundTouchStart&&this.canvas.removeEventListener("touchstart",this.boundTouchStart),this.boundTouchMove&&window.removeEventListener("touchmove",this.boundTouchMove),this.boundTouchEnd&&window.removeEventListener("touchend",this.boundTouchEnd),this.boundUpdateRect&&(window.removeEventListener("resize",this.boundUpdateRect),window.removeEventListener("scroll",this.boundUpdateRect)),this.boundMouseDown=null,this.boundMouseMove=null,this.boundMouseUp=null,this.boundTouchStart=null,this.boundTouchMove=null,this.boundTouchEnd=null)}getCanvasCoords(e,t){return{x:this.options.gridPadding+e*this.options.cellSize,y:this.options.gridPadding+t*this.options.cellSize}}getExitDir(e,t){if(!this.puzzle||this.puzzle.nodes[t]?.[e]?.type!==2)return null;let{cols:s,rows:n}=this.puzzle,r=e===0,i=e===s,o=t===0,c=t===n;return!r&&!i&&!o&&!c?null:(r||i)&&(o||c)?s>=n?r?{x:-1,y:0}:{x:1,y:0}:o?{x:0,y:-1}:{x:0,y:1}:r?{x:-1,y:0}:i?{x:1,y:0}:o?{x:0,y:-1}:c?{x:0,y:1}:null}handleStart(e){let t=this.isStartNodeHit(e);return this.worker?t?(this.isDrawing=!0,this.worker.postMessage({type:"event",payload:{eventType:"mousedown",eventData:{clientX:e.clientX,clientY:e.clientY}}}),!0):(this.isDrawing=!1,!1):t?(this.cancelFade(),this.isSuccessFading=!1,this.isInvalidPath=!1,this.isValidPath=!1,this.invalidatedCells=[],this.invalidatedEdges=[],this.invalidatedNodes=[],this.errorCells=[],this.errorEdges=[],this.errorNodes=[],this.isDrawing=!0,this.path=[{x:t.x,y:t.y}],this.currentMousePos=this.getCanvasCoords(t.x,t.y),this.exitTipPos=null,this.draw(),this.emit("path:start",{x:t.x,y:t.y}),!0):!1}isStartNodeHit(e){if(!this.puzzle)return null;let t=this.options.pixelRatio,s=this.canvasRect||(typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width/t,height:this.canvas.height/t}),n=(e.clientX-s.left)*(this.canvas.width/t/s.width),r=(e.clientY-s.top)*(this.canvas.height/t/s.height);for(let i=0;i<=this.puzzle.rows;i++)for(let o=0;o<=this.puzzle.cols;o++){if(this.puzzle.nodes[i][o].type!==1)continue;let c=this.getCanvasCoords(o,i);if(Math.hypot(c.x-n,c.y-r)<this.options.startNodeRadius)return{x:o,y:i}}return null}handleMove(e){if(this.worker){this.isDrawing&&this.worker.postMessage({type:"event",payload:{eventType:"mousemove",eventData:{clientX:e.clientX,clientY:e.clientY}}});return}if(!this.puzzle||!this.isDrawing)return;let t=this.options.pixelRatio,s=this.canvasRect||(typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.getBoundingClientRect():{left:0,top:0,width:this.canvas.width/t,height:this.canvas.height/t}),n=(e.clientX-s.left)*(this.canvas.width/t/s.width),r=(e.clientY-s.top)*(this.canvas.height/t/s.height),i=this.path[this.path.length-1],o=this.getCanvasCoords(i.x,i.y),c=n-o.x,f=r-o.y,d=this.puzzle.symmetry||0,h=this.getExitDir(i.x,i.y),a=Math.abs(c)>Math.abs(f)?{x:c>0?1:-1,y:0}:{x:0,y:f>0?1:-1};if(h&&a.x===h.x&&a.y===h.y){let m=c*h.x+f*h.y,P=Math.max(0,Math.min(m,this.options.exitLength));this.currentMousePos={x:o.x+h.x*P,y:o.y+h.y*P},this.draw();return}let y=(m,P)=>{let E=this.getEdgeType(i,m);if(m.x<0||m.x>this.puzzle.cols||m.y<0||m.y>this.puzzle.rows||E===2){this.currentMousePos=o;return}let p=E===1?this.options.cellSize*.35:this.options.cellSize,g=this.getEdgeKey(i,m);if(!(this.path.length>=2&&m.x===this.path[this.path.length-2].x&&m.y===this.path[this.path.length-2].y)){for(let b=0;b<this.path.length-1;b++)if(this.getEdgeKey(this.path[b],this.path[b+1])===g){p=0;break}}if(this.path.some(b=>b.x===m.x&&b.y===m.y)&&this.path.length>=2){let b=this.path[this.path.length-2];(m.x!==b.x||m.y!==b.y)&&(p=Math.min(p,this.options.cellSize*.5-this.options.pathWidth*.5))}if(d!==0){let b=this.getSymmetricalPoint(i),v=this.getSymmetricalPoint(m),S=this.getEdgeType(b,v),T=this.getSymmetryPath(this.path),C=this.getEdgeKey(b,v);if(v.x<0||v.x>this.puzzle.cols||v.y<0||v.y>this.puzzle.rows||S===2){this.currentMousePos=o;return}S===1&&(p=Math.min(p,this.options.cellSize*.35));let N=T.some(k=>k.x===m.x&&k.y===m.y),$=this.path.some(k=>k.x===v.x&&k.y===v.y),O=m.x===v.x&&m.y===v.y,K=T.some((k,W)=>W<T.length-1&&this.getEdgeKey(T[W],T[W+1])===g),D=this.path.some((k,W)=>W<this.path.length-1&&this.getEdgeKey(this.path[W],this.path[W+1])===C);(N||$||O||K||D||g===C)&&(p=Math.min(p,this.options.cellSize*.5-this.options.pathWidth*.5))}m.x!==i.x?this.currentMousePos={x:o.x+Math.max(-p,Math.min(p,P)),y:o.y}:this.currentMousePos={x:o.x,y:o.y+Math.max(-p,Math.min(p,P))}};if(Math.abs(c)>Math.abs(f)){let m=c>0?1:-1;y({x:i.x+m,y:i.y},c)}else{let m=f>0?1:-1;y({x:i.x,y:i.y+m},f)}let l=[{x:i.x+1,y:i.y},{x:i.x-1,y:i.y},{x:i.x,y:i.y+1},{x:i.x,y:i.y-1}],u=this.getSymmetryPath(this.path);for(let m of l)if(m.x>=0&&m.x<=this.puzzle.cols&&m.y>=0&&m.y<=this.puzzle.rows){let P=this.getCanvasCoords(m.x,m.y);if(Math.hypot(P.x-this.currentMousePos.x,P.y-this.currentMousePos.y)<this.options.cellSize*.3){let p=this.path.findIndex(g=>g.x===m.x&&g.y===m.y);if(p===-1){if(d!==0){let g=this.getSymmetricalPoint(m);if(m.x===g.x&&m.y===g.y||this.path.some(b=>b.x===g.x&&b.y===g.y)||u.some(b=>b.x===m.x&&b.y===m.y))continue;let x=this.getEdgeKey(i,m),w=this.getEdgeKey(this.getSymmetricalPoint(i),g);if(x===w)continue}this.path.push(m),this.emit("path:move",{x:m.x,y:m.y,path:this.path,currentMousePos:this.currentMousePos})}else if(p===this.path.length-2){let g=this.path.pop();g&&this.emit("path:move",{x:g.x,y:g.y,path:this.path,currentMousePos:this.currentMousePos})}}}this.draw()}handleEnd(e){if(this.worker){this.isDrawing&&(this.isDrawing=!1,this.worker.postMessage({type:"event",payload:{eventType:"mouseup",eventData:{clientX:e.clientX,clientY:e.clientY}}}));return}if(!this.puzzle||!this.isDrawing)return;this.isDrawing=!1;let t=this.path[this.path.length-1],s=this.getCanvasCoords(t.x,t.y),n=this.getExitDir(t.x,t.y),r=!1;if(n){let i=this.currentMousePos.x-s.x,o=this.currentMousePos.y-s.y;if(i*n.x+o*n.y>0){this.exitTipPos={x:s.x+n.x*this.options.exitLength,y:s.y+n.y*this.options.exitLength},r=!0,this.emit("path:complete",{path:this.path}),this.emit("path:end",{path:this.path,isExit:!0});return}}this.exitTipPos=n?{...this.currentMousePos}:null,this.emit("path:end",{path:this.path,isExit:!1}),this.startFade(this.options.colors.interrupted)}getEdgeType(e,t){if(!this.puzzle)return 2;if(e.x===t.x){let s=Math.min(e.y,t.y);return s<0||s>=this.puzzle.rows?2:this.puzzle.vEdges[s][e.x].type}else{let s=Math.min(e.x,t.x);return s<0||s>=this.puzzle.cols?2:this.puzzle.hEdges[e.y][s].type}}startFade(e="#ff4444"){this.isFading=!0,this.fadeOpacity=1,this.fadeColor=e,this.fadingPath=[...this.path],this.fadingTipPos=this.exitTipPos?{...this.exitTipPos}:null,this.path=[]}cancelFade(){this.isFading=!1}animate(){if(this.isDestroyed)return;let e=Date.now();if(this.isFading){let t=1e3/(this.options.animations.fadeDuration*60);this.fadeOpacity-=t,this.fadeOpacity<=0&&(this.isFading=!1,this.fadeOpacity=0,this.isInvalidPath&&(this.isInvalidPath=!1,this.emit("goal:validated",{result:{isValid:!1}})))}this.isSuccessFading&&e-this.successFadeStartTime>this.options.animations.blinkDuration+this.options.animations.fadeDuration&&(this.isSuccessFading=!1,this.emit("goal:validated",{result:{isValid:!0}})),this.isInvalidPath&&!this.options.stayPathOnError&&!this.isFading&&this.path.length>0&&this.startFade(this.options.colors.error),this.draw(),typeof requestAnimationFrame<"u"?this.animationFrameId=requestAnimationFrame(()=>this.animate()):(this.timeoutId=setTimeout(()=>this.animate(),1e3/60),this.timeoutId&&this.timeoutId.unref&&this.timeoutId.unref())}lastGoalReachable=!1;draw(){if(!this.puzzle||!this.ctx)return;let e=this.ctx;this.emit("render:before",{ctx:e});let t=Date.now(),s=this.options.pixelRatio;if(e.setTransform(s,0,0,s,0,0),e.globalAlpha=1,e.clearRect(0,0,this.canvas.width/s,this.canvas.height/s),this.drawGrid(e),this.drawConstraints(e),this.drawNodes(e),this.path.length===0&&!this.isDrawing&&this.drawRipples(e),this.isFading){if(this.drawPath(e,this.fadingPath,!1,this.fadeColor,this.fadeOpacity,this.fadingTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let n=this.getSymmetryPath(this.fadingPath),r=this.options.colors.symmetry;if(this.isInvalidPath){let o=this.colorToRgba(r).a;r=this.setAlpha(this.options.colors.error,o)}let i=null;if(this.fadingTipPos){let o=(this.fadingTipPos.x-this.options.gridPadding)/this.options.cellSize,c=(this.fadingTipPos.y-this.options.gridPadding)/this.options.cellSize,f=this.getSymmetricalPoint({x:o,y:c});i={x:f.x*this.options.cellSize+this.options.gridPadding,y:f.y*this.options.cellSize+this.options.gridPadding}}this.drawPath(e,n,!1,r,this.fadeOpacity,i)}}else if(this.path.length>0){let n=this.options.colors.path,r=this.colorToRgba(n).a,i=this.options.colors.error,o=this.isInvalidPath?this.setAlpha(i,r):n;(this.isSuccessFading||this.isValidPath)&&!this.puzzle.symmetry&&(o=this.setAlpha(this.options.colors.success,r));let c=1;if(!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let h=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),a=this.options.animations.blinkDuration;h<a&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(o=this.setAlpha(this.options.colors.error,r),this.options.stayPathOnError||(c=Math.max(0,1-h/this.options.animations.fadeDuration)))}let f=null;if(this.isDrawing||this.exitTipPos){let h=this.isDrawing?this.currentMousePos:this.exitTipPos;if(this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let a=(h.x-this.options.gridPadding)/this.options.cellSize,y=(h.y-this.options.gridPadding)/this.options.cellSize,l=this.getSymmetricalPoint({x:a,y},!0);f={x:l.x*this.options.cellSize+this.options.gridPadding,y:l.y*this.options.cellSize+this.options.gridPadding}}}let d=this.isPathAtExit(this.path,this.isDrawing?this.currentMousePos:this.exitTipPos);if(d!==this.lastGoalReachable&&(this.lastGoalReachable=d,this.emit("goal:reachable",{reachable:d})),d&&!this.isInvalidPath&&!this.isSuccessFading&&!this.isValidPath){let h=this.colorToRgba(o).a,a=(Math.sin(t*Math.PI*2/600)+1)/2;o=this.lerpColor(o,"#ffffff",a*.6),o=this.setAlpha(o,h)}if(this.drawPath(e,this.path,this.isDrawing,o,c,this.isDrawing?this.currentMousePos:this.exitTipPos),this.puzzle.symmetry!==void 0&&this.puzzle.symmetry!==0){let h=this.getSymmetryPath(this.path),a=this.options.colors.symmetry,y=this.colorToRgba(a).a,l=a,u=c;if(this.isInvalidPath&&(l=this.setAlpha(i,y)),!this.isDrawing&&this.exitTipPos&&!this.isInvalidPath){let m=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),P=this.options.animations.blinkDuration;m<P&&this.isSuccessFading&&(this.invalidatedCells.length>0||this.invalidatedEdges.length>0||this.invalidatedNodes.length>0)&&this.options.blinkMarksOnError&&(l=this.setAlpha(this.options.colors.error,y))}if(d&&!this.isInvalidPath&&!this.isSuccessFading&&!this.isValidPath){let m=(Math.sin(t*Math.PI*2/400)+1)/2;l=this.lerpColor(l,"#ffffff",m*.6),l=this.setAlpha(l,y)}this.drawPath(e,h,this.isDrawing,l,u,f)}}this.emit("render:after",{ctx:e})}drawRipples(e){if(!this.puzzle)return;let t=(Date.now()-this.startTime)/500;for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++)if(this.puzzle.nodes[s][n].type===2){let i=this.getCanvasCoords(n,s),o=this.getExitDir(n,s);if(!o)continue;let c={x:i.x+o.x*this.options.exitLength,y:i.y+o.y*this.options.exitLength},f=t%4,d=f*5,h=Math.max(0,1-f/3);e.beginPath(),e.arc(c.x,c.y,d,0,Math.PI*2),e.strokeStyle=`rgba(170, 170, 170, ${h*.4})`,e.lineWidth=2,e.stroke()}}drawGrid(e){if(!this.puzzle||!this.options.colors.grid)return;e.strokeStyle=this.options.colors.grid,e.lineWidth=12,e.lineCap="round";let t=(s,n,r)=>{if(r!==2)if(r===1){let o={x:s.x+(n.x-s.x)*.35,y:s.y+(n.y-s.y)*.35},c={x:s.x+(n.x-s.x)*(.5+.15),y:s.y+(n.y-s.y)*(.5+.15)};e.beginPath(),e.moveTo(s.x,s.y),e.lineTo(o.x,o.y),e.stroke(),e.beginPath(),e.moveTo(c.x,c.y),e.lineTo(n.x,n.y),e.stroke()}else e.beginPath(),e.moveTo(s.x,s.y),e.lineTo(n.x,n.y),e.stroke()};for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<this.puzzle.cols;n++)t(this.getCanvasCoords(n,s),this.getCanvasCoords(n+1,s),this.puzzle.hEdges[s][n].type);for(let s=0;s<this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++)t(this.getCanvasCoords(n,s),this.getCanvasCoords(n,s+1),this.puzzle.vEdges[s][n].type)}drawConstraints(e){if(!this.puzzle)return;let t=Date.now(),s=(Math.sin(t*Math.PI*2/this.options.animations.blinkPeriod)+1)/2,n=new Set(this.invalidatedCells.map(a=>`${a.x},${a.y}`)),r=new Set(this.errorCells.map(a=>`${a.x},${a.y}`)),i=new Set(this.invalidatedEdges.map(a=>`${a.type},${a.r},${a.c}`)),o=new Set(this.errorEdges.map(a=>`${a.type},${a.r},${a.c}`)),c=new Set(this.invalidatedNodes.map(a=>`${a.x},${a.y}`)),f=new Set(this.errorNodes.map(a=>`${a.x},${a.y}`));for(let a=0;a<this.puzzle.rows;a++)for(let y=0;y<this.puzzle.cols;y++){let l=this.puzzle.cells[a][y],u=this.getCanvasCoords(y+.5,a+.5),m=`${y},${a}`,P=n.has(m),E=r.has(m),p=1,g,x=this.getColorCode(l.color),w=this.options.colors.error;if(E&&this.options.blinkMarksOnError&&(g=this.lerpColor(x,w,s)),P){let b=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),v=this.options.animations.blinkDuration;if(b<v){if(this.options.blinkMarksOnError){let S=Math.min(1,b/200),T=b>v*.8?(v-b)/(v*.2):1,C=Math.min(S,T);g=this.lerpColor(x,w,s*C)}}else p=Math.max(.3,1-(b-v)/this.options.animations.fadeDuration)}e.save(),p<1&&(e.globalAlpha*=p),this.drawConstraintItem(e,l,u,g),e.restore()}e.lineWidth=2;let d=8,h=a=>a===3||a===3?this.options.colors.hexagon:a===4||a===4?this.options.colors.hexagonMain:a===5||a===5?this.options.colors.hexagonSymmetry:this.options.colors.hexagon;for(let a=0;a<=this.puzzle.rows;a++)for(let y=0;y<this.puzzle.cols;y++){let l=this.puzzle.hEdges[a][y].type;if(l===3||l===4||l===5){let u=this.getCanvasCoords(y+.5,a);e.save();let m=`h,${a},${y}`,P=i.has(m),E=o.has(m),p=h(l);if(E&&this.options.blinkMarksOnError){let g=this.lerpColor(p,this.options.colors.error,s);this.drawHexagon(e,u.x,u.y,d,g)}else if(P){let g=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),x=this.options.animations.blinkDuration;if(g<x)if(this.options.blinkMarksOnError){let w=Math.min(1,g/200),b=g>x*.8?(x-g)/(x*.2):1,v=Math.min(w,b),S=this.lerpColor(p,this.options.colors.error,s*v);this.drawHexagon(e,u.x,u.y,d,S)}else this.drawHexagon(e,u.x,u.y,d,p);else e.globalAlpha*=Math.max(.3,1-(g-x)/this.options.animations.fadeDuration),this.drawHexagon(e,u.x,u.y,d,p)}else this.drawHexagon(e,u.x,u.y,d,p);e.restore()}}for(let a=0;a<this.puzzle.rows;a++)for(let y=0;y<=this.puzzle.cols;y++){let l=this.puzzle.vEdges[a][y].type;if(l===3||l===4||l===5){let u=this.getCanvasCoords(y,a+.5);e.save();let m=`v,${a},${y}`,P=i.has(m),E=o.has(m),p=h(l);if(E&&this.options.blinkMarksOnError){let g=this.lerpColor(p,this.options.colors.error,s);this.drawHexagon(e,u.x,u.y,d,g)}else if(P){let g=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),x=this.options.animations.blinkDuration;if(g<x)if(this.options.blinkMarksOnError){let w=Math.min(1,g/200),b=g>x*.8?(x-g)/(x*.2):1,v=Math.min(w,b),S=this.lerpColor(p,this.options.colors.error,s*v);this.drawHexagon(e,u.x,u.y,d,S)}else this.drawHexagon(e,u.x,u.y,d,p);else e.globalAlpha*=Math.max(.3,1-(g-x)/this.options.animations.fadeDuration),this.drawHexagon(e,u.x,u.y,d,p)}else this.drawHexagon(e,u.x,u.y,d,p);e.restore()}}for(let a=0;a<=this.puzzle.rows;a++)for(let y=0;y<=this.puzzle.cols;y++){let l=this.puzzle.nodes[a][y].type;if(l===3||l===4||l===5){let u=this.getCanvasCoords(y,a);e.save();let m=`${y},${a}`,P=c.has(m),E=f.has(m),p=h(l);if(E&&this.options.blinkMarksOnError){let g=this.lerpColor(p,this.options.colors.error,s);this.drawHexagon(e,u.x,u.y,d,g)}else if(P){let g=t-(this.isSuccessFading?this.successFadeStartTime:this.eraserAnimationStartTime),x=this.options.animations.blinkDuration;if(g<x)if(this.options.blinkMarksOnError){let w=Math.min(1,g/200),b=g>x*.8?(x-g)/(x*.2):1,v=Math.min(w,b),S=this.lerpColor(p,this.options.colors.error,s*v);this.drawHexagon(e,u.x,u.y,d,S)}else this.drawHexagon(e,u.x,u.y,d,p);else e.globalAlpha*=Math.max(.3,1-(g-x)/this.options.animations.fadeDuration),this.drawHexagon(e,u.x,u.y,d,p)}else this.drawHexagon(e,u.x,u.y,d,p);e.restore()}}}drawConstraintItem(e,t,s,n){t.type===1?(e.fillStyle=n||this.getColorCode(t.color),this.drawRoundedRect(e,s.x-26/2,s.y-26/2,26,26,8)):t.type===2?this.drawStar(e,s.x,s.y,12,16,8,t.color,n):t.type===3||t.type===4?this.drawTetris(e,s.x,s.y,t.shape||[],t.type===4,t.color,!1,n):t.type===5||t.type===6?this.drawTetris(e,s.x,s.y,t.shape||[],t.type===6,t.color,!0,n):t.type===7?this.drawEraser(e,s.x,s.y,14,3,t.color,n):t.type===8&&this.drawTriangle(e,s.x,s.y,t.count||0,t.color,n)}drawNodes(e){if(!this.puzzle)return;let t=(s,n)=>{let r=[];return s>0&&r.push(this.puzzle.hEdges[n][s-1].type),s<this.puzzle.cols&&r.push(this.puzzle.hEdges[n][s].type),n>0&&r.push(this.puzzle.vEdges[n-1][s].type),n<this.puzzle.rows&&r.push(this.puzzle.vEdges[n][s].type),r.length>0&&r.every(i=>i===2)};for(let s=0;s<=this.puzzle.rows;s++)for(let n=0;n<=this.puzzle.cols;n++){if(t(n,s))continue;let r=this.puzzle.nodes[s][n];if(r.type===3||r.type===4||r.type===5)continue;let i=this.getCanvasCoords(n,s);if(r.type===1)this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(i.x,i.y,this.options.startNodeRadius,0,Math.PI*2),e.fill();else if(r.type===2){let o=this.getExitDir(n,s);if(!o)continue;this.options.colors.node&&(e.strokeStyle=this.options.colors.node),e.lineWidth=12,e.lineCap="round",e.beginPath(),e.moveTo(i.x,i.y),e.lineTo(i.x+o.x*this.options.exitLength,i.y+o.y*this.options.exitLength),e.stroke()}else this.options.colors.node&&(e.fillStyle=this.options.colors.node),e.beginPath(),e.arc(i.x,i.y,this.options.nodeRadius,0,Math.PI*2),e.fill()}}drawPath(e,t,s,n,r,i=null){if(t.length===0||!n||n==="transparent")return;let o=this.colorToRgba(n),c=`rgb(${o.r},${o.g},${o.b})`,f=r*o.a,{canvas:d,ctx:h}=this.prepareOffscreen();this.drawPathInternal(h,t,s,c,i),e.save(),e.setTransform(1,0,0,1,0,0),e.globalAlpha=f,e.drawImage(d,0,0),e.restore()}drawPathInternal(e,t,s,n,r=null){e.save(),e.strokeStyle=n,e.fillStyle=n,e.lineWidth=this.options.pathWidth,e.lineCap="round",e.lineJoin="round",e.beginPath();let i=this.getCanvasCoords(t[0].x,t[0].y);e.moveTo(i.x,i.y);for(let c=1;c<t.length;c++){let f=this.getCanvasCoords(t[c].x,t[c].y);e.lineTo(f.x,f.y)}let o=r||this.currentMousePos;(s||r)&&e.lineTo(o.x,o.y),e.stroke(),e.beginPath(),e.arc(i.x,i.y,this.options.startNodeRadius,0,Math.PI*2),e.fill(),(s||r)&&(e.beginPath(),e.arc(o.x,o.y,this.options.pathWidth/2,0,Math.PI*2),e.fill()),e.restore()}drawRoundedRect(e,t,s,n,r,i){e.beginPath(),e.moveTo(t+i,s),e.lineTo(t+n-i,s),e.quadraticCurveTo(t+n,s,t+n,s+i),e.lineTo(t+n,s+r-i),e.quadraticCurveTo(t+n,s+r,t+n-i,s+r),e.lineTo(t+i,s+r),e.quadraticCurveTo(t,s+r,t,s+r-i),e.lineTo(t,s+i),e.quadraticCurveTo(t,s,t+i,s),e.closePath(),e.fill()}drawHexagon(e,t,s,n,r){if(!(!this.options.colors.hexagon&&!r)){e.fillStyle=r||this.options.colors.hexagon,e.beginPath();for(let i=0;i<6;i++){let o=Math.PI/3*i,c=t+n*Math.cos(o),f=s+n*Math.sin(o);i===0?e.moveTo(c,f):e.lineTo(c,f)}e.closePath(),e.fill()}}drawEraser(e,t,s,n,r,i,o){e.strokeStyle=o||this.getColorCode(i),e.lineWidth=n*.5,e.lineCap="butt";let c=.5;e.beginPath();for(let f=0;f<r;f++){let d=Math.PI*2/r*f+c,h=t+n*Math.cos(d),a=s+n*Math.sin(d);e.moveTo(t,s),e.lineTo(h,a)}e.stroke()}drawStar(e,t,s,n,r,i,o,c){e.fillStyle=c||this.getColorCode(o),e.beginPath();for(let f=0;f<i*2;f++){let d=f%2===0?r:n,h=Math.PI/i*f,a=t+d*Math.cos(h),y=s+d*Math.sin(h);f===0?e.moveTo(a,y):e.lineTo(a,y)}e.closePath(),e.fill()}drawTriangle(e,t,s,n,r,i){if(n<=0)return;let o=i||this.getColorCode(r,"#ffcc00");e.fillStyle=o;let f=12*.8,d=f*2.2,h=(y,l)=>{e.beginPath();for(let u=0;u<3;u++){let m=Math.PI*2*u/3-Math.PI/2,P=y+f*Math.cos(m),E=l+f*Math.sin(m);u===0?e.moveTo(P,E):e.lineTo(P,E)}e.closePath(),e.fill()},a=(n-1)*d*.5;for(let y=0;y<n;y++)h(t-a+y*d,s)}drawTetris(e,t,s,n,r,i,o,c){if(!n||n.length===0)return;let f=12,d=2,h=n[0].length*f+(n[0].length-1)*d,a=n.length*f+(n.length-1)*d;e.save(),e.translate(t,s),r&&e.rotate(Math.PI/8);let y=c||this.getColorCode(i,o?"#00ffff":"#ffcc00");if(o){e.strokeStyle=y,e.lineWidth=2;for(let l=0;l<n.length;l++)for(let u=0;u<n[l].length;u++)if(n[l][u]){let m=u*(f+d)-h/2,P=l*(f+d)-a/2;e.strokeRect(m+1,P+1,f-2,f-2)}}else{e.fillStyle=y;for(let l=0;l<n.length;l++)for(let u=0;u<n[l].length;u++)if(n[l][u]){let m=u*(f+d)-h/2,P=l*(f+d)-a/2;e.fillRect(m,P,f,f)}}e.restore()}getColorCode(e,t="#666"){return this.options.colors.colorList&&this.options.colors.colorList[e]!==void 0?this.options.colors.colorList[e]:this.options.colors.colorMap&&this.options.colors.colorMap[e]!==void 0?this.options.colors.colorMap[e]:t}colorToRgba(e){if(!e||e==="transparent")return{r:0,g:0,b:0,a:0};if(e.startsWith("rgba")||e.startsWith("rgb")){let s=e.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);if(s)return{r:parseInt(s[1]),g:parseInt(s[2]),b:parseInt(s[3]),a:s[4]?parseFloat(s[4]):1}}let t=e.startsWith("#")?e.slice(1):e;if((t.length===3||t.length===4)&&(t=t.split("").map(s=>s+s).join("")),t.length===6){let s=parseInt(t,16);return{r:s>>16&255,g:s>>8&255,b:s&255,a:1}}else if(t.length===8){let s=parseInt(t,16);return{r:s>>24&255,g:s>>16&255,b:s>>8&255,a:(s&255)/255}}return{r:0,g:0,b:0,a:1}}lerpColor(e,t,s){try{let n=this.colorToRgba(e),r=this.colorToRgba(t),i=Math.round(n.r+(r.r-n.r)*s),o=Math.round(n.g+(r.g-n.g)*s),c=Math.round(n.b+(r.b-n.b)*s),f=n.a+(r.a-n.a)*s;return`rgba(${i},${o},${c},${f})`}catch{return e}}setAlpha(e,t){let s=this.colorToRgba(e);return`rgba(${s.r},${s.g},${s.b},${t})`}getSymmetryPath(e){return!this.puzzle||!this.puzzle.symmetry?[]:e.map(t=>this.getSymmetricalPoint(t))}getSymmetricalPoint(e,t=!1){if(!this.puzzle||!this.puzzle.symmetry)return{...e};let{cols:s,rows:n,symmetry:r}=this.puzzle;return r===1?{x:s-e.x,y:e.y}:r===2?{x:e.x,y:n-e.y}:r===3?{x:s-e.x,y:n-e.y}:{...e}}isPathAtExit(e,t){if(e.length===0||!t)return!1;let s=e[e.length-1],n=this.getExitDir(s.x,s.y);if(!n)return!1;let r=this.getCanvasCoords(s.x,s.y),i=t.x-r.x,o=t.y-r.y;return i*n.x+o*n.y>=this.options.exitLength*.9}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}sanitizeOptions(e){let t={};for(let s in e){let n=e[s];if(n&&typeof n=="object"&&!Array.isArray(n)){t[s]={};for(let r in n)typeof n[r]!="function"&&(t[s][r]=n[r])}else typeof n!="function"&&(t[s]=n)}return t}prepareOffscreen(){let e=this.options.pixelRatio;if(!this.offscreenCanvas){if(typeof document<"u")this.offscreenCanvas=document.createElement("canvas");else if(typeof OffscreenCanvas<"u")this.offscreenCanvas=new OffscreenCanvas(this.canvas.width,this.canvas.height);else throw new Error("Offscreen canvas not supported in this environment.");this.offscreenCtx=this.offscreenCanvas.getContext("2d")}if((this.offscreenCanvas.width!==this.canvas.width||this.offscreenCanvas.height!==this.canvas.height)&&(this.offscreenCanvas.width=this.canvas.width,this.offscreenCanvas.height=this.canvas.height),!this.offscreenCtx)throw new Error("Could not get offscreen 2D context.");return this.offscreenCtx.setTransform(e,0,0,e,0,0),this.offscreenCtx.clearRect(0,0,this.offscreenCanvas.width/e,this.offscreenCanvas.height/e),{canvas:this.offscreenCanvas,ctx:this.offscreenCtx}}};var ve=class{bytes=[];cur=0;bit=0;write(e,t){for(let s=0;s<t;s++)e&1<<s&&(this.cur|=1<<this.bit),this.bit++,this.bit===8&&(this.bytes.push(this.cur),this.cur=0,this.bit=0)}finish(){return this.bit>0&&this.bytes.push(this.cur),new Uint8Array(this.bytes)}},be=class{constructor(e){this.buf=e}i=0;bit=0;read(e){let t=0;for(let s=0;s<e;s++)this.buf[this.i]&1<<this.bit&&(t|=1<<s),this.bit++,this.bit===8&&(this.bit=0,this.i++);return t}get hasMore(){return this.i<this.buf.length}},ue=new Uint8Array(512),Pe=new Uint8Array(256);{let G=1;for(let e=0;e<255;e++)ue[e]=G,ue[e+255]=G,Pe[G]=e,G<<=1,G&256&&(G^=285)}function ge(G,e){return G===0||e===0?0:ue[Pe[G]+Pe[e]]}function Te(G,e){let t=new Uint8Array([1]);for(let r=0;r<e;r++){let i=new Uint8Array(t.length+1),o=ue[r];for(let c=0;c<t.length;c++)i[c]^=ge(t[c],o),i[c+1]^=t[c];t=i}let s=t.slice(0,e+1).reverse(),n=new Uint8Array(e);for(let r=0;r<G.length;r++){let i=G[r]^n[0];for(let o=0;o<e-1;o++)n[o]=n[o+1]^ge(i,s[o+1]);n[e-1]=ge(i,s[e])}return n}function ze(G,e){let t=new Uint8Array(G.length+e.length);t.set(G),t.set(e,G.length);for(let s=0;s<e.length;s++){let n=0,r=ue[s];for(let i=0;i<t.length;i++)n=ge(n,r)^t[i];if(n!==0)return!1}return!0}function Ne(G){let e=new Map;for(let t of G)for(let s of t)if(s.shape){let n=JSON.stringify(s.shape);e.has(n)||e.set(n,s.shape)}return[...e.values()]}var Se=class{static async serialize(e,t){let s,n=e;typeof n=="object"&&n!==null&&"rows"in n&&"cells"in n&&!("puzzle"in n)&&!("options"in n)&&!("path"in n)&&!("seed"in n)?s={puzzle:e,options:t}:s=e;let i=new ve,o=0;s.puzzle&&(o|=1),s.seed&&(o|=2),s.options&&(o|=4),s.path&&(o|=8);let c=s.parityMode==="recovery";c&&(o|=16),i.write(o,8),s.puzzle&&this.writePuzzle(i,s.puzzle),s.seed&&this.writeSeed(i,s.seed),s.options&&this.writeOptions(i,s.options),s.path&&this.writePath(i,s.path);let f=i.finish(),d=new Uint8Array(await new Response(new Blob([f.buffer]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()),h;if(c){let a=Te(d,10);h=new Uint8Array(d.length+10+2),h.set(d),h.set(a,d.length),h[h.length-2]=d.length&255,h[h.length-1]=d.length>>8&255}else{let a=0;for(let y of d)a^=y;h=new Uint8Array(d.length+1),h.set(d),h[d.length]=a}return btoa(String.fromCharCode(...h)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}static async deserialize(e){let t=async i=>{try{let o=i.replace(/-/g,"+").replace(/_/g,"/");for(;o.length%4;)o+="=";let c=atob(o);return Uint8Array.from(c,f=>f.charCodeAt(0))}catch{return null}},s=async i=>{if(i.length===0)return null;let o=0;for(let c=0;c<i.length-1;c++)o^=i[c];if(o===i[i.length-1])return i.slice(0,-1);if(i.length>12){let c=i[i.length-2]|i[i.length-1]<<8;if(c+12===i.length){let f=i.slice(0,c),d=i.slice(c,c+10);if(ze(f,d))return f}}return null},n=await t(e),r=n?await s(n):null;if(!r&&e.length<1e3){let i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";for(let o=0;o<=e.length;o++)for(let c=0;c<i.length;c++){let f=e.slice(0,o)+i[c]+e.slice(o),d=await t(f);if(d){let h=await s(d);if(h)try{return await this.finalizeDeserialize(h)}catch{}}}}if(!r)throw new Error("Invalid parity data or unrecoverable corruption");return this.finalizeDeserialize(r)}static async finalizeDeserialize(e){let t=new Uint8Array(await new Response(new Blob([e.buffer]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer()),s=new be(t),n=s.read(8),r={};return n&1&&(r.puzzle=this.readPuzzle(s)),n&2&&(r.seed=this.readSeed(s)),n&4&&(r.options=this.readOptions(s)),n&8&&(r.path=this.readPath(s)),r}static writePuzzle(e,t){e.write(t.rows,6),e.write(t.cols,6),e.write(t.symmetry??0,2);let s=Ne(t.cells);e.write(s.length,5);for(let r of s){e.write(r.length,4),e.write(r[0].length,4);for(let i of r)for(let o of i)e.write(o,1)}let n=new Map;s.forEach((r,i)=>n.set(JSON.stringify(r),i));for(let r of t.cells)for(let i of r)e.write(i.type,4),e.write(i.color,3),i.type===8?e.write(i.count||0,2):i.shape?(e.write(1,1),e.write(n.get(JSON.stringify(i.shape)),5)):e.write(0,1);for(let r=0;r<t.rows;r++)for(let i=0;i<t.cols+1;i++)e.write(t.vEdges[r][i].type,3);for(let r=0;r<t.rows+1;r++)for(let i=0;i<t.cols;i++)e.write(t.hEdges[r][i].type,3);for(let r=0;r<t.rows+1;r++)for(let i=0;i<t.cols+1;i++)e.write(t.nodes[r][i].type,3)}static readPuzzle(e){let t=e.read(6),s=e.read(6),n=e.read(2),r=e.read(5),i=[];for(let h=0;h<r;h++){let a=e.read(4),y=e.read(4),l=[];for(let u=0;u<a;u++){let m=[];for(let P=0;P<y;P++)m.push(e.read(1));l.push(m)}i.push(l)}let o=[];for(let h=0;h<t;h++){let a=[];for(let y=0;y<s;y++){let l=e.read(4),u=e.read(3),m={type:l,color:u};l===8?m.count=e.read(2):e.read(1)&&(m.shape=i[e.read(5)].map(P=>P.slice())),a.push(m)}o.push(a)}let c=Array.from({length:t},()=>Array.from({length:s+1},()=>({type:e.read(3)}))),f=Array.from({length:t+1},()=>Array.from({length:s},()=>({type:e.read(3)}))),d=Array.from({length:t+1},()=>Array.from({length:s+1},()=>({type:e.read(3)})));return{rows:t,cols:s,cells:o,vEdges:c,hEdges:f,nodes:d,symmetry:n}}static writeSeed(e,t){e.write(t.type,2),e.write(t.value.length,8);for(let s=0;s<t.value.length;s++)e.write(parseInt(t.value[s],16),4)}static readSeed(e){let t=e.read(2),s=e.read(8),n="";for(let r=0;r<s;r++)n+=e.read(4).toString(16);return{type:t,value:n}}static writeOptions(e,t){if(e.write(t.rows??0,6),e.write(t.cols??0,6),e.write(+!!t.useHexagons,1),e.write(+!!t.useSquares,1),e.write(+!!t.useStars,1),e.write(+!!t.useTetris,1),e.write(+!!t.useTetrisNegative,1),e.write(+!!t.useEraser,1),e.write(+!!t.useTriangles,1),e.write(+!!t.useBrokenEdges,1),e.write(t.symmetry??0,2),e.write(Math.round((t.complexity??0)*254),8),e.write(Math.round((t.difficulty??0)*254),8),e.write(Math.round((t.pathLength??0)*254),8),t.availableColors&&t.availableColors.length>0){e.write(1,1),e.write(t.availableColors.length,4);for(let s of t.availableColors)e.write(s,3)}else e.write(0,1);if(t.defaultColors){let s=Object.entries(t.defaultColors);e.write(s.length,4);for(let[n,r]of s){let i=isNaN(Number(n))?re[n]:Number(n);e.write(i,4),e.write(r,3)}}else e.write(0,4)}static readOptions(e){let t={},s=e.read(6),n=e.read(6);s>0&&(t.rows=s),n>0&&(t.cols=n),e.read(1)&&(t.useHexagons=!0),e.read(1)&&(t.useSquares=!0),e.read(1)&&(t.useStars=!0),e.read(1)&&(t.useTetris=!0),e.read(1)&&(t.useTetrisNegative=!0),e.read(1)&&(t.useEraser=!0),e.read(1)&&(t.useTriangles=!0),e.read(1)&&(t.useBrokenEdges=!0),t.symmetry=e.read(2);let r=()=>Math.round(e.read(8)/254*1e3)/1e3;if(t.complexity=r(),t.difficulty=r(),t.pathLength=r(),e.read(1)){let o=e.read(4);t.availableColors=[];for(let c=0;c<o;c++)t.availableColors.push(e.read(3))}let i=e.read(4);if(i>0){t.defaultColors={};for(let o=0;o<i;o++){let c=e.read(4),f=e.read(3);t.defaultColors[c]=f}}return t}static writePath(e,t){if(e.write(t.points.length,12),t.points.length!==0){e.write(t.points[0].x,6),e.write(t.points[0].y,6);for(let s=1;s<t.points.length;s++){let n=t.points[s-1],r=t.points[s],i=r.x-n.x,o=r.y-n.y,c=0;o===-1?c=0:i===1?c=1:o===1?c=2:i===-1&&(c=3),e.write(c,2)}}}static readPath(e){let t=e.read(12);if(t===0)return{points:[]};let s=[],n=e.read(6),r=e.read(6);s.push({x:n,y:r});for(let i=1;i<t;i++){let o=e.read(2);o===0?r--:o===1?n++:o===2?r++:o===3&&n--,s.push({x:n,y:r})}return{points:s}}};var Ee=class{generator;validator;constructor(){this.generator=new ce,this.validator=new ae}createPuzzle(e,t,s={}){return this.generator.generate(e,t,s).export()}validateSolution(e,t){let s=ie.fromData(e);return this.validator.validate(s,t)}calculateDifficulty(e){let t=ie.fromData(e);return this.validator.calculateDifficulty(t)}};if(typeof self<"u"&&"postMessage"in self&&!("document"in self)){let G=new Ee,e=null,t=null;self.addEventListener("message",s=>{let{type:n,payload:r}=s.data;switch(n){case"init":{let{canvas:i,options:o}=r;e=new fe(i,void 0,o),e.on("path:complete",({path:c})=>{if(self.postMessage({type:"drawingEnded"}),self.postMessage({type:"pathComplete",payload:c}),o.autoValidate&&t){let f=G.validateSolution(t,{points:c});e.setValidationResult(f.isValid,f.invalidatedCells,f.invalidatedEdges,f.errorCells,f.errorEdges,f.invalidatedNodes,f.errorNodes),self.postMessage({type:"validationResult",payload:f})}});break}case"createPuzzle":{let{rows:i,cols:o,genOptions:c}=r,f=G.createPuzzle(i,o,c);self.postMessage({type:"puzzleCreated",payload:{puzzle:f,genOptions:c}});break}case"setPuzzle":{t=r.puzzle,e&&t&&(e.setPuzzle(t),r.options&&e.setOptions(r.options));break}case"setOptions":{e&&e.setOptions(r);break}case"setPath":{e&&e.setPath(r.path);break}case"setValidationResult":{e&&e.setValidationResult(r.isValid,r.invalidatedCells,r.invalidatedEdges,r.errorCells,r.errorEdges,r.invalidatedNodes,r.errorNodes);break}case"setCanvasRect":{e&&e.setCanvasRect(r);break}case"validate":{if(t){let i=G.validateSolution(t,{points:r.path});e&&e.setValidationResult(i.isValid,i.invalidatedCells,i.invalidatedEdges,i.errorCells,i.errorEdges,i.invalidatedNodes,i.errorNodes),self.postMessage({type:"validationResult",payload:i})}break}case"event":{let{eventType:i,eventData:o}=r;if(e)if(i==="mousedown"||i==="touchstart"){let c=e.handleStart(o);self.postMessage({type:"drawingStarted",payload:c})}else i==="mousemove"||i==="touchmove"?e.handleMove(o):(i==="mouseup"||i==="touchend")&&(e.handleEnd(o),self.postMessage({type:"drawingEnded"}));break}}})}export{re as CellType,Y as Color,Me as Direction,le as EdgeType,ie as Grid,he as NodeType,ce as PuzzleGenerator,Se as PuzzleSerializer,ae as PuzzleValidator,Ce as RngType,de as SymmetryType,Ee as WitnessCore,fe as WitnessUI};
//# sourceMappingURL=MiniWitness.min.js.map
