// Generated by dts-bundle-generator v9.5.1

export declare enum Direction {
	Up = 0,
	Right = 1,
	Down = 2,
	Left = 3
}
export declare enum CellType {
	None = 0,
	Square = 1,// 色分けが必要なブロック
	Star = 2,// 同じ色のペア作成 (星)
	Tetris = 3,// テトリス
	TetrisRotated = 4,// テトリス（回転可能）
	Eraser = 5
}
export declare enum EdgeType {
	Normal = 0,
	Broken = 1,// 線の真ん中で断線 (通行不可)
	Absent = 2,// そもそも分岐もなし (通行不可)
	Hexagon = 3
}
export declare enum NodeType {
	Normal = 0,
	Start = 1,
	End = 2
}
/**
 * 使用可能色
 */
export declare enum Color {
	None = 0,
	Black = 1,
	White = 2,
	Red = 3,
	Blue = 4
}
export interface Point {
	x: number;
	y: number;
}
export interface CellConstraint {
	type: CellType;
	color: Color;
	shape?: number[][];
}
export interface EdgeConstraint {
	type: EdgeType;
}
export interface NodeConstraint {
	type: NodeType;
}
/**
 * パズルの静的な定義データ
 */
export interface PuzzleData {
	rows: number;
	cols: number;
	cells: CellConstraint[][];
	vEdges: EdgeConstraint[][];
	hEdges: EdgeConstraint[][];
	nodes: NodeConstraint[][];
}
/**
 * ユーザーの入力（回答パス）
 */
export interface SolutionPath {
	points: Point[];
}
export interface ValidationResult {
	isValid: boolean;
	errorReason?: string;
	invalidatedCells?: Point[];
	invalidatedEdges?: {
		type: "h" | "v";
		r: number;
		c: number;
	}[];
}
/**
 * パズル生成のオプション
 */
export interface GenerationOptions {
	useHexagons?: boolean;
	useSquares?: boolean;
	useStars?: boolean;
	useTetris?: boolean;
	useEraser?: boolean;
	useBrokenEdges?: boolean;
	complexity?: number;
	difficulty?: number;
}
export declare class Grid {
	readonly rows: number;
	readonly cols: number;
	cells: CellConstraint[][];
	hEdges: EdgeConstraint[][];
	vEdges: EdgeConstraint[][];
	nodes: NodeConstraint[][];
	constructor(rows: number, cols: number);
	private initializeGrid;
	export(): PuzzleData;
	static fromData(data: PuzzleData): Grid;
}
/**
 * パズルを自動生成するクラス
 */
export declare class PuzzleGenerator {
	/**
	 * パズルを生成する
	 * @param rows 行数
	 * @param cols 列数
	 * @param options 生成オプション
	 * @returns 生成されたグリッド
	 */
	generate(rows: number, cols: number, options?: GenerationOptions): Grid;
	/**
	 * 1回の試行でパズルを構築する
	 */
	private generateOnce;
	/**
	 * ランダムな正解パスを生成する
	 */
	private generateRandomPath;
	private getValidNeighbors;
	/**
	 * 解パスが通っていない場所にランダムに断線（Broken/Absent）を配置する
	 */
	private applyBrokenEdges;
	/**
	 * 到達不可能なエリアをAbsent化し、外部に漏れたセルをクリアする
	 */
	private cleanGrid;
	private getExternalCells;
	private isAdjacentToMark;
	/**
	 * マークが完全に断絶されたセルにいないか確認する
	 */
	private hasIsolatedMark;
	private getEdgeKey;
	private TETRIS_SHAPES;
	/**
	 * 解パスに基づいて各区画にルールを配置する
	 */
	private applyConstraintsBasedOnPath;
	/**
	 * 区画分けを行う
	 */
	private calculateRegions;
	private isAbsentEdge;
	/**
	 * 区画の境界エッジのうち、解パスが通っていないものを取得する
	 */
	private getRegionBoundaryEdges;
	private setEdgeHexagon;
	/**
	 * 要求された制約が全て含まれているか確認する
	 */
	private checkAllRequestedConstraintsPresent;
	/**
	 * 指定された区画をピースで埋め尽くすタイリングを生成する
	 */
	private generateTiling;
	/**
	 * タイリングを深さ優先探索で生成する
	 */
	private tilingDfs;
	private getShapeArea;
	private isRotationallyInvariant;
	private getAllRotations;
	private rotate90;
	private canPlace;
	private placePiece;
	private shuffleArray;
}
/**
 * UI表示設定
 */
export interface WitnessUIOptions {
	/** グリッド周囲の余白 */
	gridPadding?: number;
	/** セル1辺のサイズ */
	cellSize?: number;
	/** 通常ノードの半径 */
	nodeRadius?: number;
	/** 開始ノードの半径 */
	startNodeRadius?: number;
	/** パスの太さ */
	pathWidth?: number;
	/** 出口の長さ */
	exitLength?: number;
	/** パズルのサイズに合わせてCanvasサイズを自動調整するか */
	autoResize?: boolean;
	/** 色設定 */
	colors?: {
		/** 通常のパスの色 */
		path?: string;
		/** グリッドの色 */
		grid?: string;
		/** ノードの色 */
		node?: string;
		/** 六角形（通過必須）の色 */
		hexagon?: string;
		/** 各色のカラーコードマップ */
		colorMap?: Record<number, string>;
	};
	/** パスが完了（出口に到達）した際のコールバック */
	onPathComplete?: (path: Point[]) => void;
}
/**
 * the witnessパズルの描画とユーザー操作を管理するクラス
 */
export declare class WitnessUI {
	private canvas;
	private ctx;
	private puzzle;
	private options;
	private path;
	private isDrawing;
	private currentMousePos;
	private exitTipPos;
	private invalidatedCells;
	private invalidatedEdges;
	private isFading;
	private fadeOpacity;
	private fadeColor;
	private fadingPath;
	private fadingTipPos;
	private isSuccessFading;
	private successFadeStartTime;
	private startTime;
	private offscreenCanvas;
	private offscreenCtx;
	constructor(canvasOrId: HTMLCanvasElement | string, puzzle?: PuzzleData, options?: WitnessUIOptions);
	private mergeOptions;
	/**
	 * パズルデータを設定し、再描画する
	 */
	setPuzzle(puzzle: PuzzleData): void;
	/**
	 * 表示オプションを更新する
	 */
	setOptions(options: WitnessUIOptions): void;
	/**
	 * 検証結果を反映させる（不正解時の赤点滅や、消しゴムによる無効化の表示）
	 */
	setValidationResult(isValid: boolean, invalidatedCells?: Point[], invalidatedEdges?: {
		type: "h" | "v";
		r: number;
		c: number;
	}[]): void;
	private resizeCanvas;
	private initEvents;
	private getCanvasCoords;
	private getExitDir;
	private handleStart;
	private handleMove;
	private handleEnd;
	private getEdgeType;
	private startFade;
	private cancelFade;
	private animate;
	draw(): void;
	private drawRipples;
	private drawGrid;
	private drawConstraints;
	/**
	 * 単一の制約アイテムを描画（座標はキャンバス全体に対する絶対座標）
	 */
	private drawConstraintItem;
	private drawNodes;
	private drawPath;
	private drawPathInternal;
	private drawRoundedRect;
	private drawHexagon;
	private drawEraser;
	private drawStar;
	private drawTetris;
	private getColorCode;
	private prepareOffscreen;
}
/**
 * パズルの回答を検証するクラス
 */
export declare class PuzzleValidator {
	/**
	 * 与えられたグリッドと回答パスが正当かどうかを検証する
	 * @param grid パズルのグリッドデータ
	 * @param solution 回答パス
	 * @returns 検証結果（正誤、エラー理由、無効化された記号など）
	 */
	validate(grid: Grid, solution: SolutionPath): ValidationResult;
	/**
	 * 二点間が断線（Broken or Absent）しているか確認する
	 */
	private isBrokenEdge;
	/**
	 * 二点間が Absent（存在しない）エッジか確認する
	 */
	private isAbsentEdge;
	/**
	 * 回答パスが通過しなかった六角形エッジをリストアップする
	 */
	private getMissedHexagons;
	/**
	 * テトラポッド（エラー削除）を考慮してパズルの各制約を検証する
	 */
	private validateWithErasers;
	/**
	 * 指定されたエッジが特定の区画に隣接しているか確認する
	 */
	private isHexagonAdjacentToRegion;
	/**
	 * 区画内のエラー削除可能な全パターンを取得する
	 */
	private getPossibleErasures;
	/**
	 * 配列からN個選ぶ組み合わせを取得する
	 */
	private getNCombinations;
	/**
	 * 特定の削除・無効化を適用した状態で、区画内の制約が満たされているか検証する
	 */
	private checkRegionValid;
	/**
	 * グローバルな制約（六角形）の割り当てをバックトラッキングで探索する
	 */
	private findGlobalAssignment;
	/**
	 * テトリス制約の検証（指定された領域をピースで埋め尽くせるか）
	 */
	private checkTetrisConstraint;
	private getShapeArea;
	/**
	 * 再帰的にタイリングを試みる
	 */
	private canTile;
	private canPlace;
	private placePiece;
	private getAllRotations;
	private rotate90;
	/**
	 * 回答パスによって分割された各区画のセルリストを取得する
	 */
	private calculateRegions;
	/**
	 * エッジ（Absent）によって外部に繋がっているセルを特定する
	 */
	private getExternalCells;
	private getEdgeKey;
	/**
	 * パズルの難易度スコア(0.0-1.0)を算出する
	 */
	calculateDifficulty(grid: Grid): number;
	/**
	 * 探索空間を走査して統計情報を収集する
	 */
	private exploreSearchSpace;
	/**
	 * 正解数をカウントする
	 */
	countSolutions(grid: Grid, limit?: number): number;
	private findPathsOptimized;
	/**
	 * 終端まで到達可能かビットマスクBFSで高速に確認する
	 */
	private canReachEndOptimized;
	/**
	 * パスの論理的な指紋を取得する（区画分けに基づき、同一解を排除するため）
	 */
	private getFingerprint;
}
export declare class WitnessCore {
	private generator;
	private validator;
	constructor();
	/**
	 * 新しいパズルを生成してデータを返す
	 */
	createPuzzle(rows: number, cols: number, options?: GenerationOptions): PuzzleData;
	/**
	 * 解答を検証する
	 */
	validateSolution(puzzleData: PuzzleData, solution: SolutionPath): ValidationResult;
	/**
	 * パズルの難易度を計算する
	 */
	calculateDifficulty(puzzleData: PuzzleData): number;
}

export {};
