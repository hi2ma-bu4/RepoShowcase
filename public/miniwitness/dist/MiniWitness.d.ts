// Generated by dts-bundle-generator v9.5.1

export declare enum Direction {
	Up = 0,
	Right = 1,
	Down = 2,
	Left = 3
}
export declare enum CellType {
	None = 0,
	/** 色分けが必要なブロック */
	Square = 1,
	/** 同じ色のペア作成 (星) */
	Star = 2,
	/** テトリス */
	Tetris = 3,
	/** テトリス（回転可能） */
	TetrisRotated = 4,
	/** テトリス (減算) */
	TetrisNegative = 5,
	/** テトリス (減算・回転可能) */
	TetrisNegativeRotated = 6,
	/** テトラポッド (エラー削除) */
	Eraser = 7,
	/** 三角形 (通過辺数指定) */
	Triangle = 8
}
export declare enum EdgeType {
	Normal = 0,
	/** 線の真ん中で断線 (通行不可) */
	Broken = 1,
	/** そもそも分岐もなし (通行不可) */
	Absent = 2,
	/** 通過必須 (ワイルドカード) */
	Hexagon = 3,
	/** メイン線のみ通過必須 */
	HexagonMain = 4,
	/** 対称線のみ通過必須 */
	HexagonSymmetry = 5
}
export declare enum NodeType {
	Normal = 0,
	Start = 1,
	End = 2,
	/** 通過必須 (ワイルドカード) */
	Hexagon = 3,
	/** メイン線のみ通過必須 */
	HexagonMain = 4,
	/** 対称線のみ通過必須 */
	HexagonSymmetry = 5
}
export declare enum SymmetryType {
	None = 0,
	/** 左右対称 */
	Horizontal = 1,
	/** 上下対称 */
	Vertical = 2,
	/** 点対称 */
	Rotational = 3
}
/**
 * 使用可能色
 * Core内部では数値で管理し、UIで実際の色（文字列）と紐付ける
 */
export type Color = number;
export declare const Color: {
	readonly None: Color;
	readonly Black: Color;
	readonly White: Color;
	readonly Red: Color;
	readonly Blue: Color;
};
export interface Point {
	x: number;
	y: number;
}
export interface CellConstraint {
	type: CellType;
	color: Color;
	shape?: number[][];
	count?: number;
}
export interface EdgeConstraint {
	type: EdgeType;
}
export interface NodeConstraint {
	type: NodeType;
}
/**
 * パズルの静的な定義データ
 */
export interface PuzzleData {
	rows: number;
	cols: number;
	cells: CellConstraint[][];
	vEdges: EdgeConstraint[][];
	hEdges: EdgeConstraint[][];
	nodes: NodeConstraint[][];
	symmetry?: SymmetryType;
	/** パズル生成に使用された乱数シード (16進数文字列) */
	seed?: string;
}
/**
 * ユーザーの入力（回答パス）
 */
export interface SolutionPath {
	points: Point[];
}
export interface ValidationResult {
	isValid: boolean;
	errorReason?: string;
	invalidatedCells?: Point[];
	invalidatedEdges?: {
		type: "h" | "v";
		r: number;
		c: number;
	}[];
	invalidatedNodes?: Point[];
	errorCells?: Point[];
	errorEdges?: {
		type: "h" | "v";
		r: number;
		c: number;
	}[];
	errorNodes?: Point[];
	regions?: Point[][];
}
/**
 * パズル生成のオプション
 */
export interface GenerationOptions {
	rows?: number;
	cols?: number;
	useHexagons?: boolean;
	useSquares?: boolean;
	useStars?: boolean;
	useTetris?: boolean;
	useTetrisNegative?: boolean;
	useEraser?: boolean;
	useTriangles?: boolean;
	useBrokenEdges?: boolean;
	complexity?: number;
	difficulty?: number;
	pathLength?: number;
	symmetry?: SymmetryType;
	/** 四角形や星などの記号に使用可能な色のリスト。指定がない場合はデフォルト（黒・白・赤・青）が使用される。 */
	availableColors?: Color[];
	/** 各記号タイプのデフォルトカラー。指定がない場合はそれぞれの記号の標準色が使用される。
	 * キーには CellType の数値、または "Square", "Tetris" などの文字列が使用可能です。
	 */
	defaultColors?: Partial<Record<CellType | keyof typeof CellType, Color>>;
	/** パズル生成に使用する乱数シード (16進数文字列) */
	seed?: string;
	/** 使用する乱数アルゴリズム */
	rngType?: RngType;
	/** 固定したいスタート地点のリスト */
	starts?: Point[];
	/** 固定したいゴール地点のリスト */
	ends?: Point[];
}
export declare enum RngType {
	Mulberry32 = 0,
	XorShift128Plus = 1,
	MathRandom = 2
}
/**
 * シリアライズ時のオプション
 */
export interface SerializationOptions {
	/** パズル構造データを含めるか */
	puzzle?: PuzzleData;
	/** シード情報を含めるか */
	seed?: {
		type: RngType;
		value: string;
	};
	/** 生成設定を含めるか */
	options?: GenerationOptions;
	/** 解答パスを含めるか */
	path?: SolutionPath;
	/** UIのカラーフィルター設定を含めるか */
	filter?: {
		enabled?: boolean;
		mode?: "custom" | "rgb";
		customColor?: string;
		rgbColors?: [
			string,
			string,
			string
		];
		rgbIndex?: 0 | 1 | 2;
		threshold?: number;
	};
	/** パリティモード ('detection': 破損検知のみ, 'recovery': 部分復元可能) */
	parityMode?: "detection" | "recovery";
}
/**
 * デシリアライズされたデータ
 */
export interface DeserializedData {
	puzzle?: PuzzleData;
	seed?: {
		type: RngType;
		value: string;
	};
	options?: GenerationOptions;
	path?: SolutionPath;
	filter?: {
		enabled?: boolean;
		mode?: "custom" | "rgb";
		customColor?: string;
		rgbColors?: [
			string,
			string,
			string
		];
		rgbIndex?: 0 | 1 | 2;
		threshold?: number;
	};
}
/**
 * パズルのグリッド構造と状態を管理するクラス
 */
export declare class Grid {
	/** 行数 */
	readonly rows: number;
	/** 列数 */
	readonly cols: number;
	/** セルの制約（記号）マトリクス */
	cells: CellConstraint[][];
	/** 水平エッジの制約マトリクス */
	hEdges: EdgeConstraint[][];
	/** 垂直エッジの制約マトリクス */
	vEdges: EdgeConstraint[][];
	/** ノードの制約マトリクス */
	nodes: NodeConstraint[][];
	/** 対称性の設定 (SymmetryType) */
	symmetry: number;
	/** パズル生成に使用された乱数シード (16進数文字列) */
	seed?: string;
	/**
	 * 新しいグリッドを初期化する
	 * @param rows 行数
	 * @param cols 列数
	 */
	constructor(rows: number, cols: number);
	/**
	 * グリッドの各要素を初期状態（制約なし）で生成する
	 */
	private initializeGrid;
	/**
	 * グリッドの状態を PuzzleData 形式でエクスポートする
	 * @returns パズルデータ
	 */
	export(): PuzzleData;
	/**
	 * PuzzleData から Grid インスタンスを生成する
	 * @param data パズルデータ
	 * @returns Grid インスタンス
	 */
	static fromData(data: PuzzleData): Grid;
}
/**
 * パズルを自動生成するクラス
 */
export declare class PuzzleGenerator {
	private isWorker;
	private TETRIS_SHAPES_WITH_ROTATIONS;
	private rng;
	constructor();
	private stringToSeed;
	/**
	 * パズルを生成する
	 * @param rows 行数
	 * @param cols 列数
	 * @param options 生成オプション
	 * @returns 生成されたグリッド
	 */
	generate(rows: number, cols: number, options?: GenerationOptions): Grid;
	/**
	 * 指定されたパスに基づいてパズルを構築する
	 * @param rows 行数
	 * @param cols 列数
	 * @param solutionPath 解答パス
	 * @param options 生成オプション
	 * @param starts 全てのスタート地点
	 * @param ends 全てのゴール地点
	 * @param precalculatedRegions 事前計算された区画
	 * @param precalculatedBoundaryEdges 事前計算された境界エッジ
	 * @returns 構築されたグリッド
	 */
	private generateFromPath;
	/**
	 * ランダムな正解パスを生成する
	 * @param targetLengthFactor 0.0 (最短) - 1.0 (最長)
	 */
	private generateRandomPath;
	/**
	 * 1本のランダムパスを生成する
	 * @param grid グリッド
	 * @param starts 開始候補点リスト
	 * @param ends 終了候補点リスト
	 * @param biasFactor 長さのバイアス
	 * @param symmetry 対称性
	 * @returns 生成されたパス
	 */
	private generateSingleRandomPath;
	private toPointIndex;
	private getValidNeighbors;
	/**
	 * 解パスが通っていない場所にランダムに断線（Broken/Absent）を配置する
	 * @param grid グリッド
	 * @param path 解答パス
	 * @param options 生成オプション
	 */
	private applyBrokenEdges;
	/**
	 * エッジがAbsentに変換可能か判定する
	 * @param grid グリッド
	 * @param edge 判定対象のエッジ
	 * @returns 変換可能かどうか
	 */
	private canBecomeAbsent;
	/**
	 * 到達不可能なエリアをAbsent化し、外部に漏れたセルをクリアする
	 * @param grid グリッド
	 */
	private cleanGrid;
	private getExternalCells;
	private isAdjacentToMark;
	/**
	 * マークが完全に断絶されたセルにいないか確認する
	 * @param grid グリッド
	 * @returns 孤立したマークがあるかどうか
	 */
	private hasIsolatedMark;
	private getSymmetricalPoint;
	private getEdgeKey;
	private TETRIS_SHAPES;
	/**
	 * 解パスに基づいて各区画にルールを配置する
	 * @param grid グリッド
	 * @param path 解答パス
	 * @param options 生成オプション
	 * @param symPath 対称パス
	 * @param precalculatedRegions 事前計算された区画
	 * @param precalculatedBoundaryEdges 事前計算された境界エッジ
	 */
	private applyConstraintsBasedOnPath;
	/**
	 * 区画分けを行う
	 * @param grid グリッド
	 * @param path 解答パス
	 * @param symPath 対称パス
	 * @returns 区画リスト
	 */
	private calculateRegions;
	private isAbsentEdge;
	/**
	 * 区画の境界エッジのうち、解パスが通っていないものを取得する
	 * @param grid グリッド
	 * @param region 区画
	 * @param path 解答パス
	 * @param symPath 対称パス
	 * @returns 境界エッジのリスト
	 */
	private getRegionBoundaryEdges;
	private setEdgeHexagon;
	private hasIncidentHexagonEdge;
	private isEdgeAdjacentToHexagonNode;
	/**
	 * 要求された制約が全て含まれているか確認する
	 * @param grid グリッド
	 * @param options 生成オプション
	 * @returns 全ての要求された制約が含まれているか
	 */
	private checkAllRequestedConstraintsPresent;
	/**
	 * 指定された区画をピースで埋め尽くすタイリングを生成する
	 * @param region 区画
	 * @param maxPieces 最大ピース数
	 * @param options 生成オプション
	 * @returns タイリング結果
	 */
	private generateTiling;
	/**
	 * タイリングを深さ優先探索で生成する
	 * @param regionGrid 領域のグリッド表現
	 * @param currentPieces 現在配置済みのピース
	 * @param maxPieces 最大ピース数
	 * @param options 生成オプション
	 * @returns 成功した場合はピースのリスト、失敗した場合はnull
	 */
	private tilingDfs;
	private getShapeArea;
	private isRotationallyInvariant;
	private getAllRotations;
	private rotate90;
	private canPlace;
	private placePiece;
	private isSameShape;
	private countRegionNonEraserSymbols;
	private hasRegionTetrisSymbol;
	private canPlaceGeneratedTetrisNegative;
	private canPlaceGeneratedEraser;
	private canTilePieceWith;
	private findStandardTriple;
	private shuffleArray;
}
/**
 * パズルデータ、設定、シード、経路などをシリアライズ/デシリアライズするクラス
 */
export declare class PuzzleSerializer {
	/**
	 * データを圧縮されたBase64文字列に変換する
	 */
	static serialize(data: SerializationOptions | PuzzleData, legacyOptions?: GenerationOptions): Promise<string>;
	/**
	 * シリアライズされた文字列からデータを復元する
	 */
	static deserialize(str: string): Promise<DeserializedData>;
	private static toBase64Url;
	private static share64Value;
	private static solveLinearGF64;
	private static encodeRobustShareCode;
	private static decodeRobustShareCode;
	private static extractShareCodeCandidates;
	private static finalizeDeserialize;
	private static writePuzzle;
	private static readPuzzle;
	private static writeSeed;
	private static readSeed;
	private static writeOptions;
	private static readOptions;
	private static writePath;
	private static readPath;
	private static writeColorHex24;
	private static readColorHex24;
	private static writeFilter;
	private static readFilter;
}
/**
 * UI表示設定
 */
export interface WitnessUIOptions {
	/** グリッド周囲の余白 */
	gridPadding?: number;
	/** セル1辺のサイズ */
	cellSize?: number;
	/** 通常ノードの半径 */
	nodeRadius?: number;
	/** 開始ノードの半径 */
	startNodeRadius?: number;
	/** パスの太さ */
	pathWidth?: number;
	/** 出口の長さ */
	exitLength?: number;
	/** パズルのサイズに合わせてCanvasサイズを自動調整するか */
	autoResize?: boolean;
	/** 失敗時にマークを赤く点滅させるか */
	blinkMarksOnError?: boolean;
	/** 失敗時に引いた線（対称線含む）を残すか（falseの場合はフェードアウトする） */
	stayPathOnError?: boolean;
	/** パスが完了した際に自動的にバリデーションを実行するか (Workerモード時のみ有効) */
	autoValidate?: boolean;
	/** WebWorkerを使用して生成・検証を行うか */
	useWorker?: boolean;
	/** Workerスクリプトのパス (デフォルトは import.meta.url) */
	workerScript?: string;
	/** アニメーション設定 */
	animations?: {
		/** 点滅・前アニメーションの時間(ms) */
		blinkDuration: number;
		/** 無効化フェードの時間(ms) */
		fadeDuration: number;
		/** 点滅の周期(ms) */
		blinkPeriod: number;
	};
	/** 色設定 */
	colors?: {
		/** 通常のパスの色 */
		path?: string;
		/** エラー時の色 */
		error?: string;
		/** 成功時のフラッシュ/アニメーション用 */
		success?: string;
		/** 対称パスの色 */
		symmetry?: string;
		/** 途中で離した際のフェード色 */
		interrupted?: string;
		/** グリッドの色 */
		grid?: string;
		/** ノードの色 */
		node?: string;
		/** 六角形（通過必須）の色 */
		hexagon?: string;
		/** メイン線のみの六角形の色 */
		hexagonMain?: string;
		/** 対称線のみの六角形の色 */
		hexagonSymmetry?: string;
		/** 各色のカラーコードマップ */
		colorMap?: Record<number, string>;
		/** 各色のカラーコードリスト（インデックスがColor値に対応） */
		colorList?: string[];
	};
	/** パズル全体に掛けるカラーフィルター設定 */
	filter?: {
		/** フィルターを有効化するか */
		enabled?: boolean;
		/** カスタム単色か、RGB 3色プリセットか */
		mode?: "custom" | "rgb";
		/** customモード時に使用する色 */
		customColor?: string;
		/** rgbモード時の3色フィルター */
		rgbColors?: [
			string,
			string,
			string
		];
		/** rgbモード時に使用する色インデックス */
		rgbIndex?: 0 | 1 | 2;
		/** 白黒化のしきい値 (0-255) */
		threshold?: number;
	};
	/** 高解像度ディスプレイ(Retina等)に対応させるためのピクセル比。省略時はwindow.devicePixelRatioが使用されます。 */
	pixelRatio?: number;
}
/**
 * WitnessUIが発行するイベントのマップ
 */
export interface WitnessEventMap {
	/** 描画の直前 (コンテキストが渡される) */
	"render:before": {
		ctx: WitnessContext;
	};
	/** 描画の直後 (コンテキストが渡される) */
	"render:after": {
		ctx: WitnessContext;
	};
	/** パスの描き始め (グリッド座標) */
	"path:start": {
		x: number;
		y: number;
	};
	/** パスの移動中 (グリッド座標、パス全体、現在のマウス位置) */
	"path:move": {
		x: number;
		y: number;
		path: Point[];
		currentMousePos: Point;
	};
	/** パスの終了 (パス全体、出口に到達したか) */
	"path:end": {
		path: Point[];
		isExit: boolean;
	};
	/** パスが完了し、出口に到達した瞬間 */
	"path:complete": {
		path: Point[];
	};
	/** ゴール可能状態（先端がゴールの出っ張りに近い）の変化 */
	"goal:reachable": {
		reachable: boolean;
	};
	/** ゴールに到達し、成功または失敗のアニメーションが開始された時 */
	"goal:reached": {
		path: Point[];
		isValid: boolean;
	};
	/** 無効化アニメーション（消しゴム等）が終了し、完全にバリデーション表示が完了した時 */
	"goal:validated": {
		result: ValidationResult;
	};
	/** Workerで新しいパズルが生成された時 */
	"puzzle:generated": {
		puzzle: PuzzleData;
		genOptions: any;
	};
	/** 新しいパズルがセットされた時 */
	"puzzle:created": {
		puzzle: PuzzleData;
	};
}
export type WitnessEventName = keyof WitnessEventMap;
export type WitnessContext = CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;
/**
 * the witnessパズルの描画とユーザー操作を管理するクラス
 */
export declare class WitnessUI {
	private canvas;
	private ctx;
	private worker;
	private puzzle;
	private options;
	private listeners;
	private path;
	private isDrawing;
	private currentMousePos;
	private exitTipPos;
	private isInvalidPath;
	private isValidPath;
	private invalidatedCells;
	private invalidatedEdges;
	private invalidatedNodes;
	private errorCells;
	private errorEdges;
	private errorNodes;
	private eraserAnimationStartTime;
	private isFading;
	private fadeOpacity;
	private fadeColor;
	private fadingPath;
	private fadingTipPos;
	private isSuccessFading;
	private successFadeStartTime;
	private startTime;
	private offscreenCanvas;
	private offscreenCtx;
	private filterCanvas;
	private filterCtx;
	private canvasRect;
	private isDestroyed;
	private animationFrameId;
	private timeoutId;
	private boundMouseDown;
	private boundMouseMove;
	private boundMouseUp;
	private boundTouchStart;
	private boundTouchMove;
	private boundTouchEnd;
	private boundUpdateRect;
	constructor(canvasOrId: HTMLCanvasElement | OffscreenCanvas | string, puzzle?: PuzzleData, options?: WitnessUIOptions);
	/**
	 * デフォルトオプションとユーザー指定オプションをマージする
	 * @param options 指定されたオプション
	 * @returns マージ後の全オプション
	 */
	private mergeOptions;
	/**
	 * パズルデータを設定し、再描画する
	 */
	setPuzzle(puzzle: PuzzleData): void;
	/**
	 * 外部からパス（解答経路）を強制的に設定する
	 * @param path 経路の点配列
	 */
	setPath(path: Point[]): void;
	/**
	 * 表示オプションを更新する
	 */
	setOptions(options: WitnessUIOptions): void;
	/**
	 * イベントリスナーを追加する
	 */
	addEventListener<K extends WitnessEventName>(type: K, listener: (data: WitnessEventMap[K]) => void): void;
	/**
	 * イベントリスナーを削除する
	 */
	removeEventListener<K extends WitnessEventName>(type: K, listener: (data: WitnessEventMap[K]) => void): void;
	/**
	 * イベントリスナーを追加する (エイリアス)
	 */
	on<K extends WitnessEventName>(type: K, listener: (data: WitnessEventMap[K]) => void): this;
	/**
	 * イベントリスナーを削除する (エイリアス)
	 */
	off<K extends WitnessEventName>(type: K, listener: (data: WitnessEventMap[K]) => void): this;
	/**
	 * 内部イベントを発行する
	 */
	private emit;
	/**
	 * 検証結果を反映させる（不正解時の赤点滅や、消しゴムによる無効化の表示）
	 */
	setValidationResult(isValid: boolean, invalidatedCells?: Point[], invalidatedEdges?: {
		type: "h" | "v";
		r: number;
		c: number;
	}[], errorCells?: Point[], errorEdges?: {
		type: "h" | "v";
		r: number;
		c: number;
	}[], invalidatedNodes?: Point[], errorNodes?: Point[]): void;
	/**
	 * パズルのサイズに合わせてCanvasの物理サイズを調整する
	 */
	private resizeCanvas;
	/**
	 * Canvasの表示上の矩形情報を設定する（Worker時などに必要）
	 */
	setCanvasRect(rect: {
		left: number;
		top: number;
		width: number;
		height: number;
	}): void;
	/**
	 * Workerにパズル生成を依頼する (Workerモード時のみ有効)
	 */
	createPuzzle(rows: number, cols: number, genOptions: any): void;
	/**
	 * マウス・タッチイベントを初期化する
	 */
	private initEvents;
	/**
	 * イベントリスナーを解除し、リソースを解放する
	 */
	destroy(): void;
	/**
	 * グリッド座標をCanvas上のピクセル座標に変換する
	 * @param gridX グリッドX
	 * @param gridY グリッドY
	 * @returns Canvas座標
	 */
	private getCanvasCoords;
	/**
	 * 指定されたノードが出口の場合、その出っ張りの方向ベクトルを返す
	 * @param x グリッドX
	 * @param y グリッドY
	 * @returns 方向ベクトル、またはnull
	 */
	private getExitDir;
	handleStart(e: {
		clientX: number;
		clientY: number;
	}): boolean;
	private isStartNodeHit;
	handleMove(e: {
		clientX: number;
		clientY: number;
	}): void;
	handleEnd(e: {
		clientX: number;
		clientY: number;
	}): void;
	/**
	 * 二点間のエッジタイプを取得する
	 * @param p1 点1
	 * @param p2 点2
	 * @returns エッジタイプ
	 */
	private getEdgeType;
	/**
	 * パスのフェードアウトアニメーションを開始する
	 * @param color フェード時の色
	 */
	private startFade;
	/**
	 * 現在のフェードアニメーションを中止する
	 */
	private cancelFade;
	/**
	 * アニメーションループ
	 */
	private animate;
	private lastGoalReachable;
	draw(): void;
	private applyFilter;
	private prepareFilterBuffer;
	private getActiveFilterColor;
	private isNoopFilterColor;
	/**
	 * ゴール地点の波紋アニメーションを描画する
	 * @param ctx 描画コンテキスト
	 */
	private drawRipples;
	/**
	 * グリッド（背景の線）を描画する
	 * @param ctx 描画コンテキスト
	 */
	private drawGrid;
	/**
	 * 全ての制約記号（四角、星、六角形など）を描画する
	 * @param ctx 描画コンテキスト
	 */
	private drawConstraints;
	/**
	 * 単一の制約アイテムを描画（座標はキャンバス全体に対する絶対座標）
	 */
	private drawConstraintItem;
	/**
	 * 全てのノード（交点、始点、終点）を描画する
	 * @param ctx 描画コンテキスト
	 */
	private drawNodes;
	/**
	 * 解答パスを描画する（オフスクリーン合成により重なりを防止）
	 * @param ctx 描画コンテキスト
	 * @param path パス座標配列
	 * @param isDrawing 描画中かどうか
	 * @param color パスの色
	 * @param opacity 不透明度
	 * @param tipPos 先端の座標（描画中用）
	 */
	private drawPath;
	/**
	 * 解答パスの実際の描画処理
	 * @param ctx 描画コンテキスト
	 * @param path パス座標配列
	 * @param isDrawing 描画中かどうか
	 * @param color パスの色
	 * @param tipPos 先端の座標
	 */
	private drawPathInternal;
	/**
	 * 角丸長方形を描画する
	 */
	private drawRoundedRect;
	/**
	 * 六角形（通過必須マーク）を描画する
	 */
	private drawHexagon;
	/**
	 * 消しゴム（テトラポッド）を描画する
	 */
	private drawEraser;
	/**
	 * 星を描画する
	 */
	private drawStar;
	/**
	 * 三角形を描画する
	 */
	private drawTriangle;
	/**
	 * テトリスピースを描画する
	 */
	private drawTetris;
	/**
	 * Color値に対応するカラーコードを取得する
	 * @param colorEnum Color値
	 * @param defaultFallback 見つからない場合のデフォルト
	 * @returns カラーコード文字列
	 */
	private getColorCode;
	/**
	 * カラー文字列をRGBA成分に分解する
	 * @param color #hex または rgba() 文字列
	 * @returns RGBAオブジェクト
	 */
	private colorToRgba;
	/**
	 * 二つの色を線形補間する
	 * @param c1 色1
	 * @param c2 色2
	 * @param t 割合 (0.0 - 1.0)
	 * @returns 補間後の色 (rgba形式)
	 */
	private lerpColor;
	/**
	 * 色のアルファ値を上書きする
	 * @param color 元の色
	 * @param alpha 新しいアルファ値
	 * @returns 変更後の色
	 */
	private setAlpha;
	/**
	 * 指定されたパスの対称パスを生成する
	 * @param path メインパス
	 * @returns 対称パス
	 */
	private getSymmetryPath;
	/**
	 * 指定された点の対称点を取得する
	 * @param p 元の点
	 * @param isFloat 小数点座標を維持するか
	 * @returns 対称点
	 */
	private getSymmetricalPoint;
	/**
	 * 指定されたパスの先端が出口の出っ張りにあるか判定する
	 */
	private isPathAtExit;
	/**
	 * 二点間のエッジを識別するユニークなキーを取得する
	 */
	private getEdgeKey;
	/**
	 * 合成用のオフスクリーンCanvasを準備する
	 */
	/**
	 * Workerに送信できない関数などのプロパティを除去したオプションを生成する
	 */
	private sanitizeOptions;
	private prepareOffscreen;
}
export interface IRng {
	next(): number;
}
/**
 * パズルの回答を検証するクラス
 */
export declare class PuzzleValidator {
	private tetrisCache;
	private reachabilityCache;
	private rng;
	setRng(rng: IRng | null): void;
	/**
	 * 与えられたグリッドと回答パスが正当かどうかを検証する
	 * @param grid パズルのグリッドデータ
	 * @param solution 回答パス
	 * @param externalCellsPrecalculated 既知の外部セル（高速化用）
	 * @returns 検証結果（正誤、エラー理由、無効化された記号など）
	 */
	validate(grid: Grid, solution: SolutionPath, externalCellsPrecalculated?: Set<string>): ValidationResult;
	/**
	 * 高速化された検証（内部探索用）
	 * @param grid グリッド
	 * @param path メインパス
	 * @param symPath 対称パス
	 * @param externalCells 外部セルのキャッシュ
	 * @returns 検証結果
	 */
	private validateFast;
	/**
	 * 二点間が断線（Broken or Absent）しているか確認する
	 * @param grid グリッド
	 * @param p1 点1
	 * @param p2 点2
	 * @returns 断線しているかどうか
	 */
	private isBrokenEdge;
	/**
	 * 二点間が Absent（存在しない）エッジか確認する
	 * @param grid グリッド
	 * @param p1 点1
	 * @param p2 点2
	 * @returns 存在しないかどうか
	 */
	private isAbsentEdge;
	/**
	 * 回答パスが通過しなかった六角形（エッジ・ノード）をリストアップする
	 * @param grid グリッド
	 * @param path メインパス
	 * @param symPath 対称パス
	 * @returns 通過しなかった六角形のリスト
	 */
	private getMissedHexagons;
	/**
	 * テトラポッド（エラー削除）を考慮してパズルの各制約を検証する
	 * @param grid グリッド
	 * @param regions 区画リスト
	 * @param missedHexagons 通過しなかったエッジ六角形
	 * @param missedNodeHexagons 通過しなかったノード六角形
	 * @returns 検証結果
	 */
	private validateWithErasers;
	/**
	 * 指定されたエッジが特定の区画に隣接しているか確認する
	 * @param grid グリッド
	 * @param hex 六角形エッジ
	 * @param region 区画
	 * @returns 隣接しているかどうか
	 */
	private isHexagonAdjacentToRegion;
	/**
	 * 指定されたノードが特定の区画に隣接しているか確認する
	 * @param grid グリッド
	 * @param node ノード座標
	 * @param region 区画
	 * @returns 隣接しているかどうか
	 */
	private isNodeHexagonAdjacentToRegion;
	/**
	 * 区画内のエラー削除可能な全パターンを取得する
	 * @param grid グリッド
	 * @param region 区画
	 * @param erasers 消しゴムのリスト
	 * @param otherMarks 他の記号のリスト
	 * @param adjacentMissedHexagons 隣接する未通過エッジ六角形
	 * @param adjacentMissedNodeHexagons 隣接する未通過ノード六角形
	 * @returns 可能な削除パターンのリスト
	 */
	private getPossibleErasures;
	/**
	 * エラーが解消できなかった場合のベストエフォートな削除（可能な限り消しゴムを適用）を取得する
	 * @param grid グリッド
	 * @param region 区画
	 * @param erasers 消しゴムのリスト
	 * @param otherMarks 他の記号のリスト
	 * @param adjacentMissedHexagons 隣接する未通過エッジ六角形
	 * @param adjacentMissedNodeHexagons 隣接する未通過ノード六角形
	 * @returns ベストエフォートな削除結果
	 */
	private getBestEffortErasures;
	/**
	 * 配列からN個選ぶ組み合わせを取得する
	 * @param items 配列
	 * @param n 選択する数
	 * @returns 組み合わせのリスト
	 */
	private getNCombinations;
	/**
	 * 特定の削除・無効化を適用した状態で、区画内の制約が満たされているか検証する
	 * @param grid グリッド
	 * @param region 区画
	 * @param erasedCells 無効化されたセルのリスト
	 * @returns 有効かどうか
	 */
	private checkRegionValid;
	/**
	 * 区画内のエラーとなっているセルを特定する
	 * @param grid グリッド
	 * @param region 区画
	 * @param erasedCells 無効化されたセルのリスト
	 * @returns エラーセルのリスト
	 */
	private getRegionErrors;
	/**
	 * グローバルな制約（六角形）の割り当てをバックトラッキングで探索する
	 * @param regionResults 各区画の削除候補リスト
	 * @param totalMissedHexagons 合計未通過エッジ六角形数
	 * @param totalMissedNodeHexagons 合計未通過ノード六角形数
	 * @returns 成功した場合は割り当て結果、失敗した場合はnull
	 */
	private findGlobalAssignment;
	/**
	 * テトリス制約の検証
	 * 領域内の全てのテトリスピース（正・負）を盤面内に配置し、
	 * 各セルの合計値が「領域内なら1、領域外なら0」になる配置が存在するかを確認する。
	 * 重なりは許容されるが、最終的な合計がマイナスになることは許されない。
	 * また、全てのピースはパズル（グリッド）の範囲内に収まっている必要がある。
	 * @param gridObj グリッドオブジェクト
	 * @param region 区画
	 * @param pieces 正のテトリスピース
	 * @param negativePieces 負のテトリスピース
	 */
	private checkTetrisConstraint;
	private getShapeArea;
	private getShapeKey;
	/**
	 * 再帰的にタイリングを試みる
	 * @param regionGrid 領域のグリッド表現
	 * @param pieces 残りのピース
	 * @returns タイリング可能かどうか
	 */
	private getAllRotations;
	private rotate90;
	/**
	 * 回答パスによって分割された各区画のセルリストを取得する
	 * @param grid グリッド
	 * @param path メインパス
	 * @param symPath 対称パス
	 * @param externalCellsPrecalculated 外部セルのキャッシュ
	 * @returns 区画リスト
	 */
	private calculateRegions;
	/**
	 * エッジ（Absent）によって外部に繋がっているセルを特定する
	 * @param grid グリッド
	 * @returns 外部セルのセット
	 */
	private getExternalCells;
	private getSymmetricalPoint;
	private getSymmetricalPointIndex;
	private getEdgeKey;
	/**
	 * パズルの難易度スコア(0.0-1.0)を算出する
	 * @param grid グリッド
	 * @param starts 探索を開始するスタートノードのリスト（省略時は全スタートノード）
	 */
	calculateDifficulty(grid: Grid, starts?: Point[]): number;
	/**
	 * 探索空間を走査して統計情報を収集する
	 */
	private exploreSearchSpace;
	/**
	 * 正解数をカウントする
	 * @param grid グリッド
	 * @param limit カウントリミット
	 * @param starts 探索を開始するスタートノードのリスト（省略時は全スタートノード）
	 */
	countSolutions(grid: Grid, limit?: number, starts?: Point[]): number;
	private findPathsOptimized;
	/**
	 * 終端まで到達可能かビットマスクBFSで高速に確認する
	 */
	private canReachEndOptimized;
	/**
	 * パスの論理的な指紋を取得する（区画分けに基づき、同一解を排除するため）
	 */
	private getFingerprint;
}
/**
 * the witnessパズルのコア機能（生成・検証・難易度計算）を提供するメインクラス
 */
export declare class WitnessCore {
	private generator;
	private validator;
	/**
	 * インスタンスを生成する
	 */
	constructor();
	/**
	 * 指定されたサイズとオプションで新しいパズルを生成する
	 * @param rows 行数
	 * @param cols 列数
	 * @param options 生成オプション
	 * @returns 生成されたパズルデータ
	 */
	createPuzzle(rows: number, cols: number, options?: GenerationOptions): PuzzleData;
	/**
	 * 与えられたパズルデータに対して解答パスを検証する
	 * @param puzzleData パズルデータ
	 * @param solution 解答パス
	 * @returns 検証結果
	 */
	validateSolution(puzzleData: PuzzleData, solution: SolutionPath): ValidationResult;
	/**
	 * パズルデータの難易度を算出する
	 * @param puzzleData パズルデータ
	 * @returns 難易度スコア (0.0 - 1.0)
	 */
	calculateDifficulty(puzzleData: PuzzleData): number;
}

export {};
