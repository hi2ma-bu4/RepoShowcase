// Generated by dts-bundle-generator v9.5.1

export declare enum Direction {
	Up = 0,
	Right = 1,
	Down = 2,
	Left = 3
}
export declare enum CellType {
	None = 0,
	/** 色分けが必要なブロック */
	Square = 1,
	/** 同じ色のペア作成 (星) */
	Star = 2,
	/** テトリス */
	Tetris = 3,
	/** テトリス（回転可能） */
	TetrisRotated = 4,
	/** テトリス (減算) */
	TetrisNegative = 5,
	/** テトリス (減算・回転可能) */
	TetrisNegativeRotated = 6,
	/** テトラポッド (エラー削除) */
	Eraser = 7,
	/** 三角形 (通過辺数指定) */
	Triangle = 8
}
export declare enum EdgeType {
	Normal = 0,
	/** 線の真ん中で断線 (通行不可) */
	Broken = 1,
	/** そもそも分岐もなし (通行不可) */
	Absent = 2,
	/** 通過必須 (ワイルドカード) */
	Hexagon = 3,
	/** メイン線のみ通過必須 */
	HexagonMain = 4,
	/** 対称線のみ通過必須 */
	HexagonSymmetry = 5
}
export declare enum NodeType {
	Normal = 0,
	Start = 1,
	End = 2,
	/** 通過必須 (ワイルドカード) */
	Hexagon = 3,
	/** メイン線のみ通過必須 */
	HexagonMain = 4,
	/** 対称線のみ通過必須 */
	HexagonSymmetry = 5
}
export declare enum SymmetryType {
	None = 0,
	/** 左右対称 */
	Horizontal = 1,
	/** 上下対称 */
	Vertical = 2,
	/** 点対称 */
	Rotational = 3
}
/**
 * 使用可能色
 * Core内部では数値で管理し、UIで実際の色（文字列）と紐付ける
 */
export type Color = number;
export declare const Color: {
	readonly None: Color;
	readonly Black: Color;
	readonly White: Color;
	readonly Red: Color;
	readonly Blue: Color;
};
export interface Point {
	x: number;
	y: number;
}
export interface CellConstraint {
	type: CellType;
	color: Color;
	shape?: number[][];
	count?: number;
}
export interface EdgeConstraint {
	type: EdgeType;
}
export interface NodeConstraint {
	type: NodeType;
}
/**
 * パズルの静的な定義データ
 */
export interface PuzzleData {
	rows: number;
	cols: number;
	cells: CellConstraint[][];
	vEdges: EdgeConstraint[][];
	hEdges: EdgeConstraint[][];
	nodes: NodeConstraint[][];
	symmetry?: SymmetryType;
	/** パズル生成に使用された乱数シード (16進数文字列) */
	seed?: string;
}
/**
 * ユーザーの入力（回答パス）
 */
export interface SolutionPath {
	points: Point[];
}
export interface ValidationResult {
	isValid: boolean;
	errorReason?: string;
	invalidatedCells?: Point[];
	invalidatedEdges?: {
		type: "h" | "v";
		r: number;
		c: number;
	}[];
	invalidatedNodes?: Point[];
	errorCells?: Point[];
	errorEdges?: {
		type: "h" | "v";
		r: number;
		c: number;
	}[];
	errorNodes?: Point[];
	regions?: Point[][];
}
/**
 * パズル生成のオプション
 */
export interface GenerationOptions {
	useHexagons?: boolean;
	useSquares?: boolean;
	useStars?: boolean;
	useTetris?: boolean;
	useTetrisNegative?: boolean;
	useEraser?: boolean;
	useTriangles?: boolean;
	useBrokenEdges?: boolean;
	complexity?: number;
	difficulty?: number;
	pathLength?: number;
	symmetry?: SymmetryType;
	/** 四角形や星などの記号に使用可能な色のリスト。指定がない場合はデフォルト（黒・白・赤・青）が使用される。 */
	availableColors?: Color[];
	/** 各記号タイプのデフォルトカラー。指定がない場合はそれぞれの記号の標準色が使用される。
	 * キーには CellType の数値、または "Square", "Tetris" などの文字列が使用可能です。
	 */
	defaultColors?: Partial<Record<CellType | keyof typeof CellType, Color>>;
	/** パズル生成に使用する乱数シード (16進数文字列) */
	seed?: string;
	/** 使用する乱数アルゴリズム */
	rngType?: RngType;
}
export declare enum RngType {
	Mulberry32 = 0,
	XorShift128Plus = 1,
	MathRandom = 2
}
/**
 * パズルのグリッド構造と状態を管理するクラス
 */
export declare class Grid {
	/** 行数 */
	readonly rows: number;
	/** 列数 */
	readonly cols: number;
	/** セルの制約（記号）マトリクス */
	cells: CellConstraint[][];
	/** 水平エッジの制約マトリクス */
	hEdges: EdgeConstraint[][];
	/** 垂直エッジの制約マトリクス */
	vEdges: EdgeConstraint[][];
	/** ノードの制約マトリクス */
	nodes: NodeConstraint[][];
	/** 対称性の設定 (SymmetryType) */
	symmetry: number;
	/** パズル生成に使用された乱数シード (16進数文字列) */
	seed?: string;
	/**
	 * 新しいグリッドを初期化する
	 * @param rows 行数
	 * @param cols 列数
	 */
	constructor(rows: number, cols: number);
	/**
	 * グリッドの各要素を初期状態（制約なし）で生成する
	 */
	private initializeGrid;
	/**
	 * グリッドの状態を PuzzleData 形式でエクスポートする
	 * @returns パズルデータ
	 */
	export(): PuzzleData;
	/**
	 * PuzzleData から Grid インスタンスを生成する
	 * @param data パズルデータ
	 * @returns Grid インスタンス
	 */
	static fromData(data: PuzzleData): Grid;
}
/**
 * パズルを自動生成するクラス
 */
export declare class PuzzleGenerator {
	private isWorker;
	private TETRIS_SHAPES_WITH_ROTATIONS;
	private rng;
	constructor();
	private stringToSeed;
	/**
	 * パズルを生成する
	 * @param rows 行数
	 * @param cols 列数
	 * @param options 生成オプション
	 * @returns 生成されたグリッド
	 */
	generate(rows: number, cols: number, options?: GenerationOptions): Grid;
	/**
	 * 指定されたパスに基づいてパズルを構築する
	 * @param rows 行数
	 * @param cols 列数
	 * @param solutionPath 解答パス
	 * @param options 生成オプション
	 * @param precalculatedRegions 事前計算された区画
	 * @param precalculatedBoundaryEdges 事前計算された境界エッジ
	 * @returns 構築されたグリッド
	 */
	private generateFromPath;
	/**
	 * ランダムな正解パスを生成する
	 * @param targetLengthFactor 0.0 (最短) - 1.0 (最長)
	 */
	private generateRandomPath;
	/**
	 * 1本のランダムパスを生成する
	 * @param grid グリッド
	 * @param start 開始点
	 * @param end 終了点
	 * @param biasFactor 長さのバイアス
	 * @param symmetry 対称性
	 * @returns 生成されたパス
	 */
	private generateSingleRandomPath;
	private getValidNeighbors;
	/**
	 * 解パスが通っていない場所にランダムに断線（Broken/Absent）を配置する
	 * @param grid グリッド
	 * @param path 解答パス
	 * @param options 生成オプション
	 */
	private applyBrokenEdges;
	/**
	 * エッジがAbsentに変換可能か判定する
	 * @param grid グリッド
	 * @param edge 判定対象のエッジ
	 * @returns 変換可能かどうか
	 */
	private canBecomeAbsent;
	/**
	 * 到達不可能なエリアをAbsent化し、外部に漏れたセルをクリアする
	 * @param grid グリッド
	 */
	private cleanGrid;
	private getExternalCells;
	private isAdjacentToMark;
	/**
	 * マークが完全に断絶されたセルにいないか確認する
	 * @param grid グリッド
	 * @returns 孤立したマークがあるかどうか
	 */
	private hasIsolatedMark;
	private getSymmetricalPoint;
	private getEdgeKey;
	private TETRIS_SHAPES;
	/**
	 * 解パスに基づいて各区画にルールを配置する
	 * @param grid グリッド
	 * @param path 解答パス
	 * @param options 生成オプション
	 * @param symPath 対称パス
	 * @param precalculatedRegions 事前計算された区画
	 * @param precalculatedBoundaryEdges 事前計算された境界エッジ
	 */
	private applyConstraintsBasedOnPath;
	/**
	 * 区画分けを行う
	 * @param grid グリッド
	 * @param path 解答パス
	 * @param symPath 対称パス
	 * @returns 区画リスト
	 */
	private calculateRegions;
	private isAbsentEdge;
	/**
	 * 区画の境界エッジのうち、解パスが通っていないものを取得する
	 * @param grid グリッド
	 * @param region 区画
	 * @param path 解答パス
	 * @param symPath 対称パス
	 * @returns 境界エッジのリスト
	 */
	private getRegionBoundaryEdges;
	private setEdgeHexagon;
	private hasIncidentHexagonEdge;
	private isEdgeAdjacentToHexagonNode;
	/**
	 * 要求された制約が全て含まれているか確認する
	 * @param grid グリッド
	 * @param options 生成オプション
	 * @returns 全ての要求された制約が含まれているか
	 */
	private checkAllRequestedConstraintsPresent;
	/**
	 * 指定された区画をピースで埋め尽くすタイリングを生成する
	 * @param region 区画
	 * @param maxPieces 最大ピース数
	 * @param options 生成オプション
	 * @returns タイリング結果
	 */
	private generateTiling;
	/**
	 * タイリングを深さ優先探索で生成する
	 * @param regionGrid 領域のグリッド表現
	 * @param currentPieces 現在配置済みのピース
	 * @param maxPieces 最大ピース数
	 * @param options 生成オプション
	 * @returns 成功した場合はピースのリスト、失敗した場合はnull
	 */
	private tilingDfs;
	private getShapeArea;
	private isRotationallyInvariant;
	private getAllRotations;
	private rotate90;
	private canPlace;
	private placePiece;
	private isSameShape;
	private countRegionNonEraserSymbols;
	private hasRegionTetrisSymbol;
	private canPlaceGeneratedTetrisNegative;
	private canPlaceGeneratedEraser;
	private canTilePieceWith;
	private findStandardTriple;
	private shuffleArray;
}
/**
 * パズルデータと生成オプションをシリアライズ/デシリアライズするクラス
 * URL共有などのためにデータを短縮して文字列化する
 */
export declare class PuzzleSerializer {
	/**
	 * パズルデータとオプションを圧縮されたBase64文字列に変換する
	 * @param puzzle パズルデータ
	 * @param options 生成オプション
	 * @returns シリアライズされた文字列
	 */
	static serialize(puzzle: PuzzleData, options: GenerationOptions): Promise<string>;
	/**
	 * シリアライズされた文字列からパズルデータとオプションを復元する
	 * @param str シリアライズされた文字列
	 * @returns 復元されたパズルデータとオプション
	 */
	static deserialize(str: string): Promise<{
		puzzle: PuzzleData;
		options: GenerationOptions;
	}>;
}
/**
 * UI表示設定
 */
export interface WitnessUIOptions {
	/** グリッド周囲の余白 */
	gridPadding?: number;
	/** セル1辺のサイズ */
	cellSize?: number;
	/** 通常ノードの半径 */
	nodeRadius?: number;
	/** 開始ノードの半径 */
	startNodeRadius?: number;
	/** パスの太さ */
	pathWidth?: number;
	/** 出口の長さ */
	exitLength?: number;
	/** パズルのサイズに合わせてCanvasサイズを自動調整するか */
	autoResize?: boolean;
	/** 失敗時にマークを赤く点滅させるか */
	blinkMarksOnError?: boolean;
	/** 失敗時に引いた線（対称線含む）を残すか（falseの場合はフェードアウトする） */
	stayPathOnError?: boolean;
	/** パスが完了した際に自動的にバリデーションを実行するか (Workerモード時のみ有効) */
	autoValidate?: boolean;
	/** WebWorkerを使用して生成・検証を行うか */
	useWorker?: boolean;
	/** Workerスクリプトのパス (デフォルトは import.meta.url) */
	workerScript?: string;
	/** アニメーション設定 */
	animations?: {
		/** 点滅・前アニメーションの時間(ms) */
		blinkDuration: number;
		/** 無効化フェードの時間(ms) */
		fadeDuration: number;
		/** 点滅の周期(ms) */
		blinkPeriod: number;
	};
	/** 色設定 */
	colors?: {
		/** 通常のパスの色 */
		path?: string;
		/** エラー時の色 */
		error?: string;
		/** 成功時のフラッシュ/アニメーション用 */
		success?: string;
		/** 対称パスの色 */
		symmetry?: string;
		/** 途中で離した際のフェード色 */
		interrupted?: string;
		/** グリッドの色 */
		grid?: string;
		/** ノードの色 */
		node?: string;
		/** 六角形（通過必須）の色 */
		hexagon?: string;
		/** メイン線のみの六角形の色 */
		hexagonMain?: string;
		/** 対称線のみの六角形の色 */
		hexagonSymmetry?: string;
		/** 各色のカラーコードマップ */
		colorMap?: Record<number, string>;
		/** 各色のカラーコードリスト（インデックスがColor値に対応） */
		colorList?: string[];
	};
	/** パスが完了（出口に到達）した際のコールバック */
	onPathComplete?: (path: Point[]) => void;
	/** パズルが生成された際のコールバック (Workerモード時のみ有効) */
	onPuzzleCreated?: (payload: {
		puzzle: PuzzleData;
		genOptions: any;
	}) => void;
	/** バリデーション結果が返ってきた際のコールバック (Workerモード時のみ有効) */
	onValidationResult?: (result: ValidationResult) => void;
}
/**
 * the witnessパズルの描画とユーザー操作を管理するクラス
 */
export declare class WitnessUI {
	private canvas;
	private ctx;
	private worker;
	private puzzle;
	private options;
	private path;
	private isDrawing;
	private currentMousePos;
	private exitTipPos;
	private isInvalidPath;
	private invalidatedCells;
	private invalidatedEdges;
	private invalidatedNodes;
	private errorCells;
	private errorEdges;
	private errorNodes;
	private eraserAnimationStartTime;
	private isFading;
	private fadeOpacity;
	private fadeColor;
	private fadingPath;
	private fadingTipPos;
	private isSuccessFading;
	private successFadeStartTime;
	private startTime;
	private offscreenCanvas;
	private offscreenCtx;
	private canvasRect;
	private isDestroyed;
	private animationFrameId;
	private timeoutId;
	private boundMouseDown;
	private boundMouseMove;
	private boundMouseUp;
	private boundTouchStart;
	private boundTouchMove;
	private boundTouchEnd;
	private boundUpdateRect;
	constructor(canvasOrId: HTMLCanvasElement | OffscreenCanvas | string, puzzle?: PuzzleData, options?: WitnessUIOptions);
	/**
	 * デフォルトオプションとユーザー指定オプションをマージする
	 * @param options 指定されたオプション
	 * @returns マージ後の全オプション
	 */
	private mergeOptions;
	/**
	 * パズルデータを設定し、再描画する
	 */
	setPuzzle(puzzle: PuzzleData): void;
	/**
	 * 表示オプションを更新する
	 */
	setOptions(options: WitnessUIOptions): void;
	/**
	 * 検証結果を反映させる（不正解時の赤点滅や、消しゴムによる無効化の表示）
	 */
	setValidationResult(isValid: boolean, invalidatedCells?: Point[], invalidatedEdges?: {
		type: "h" | "v";
		r: number;
		c: number;
	}[], errorCells?: Point[], errorEdges?: {
		type: "h" | "v";
		r: number;
		c: number;
	}[], invalidatedNodes?: Point[], errorNodes?: Point[]): void;
	/**
	 * パズルのサイズに合わせてCanvasの物理サイズを調整する
	 */
	private resizeCanvas;
	/**
	 * Canvasの表示上の矩形情報を設定する（Worker時などに必要）
	 */
	setCanvasRect(rect: {
		left: number;
		top: number;
		width: number;
		height: number;
	}): void;
	/**
	 * Workerにパズル生成を依頼する (Workerモード時のみ有効)
	 */
	createPuzzle(rows: number, cols: number, genOptions: any): void;
	/**
	 * マウス・タッチイベントを初期化する
	 */
	private initEvents;
	/**
	 * イベントリスナーを解除し、リソースを解放する
	 */
	destroy(): void;
	/**
	 * グリッド座標をCanvas上のピクセル座標に変換する
	 * @param gridX グリッドX
	 * @param gridY グリッドY
	 * @returns Canvas座標
	 */
	private getCanvasCoords;
	/**
	 * 指定されたノードが出口の場合、その出っ張りの方向ベクトルを返す
	 * @param x グリッドX
	 * @param y グリッドY
	 * @returns 方向ベクトル、またはnull
	 */
	private getExitDir;
	handleStart(e: {
		clientX: number;
		clientY: number;
	}): boolean;
	handleMove(e: {
		clientX: number;
		clientY: number;
	}): void;
	handleEnd(e: {
		clientX: number;
		clientY: number;
	}): void;
	/**
	 * 二点間のエッジタイプを取得する
	 * @param p1 点1
	 * @param p2 点2
	 * @returns エッジタイプ
	 */
	private getEdgeType;
	/**
	 * パスのフェードアウトアニメーションを開始する
	 * @param color フェード時の色
	 */
	private startFade;
	/**
	 * 現在のフェードアニメーションを中止する
	 */
	private cancelFade;
	/**
	 * アニメーションループ
	 */
	private animate;
	draw(): void;
	/**
	 * ゴール地点の波紋アニメーションを描画する
	 * @param ctx 描画コンテキスト
	 */
	private drawRipples;
	/**
	 * グリッド（背景の線）を描画する
	 * @param ctx 描画コンテキスト
	 */
	private drawGrid;
	/**
	 * 全ての制約記号（四角、星、六角形など）を描画する
	 * @param ctx 描画コンテキスト
	 */
	private drawConstraints;
	/**
	 * 単一の制約アイテムを描画（座標はキャンバス全体に対する絶対座標）
	 */
	private drawConstraintItem;
	/**
	 * 全てのノード（交点、始点、終点）を描画する
	 * @param ctx 描画コンテキスト
	 */
	private drawNodes;
	/**
	 * 解答パスを描画する（オフスクリーン合成により重なりを防止）
	 * @param ctx 描画コンテキスト
	 * @param path パス座標配列
	 * @param isDrawing 描画中かどうか
	 * @param color パスの色
	 * @param opacity 不透明度
	 * @param tipPos 先端の座標（描画中用）
	 */
	private drawPath;
	/**
	 * 解答パスの実際の描画処理
	 * @param ctx 描画コンテキスト
	 * @param path パス座標配列
	 * @param isDrawing 描画中かどうか
	 * @param color パスの色
	 * @param tipPos 先端の座標
	 */
	private drawPathInternal;
	/**
	 * 角丸長方形を描画する
	 */
	private drawRoundedRect;
	/**
	 * 六角形（通過必須マーク）を描画する
	 */
	private drawHexagon;
	/**
	 * 消しゴム（テトラポッド）を描画する
	 */
	private drawEraser;
	/**
	 * 星を描画する
	 */
	private drawStar;
	/**
	 * 三角形を描画する
	 */
	private drawTriangle;
	/**
	 * テトリスピースを描画する
	 */
	private drawTetris;
	/**
	 * Color値に対応するカラーコードを取得する
	 * @param colorEnum Color値
	 * @param defaultFallback 見つからない場合のデフォルト
	 * @returns カラーコード文字列
	 */
	private getColorCode;
	/**
	 * カラー文字列をRGBA成分に分解する
	 * @param color #hex または rgba() 文字列
	 * @returns RGBAオブジェクト
	 */
	private colorToRgba;
	/**
	 * 二つの色を線形補間する
	 * @param c1 色1
	 * @param c2 色2
	 * @param t 割合 (0.0 - 1.0)
	 * @returns 補間後の色 (rgba形式)
	 */
	private lerpColor;
	/**
	 * 色のアルファ値を上書きする
	 * @param color 元の色
	 * @param alpha 新しいアルファ値
	 * @returns 変更後の色
	 */
	private setAlpha;
	/**
	 * 指定されたパスの対称パスを生成する
	 * @param path メインパス
	 * @returns 対称パス
	 */
	private getSymmetryPath;
	/**
	 * 指定された点の対称点を取得する
	 * @param p 元の点
	 * @param isFloat 小数点座標を維持するか
	 * @returns 対称点
	 */
	private getSymmetricalPoint;
	/**
	 * 指定されたパスの先端が出口の出っ張りにあるか判定する
	 */
	private isPathAtExit;
	/**
	 * 二点間のエッジを識別するユニークなキーを取得する
	 */
	private getEdgeKey;
	/**
	 * 合成用のオフスクリーンCanvasを準備する
	 */
	/**
	 * Workerに送信できない関数などのプロパティを除去したオプションを生成する
	 */
	private sanitizeOptions;
	private prepareOffscreen;
}
export interface IRng {
	next(): number;
}
/**
 * パズルの回答を検証するクラス
 */
export declare class PuzzleValidator {
	private tetrisCache;
	private rng;
	setRng(rng: IRng | null): void;
	/**
	 * 与えられたグリッドと回答パスが正当かどうかを検証する
	 * @param grid パズルのグリッドデータ
	 * @param solution 回答パス
	 * @param externalCellsPrecalculated 既知の外部セル（高速化用）
	 * @returns 検証結果（正誤、エラー理由、無効化された記号など）
	 */
	validate(grid: Grid, solution: SolutionPath, externalCellsPrecalculated?: Set<string>): ValidationResult;
	/**
	 * 高速化された検証（内部探索用）
	 * @param grid グリッド
	 * @param path メインパス
	 * @param symPath 対称パス
	 * @param externalCells 外部セルのキャッシュ
	 * @returns 検証結果
	 */
	private validateFast;
	/**
	 * 二点間が断線（Broken or Absent）しているか確認する
	 * @param grid グリッド
	 * @param p1 点1
	 * @param p2 点2
	 * @returns 断線しているかどうか
	 */
	private isBrokenEdge;
	/**
	 * 二点間が Absent（存在しない）エッジか確認する
	 * @param grid グリッド
	 * @param p1 点1
	 * @param p2 点2
	 * @returns 存在しないかどうか
	 */
	private isAbsentEdge;
	/**
	 * 回答パスが通過しなかった六角形（エッジ・ノード）をリストアップする
	 * @param grid グリッド
	 * @param path メインパス
	 * @param symPath 対称パス
	 * @returns 通過しなかった六角形のリスト
	 */
	private getMissedHexagons;
	/**
	 * テトラポッド（エラー削除）を考慮してパズルの各制約を検証する
	 * @param grid グリッド
	 * @param regions 区画リスト
	 * @param missedHexagons 通過しなかったエッジ六角形
	 * @param missedNodeHexagons 通過しなかったノード六角形
	 * @returns 検証結果
	 */
	private validateWithErasers;
	/**
	 * 指定されたエッジが特定の区画に隣接しているか確認する
	 * @param grid グリッド
	 * @param hex 六角形エッジ
	 * @param region 区画
	 * @returns 隣接しているかどうか
	 */
	private isHexagonAdjacentToRegion;
	/**
	 * 指定されたノードが特定の区画に隣接しているか確認する
	 * @param grid グリッド
	 * @param node ノード座標
	 * @param region 区画
	 * @returns 隣接しているかどうか
	 */
	private isNodeHexagonAdjacentToRegion;
	/**
	 * 区画内のエラー削除可能な全パターンを取得する
	 * @param grid グリッド
	 * @param region 区画
	 * @param erasers 消しゴムのリスト
	 * @param otherMarks 他の記号のリスト
	 * @param adjacentMissedHexagons 隣接する未通過エッジ六角形
	 * @param adjacentMissedNodeHexagons 隣接する未通過ノード六角形
	 * @returns 可能な削除パターンのリスト
	 */
	private getPossibleErasures;
	/**
	 * エラーが解消できなかった場合のベストエフォートな削除（可能な限り消しゴムを適用）を取得する
	 * @param grid グリッド
	 * @param region 区画
	 * @param erasers 消しゴムのリスト
	 * @param otherMarks 他の記号のリスト
	 * @param adjacentMissedHexagons 隣接する未通過エッジ六角形
	 * @param adjacentMissedNodeHexagons 隣接する未通過ノード六角形
	 * @returns ベストエフォートな削除結果
	 */
	private getBestEffortErasures;
	/**
	 * 配列からN個選ぶ組み合わせを取得する
	 * @param items 配列
	 * @param n 選択する数
	 * @returns 組み合わせのリスト
	 */
	private getNCombinations;
	/**
	 * 特定の削除・無効化を適用した状態で、区画内の制約が満たされているか検証する
	 * @param grid グリッド
	 * @param region 区画
	 * @param erasedCells 無効化されたセルのリスト
	 * @returns 有効かどうか
	 */
	private checkRegionValid;
	/**
	 * 区画内のエラーとなっているセルを特定する
	 * @param grid グリッド
	 * @param region 区画
	 * @param erasedCells 無効化されたセルのリスト
	 * @returns エラーセルのリスト
	 */
	private getRegionErrors;
	/**
	 * グローバルな制約（六角形）の割り当てをバックトラッキングで探索する
	 * @param regionResults 各区画の削除候補リスト
	 * @param totalMissedHexagons 合計未通過エッジ六角形数
	 * @param totalMissedNodeHexagons 合計未通過ノード六角形数
	 * @returns 成功した場合は割り当て結果、失敗した場合はnull
	 */
	private findGlobalAssignment;
	/**
	 * テトリス制約の検証
	 * 領域内の全てのテトリスピース（正・負）を盤面内に配置し、
	 * 各セルの合計値が「領域内なら1、領域外なら0」になる配置が存在するかを確認する。
	 * 重なりは許容されるが、最終的な合計がマイナスになることは許されない。
	 * また、全てのピースはパズル（グリッド）の範囲内に収まっている必要がある。
	 * @param gridObj グリッドオブジェクト
	 * @param region 区画
	 * @param pieces 正のテトリスピース
	 * @param negativePieces 負のテトリスピース
	 */
	private checkTetrisConstraint;
	private getShapeArea;
	private getShapeKey;
	/**
	 * 再帰的にタイリングを試みる
	 * @param regionGrid 領域のグリッド表現
	 * @param pieces 残りのピース
	 * @returns タイリング可能かどうか
	 */
	private getAllRotations;
	private rotate90;
	/**
	 * 回答パスによって分割された各区画のセルリストを取得する
	 * @param grid グリッド
	 * @param path メインパス
	 * @param symPath 対称パス
	 * @param externalCellsPrecalculated 外部セルのキャッシュ
	 * @returns 区画リスト
	 */
	private calculateRegions;
	/**
	 * エッジ（Absent）によって外部に繋がっているセルを特定する
	 * @param grid グリッド
	 * @returns 外部セルのセット
	 */
	private getExternalCells;
	private getSymmetricalPoint;
	private getSymmetricalPointIndex;
	private getEdgeKey;
	/**
	 * パズルの難易度スコア(0.0-1.0)を算出する
	 */
	calculateDifficulty(grid: Grid): number;
	/**
	 * 探索空間を走査して統計情報を収集する
	 */
	private exploreSearchSpace;
	/**
	 * 正解数をカウントする
	 */
	countSolutions(grid: Grid, limit?: number): number;
	private findPathsOptimized;
	/**
	 * 終端まで到達可能かビットマスクBFSで高速に確認する
	 */
	private canReachEndOptimized;
	/**
	 * パスの論理的な指紋を取得する（区画分けに基づき、同一解を排除するため）
	 */
	private getFingerprint;
}
/**
 * the witnessパズルのコア機能（生成・検証・難易度計算）を提供するメインクラス
 */
export declare class WitnessCore {
	private generator;
	private validator;
	/**
	 * インスタンスを生成する
	 */
	constructor();
	/**
	 * 指定されたサイズとオプションで新しいパズルを生成する
	 * @param rows 行数
	 * @param cols 列数
	 * @param options 生成オプション
	 * @returns 生成されたパズルデータ
	 */
	createPuzzle(rows: number, cols: number, options?: GenerationOptions): PuzzleData;
	/**
	 * 与えられたパズルデータに対して解答パスを検証する
	 * @param puzzleData パズルデータ
	 * @param solution 解答パス
	 * @returns 検証結果
	 */
	validateSolution(puzzleData: PuzzleData, solution: SolutionPath): ValidationResult;
	/**
	 * パズルデータの難易度を算出する
	 * @param puzzleData パズルデータ
	 * @returns 難易度スコア (0.0 - 1.0)
	 */
	calculateDifficulty(puzzleData: PuzzleData): number;
}

export {};
