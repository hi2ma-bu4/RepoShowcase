// Generated by dts-bundle-generator v9.5.1

export declare enum Direction {
	Up = 0,
	Right = 1,
	Down = 2,
	Left = 3
}
export declare enum CellType {
	None = 0,
	Square = 1,// 色分けが必要なブロック
	Star = 2,// 同じ色のペア作成 (星)
	Tetris = 3,// テトリス
	TetrisRotated = 4,// テトリス（回転可能）
	Eraser = 5
}
export declare enum EdgeType {
	Normal = 0,
	Broken = 1,// 線の真ん中で断線 (通行不可)
	Absent = 2,// そもそも分岐もなし (通行不可)
	Hexagon = 3
}
export declare enum NodeType {
	Normal = 0,
	Start = 1,
	End = 2,
	Hexagon = 3
}
export declare enum SymmetryType {
	None = 0,
	Horizontal = 1,// 左右対称
	Vertical = 2,// 上下対称
	Rotational = 3
}
/**
 * 使用可能色
 * Core内部では数値で管理し、UIで実際の色（文字列）と紐付ける
 */
export type Color = number;
export declare const Color: {
	readonly None: Color;
	readonly Black: Color;
	readonly White: Color;
	readonly Red: Color;
	readonly Blue: Color;
};
export interface Point {
	x: number;
	y: number;
}
export interface CellConstraint {
	type: CellType;
	color: Color;
	shape?: number[][];
}
export interface EdgeConstraint {
	type: EdgeType;
}
export interface NodeConstraint {
	type: NodeType;
}
/**
 * パズルの静的な定義データ
 */
export interface PuzzleData {
	rows: number;
	cols: number;
	cells: CellConstraint[][];
	vEdges: EdgeConstraint[][];
	hEdges: EdgeConstraint[][];
	nodes: NodeConstraint[][];
	symmetry?: SymmetryType;
}
/**
 * ユーザーの入力（回答パス）
 */
export interface SolutionPath {
	points: Point[];
}
export interface ValidationResult {
	isValid: boolean;
	errorReason?: string;
	invalidatedCells?: Point[];
	invalidatedEdges?: {
		type: "h" | "v";
		r: number;
		c: number;
	}[];
	invalidatedNodes?: Point[];
	errorCells?: Point[];
	errorEdges?: {
		type: "h" | "v";
		r: number;
		c: number;
	}[];
	errorNodes?: Point[];
	regions?: Point[][];
}
/**
 * パズル生成のオプション
 */
export interface GenerationOptions {
	useHexagons?: boolean;
	useSquares?: boolean;
	useStars?: boolean;
	useTetris?: boolean;
	useEraser?: boolean;
	useBrokenEdges?: boolean;
	complexity?: number;
	difficulty?: number;
	pathLength?: number;
	symmetry?: SymmetryType;
	/** 四角形や星などの記号に使用可能な色のリスト。指定がない場合はデフォルト（黒・白・赤・青）が使用される。 */
	availableColors?: Color[];
	/** 各記号タイプのデフォルトカラー。指定がない場合はそれぞれの記号の標準色が使用される。
	 * キーには CellType の数値、または "Square", "Tetris" などの文字列が使用可能です。
	 */
	defaultColors?: Partial<Record<CellType | keyof typeof CellType, Color>>;
}
export declare class Grid {
	readonly rows: number;
	readonly cols: number;
	cells: CellConstraint[][];
	hEdges: EdgeConstraint[][];
	vEdges: EdgeConstraint[][];
	nodes: NodeConstraint[][];
	symmetry: number;
	constructor(rows: number, cols: number);
	private initializeGrid;
	export(): PuzzleData;
	static fromData(data: PuzzleData): Grid;
}
/**
 * パズルを自動生成するクラス
 */
export declare class PuzzleGenerator {
	private isWorker;
	constructor();
	/**
	 * パズルを生成する
	 * @param rows 行数
	 * @param cols 列数
	 * @param options 生成オプション
	 * @returns 生成されたグリッド
	 */
	generate(rows: number, cols: number, options?: GenerationOptions): Grid;
	/**
	 * 指定されたパスに基づいてパズルを構築する
	 */
	private generateFromPath;
	/**
	 * ランダムな正解パスを生成する
	 * @param targetLengthFactor 0.0 (最短) - 1.0 (最長)
	 */
	private generateRandomPath;
	/**
	 * 1本のランダムパスを生成する
	 */
	private generateSingleRandomPath;
	private getValidNeighbors;
	/**
	 * 解パスが通っていない場所にランダムに断線（Broken/Absent）を配置する
	 */
	private applyBrokenEdges;
	/**
	 * エッジがAbsentに変換可能か判定する
	 */
	private canBecomeAbsent;
	/**
	 * 到達不可能なエリアをAbsent化し、外部に漏れたセルをクリアする
	 */
	private cleanGrid;
	private getExternalCells;
	private isAdjacentToMark;
	/**
	 * マークが完全に断絶されたセルにいないか確認する
	 */
	private hasIsolatedMark;
	private getSymmetricalPoint;
	private getEdgeKey;
	private TETRIS_SHAPES;
	/**
	 * 解パスに基づいて各区画にルールを配置する
	 */
	private applyConstraintsBasedOnPath;
	/**
	 * 区画分けを行う
	 */
	private calculateRegions;
	private isAbsentEdge;
	/**
	 * 区画の境界エッジのうち、解パスが通っていないものを取得する
	 */
	private getRegionBoundaryEdges;
	private setEdgeHexagon;
	private hasIncidentHexagonEdge;
	private isEdgeAdjacentToHexagonNode;
	/**
	 * 要求された制約が全て含まれているか確認する
	 */
	private checkAllRequestedConstraintsPresent;
	/**
	 * 指定された区画をピースで埋め尽くすタイリングを生成する
	 */
	private generateTiling;
	/**
	 * タイリングを深さ優先探索で生成する
	 */
	private tilingDfs;
	private getShapeArea;
	private isRotationallyInvariant;
	private getAllRotations;
	private rotate90;
	private canPlace;
	private placePiece;
	private shuffleArray;
}
export declare class PuzzleSerializer {
	static serialize(puzzle: PuzzleData, options: GenerationOptions): Promise<string>;
	static deserialize(str: string): Promise<{
		puzzle: PuzzleData;
		options: GenerationOptions;
	}>;
}
/**
 * UI表示設定
 */
export interface WitnessUIOptions {
	/** グリッド周囲の余白 */
	gridPadding?: number;
	/** セル1辺のサイズ */
	cellSize?: number;
	/** 通常ノードの半径 */
	nodeRadius?: number;
	/** 開始ノードの半径 */
	startNodeRadius?: number;
	/** パスの太さ */
	pathWidth?: number;
	/** 出口の長さ */
	exitLength?: number;
	/** パズルのサイズに合わせてCanvasサイズを自動調整するか */
	autoResize?: boolean;
	/** アニメーション設定 */
	animations?: {
		/** 点滅・前アニメーションの時間(ms) */
		blinkDuration: number;
		/** 無効化フェードの時間(ms) */
		fadeDuration: number;
		/** 点滅の周期(ms) */
		blinkPeriod: number;
	};
	/** 色設定 */
	colors?: {
		/** 通常のパスの色 */
		path?: string;
		/** エラー時の色 */
		error?: string;
		/** 成功時のフラッシュ/アニメーション用 */
		success?: string;
		/** 対称パスの色 */
		symmetry?: string;
		/** 途中で離した際のフェード色 */
		interrupted?: string;
		/** グリッドの色 */
		grid?: string;
		/** ノードの色 */
		node?: string;
		/** 六角形（通過必須）の色 */
		hexagon?: string;
		/** 各色のカラーコードマップ */
		colorMap?: Record<number, string>;
		/** 各色のカラーコードリスト（インデックスがColor値に対応） */
		colorList?: string[];
	};
	/** パスが完了（出口に到達）した際のコールバック */
	onPathComplete?: (path: Point[]) => void;
}
/**
 * the witnessパズルの描画とユーザー操作を管理するクラス
 */
export declare class WitnessUI {
	private canvas;
	private ctx;
	private puzzle;
	private options;
	private path;
	private isDrawing;
	private currentMousePos;
	private exitTipPos;
	private isInvalidPath;
	private invalidatedCells;
	private invalidatedEdges;
	private invalidatedNodes;
	private errorCells;
	private errorEdges;
	private errorNodes;
	private eraserAnimationStartTime;
	private isFading;
	private fadeOpacity;
	private fadeColor;
	private fadingPath;
	private fadingTipPos;
	private isSuccessFading;
	private successFadeStartTime;
	private startTime;
	private offscreenCanvas;
	private offscreenCtx;
	private canvasRect;
	constructor(canvasOrId: HTMLCanvasElement | OffscreenCanvas | string, puzzle?: PuzzleData, options?: WitnessUIOptions);
	private mergeOptions;
	/**
	 * パズルデータを設定し、再描画する
	 */
	setPuzzle(puzzle: PuzzleData): void;
	/**
	 * 表示オプションを更新する
	 */
	setOptions(options: WitnessUIOptions): void;
	/**
	 * 検証結果を反映させる（不正解時の赤点滅や、消しゴムによる無効化の表示）
	 */
	setValidationResult(isValid: boolean, invalidatedCells?: Point[], invalidatedEdges?: {
		type: "h" | "v";
		r: number;
		c: number;
	}[], errorCells?: Point[], errorEdges?: {
		type: "h" | "v";
		r: number;
		c: number;
	}[], invalidatedNodes?: Point[], errorNodes?: Point[]): void;
	private resizeCanvas;
	/**
	 * Canvasの表示上の矩形情報を設定する（Worker時などに必要）
	 */
	setCanvasRect(rect: {
		left: number;
		top: number;
		width: number;
		height: number;
	}): void;
	private initEvents;
	private getCanvasCoords;
	private getExitDir;
	handleStart(e: {
		clientX: number;
		clientY: number;
	}): boolean;
	handleMove(e: {
		clientX: number;
		clientY: number;
	}): void;
	handleEnd(e: {
		clientX: number;
		clientY: number;
	}): void;
	private getEdgeType;
	private startFade;
	private cancelFade;
	private animate;
	draw(): void;
	private drawRipples;
	private drawGrid;
	private drawConstraints;
	/**
	 * 単一の制約アイテムを描画（座標はキャンバス全体に対する絶対座標）
	 */
	private drawConstraintItem;
	private drawNodes;
	private drawPath;
	private drawPathInternal;
	private drawRoundedRect;
	private drawHexagon;
	private drawEraser;
	private drawStar;
	private drawTetris;
	private getColorCode;
	private colorToRgba;
	private lerpColor;
	private setAlpha;
	private getSymmetryPath;
	private getSymmetricalPoint;
	private getEdgeKey;
	private prepareOffscreen;
}
/**
 * パズルの回答を検証するクラス
 */
export declare class PuzzleValidator {
	/**
	 * 与えられたグリッドと回答パスが正当かどうかを検証する
	 * @param grid パズルのグリッドデータ
	 * @param solution 回答パス
	 * @param externalCellsPrecalculated 既知の外部セル（高速化用）
	 * @returns 検証結果（正誤、エラー理由、無効化された記号など）
	 */
	validate(grid: Grid, solution: SolutionPath, externalCellsPrecalculated?: Set<string>): ValidationResult;
	/**
	 * 高速化された検証（内部探索用）
	 */
	private validateFast;
	/**
	 * 二点間が断線（Broken or Absent）しているか確認する
	 */
	private isBrokenEdge;
	/**
	 * 二点間が Absent（存在しない）エッジか確認する
	 */
	private isAbsentEdge;
	/**
	 * 回答パスが通過しなかった六角形（エッジ・ノード）をリストアップする
	 */
	private getMissedHexagons;
	/**
	 * テトラポッド（エラー削除）を考慮してパズルの各制約を検証する
	 */
	private validateWithErasers;
	/**
	 * 指定されたエッジが特定の区画に隣接しているか確認する
	 */
	private isHexagonAdjacentToRegion;
	/**
	 * 指定されたノードが特定の区画に隣接しているか確認する
	 */
	private isNodeHexagonAdjacentToRegion;
	/**
	 * 区画内のエラー削除可能な全パターンを取得する
	 */
	private getPossibleErasures;
	/**
	 * エラーが解消できなかった場合のベストエフォートな削除（可能な限り消しゴムを適用）を取得する
	 */
	private getBestEffortErasures;
	/**
	 * 配列からN個選ぶ組み合わせを取得する
	 */
	private getNCombinations;
	/**
	 * 特定の削除・無効化を適用した状態で、区画内の制約が満たされているか検証する
	 */
	private checkRegionValid;
	/**
	 * 区画内のエラーとなっているセルを特定する
	 */
	private getRegionErrors;
	/**
	 * グローバルな制約（六角形）の割り当てをバックトラッキングで探索する
	 */
	private findGlobalAssignment;
	/**
	 * テトリス制約の検証（指定された領域をピースで埋め尽くせるか）
	 */
	private checkTetrisConstraint;
	private getShapeArea;
	/**
	 * 再帰的にタイリングを試みる
	 */
	private canTile;
	private canPlace;
	private placePiece;
	private getAllRotations;
	private rotate90;
	/**
	 * 回答パスによって分割された各区画のセルリストを取得する
	 */
	private calculateRegions;
	/**
	 * エッジ（Absent）によって外部に繋がっているセルを特定する
	 */
	private getExternalCells;
	private getSymmetricalPoint;
	private getSymmetricalPointIndex;
	private getEdgeKey;
	/**
	 * パズルの難易度スコア(0.0-1.0)を算出する
	 */
	calculateDifficulty(grid: Grid): number;
	/**
	 * 探索空間を走査して統計情報を収集する
	 */
	private exploreSearchSpace;
	/**
	 * 正解数をカウントする
	 */
	countSolutions(grid: Grid, limit?: number): number;
	private findPathsOptimized;
	/**
	 * 終端まで到達可能かビットマスクBFSで高速に確認する
	 */
	private canReachEndOptimized;
	/**
	 * パスの論理的な指紋を取得する（区画分けに基づき、同一解を排除するため）
	 */
	private getFingerprint;
}
export declare class WitnessCore {
	private generator;
	private validator;
	constructor();
	/**
	 * 新しいパズルを生成してデータを返す
	 */
	createPuzzle(rows: number, cols: number, options?: GenerationOptions): PuzzleData;
	/**
	 * 解答を検証する
	 */
	validateSolution(puzzleData: PuzzleData, solution: SolutionPath): ValidationResult;
	/**
	 * パズルの難易度を計算する
	 */
	calculateDifficulty(puzzleData: PuzzleData): number;
}

export {};
