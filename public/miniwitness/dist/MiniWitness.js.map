{
  "version": 3,
  "sources": ["../src/types.ts", "../src/grid.ts", "../src/validator.ts", "../src/generator.ts", "../src/serializer.ts", "../src/ui.ts", "../src/index.ts"],
  "sourcesContent": ["export enum Direction {\n\tUp = 0,\n\tRight = 1,\n\tDown = 2,\n\tLeft = 3,\n}\n\nexport enum CellType {\n\tNone = 0,\n\tSquare = 1, // \u8272\u5206\u3051\u304C\u5FC5\u8981\u306A\u30D6\u30ED\u30C3\u30AF\n\tStar = 2, // \u540C\u3058\u8272\u306E\u30DA\u30A2\u4F5C\u6210 (\u661F)\n\tTetris = 3, // \u30C6\u30C8\u30EA\u30B9\n\tTetrisRotated = 4, // \u30C6\u30C8\u30EA\u30B9\uFF08\u56DE\u8EE2\u53EF\u80FD\uFF09\n\tEraser = 5, // \u30C6\u30C8\u30E9\u30DD\u30C3\u30C9 (\u30A8\u30E9\u30FC\u524A\u9664)\n}\n\nexport enum EdgeType {\n\tNormal = 0,\n\tBroken = 1, // \u7DDA\u306E\u771F\u3093\u4E2D\u3067\u65AD\u7DDA (\u901A\u884C\u4E0D\u53EF)\n\tAbsent = 2, // \u305D\u3082\u305D\u3082\u5206\u5C90\u3082\u306A\u3057 (\u901A\u884C\u4E0D\u53EF)\n\tHexagon = 3, // \u901A\u904E\u5FC5\u9808\n}\n\nexport enum NodeType {\n\tNormal = 0,\n\tStart = 1,\n\tEnd = 2,\n\tHexagon = 3, // \u901A\u904E\u5FC5\u9808\n}\n\nexport enum SymmetryType {\n\tNone = 0,\n\tHorizontal = 1, // \u5DE6\u53F3\u5BFE\u79F0\n\tVertical = 2, // \u4E0A\u4E0B\u5BFE\u79F0\n\tRotational = 3, // \u70B9\u5BFE\u79F0\n}\n\n/**\n * \u4F7F\u7528\u53EF\u80FD\u8272\n * Core\u5185\u90E8\u3067\u306F\u6570\u5024\u3067\u7BA1\u7406\u3057\u3001UI\u3067\u5B9F\u969B\u306E\u8272\uFF08\u6587\u5B57\u5217\uFF09\u3068\u7D10\u4ED8\u3051\u308B\n */\nexport type Color = number;\nexport const Color = {\n\tNone: 0 as Color,\n\tBlack: 1 as Color,\n\tWhite: 2 as Color,\n\tRed: 3 as Color,\n\tBlue: 4 as Color,\n} as const;\n\nexport interface Point {\n\tx: number;\n\ty: number;\n}\n\nexport interface CellConstraint {\n\ttype: CellType;\n\tcolor: Color;\n\tshape?: number[][]; // [row][col] 0 or 1\n}\n\nexport interface EdgeConstraint {\n\ttype: EdgeType;\n}\n\nexport interface NodeConstraint {\n\ttype: NodeType;\n}\n\n/**\n * \u30D1\u30BA\u30EB\u306E\u9759\u7684\u306A\u5B9A\u7FA9\u30C7\u30FC\u30BF\n */\nexport interface PuzzleData {\n\trows: number;\n\tcols: number;\n\tcells: CellConstraint[][]; // [row][col]\n\tvEdges: EdgeConstraint[][]; // Vertical edges [row][col] (row: 0..rows-1, col: 0..cols)\n\thEdges: EdgeConstraint[][]; // Horizontal edges [row][col] (row: 0..rows, col: 0..cols-1)\n\tnodes: NodeConstraint[][]; // [row][col]\n\tsymmetry?: SymmetryType;\n}\n\n/**\n * \u30E6\u30FC\u30B6\u30FC\u306E\u5165\u529B\uFF08\u56DE\u7B54\u30D1\u30B9\uFF09\n */\nexport interface SolutionPath {\n\tpoints: Point[]; // \u901A\u904E\u3057\u305F\u30CE\u30FC\u30C9\u306E\u5EA7\u6A19\u914D\u5217\n}\n\nexport interface ValidationResult {\n\tisValid: boolean;\n\terrorReason?: string;\n\tinvalidatedCells?: Point[];\n\tinvalidatedEdges?: { type: \"h\" | \"v\"; r: number; c: number }[];\n\tinvalidatedNodes?: Point[];\n\terrorCells?: Point[];\n\terrorEdges?: { type: \"h\" | \"v\"; r: number; c: number }[];\n\terrorNodes?: Point[];\n\tregions?: Point[][];\n}\n\n/**\n * \u30D1\u30BA\u30EB\u751F\u6210\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\n */\nexport interface GenerationOptions {\n\tuseHexagons?: boolean;\n\tuseSquares?: boolean;\n\tuseStars?: boolean;\n\tuseTetris?: boolean;\n\tuseEraser?: boolean;\n\tuseBrokenEdges?: boolean;\n\tcomplexity?: number; // 0.0 - 1.0 (\u5236\u7D04\u306E\u5BC6\u5EA6)\n\tdifficulty?: number; // 0.0 (Easy) - 1.0 (Hard) (\u89E3\u30D1\u30BF\u30FC\u30F3\u306E\u6570\u306B\u57FA\u3065\u304F)\n\tpathLength?: number; // 0.0 (Shortest) - 1.0 (Longest)\n\tsymmetry?: SymmetryType;\n\t/** \u56DB\u89D2\u5F62\u3084\u661F\u306A\u3069\u306E\u8A18\u53F7\u306B\u4F7F\u7528\u53EF\u80FD\u306A\u8272\u306E\u30EA\u30B9\u30C8\u3002\u6307\u5B9A\u304C\u306A\u3044\u5834\u5408\u306F\u30C7\u30D5\u30A9\u30EB\u30C8\uFF08\u9ED2\u30FB\u767D\u30FB\u8D64\u30FB\u9752\uFF09\u304C\u4F7F\u7528\u3055\u308C\u308B\u3002 */\n\tavailableColors?: Color[];\n\t/** \u5404\u8A18\u53F7\u30BF\u30A4\u30D7\u306E\u30C7\u30D5\u30A9\u30EB\u30C8\u30AB\u30E9\u30FC\u3002\u6307\u5B9A\u304C\u306A\u3044\u5834\u5408\u306F\u305D\u308C\u305E\u308C\u306E\u8A18\u53F7\u306E\u6A19\u6E96\u8272\u304C\u4F7F\u7528\u3055\u308C\u308B\u3002\n\t * \u30AD\u30FC\u306B\u306F CellType \u306E\u6570\u5024\u3001\u307E\u305F\u306F \"Square\", \"Tetris\" \u306A\u3069\u306E\u6587\u5B57\u5217\u304C\u4F7F\u7528\u53EF\u80FD\u3067\u3059\u3002\n\t */\n\tdefaultColors?: Partial<Record<CellType | keyof typeof CellType, Color>>;\n}\n", "import { type CellConstraint, CellType, Color, type EdgeConstraint, EdgeType, type NodeConstraint, NodeType, type PuzzleData } from \"./types\";\n\nexport class Grid {\n\tpublic readonly rows: number;\n\tpublic readonly cols: number;\n\n\t// \u30C7\u30FC\u30BF\u30DE\u30C8\u30EA\u30AF\u30B9\n\tpublic cells: CellConstraint[][] = [];\n\tpublic hEdges: EdgeConstraint[][] = []; // \u6A2A\u68D2\n\tpublic vEdges: EdgeConstraint[][] = []; // \u7E26\u68D2\n\tpublic nodes: NodeConstraint[][] = [];\n\tpublic symmetry: number = 0; // SymmetryType\n\n\tconstructor(rows: number, cols: number) {\n\t\tthis.rows = rows;\n\t\tthis.cols = cols;\n\t\tthis.initializeGrid();\n\t}\n\n\tprivate initializeGrid() {\n\t\t// Cells: rows * cols\n\t\tthis.cells = Array.from({ length: this.rows }, () => Array.from({ length: this.cols }, () => ({ type: CellType.None, color: Color.None })));\n\n\t\t// H-Edges: (rows + 1) * cols\n\t\tthis.hEdges = Array.from({ length: this.rows + 1 }, () => Array.from({ length: this.cols }, () => ({ type: EdgeType.Normal })));\n\n\t\t// V-Edges: rows * (cols + 1)\n\t\tthis.vEdges = Array.from({ length: this.rows }, () => Array.from({ length: this.cols + 1 }, () => ({ type: EdgeType.Normal })));\n\n\t\t// Nodes: (rows + 1) * (cols + 1)\n\t\tthis.nodes = Array.from({ length: this.rows + 1 }, () => Array.from({ length: this.cols + 1 }, () => ({ type: NodeType.Normal })));\n\t}\n\n\tpublic export(): PuzzleData {\n\t\t// \u30C7\u30FC\u30BF\u306E\u30C7\u30A3\u30FC\u30D7\u30B3\u30D4\u30FC\u3092\u8FD4\u3059\n\t\treturn JSON.parse(\n\t\t\tJSON.stringify({\n\t\t\t\trows: this.rows,\n\t\t\t\tcols: this.cols,\n\t\t\t\tcells: this.cells,\n\t\t\t\tvEdges: this.vEdges,\n\t\t\t\thEdges: this.hEdges,\n\t\t\t\tnodes: this.nodes,\n\t\t\t\tsymmetry: this.symmetry,\n\t\t\t}),\n\t\t);\n\t}\n\n\tpublic static fromData(data: PuzzleData): Grid {\n\t\tconst grid = new Grid(data.rows, data.cols);\n\t\tgrid.cells = data.cells;\n\t\tgrid.vEdges = data.vEdges;\n\t\tgrid.hEdges = data.hEdges;\n\t\tgrid.nodes = data.nodes;\n\t\tgrid.symmetry = data.symmetry || 0;\n\t\treturn grid;\n\t}\n}\n", "import { Grid } from \"./grid\";\nimport { CellType, Color, EdgeType, NodeType, SymmetryType, type Point, type SolutionPath, type ValidationResult } from \"./types\";\n\n/**\n * \u30D1\u30BA\u30EB\u306E\u56DE\u7B54\u3092\u691C\u8A3C\u3059\u308B\u30AF\u30E9\u30B9\n */\nexport class PuzzleValidator {\n\t/**\n\t * \u4E0E\u3048\u3089\u308C\u305F\u30B0\u30EA\u30C3\u30C9\u3068\u56DE\u7B54\u30D1\u30B9\u304C\u6B63\u5F53\u304B\u3069\u3046\u304B\u3092\u691C\u8A3C\u3059\u308B\n\t * @param grid \u30D1\u30BA\u30EB\u306E\u30B0\u30EA\u30C3\u30C9\u30C7\u30FC\u30BF\n\t * @param solution \u56DE\u7B54\u30D1\u30B9\n\t * @param externalCellsPrecalculated \u65E2\u77E5\u306E\u5916\u90E8\u30BB\u30EB\uFF08\u9AD8\u901F\u5316\u7528\uFF09\n\t * @returns \u691C\u8A3C\u7D50\u679C\uFF08\u6B63\u8AA4\u3001\u30A8\u30E9\u30FC\u7406\u7531\u3001\u7121\u52B9\u5316\u3055\u308C\u305F\u8A18\u53F7\u306A\u3069\uFF09\n\t */\n\tpublic validate(grid: Grid, solution: SolutionPath, externalCellsPrecalculated?: Set<string>): ValidationResult {\n\t\tconst path = solution.points;\n\t\tif (path.length < 2) return { isValid: false, errorReason: \"Path too short\" };\n\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\tconst symPath: Point[] = [];\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tfor (const p of path) {\n\t\t\t\tsymPath.push(this.getSymmetricalPoint(grid, p));\n\t\t\t}\n\t\t}\n\n\t\tconst start = path[0];\n\t\tconst end = path[path.length - 1];\n\n\t\t// \u958B\u59CB\u30CE\u30FC\u30C9\u3068\u7D42\u4E86\u30CE\u30FC\u30C9\u306E\u30C1\u30A7\u30C3\u30AF\n\t\tif (grid.nodes[start.y][start.x].type !== NodeType.Start) return { isValid: false, errorReason: \"Must start at Start Node\" };\n\t\tif (grid.nodes[end.y][end.x].type !== NodeType.End) return { isValid: false, errorReason: \"Must end at End Node\" };\n\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tconst symStart = symPath[0];\n\t\t\tconst symEnd = symPath[symPath.length - 1];\n\t\t\tif (grid.nodes[symStart.y][symStart.x].type !== NodeType.Start) return { isValid: false, errorReason: \"Symmetrical path must start at Start Node\" };\n\t\t\tif (grid.nodes[symEnd.y][symEnd.x].type !== NodeType.End) return { isValid: false, errorReason: \"Symmetrical path must end at End Node\" };\n\t\t}\n\n\t\t// \u30D1\u30B9\u306E\u9023\u7D9A\u6027\u3068\u81EA\u5DF1\u4EA4\u5DEE\u3001\u65AD\u7DDA\u30C1\u30A7\u30C3\u30AF\n\t\tconst visitedNodes = new Set<string>();\n\t\tconst visitedEdges = new Set<string>();\n\t\tvisitedNodes.add(`${start.x},${start.y}`);\n\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tconst symStart = symPath[0];\n\t\t\tif (visitedNodes.has(`${symStart.x},${symStart.y}`)) return { isValid: false, errorReason: \"Paths collide at start\" };\n\t\t\tvisitedNodes.add(`${symStart.x},${symStart.y}`);\n\t\t}\n\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst p1 = path[i];\n\t\t\tconst p2 = path[i + 1];\n\t\t\tconst dist = Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n\t\t\tif (dist !== 1) return { isValid: false, errorReason: \"Invalid jump in path\" };\n\n\t\t\tconst key = `${p2.x},${p2.y}`;\n\t\t\tif (visitedNodes.has(key)) return { isValid: false, errorReason: \"Self-intersecting path or path collision\" };\n\t\t\tvisitedNodes.add(key);\n\n\t\t\tif (this.isBrokenEdge(grid, p1, p2)) return { isValid: false, errorReason: \"Passed through broken edge\" };\n\t\t\tvisitedEdges.add(this.getEdgeKey(p1, p2));\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst sp1 = symPath[i];\n\t\t\t\tconst sp2 = symPath[i + 1];\n\t\t\t\tconst symKey = `${sp2.x},${sp2.y}`;\n\n\t\t\t\tif (visitedNodes.has(symKey)) return { isValid: false, errorReason: \"Path collision\" };\n\t\t\t\tvisitedNodes.add(symKey);\n\n\t\t\t\tif (this.isBrokenEdge(grid, sp1, sp2)) return { isValid: false, errorReason: \"Symmetrical path passed through broken edge\" };\n\n\t\t\t\tconst edgeKey = this.getEdgeKey(sp1, sp2);\n\t\t\t\tif (visitedEdges.has(edgeKey)) return { isValid: false, errorReason: \"Paths cross the same edge\" };\n\t\t\t\tvisitedEdges.add(edgeKey);\n\t\t\t}\n\t\t}\n\n\t\t// \u533A\u753B\u306E\u8A08\u7B97\n\t\tconst regions = this.calculateRegions(grid, path, symPath, externalCellsPrecalculated);\n\t\t// \u901A\u904E\u3057\u306A\u304B\u3063\u305F\u516D\u89D2\u5F62\u306E\u53D6\u5F97\n\t\tconst missed = this.getMissedHexagons(grid, path, symPath);\n\t\t// \u30A8\u30E9\u30FC\u524A\u9664\uFF08\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF09\u3092\u8003\u616E\u3057\u305F\u5236\u7D04\u691C\u8A3C\n\t\tconst result = this.validateWithErasers(grid, regions, missed.edges, missed.nodes);\n\t\tresult.regions = regions;\n\t\treturn result;\n\t}\n\n\t/**\n\t * \u9AD8\u901F\u5316\u3055\u308C\u305F\u691C\u8A3C\uFF08\u5185\u90E8\u63A2\u7D22\u7528\uFF09\n\t */\n\tprivate validateFast(grid: Grid, path: Point[], symPath: Point[], externalCells?: Set<string>): ValidationResult {\n\t\tconst regions = this.calculateRegions(grid, path, symPath, externalCells);\n\t\tconst missed = this.getMissedHexagons(grid, path, symPath);\n\t\treturn this.validateWithErasers(grid, regions, missed.edges, missed.nodes);\n\t}\n\n\t/**\n\t * \u4E8C\u70B9\u9593\u304C\u65AD\u7DDA\uFF08Broken or Absent\uFF09\u3057\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate isBrokenEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tlet type: EdgeType;\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\ttype = grid.vEdges[y][p1.x].type;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\ttype = grid.hEdges[p1.y][x].type;\n\t\t}\n\t\treturn type === EdgeType.Broken || type === EdgeType.Absent;\n\t}\n\n\t/**\n\t * \u4E8C\u70B9\u9593\u304C Absent\uFF08\u5B58\u5728\u3057\u306A\u3044\uFF09\u30A8\u30C3\u30B8\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate isAbsentEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\treturn grid.vEdges[y][p1.x].type === EdgeType.Absent;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\treturn grid.hEdges[p1.y][x].type === EdgeType.Absent;\n\t\t}\n\t}\n\n\t/**\n\t * \u56DE\u7B54\u30D1\u30B9\u304C\u901A\u904E\u3057\u306A\u304B\u3063\u305F\u516D\u89D2\u5F62\uFF08\u30A8\u30C3\u30B8\u30FB\u30CE\u30FC\u30C9\uFF09\u3092\u30EA\u30B9\u30C8\u30A2\u30C3\u30D7\u3059\u308B\n\t */\n\tprivate getMissedHexagons(grid: Grid, path: Point[], symPath: Point[] = []): { edges: { type: \"h\" | \"v\"; r: number; c: number }[]; nodes: Point[] } {\n\t\tconst pathEdges = new Set<string>();\n\t\tconst pathNodes = new Set<string>();\n\t\tfor (let i = 0; i < path.length; i++) {\n\t\t\tpathNodes.add(`${path[i].x},${path[i].y}`);\n\t\t\tif (i < path.length - 1) {\n\t\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < symPath.length; i++) {\n\t\t\tpathNodes.add(`${symPath[i].x},${symPath[i].y}`);\n\t\t\tif (i < symPath.length - 1) {\n\t\t\t\tpathEdges.add(this.getEdgeKey(symPath[i], symPath[i + 1]));\n\t\t\t}\n\t\t}\n\n\t\tconst missedEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst key = this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r });\n\t\t\t\t\tif (!pathEdges.has(key)) missedEdges.push({ type: \"h\", r, c });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst key = this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 });\n\t\t\t\t\tif (!pathEdges.has(key)) missedEdges.push({ type: \"v\", r, c });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst missedNodes: Point[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Hexagon) {\n\t\t\t\t\tif (!pathNodes.has(`${c},${r}`)) missedNodes.push({ x: c, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { edges: missedEdges, nodes: missedNodes };\n\t}\n\n\t/**\n\t * \u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF08\u30A8\u30E9\u30FC\u524A\u9664\uFF09\u3092\u8003\u616E\u3057\u3066\u30D1\u30BA\u30EB\u306E\u5404\u5236\u7D04\u3092\u691C\u8A3C\u3059\u308B\n\t */\n\tprivate validateWithErasers(grid: Grid, regions: Point[][], missedHexagons: { type: \"h\" | \"v\"; r: number; c: number }[], missedNodeHexagons: Point[]): ValidationResult {\n\t\tconst regionResults: { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] }[][] = [];\n\t\tlet allRegionsPossiblyValid = true;\n\n\t\tfor (let i = 0; i < regions.length; i++) {\n\t\t\tconst region = regions[i];\n\t\t\tconst erasers = region.filter((p) => grid.cells[p.y][p.x].type === CellType.Eraser);\n\t\t\tconst otherMarks = region.filter((p) => grid.cells[p.y][p.x].type !== CellType.None && grid.cells[p.y][p.x].type !== CellType.Eraser);\n\n\t\t\tconst adjacentMissedHexagons: number[] = [];\n\t\t\tfor (let j = 0; j < missedHexagons.length; j++) {\n\t\t\t\tif (this.isHexagonAdjacentToRegion(grid, missedHexagons[j], region)) adjacentMissedHexagons.push(j);\n\t\t\t}\n\n\t\t\tconst adjacentMissedNodeHexagons: number[] = [];\n\t\t\tfor (let j = 0; j < missedNodeHexagons.length; j++) {\n\t\t\t\tif (this.isNodeHexagonAdjacentToRegion(grid, missedNodeHexagons[j], region)) adjacentMissedNodeHexagons.push(j);\n\t\t\t}\n\n\t\t\t// \u5404\u533A\u753B\u3067\u30A8\u30E9\u30FC\u524A\u9664\u306E\u5168\u7D44\u307F\u5408\u308F\u305B\u3092\u8A66\u884C\n\t\t\tconst possible = this.getPossibleErasures(grid, region, erasers, otherMarks, adjacentMissedHexagons, adjacentMissedNodeHexagons);\n\t\t\tif (possible.length === 0) {\n\t\t\t\tallRegionsPossiblyValid = false;\n\t\t\t\t// \u30A8\u30E9\u30FC\u7B87\u6240\u3092\u7279\u5B9A\u3059\u308B\u305F\u3081\u306E\u30D9\u30B9\u30C8\u30A8\u30D5\u30A9\u30FC\u30C8\uFF08\u30E9\u30F3\u30C0\u30E0\u306A\u524A\u9664\uFF09\n\t\t\t\tconst bestEffort = this.getBestEffortErasures(grid, region, erasers, otherMarks, adjacentMissedHexagons, adjacentMissedNodeHexagons);\n\t\t\t\tregionResults.push([bestEffort]);\n\t\t\t} else {\n\t\t\t\t// \u6700\u5C0F\u306E\u524A\u9664\u6570\u3092\u6301\u3064\u89E3\u6C7A\u7B56\u3092\u512A\u5148\u3059\u308B\n\t\t\t\tpossible.sort((a, b) => {\n\t\t\t\t\tconst costA = a.invalidatedCells.length + a.invalidatedHexagons.length + a.invalidatedNodeHexagons.length;\n\t\t\t\t\tconst costB = b.invalidatedCells.length + b.invalidatedHexagons.length + b.invalidatedNodeHexagons.length;\n\t\t\t\t\treturn costA - costB;\n\t\t\t\t});\n\t\t\t\tregionResults.push(possible);\n\t\t\t}\n\t\t}\n\n\t\tif (allRegionsPossiblyValid) {\n\t\t\t// \u8907\u6570\u306E\u533A\u753B\u306B\u307E\u305F\u304C\u308B\u516D\u89D2\u5F62\u306E\u30A8\u30E9\u30FC\u524A\u9664\u5272\u308A\u5F53\u3066\u3092\u6C7A\u5B9A\n\t\t\tconst assignment = this.findGlobalAssignment(regionResults, missedHexagons.length, missedNodeHexagons.length);\n\t\t\tif (assignment) {\n\t\t\t\treturn {\n\t\t\t\t\tisValid: true,\n\t\t\t\t\tinvalidatedCells: assignment.invalidatedCells,\n\t\t\t\t\tinvalidatedEdges: assignment.invalidatedHexIndices.map((idx) => missedHexagons[idx]),\n\t\t\t\t\tinvalidatedNodes: assignment.invalidatedNodeHexIndices.map((idx) => missedNodeHexagons[idx]),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// \u5931\u6557\u6642\uFF1A\u30A8\u30E9\u30FC\u7B87\u6240\u306E\u53CE\u96C6\n\t\tconst errorCells: Point[] = [];\n\t\tconst invalidatedCells: Point[] = [];\n\t\tconst invalidatedHexIndices = new Set<number>();\n\t\tconst invalidatedNodeHexIndices = new Set<number>();\n\n\t\tfor (const options of regionResults) {\n\t\t\tconst best = options[0]; // \u6700\u521D\u306E\uFF08\u6700\u3082\u30B3\u30B9\u30C8\u306E\u4F4E\u3044\u3001\u307E\u305F\u306F\u30D9\u30B9\u30C8\u30A8\u30D5\u30A9\u30FC\u30C8\u306A\uFF09\u3082\u306E\u3092\u9078\u629E\n\t\t\terrorCells.push(...best.errorCells);\n\t\t\tinvalidatedCells.push(...best.invalidatedCells);\n\t\t\tfor (const idx of best.invalidatedHexagons) invalidatedHexIndices.add(idx);\n\t\t\tfor (const idx of best.invalidatedNodeHexagons) invalidatedNodeHexIndices.add(idx);\n\t\t}\n\n\t\t// \u7121\u52B9\u5316\u3055\u308C\u306A\u304B\u3063\u305F\u516D\u89D2\u5F62\u3082\u30A8\u30E9\u30FC\u3068\u3059\u308B\n\t\tconst errorEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\tfor (let i = 0; i < missedHexagons.length; i++) {\n\t\t\tif (!invalidatedHexIndices.has(i)) {\n\t\t\t\terrorEdges.push(missedHexagons[i]);\n\t\t\t}\n\t\t}\n\t\tconst errorNodes: Point[] = [];\n\t\tfor (let i = 0; i < missedNodeHexagons.length; i++) {\n\t\t\tif (!invalidatedNodeHexIndices.has(i)) {\n\t\t\t\terrorNodes.push(missedNodeHexagons[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tisValid: false,\n\t\t\terrorReason: \"Constraints failed\",\n\t\t\terrorCells,\n\t\t\terrorEdges,\n\t\t\terrorNodes,\n\t\t\tinvalidatedCells,\n\t\t\tinvalidatedEdges: Array.from(invalidatedHexIndices).map((idx) => missedHexagons[idx]),\n\t\t\tinvalidatedNodes: Array.from(invalidatedNodeHexIndices).map((idx) => missedNodeHexagons[idx]),\n\t\t};\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30A8\u30C3\u30B8\u304C\u7279\u5B9A\u306E\u533A\u753B\u306B\u96A3\u63A5\u3057\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate isHexagonAdjacentToRegion(grid: Grid, hex: { type: \"h\" | \"v\"; r: number; c: number }, region: Point[]): boolean {\n\t\tconst regionCells = new Set(region.map((p) => `${p.x},${p.y}`));\n\t\tif (hex.type === \"h\") {\n\t\t\tif (hex.r > 0 && regionCells.has(`${hex.c},${hex.r - 1}`)) return true;\n\t\t\tif (hex.r < grid.rows && regionCells.has(`${hex.c},${hex.r}`)) return true;\n\t\t} else {\n\t\t\tif (hex.c > 0 && regionCells.has(`${hex.c - 1},${hex.r}`)) return true;\n\t\t\tif (hex.c < grid.cols && regionCells.has(`${hex.c},${hex.r}`)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30CE\u30FC\u30C9\u304C\u7279\u5B9A\u306E\u533A\u753B\u306B\u96A3\u63A5\u3057\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate isNodeHexagonAdjacentToRegion(grid: Grid, node: Point, region: Point[]): boolean {\n\t\tconst regionCells = new Set(region.map((p) => `${p.x},${p.y}`));\n\t\t// \u30CE\u30FC\u30C9\u306E\u5468\u56F24\u3064\u306E\u30BB\u30EB\u306E\u3044\u305A\u308C\u304B\u304C\u533A\u753B\u306B\u542B\u307E\u308C\u3066\u3044\u308C\u3070\u96A3\u63A5\n\t\tconst adjCells = [\n\t\t\t{ x: node.x - 1, y: node.y - 1 },\n\t\t\t{ x: node.x, y: node.y - 1 },\n\t\t\t{ x: node.x - 1, y: node.y },\n\t\t\t{ x: node.x, y: node.y },\n\t\t];\n\t\tfor (const cell of adjCells) {\n\t\t\tif (cell.x >= 0 && cell.x < grid.cols && cell.y >= 0 && cell.y < grid.rows) {\n\t\t\t\tif (regionCells.has(`${cell.x},${cell.y}`)) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u533A\u753B\u5185\u306E\u30A8\u30E9\u30FC\u524A\u9664\u53EF\u80FD\u306A\u5168\u30D1\u30BF\u30FC\u30F3\u3092\u53D6\u5F97\u3059\u308B\n\t */\n\tprivate getPossibleErasures(grid: Grid, region: Point[], erasers: Point[], otherMarks: Point[], adjacentMissedHexagons: number[], adjacentMissedNodeHexagons: number[]): { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] }[] {\n\t\tconst results: { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] }[] = [];\n\t\tconst numErasers = erasers.length;\n\t\tif (numErasers === 0) {\n\t\t\tconst errorCells = this.getRegionErrors(grid, region, []);\n\t\t\tif (errorCells.length === 0 && adjacentMissedHexagons.length === 0 && adjacentMissedNodeHexagons.length === 0) {\n\t\t\t\tresults.push({ invalidatedCells: [], invalidatedHexagons: [], invalidatedNodeHexagons: [], isValid: true, errorCells: [] });\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\n\t\tconst itemsToNegate = [...otherMarks.map((p) => ({ type: \"cell\" as const, pos: p })), ...adjacentMissedHexagons.map((idx) => ({ type: \"hex\" as const, index: idx })), ...adjacentMissedNodeHexagons.map((idx) => ({ type: \"nodeHex\" as const, index: idx }))];\n\n\t\t// \u521D\u671F\u72B6\u614B\u3067\u30A8\u30E9\u30FC\u304C\u3042\u308B\u304B\u78BA\u8A8D\n\t\tconst initiallyValid = this.getRegionErrors(grid, region, []).length === 0 && adjacentMissedHexagons.length === 0 && adjacentMissedNodeHexagons.length === 0;\n\n\t\tfor (let N = 0; N <= numErasers; N++) {\n\t\t\tconst negatedEraserCombinations = this.getNCombinations(erasers, N);\n\t\t\tfor (const negatedErasers of negatedEraserCombinations) {\n\t\t\t\tconst negatedErasersSet = new Set(negatedErasers.map((e) => `${e.x},${e.y}`));\n\t\t\t\tconst activeErasers = erasers.filter((e) => !negatedErasersSet.has(`${e.x},${e.y}`));\n\n\t\t\t\tfor (let K = 0; K <= itemsToNegate.length; K++) {\n\t\t\t\t\tif (activeErasers.length !== N + K) continue;\n\n\t\t\t\t\tconst itemCombinations = this.getNCombinations(itemsToNegate, K);\n\t\t\t\t\tfor (const negatedItems of itemCombinations) {\n\t\t\t\t\t\tconst negatedCells = negatedItems.filter((it) => it.type === \"cell\").map((it) => it.pos as Point);\n\t\t\t\t\t\tconst negatedHexIndices = negatedItems.filter((it) => it.type === \"hex\").map((it) => it.index as number);\n\t\t\t\t\t\tconst negatedNodeHexIndices = negatedItems.filter((it) => it.type === \"nodeHex\").map((it) => it.index as number);\n\n\t\t\t\t\t\tconst errorCells = this.getRegionErrors(grid, region, [...negatedCells, ...negatedErasers]);\n\t\t\t\t\t\tconst isValid = errorCells.length === 0;\n\n\t\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\t\tlet isUseful = true;\n\t\t\t\t\t\t\tif (initiallyValid) {\n\t\t\t\t\t\t\t\tif (K > 0) isUseful = false;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < negatedItems.length; i++) {\n\t\t\t\t\t\t\t\t\tconst subset = [...negatedItems.slice(0, i), ...negatedItems.slice(i + 1)];\n\t\t\t\t\t\t\t\t\tconst subsetCells = subset.filter((it) => it.type === \"cell\").map((it) => it.pos as Point);\n\t\t\t\t\t\t\t\t\tconst subsetHexIndices = new Set(subset.filter((it) => it.type === \"hex\").map((it) => it.index as number));\n\t\t\t\t\t\t\t\t\tconst subsetNodeHexIndices = new Set(subset.filter((it) => it.type === \"nodeHex\").map((it) => it.index as number));\n\n\t\t\t\t\t\t\t\t\tconst allHexSatisfied = adjacentMissedHexagons.every((idx) => subsetHexIndices.has(idx));\n\t\t\t\t\t\t\t\t\tconst allNodeHexSatisfied = adjacentMissedNodeHexagons.every((idx) => subsetNodeHexIndices.has(idx));\n\n\t\t\t\t\t\t\t\t\tif (this.getRegionErrors(grid, region, subsetCells).length === 0 && allHexSatisfied && allNodeHexSatisfied) {\n\t\t\t\t\t\t\t\t\t\tisUseful = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (isUseful) {\n\t\t\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\t\t\tinvalidatedCells: [...negatedCells, ...negatedErasers],\n\t\t\t\t\t\t\t\t\tinvalidatedHexagons: negatedHexIndices,\n\t\t\t\t\t\t\t\t\tinvalidatedNodeHexagons: negatedNodeHexIndices,\n\t\t\t\t\t\t\t\t\tisValid: true,\n\t\t\t\t\t\t\t\t\terrorCells: [],\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * \u30A8\u30E9\u30FC\u304C\u89E3\u6D88\u3067\u304D\u306A\u304B\u3063\u305F\u5834\u5408\u306E\u30D9\u30B9\u30C8\u30A8\u30D5\u30A9\u30FC\u30C8\u306A\u524A\u9664\uFF08\u53EF\u80FD\u306A\u9650\u308A\u6D88\u3057\u30B4\u30E0\u3092\u9069\u7528\uFF09\u3092\u53D6\u5F97\u3059\u308B\n\t */\n\tprivate getBestEffortErasures(grid: Grid, region: Point[], erasers: Point[], otherMarks: Point[], adjacentMissedHexagons: number[], adjacentMissedNodeHexagons: number[]): { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] } {\n\t\tconst naturalErrors = this.getRegionErrors(grid, region, []);\n\t\tconst initiallyValid = naturalErrors.length === 0 && adjacentMissedHexagons.length === 0 && adjacentMissedNodeHexagons.length === 0;\n\n\t\t// \u521D\u671F\u72B6\u614B\u3067\u6709\u52B9\u306A\u3089\u3001\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\u81EA\u4F53\u304C\u30A8\u30E9\u30FC\u3002\n\t\tif (initiallyValid) {\n\t\t\treturn {\n\t\t\t\tinvalidatedCells: [],\n\t\t\t\tinvalidatedHexagons: [],\n\t\t\t\tinvalidatedNodeHexagons: [],\n\t\t\t\tisValid: false,\n\t\t\t\terrorCells: [...erasers],\n\t\t\t};\n\t\t}\n\n\t\tif (erasers.length > 0) {\n\t\t\tconst itemsToNegate = [...otherMarks.map((p) => ({ type: \"cell\" as const, pos: p })), ...adjacentMissedHexagons.map((idx) => ({ type: \"hex\" as const, index: idx })), ...adjacentMissedNodeHexagons.map((idx) => ({ type: \"nodeHex\" as const, index: idx }))];\n\n\t\t\t// \u30A8\u30E9\u30FC\u89E3\u6D88\u30D1\u30BF\u30FC\u30F3\u3092\u3044\u304F\u3064\u304B\u8A66\u3057\u3001\u6700\u3082\u30A8\u30E9\u30FC\u304C\u5C11\u306A\u304F\u306A\u308B\u3082\u306E\u3092\u63A1\u7528\u3059\u308B\n\t\t\tlet bestResult: { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] } | null = null;\n\t\t\tlet minErrorCount = Infinity;\n\n\t\t\t// \u5358\u7D14\u306A\u512A\u5148\u9806\u4F4D\u306B\u57FA\u3065\u304F\u30D1\u30BF\u30FC\u30F3\n\t\t\tconst tryNegate = (priorityItems: ({ type: \"cell\"; pos: Point } | { type: \"hex\"; index: number } | { type: \"nodeHex\"; index: number })[]) => {\n\t\t\t\tconst toInvalidateCells: Point[] = [];\n\t\t\t\tconst toInvalidateHexagons: number[] = [];\n\t\t\t\tconst toInvalidateNodeHexagons: number[] = [];\n\t\t\t\tlet usedErasersCount = 0;\n\n\t\t\t\tfor (const item of priorityItems) {\n\t\t\t\t\tif (usedErasersCount < erasers.length) {\n\t\t\t\t\t\tif (item.type === \"cell\") toInvalidateCells.push(item.pos);\n\t\t\t\t\t\telse if (item.type === \"hex\") toInvalidateHexagons.push(item.index);\n\t\t\t\t\t\telse toInvalidateNodeHexagons.push(item.index);\n\t\t\t\t\t\tusedErasersCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// \u6B8B\u308A\u306E\u6D88\u3057\u30B4\u30E0\u306F\u30DA\u30A2\u306B\u3057\u3066\u7121\u52B9\u5316\u3092\u8A66\u307F\u308B\n\t\t\t\tconst remainingForPairs = erasers.length - usedErasersCount;\n\t\t\t\tconst N = Math.floor(remainingForPairs / 2);\n\t\t\t\tconst negatedErasers = erasers.slice(usedErasersCount, usedErasersCount + N);\n\t\t\t\tusedErasersCount += N * 2;\n\n\t\t\t\t// \u6D88\u3057\u30B4\u30E0\u81EA\u8EAB\u304C\u30A8\u30E9\u30FC\u304B\u3069\u3046\u304B\u3092\u5224\u5B9A\u3059\u308B\u305F\u3081\u3001getRegionErrors\u3092\u547C\u3076\n\t\t\t\t// \u6D88\u3057\u30B4\u30E0\u81EA\u8EAB\u306F\uFF08\u6D88\u3057\u5408\u3063\u305F\u30DA\u30A2\u3092\u9664\u304D\uFF09\u30DE\u30FC\u30AF\u3068\u3057\u3066\u6B8B\u308B\n\t\t\t\tconst errorCells = this.getRegionErrors(grid, region, [...toInvalidateCells, ...negatedErasers]);\n\t\t\t\t// \u4F7F\u308F\u308C\u306A\u304B\u3063\u305F\u6D88\u3057\u30B4\u30E0\u306F\u30A8\u30E9\u30FC\n\t\t\t\tfor (let i = usedErasersCount; i < erasers.length; i++) {\n\t\t\t\t\terrorCells.push(erasers[i]);\n\t\t\t\t}\n\n\t\t\t\tconst errorCount = errorCells.length;\n\t\t\t\tif (errorCount < minErrorCount) {\n\t\t\t\t\tminErrorCount = errorCount;\n\n\t\t\t\t\tbestResult = {\n\t\t\t\t\t\tinvalidatedCells: [...toInvalidateCells, ...negatedErasers],\n\t\t\t\t\t\tinvalidatedHexagons: toInvalidateHexagons,\n\t\t\t\t\t\tinvalidatedNodeHexagons: toInvalidateNodeHexagons,\n\t\t\t\t\t\tisValid: false,\n\t\t\t\t\t\terrorCells,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// \u30D1\u30BF\u30FC\u30F31: \u81EA\u7136\u767A\u751F\u3057\u305F\u30A8\u30E9\u30FC\u3092\u512A\u5148\n\t\t\ttryNegate([...naturalErrors.map((p) => ({ type: \"cell\" as const, pos: p })), ...adjacentMissedHexagons.map((idx) => ({ type: \"hex\" as const, index: idx })), ...adjacentMissedNodeHexagons.map((idx) => ({ type: \"nodeHex\" as const, index: idx }))]);\n\t\t\t// \u30D1\u30BF\u30FC\u30F32: \u5168\u3066\u306E\u30A2\u30A4\u30C6\u30E0\u3092\u9806\u756A\u306B\n\t\t\ttryNegate(itemsToNegate);\n\t\t\t// \u30D1\u30BF\u30FC\u30F33: \u81EA\u7136\u767A\u751F\u3057\u305F\u5404\u30A8\u30E9\u30FC\u3092\u500B\u5225\u306B1\u3064\u305A\u3064\u6D88\u3057\u3066\u307F\u308B\n\t\t\tfor (const errCell of naturalErrors) {\n\t\t\t\ttryNegate([{ type: \"cell\", pos: errCell }]);\n\t\t\t}\n\n\t\t\tif (bestResult) return bestResult;\n\t\t}\n\n\t\tconst errorCells = [...naturalErrors, ...erasers];\n\t\treturn {\n\t\t\tinvalidatedCells: [],\n\t\t\tinvalidatedHexagons: [],\n\t\t\tinvalidatedNodeHexagons: [],\n\t\t\tisValid: false,\n\t\t\terrorCells,\n\t\t};\n\t}\n\n\t/**\n\t * \u914D\u5217\u304B\u3089N\u500B\u9078\u3076\u7D44\u307F\u5408\u308F\u305B\u3092\u53D6\u5F97\u3059\u308B\n\t */\n\tprivate getNCombinations<T>(items: T[], n: number): T[][] {\n\t\tconst results: T[][] = [];\n\t\tconst backtrack = (start: number, current: T[]) => {\n\t\t\tif (current.length === n) {\n\t\t\t\tresults.push([...current]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (let i = start; i < items.length; i++) {\n\t\t\t\tcurrent.push(items[i]);\n\t\t\t\tbacktrack(i + 1, current);\n\t\t\t\tcurrent.pop();\n\t\t\t}\n\t\t};\n\t\tbacktrack(0, []);\n\t\treturn results;\n\t}\n\n\t/**\n\t * \u7279\u5B9A\u306E\u524A\u9664\u30FB\u7121\u52B9\u5316\u3092\u9069\u7528\u3057\u305F\u72B6\u614B\u3067\u3001\u533A\u753B\u5185\u306E\u5236\u7D04\u304C\u6E80\u305F\u3055\u308C\u3066\u3044\u308B\u304B\u691C\u8A3C\u3059\u308B\n\t */\n\tprivate checkRegionValid(grid: Grid, region: Point[], erasedCells: Point[]): boolean {\n\t\treturn this.getRegionErrors(grid, region, erasedCells).length === 0;\n\t}\n\n\t/**\n\t * \u533A\u753B\u5185\u306E\u30A8\u30E9\u30FC\u3068\u306A\u3063\u3066\u3044\u308B\u30BB\u30EB\u3092\u7279\u5B9A\u3059\u308B\n\t */\n\tprivate getRegionErrors(grid: Grid, region: Point[], erasedCells: Point[]): Point[] {\n\t\tconst erasedSet = new Set(erasedCells.map((p) => `${p.x},${p.y}`));\n\t\tconst colorCounts = new Map<number, number>();\n\t\tconst colorCells = new Map<number, Point[]>();\n\t\tconst starColors = new Set<number>();\n\t\tconst squareColors = new Set<number>();\n\t\tconst tetrisPieces: { shape: number[][]; rotatable: boolean; pos: Point }[] = [];\n\n\t\tfor (const cell of region) {\n\t\t\tif (erasedSet.has(`${cell.x},${cell.y}`)) continue;\n\t\t\tconst constraint = grid.cells[cell.y][cell.x];\n\t\t\tif (constraint.type === CellType.None) continue;\n\n\t\t\tconst color = constraint.color;\n\t\t\tif (color !== Color.None) {\n\t\t\t\tcolorCounts.set(color, (colorCounts.get(color) || 0) + 1);\n\t\t\t\tif (!colorCells.has(color)) colorCells.set(color, []);\n\t\t\t\tcolorCells.get(color)!.push(cell);\n\t\t\t}\n\n\t\t\tif (constraint.type === CellType.Square) squareColors.add(color);\n\t\t\telse if (constraint.type === CellType.Star) starColors.add(color);\n\t\t\telse if (constraint.type === CellType.Tetris || constraint.type === CellType.TetrisRotated) {\n\t\t\t\tif (constraint.shape) tetrisPieces.push({ shape: constraint.shape, rotatable: constraint.type === CellType.TetrisRotated, pos: cell });\n\t\t\t}\n\t\t}\n\n\t\tconst errorCells: Point[] = [];\n\t\t// \u56DB\u89D2\u5F62\u306E\u30EB\u30FC\u30EB\uFF1A\u540C\u533A\u753B\u5185\u306F\u540C\u3058\u8272\n\t\tif (squareColors.size > 1) {\n\t\t\tfor (const cell of region) {\n\t\t\t\tif (erasedSet.has(`${cell.x},${cell.y}`)) continue;\n\t\t\t\tif (grid.cells[cell.y][cell.x].type === CellType.Square) errorCells.push(cell);\n\t\t\t}\n\t\t}\n\n\t\t// \u661F\u306E\u30EB\u30FC\u30EB\uFF1A\u540C\u8272\u306E\u8A18\u53F7\u304C\u3061\u3087\u3046\u30692\u3064\n\t\tfor (const color of starColors) {\n\t\t\tif (colorCounts.get(color) !== 2) {\n\t\t\t\tconst cells = colorCells.get(color) || [];\n\t\t\t\tfor (const p of cells) {\n\t\t\t\t\tconst type = grid.cells[p.y][p.x].type;\n\t\t\t\t\tif (type === CellType.Star) {\n\t\t\t\t\t\terrorCells.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// \u30C6\u30C8\u30EA\u30B9\u306E\u30EB\u30FC\u30EB\uFF1A\u30BF\u30A4\u30EA\u30F3\u30B0\u53EF\u80FD\n\t\tif (tetrisPieces.length > 0) {\n\t\t\tif (\n\t\t\t\t!this.checkTetrisConstraint(\n\t\t\t\t\tregion,\n\t\t\t\t\ttetrisPieces.map((p) => ({ shape: p.shape, rotatable: p.rotatable })),\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tfor (const p of tetrisPieces) errorCells.push(p.pos);\n\t\t\t}\n\t\t}\n\t\treturn errorCells;\n\t}\n\n\t/**\n\t * \u30B0\u30ED\u30FC\u30D0\u30EB\u306A\u5236\u7D04\uFF08\u516D\u89D2\u5F62\uFF09\u306E\u5272\u308A\u5F53\u3066\u3092\u30D0\u30C3\u30AF\u30C8\u30E9\u30C3\u30AD\u30F3\u30B0\u3067\u63A2\u7D22\u3059\u308B\n\t */\n\tprivate findGlobalAssignment(regionResults: { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean }[][], totalMissedHexagons: number, totalMissedNodeHexagons: number): { invalidatedCells: Point[]; invalidatedHexIndices: number[]; invalidatedNodeHexIndices: number[] } | null {\n\t\tconst numRegions = regionResults.length;\n\t\tconst currentHexErasures = new Array(totalMissedHexagons).fill(0);\n\t\tconst currentNodeHexErasures = new Array(totalMissedNodeHexagons).fill(0);\n\t\tconst allInvalidatedCells: Point[] = [];\n\t\tconst allInvalidatedHexIndices: number[] = [];\n\t\tconst allInvalidatedNodeHexIndices: number[] = [];\n\n\t\tconst backtrack = (regionIdx: number): boolean => {\n\t\t\tif (regionIdx === numRegions) return currentHexErasures.every((count) => count === 1) && currentNodeHexErasures.every((count) => count === 1);\n\t\t\tfor (const option of regionResults[regionIdx]) {\n\t\t\t\tlet possible = true;\n\t\t\t\tfor (const hexIdx of option.invalidatedHexagons)\n\t\t\t\t\tif (currentHexErasures[hexIdx] > 0) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (possible) {\n\t\t\t\t\tfor (const hexIdx of option.invalidatedNodeHexagons)\n\t\t\t\t\t\tif (currentNodeHexErasures[hexIdx] > 0) {\n\t\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (possible) {\n\t\t\t\t\tfor (const hexIdx of option.invalidatedHexagons) {\n\t\t\t\t\t\tcurrentHexErasures[hexIdx]++;\n\t\t\t\t\t\tallInvalidatedHexIndices.push(hexIdx);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const hexIdx of option.invalidatedNodeHexagons) {\n\t\t\t\t\t\tcurrentNodeHexErasures[hexIdx]++;\n\t\t\t\t\t\tallInvalidatedNodeHexIndices.push(hexIdx);\n\t\t\t\t\t}\n\t\t\t\t\tallInvalidatedCells.push(...option.invalidatedCells);\n\t\t\t\t\tif (backtrack(regionIdx + 1)) return true;\n\n\t\t\t\t\tfor (const hexIdx of option.invalidatedHexagons) {\n\t\t\t\t\t\tcurrentHexErasures[hexIdx]--;\n\t\t\t\t\t\tallInvalidatedHexIndices.pop();\n\t\t\t\t\t}\n\t\t\t\t\tfor (const hexIdx of option.invalidatedNodeHexagons) {\n\t\t\t\t\t\tcurrentNodeHexErasures[hexIdx]--;\n\t\t\t\t\t\tallInvalidatedNodeHexIndices.pop();\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < option.invalidatedCells.length; i++) allInvalidatedCells.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tif (backtrack(0))\n\t\t\treturn {\n\t\t\t\tinvalidatedCells: allInvalidatedCells,\n\t\t\t\tinvalidatedHexIndices: allInvalidatedHexIndices,\n\t\t\t\tinvalidatedNodeHexIndices: allInvalidatedNodeHexIndices,\n\t\t\t};\n\t\treturn null;\n\t}\n\n\t/**\n\t * \u30C6\u30C8\u30EA\u30B9\u5236\u7D04\u306E\u691C\u8A3C\uFF08\u6307\u5B9A\u3055\u308C\u305F\u9818\u57DF\u3092\u30D4\u30FC\u30B9\u3067\u57CB\u3081\u5C3D\u304F\u305B\u308B\u304B\uFF09\n\t */\n\tprivate checkTetrisConstraint(region: Point[], pieces: { shape: number[][]; rotatable: boolean }[]): boolean {\n\t\tconst totalTetrisArea = pieces.reduce((sum, p) => sum + this.getShapeArea(p.shape), 0);\n\t\tif (totalTetrisArea !== region.length) return false;\n\n\t\tconst minX = Math.min(...region.map((p) => p.x));\n\t\tconst minY = Math.min(...region.map((p) => p.y));\n\t\tconst maxX = Math.max(...region.map((p) => p.x));\n\t\tconst maxY = Math.max(...region.map((p) => p.y));\n\t\tconst width = maxX - minX + 1;\n\t\tconst height = maxY - minY + 1;\n\n\t\tconst regionGrid = Array.from({ length: height }, () => Array(width).fill(false));\n\t\tfor (const p of region) regionGrid[p.y - minY][p.x - minX] = true;\n\n\t\treturn this.canTile(regionGrid, pieces);\n\t}\n\n\tprivate getShapeArea(shape: number[][]): number {\n\t\tlet area = 0;\n\t\tfor (const row of shape) for (const cell of row) if (cell) area++;\n\t\treturn area;\n\t}\n\n\t/**\n\t * \u518D\u5E30\u7684\u306B\u30BF\u30A4\u30EA\u30F3\u30B0\u3092\u8A66\u307F\u308B\n\t */\n\tprivate canTile(regionGrid: boolean[][], pieces: { shape: number[][]; rotatable: boolean }[]): boolean {\n\t\tlet r0 = -1;\n\t\tlet c0 = -1;\n\t\tfor (let r = 0; r < regionGrid.length; r++) {\n\t\t\tfor (let c = 0; c < regionGrid[0].length; c++) {\n\t\t\t\tif (regionGrid[r][c]) {\n\t\t\t\t\tr0 = r;\n\t\t\t\t\tc0 = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r0 !== -1) break;\n\t\t}\n\t\tif (r0 === -1) return pieces.length === 0;\n\t\tif (pieces.length === 0) return false;\n\n\t\tfor (let i = 0; i < pieces.length; i++) {\n\t\t\tconst piece = pieces[i];\n\t\t\tconst nextPieces = [...pieces.slice(0, i), ...pieces.slice(i + 1)];\n\t\t\tconst rotations = piece.rotatable ? this.getAllRotations(piece.shape) : [piece.shape];\n\n\t\t\tfor (const shape of rotations) {\n\t\t\t\tconst blocks: { r: number; c: number }[] = [];\n\t\t\t\tfor (let pr = 0; pr < shape.length; pr++) {\n\t\t\t\t\tfor (let pc = 0; pc < shape[0].length; pc++) {\n\t\t\t\t\t\tif (shape[pr][pc]) blocks.push({ r: pr, c: pc });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const anchor of blocks) {\n\t\t\t\t\tconst dr = r0 - anchor.r;\n\t\t\t\t\tconst dc = c0 - anchor.c;\n\t\t\t\t\tif (this.canPlace(regionGrid, shape, dr, dc)) {\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, false);\n\t\t\t\t\t\tif (this.canTile(regionGrid, nextPieces)) return true;\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate canPlace(regionGrid: boolean[][], shape: number[][], r: number, c: number): boolean {\n\t\tfor (let i = 0; i < shape.length; i++) {\n\t\t\tfor (let j = 0; j < shape[0].length; j++) {\n\t\t\t\tif (shape[i][j]) {\n\t\t\t\t\tconst nr = r + i;\n\t\t\t\t\tconst nc = c + j;\n\t\t\t\t\tif (nr < 0 || nr >= regionGrid.length || nc < 0 || nc >= regionGrid[0].length || !regionGrid[nr][nc]) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate placePiece(regionGrid: boolean[][], shape: number[][], r: number, c: number, value: boolean) {\n\t\tfor (let i = 0; i < shape.length; i++) for (let j = 0; j < shape[0].length; j++) if (shape[i][j]) regionGrid[r + i][c + j] = value;\n\t}\n\n\tprivate getAllRotations(shape: number[][]): number[][][] {\n\t\tconst results: number[][][] = [];\n\t\tconst keys = new Set<string>();\n\t\tlet curr = shape;\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tconst key = JSON.stringify(curr);\n\t\t\tif (!keys.has(key)) {\n\t\t\t\tresults.push(curr);\n\t\t\t\tkeys.add(key);\n\t\t\t}\n\t\t\tcurr = this.rotate90(curr);\n\t\t}\n\t\treturn results;\n\t}\n\n\tprivate rotate90(shape: number[][]): number[][] {\n\t\tconst rows = shape.length;\n\t\tconst cols = shape[0].length;\n\t\tconst newShape = Array.from({ length: cols }, () => Array(rows).fill(0));\n\t\tfor (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) newShape[c][rows - 1 - r] = shape[r][c];\n\t\treturn newShape;\n\t}\n\n\t/**\n\t * \u56DE\u7B54\u30D1\u30B9\u306B\u3088\u3063\u3066\u5206\u5272\u3055\u308C\u305F\u5404\u533A\u753B\u306E\u30BB\u30EB\u30EA\u30B9\u30C8\u3092\u53D6\u5F97\u3059\u308B\n\t */\n\tprivate calculateRegions(grid: Grid, path: Point[], symPath: Point[] = [], externalCellsPrecalculated?: Set<string>): Point[][] {\n\t\tconst regions: Point[][] = [];\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst visitedCells = new Uint8Array(rows * cols);\n\n\t\t// \u30A8\u30C3\u30B8\u306E\u30DE\u30B9\u30AF\u4F5C\u6210 (\u9AD8\u901F\u5316)\n\t\tconst hEdgesMask = new Uint8Array((rows + 1) * cols);\n\t\tconst vEdgesMask = new Uint8Array(rows * (cols + 1));\n\n\t\tconst setEdge = (p1: Point, p2: Point) => {\n\t\t\tif (p1.x === p2.x) {\n\t\t\t\tvEdgesMask[Math.min(p1.y, p2.y) * (cols + 1) + p1.x] = 1;\n\t\t\t} else {\n\t\t\t\thEdgesMask[p1.y * cols + Math.min(p1.x, p2.x)] = 1;\n\t\t\t}\n\t\t};\n\n\t\tfor (let i = 0; i < path.length - 1; i++) setEdge(path[i], path[i + 1]);\n\t\tfor (let i = 0; i < symPath.length - 1; i++) setEdge(symPath[i], symPath[i + 1]);\n\n\t\t// Absent\u30A8\u30C3\u30B8\u3082\u30DE\u30B9\u30AF\u306B\u8FFD\u52A0\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Absent) hEdgesMask[r * cols + c] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Absent) vEdgesMask[r * (cols + 1) + c] = 1;\n\t\t\t}\n\t\t}\n\n\t\tconst externalCells = externalCellsPrecalculated || this.getExternalCells(grid);\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tconst idx = r * cols + c;\n\t\t\t\tif (visitedCells[idx] || (externalCells && externalCells.has(`${c},${r}`))) continue;\n\n\t\t\t\tconst region: Point[] = [];\n\t\t\t\tconst queue: number[] = [idx];\n\t\t\t\tvisitedCells[idx] = 1;\n\n\t\t\t\tlet head = 0;\n\t\t\t\twhile (head < queue.length) {\n\t\t\t\t\tconst currIdx = queue[head++];\n\t\t\t\t\tconst cx = currIdx % cols;\n\t\t\t\t\tconst cy = Math.floor(currIdx / cols);\n\t\t\t\t\tregion.push({ x: cx, y: cy });\n\n\t\t\t\t\t// Neighbors: Up, Down, Left, Right\n\t\t\t\t\t// Up\n\t\t\t\t\tif (cy > 0 && !hEdgesMask[cy * cols + cx]) {\n\t\t\t\t\t\tconst nIdx = (cy - 1) * cols + cx;\n\t\t\t\t\t\tif (!visitedCells[nIdx] && (!externalCells || !externalCells.has(`${cx},${cy - 1}`))) {\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\n\t\t\t\t\t\t\tqueue.push(nIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Down\n\t\t\t\t\tif (cy < rows - 1 && !hEdgesMask[(cy + 1) * cols + cx]) {\n\t\t\t\t\t\tconst nIdx = (cy + 1) * cols + cx;\n\t\t\t\t\t\tif (!visitedCells[nIdx] && (!externalCells || !externalCells.has(`${cx},${cy + 1}`))) {\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\n\t\t\t\t\t\t\tqueue.push(nIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Left\n\t\t\t\t\tif (cx > 0 && !vEdgesMask[cy * (cols + 1) + cx]) {\n\t\t\t\t\t\tconst nIdx = cy * cols + (cx - 1);\n\t\t\t\t\t\tif (!visitedCells[nIdx] && (!externalCells || !externalCells.has(`${cx - 1},${cy}`))) {\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\n\t\t\t\t\t\t\tqueue.push(nIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Right\n\t\t\t\t\tif (cx < cols - 1 && !vEdgesMask[cy * (cols + 1) + (cx + 1)]) {\n\t\t\t\t\t\tconst nIdx = cy * cols + (cx + 1);\n\t\t\t\t\t\tif (!visitedCells[nIdx] && (!externalCells || !externalCells.has(`${cx + 1},${cy}`))) {\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\n\t\t\t\t\t\t\tqueue.push(nIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregions.push(region);\n\t\t\t}\n\t\t}\n\t\treturn regions;\n\t}\n\n\t/**\n\t * \u30A8\u30C3\u30B8\uFF08Absent\uFF09\u306B\u3088\u3063\u3066\u5916\u90E8\u306B\u7E4B\u304C\u3063\u3066\u3044\u308B\u30BB\u30EB\u3092\u7279\u5B9A\u3059\u308B\n\t */\n\tprivate getExternalCells(grid: Grid): Set<string> {\n\t\tconst external = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [];\n\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\tif (grid.hEdges[0][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},0`)) {\n\t\t\t\t\texternal.add(`${c},0`);\n\t\t\t\t\tqueue.push({ x: c, y: 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.hEdges[grid.rows][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},${grid.rows - 1}`)) {\n\t\t\t\t\texternal.add(`${c},${grid.rows - 1}`);\n\t\t\t\t\tqueue.push({ x: c, y: grid.rows - 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tif (grid.vEdges[r][0].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`0,${r}`)) {\n\t\t\t\t\texternal.add(`0,${r}`);\n\t\t\t\t\tqueue.push({ x: 0, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.vEdges[r][grid.cols].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${grid.cols - 1},${r}`)) {\n\t\t\t\t\texternal.add(`${grid.cols - 1},${r}`);\n\t\t\t\t\tqueue.push({ x: grid.cols - 1, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.hEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.hEdges[curr.y + 1][curr.x] },\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x + 1] },\n\t\t\t];\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\tif (!external.has(`${n.nx},${n.ny}`) && n.edge.type === EdgeType.Absent) {\n\t\t\t\t\t\texternal.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn external;\n\t}\n\n\tprivate getSymmetricalPoint(grid: Grid, p: Point): Point {\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\treturn { x: grid.cols - p.x, y: p.y };\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\treturn { x: p.x, y: grid.rows - p.y };\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\treturn { x: grid.cols - p.x, y: grid.rows - p.y };\n\t\t}\n\t\treturn { ...p };\n\t}\n\n\tprivate getSymmetricalPointIndex(grid: Grid, idx: number): number {\n\t\tconst nodeCols = grid.cols + 1;\n\t\tconst r = Math.floor(idx / nodeCols);\n\t\tconst c = idx % nodeCols;\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\tlet sr = r,\n\t\t\tsc = c;\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\tsc = grid.cols - c;\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\tsr = grid.rows - r;\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\tsc = grid.cols - c;\n\t\t\tsr = grid.rows - r;\n\t\t}\n\t\treturn sr * nodeCols + sc;\n\t}\n\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u306E\u96E3\u6613\u5EA6\u30B9\u30B3\u30A2(0.0-1.0)\u3092\u7B97\u51FA\u3059\u308B\n\t */\n\tpublic calculateDifficulty(grid: Grid): number {\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst nodeCols = cols + 1;\n\t\tconst nodeCount = (rows + 1) * nodeCols;\n\t\tconst adj = Array.from({ length: nodeCount }, () => [] as { next: number; isHexagon: boolean; isBroken: boolean }[]);\n\t\tconst startNodes: number[] = [];\n\t\tconst endNodes: number[] = [];\n\t\tconst hexagonEdges = new Set<string>();\n\t\tconst hexagonNodes = new Set<number>();\n\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tconst u = r * nodeCols + c;\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Start) startNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.End) endNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Hexagon) hexagonNodes.add(u);\n\n\t\t\t\tif (c < cols) {\n\t\t\t\t\tconst v = u + 1;\n\t\t\t\t\tconst type = grid.hEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r }));\n\t\t\t\t}\n\t\t\t\tif (r < rows) {\n\t\t\t\t\tconst v = u + nodeCols;\n\t\t\t\t\tconst type = grid.vEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 }));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst stats = { totalNodesVisited: 0, branchingPoints: 0, solutions: 0, maxDepth: 0, backtracks: 0 };\n\t\tconst totalHexagons = hexagonEdges.size + hexagonNodes.size;\n\t\tconst fingerprints = new Set<string>();\n\n\t\t// \u76E4\u9762\u306E\u5927\u304D\u3055\u306B\u5408\u308F\u305B\u3066\u63A2\u7D22\u30EA\u30DF\u30C3\u30C8\u3092\u8ABF\u6574\n\t\tconst searchLimit = Math.max(1000, rows * cols * 200);\n\t\tconst externalCells = this.getExternalCells(grid);\n\n\t\t// \u30BB\u30EB\u30DE\u30FC\u30AF\uFF08\u56DB\u89D2\u3001\u661F\u3001\u30C6\u30C8\u30EA\u30B9\u3001\u6D88\u3057\u30B4\u30E0\uFF09\u304C\u3042\u308B\u304B\u4E8B\u524D\u306B\u30C1\u30A7\u30C3\u30AF\n\t\tlet hasCellMarks = false;\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tif (grid.cells[r][c].type !== CellType.None) {\n\t\t\t\t\thasCellMarks = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasCellMarks) break;\n\t\t}\n\n\t\tfor (const startIdx of startNodes) {\n\t\t\tconst startIsHex = hexagonNodes.has(startIdx) ? 1 : 0;\n\t\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\t\tlet visitedMask = 1n << BigInt(startIdx);\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snStart = this.getSymmetricalPointIndex(grid, startIdx);\n\t\t\t\tif (snStart === startIdx) continue; // \u30B9\u30BF\u30FC\u30C8\u4F4D\u7F6E\u304C\u5BFE\u79F0\u70B9\uFF08\u8EF8\u4E0A\uFF09\u306A\u3089\u4E0D\u9069\uFF08\u901A\u5E38\u907F\u3051\u308B\uFF09\n\t\t\t\tvisitedMask |= 1n << BigInt(snStart);\n\t\t\t}\n\n\t\t\tthis.exploreSearchSpace(grid, startIdx, visitedMask, [startIdx], startIsHex, totalHexagons, adj, endNodes, fingerprints, stats, searchLimit, externalCells, hasCellMarks);\n\t\t}\n\n\t\tif (stats.solutions === 0) return 0;\n\n\t\tlet constraintCount = hexagonEdges.size + hexagonNodes.size;\n\t\tconst constraintTypes = new Set<number>();\n\t\tif (hexagonEdges.size > 0) constraintTypes.add(999);\n\n\t\tlet tetrisCount = 0;\n\t\tlet rotatedTetrisCount = 0;\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tconst cell = grid.cells[r][c];\n\t\t\t\tif (cell.type !== CellType.None) {\n\t\t\t\t\tconstraintCount++;\n\t\t\t\t\tconstraintTypes.add(cell.type);\n\t\t\t\t\tif (cell.type === CellType.Tetris) tetrisCount++;\n\t\t\t\t\telse if (cell.type === CellType.TetrisRotated) {\n\t\t\t\t\t\ttetrisCount++;\n\t\t\t\t\t\trotatedTetrisCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst branchingFactor = stats.branchingPoints / (stats.totalNodesVisited || 1);\n\t\tconst searchComplexity = Math.log10(stats.totalNodesVisited + 1);\n\t\t// \u89E3\u306E\u6570\u304C\u591A\u3044\u307B\u3069\u96E3\u6613\u5EA6\u3092\u4E0B\u3052\u308B\u3002\u30B9\u30B1\u30FC\u30EB\u3092\u8ABF\u6574\n\t\tlet difficulty = (branchingFactor * 10 + searchComplexity * 1.5) / (Math.log2(stats.solutions + 1) * 0.5 + 1);\n\n\t\t// \u30A8\u30C3\u30B8\u306E\u516D\u89D2\u5F62\u304C\u591A\u3044\u307B\u3069\u7C21\u5358\u306B\u306A\u308B\uFF08\u30AC\u30A4\u30C9\u306B\u306A\u308B\u305F\u3081\uFF09\n\t\tdifficulty -= hexagonEdges.size * 0.05;\n\t\t// \u30CE\u30FC\u30C9\u306E\u516D\u89D2\u5F62\u306F\u96E3\u6613\u5EA6\u3092\u4E0A\u3052\u308B\uFF08\u901A\u904E\u304C\u5F37\u5236\u3055\u308C\u308B\u305F\u3081\uFF09\n\t\tdifficulty += hexagonNodes.size * 0.12;\n\n\t\tif (tetrisCount > 0) {\n\t\t\tdifficulty += rotatedTetrisCount * 0.5;\n\t\t\tdifficulty += (tetrisCount - rotatedTetrisCount) * 0.2;\n\t\t}\n\n\t\tconst cellCount = rows * cols;\n\t\tconst density = constraintCount / cellCount;\n\t\t// \u5BC6\u5EA6\u304C\u4F4E\u3059\u304E\u308B\u3068\u6025\u6FC0\u306B\u96E3\u6613\u5EA6\u304C\u4E0B\u304C\u308B\u3088\u3046\u306B\u8ABF\u6574\u3002\u3088\u308A\u53B3\u3057\u304F\u3002\n\t\tconst densityFactor = density < 0.25 ? Math.pow(density / 0.25, 4) : 1.0;\n\t\tconst typeFactor = constraintTypes.size <= 1 ? 0.5 : 1.0;\n\n\t\tdifficulty *= densityFactor * typeFactor;\n\t\t// \u76E4\u9762\u30B5\u30A4\u30BA\u306B\u3088\u308B\u88DC\u6B63\u3092\u7DE9\u3084\u304B\u306B\n\t\tconst sizeFactor = Math.log2(cellCount) / 5;\n\t\tdifficulty *= sizeFactor;\n\n\t\treturn Math.max(0.01, Math.min(1.0, difficulty / 4));\n\t}\n\n\t/**\n\t * \u63A2\u7D22\u7A7A\u9593\u3092\u8D70\u67FB\u3057\u3066\u7D71\u8A08\u60C5\u5831\u3092\u53CE\u96C6\u3059\u308B\n\t */\n\tprivate exploreSearchSpace(grid: Grid, currIdx: number, visitedMask: bigint, path: number[], hexagonsOnPath: number, totalHexagons: number, adj: { next: number; isHexagon: boolean; isBroken: boolean }[][], endNodes: number[], fingerprints: Set<string>, stats: { totalNodesVisited: number; branchingPoints: number; solutions: number; maxDepth: number; backtracks: number }, limit: number, externalCells?: Set<string>, hasCellMarks: boolean = true): void {\n\t\tstats.totalNodesVisited++;\n\t\tstats.maxDepth = Math.max(stats.maxDepth, path.length);\n\t\tif (stats.totalNodesVisited > limit) return;\n\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\n\t\tif (endNodes.includes(currIdx)) {\n\t\t\tif (hexagonsOnPath === totalHexagons) {\n\t\t\t\tconst points = path.map((idx) => ({ x: idx % (grid.cols + 1), y: Math.floor(idx / (grid.cols + 1)) }));\n\t\t\t\tconst solutionPath = { points };\n\t\t\t\t// symmetry\u30E2\u30FC\u30C9\u306E\u969B\u3001\u3082\u3046\u4E00\u65B9\u3082EndNode\u306B\u3044\u308B\u5FC5\u8981\u304C\u3042\u308B\n\t\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\t\tconst snEnd = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\t\tconst nodeCols = grid.cols + 1;\n\t\t\t\t\tif (grid.nodes[Math.floor(snEnd / nodeCols)][snEnd % nodeCols].type !== NodeType.End) return;\n\t\t\t\t}\n\n\t\t\t\tconst symPathPoints = symmetry !== SymmetryType.None ? points.map((p) => this.getSymmetricalPoint(grid, p)) : [];\n\t\t\t\t// \u30BB\u30EB\u30DE\u30FC\u30AF\u304C\u306A\u3044\u5834\u5408\u306F\u3001\u3053\u306E\u6642\u70B9\u3067\u6709\u52B9\u306A\u89E3\u3068\u3057\u3066\u78BA\u5B9A\u3067\u304D\u308B\uFF08DFS\u306B\u3088\u308A\u30D1\u30B9\u306E\u6B63\u5F53\u6027\u3068\u5168\u516D\u89D2\u5F62\u901A\u904E\u306F\u4FDD\u8A3C\u6E08\u307F\uFF09\n\t\t\t\tif (!hasCellMarks) {\n\t\t\t\t\tconst fp = this.getFingerprint(grid, points, symPathPoints, undefined, externalCells);\n\t\t\t\t\tif (!fingerprints.has(fp)) {\n\t\t\t\t\t\tfingerprints.add(fp);\n\t\t\t\t\t\tstats.solutions++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// \u30BB\u30EB\u30DE\u30FC\u30AF\u304C\u3042\u308B\u5834\u5408\u306F\u8A73\u7D30\u306A\u691C\u8A3C\u3092\u884C\u3046\n\t\t\t\t\tconst result = this.validateFast(grid, points, symPathPoints, externalCells);\n\t\t\t\t\tif (result.isValid) {\n\t\t\t\t\t\tconst fp = this.getFingerprint(grid, points, symPathPoints, result.regions, externalCells);\n\t\t\t\t\t\tif (!fingerprints.has(fp)) {\n\t\t\t\t\t\t\tfingerprints.add(fp);\n\t\t\t\t\t\t\tstats.solutions++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.canReachEndOptimized(currIdx, visitedMask, adj, endNodes)) {\n\t\t\tstats.backtracks++;\n\t\t\treturn;\n\t\t}\n\n\t\tconst validMoves = [];\n\t\tfor (const edge of adj[currIdx]) {\n\t\t\tif (edge.isBroken) continue;\n\t\t\tif (visitedMask & (1n << BigInt(edge.next))) continue;\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snCurr = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\n\t\t\t\t// \u5BFE\u79F0\u70B9\u3068\u306E\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\n\t\t\t\tif (edge.next === snNext) continue; // \u30CE\u30FC\u30C9\u885D\u7A81\n\t\t\t\tif (currIdx === snNext && edge.next === snCurr) continue; // \u30A8\u30C3\u30B8\u885D\u7A81\uFF08\u53CD\u5BFE\u5411\u304D\uFF09\n\t\t\t}\n\n\t\t\t// \u516D\u89D2\u5F62\u306E\u679D\u5208\u308A\uFF08\u73FE\u5728\u306E\u30CE\u30FC\u30C9\u304B\u3089\u5FC5\u9808\u30A8\u30C3\u30B8\u304C\u51FA\u3066\u3044\u308B\u304C\u3001\u305D\u308C\u3092\u9078\u3070\u306A\u3044\u5834\u5408\u306F\u7121\u52B9\uFF09\n\t\t\tlet possible = true;\n\t\t\tfor (const otherEdge of adj[currIdx]) {\n\t\t\t\tif (otherEdge.isHexagon) {\n\t\t\t\t\tconst isAlreadyOnPath = path.length >= 2 && otherEdge.next === path[path.length - 2];\n\t\t\t\t\tconst isNextMove = otherEdge.next === edge.next;\n\t\t\t\t\tif (!isAlreadyOnPath && !isNextMove) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (possible) validMoves.push(edge);\n\t\t}\n\n\t\tif (validMoves.length > 1) stats.branchingPoints++;\n\n\t\t// \u5927\u304D\u306A\u76E4\u9762\u3067\u306F\u63A2\u7D22\u304C\u30EA\u30DF\u30C3\u30C8\u306B\u9054\u3057\u3084\u3059\u3044\u305F\u3081\u3001\u63A2\u7D22\u9806\u5E8F\u3092\u30E9\u30F3\u30C0\u30E0\u5316\u3057\u3066\n\t\t// \u5C11\u306A\u304F\u3068\u3082\u3044\u304F\u3064\u304B\u306E\u89E3\u3092\u898B\u3064\u3051\u3084\u3059\u304F\u3059\u308B\n\t\tif (grid.rows * grid.cols > 30) {\n\t\t\tfor (let i = validMoves.length - 1; i > 0; i--) {\n\t\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t\t[validMoves[i], validMoves[j]] = [validMoves[j], validMoves[i]];\n\t\t\t}\n\t\t}\n\n\t\tconst nodeCols = grid.cols + 1;\n\t\tfor (const move of validMoves) {\n\t\t\tconst nodeIsHex = grid.nodes[Math.floor(move.next / nodeCols)][move.next % nodeCols].type === NodeType.Hexagon ? 1 : 0;\n\t\t\tpath.push(move.next);\n\n\t\t\tlet nextVisitedMask = visitedMask | (1n << BigInt(move.next));\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, move.next);\n\t\t\t\tnextVisitedMask |= 1n << BigInt(snNext);\n\t\t\t}\n\n\t\t\tthis.exploreSearchSpace(grid, move.next, nextVisitedMask, path, hexagonsOnPath + (move.isHexagon ? 1 : 0) + nodeIsHex, totalHexagons, adj, endNodes, fingerprints, stats, limit, externalCells, hasCellMarks);\n\t\t\tpath.pop();\n\t\t\tif (stats.totalNodesVisited > limit) return;\n\t\t}\n\t}\n\n\t/**\n\t * \u6B63\u89E3\u6570\u3092\u30AB\u30A6\u30F3\u30C8\u3059\u308B\n\t */\n\tpublic countSolutions(grid: Grid, limit: number = 100): number {\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst nodeCols = cols + 1;\n\t\tconst nodeCount = (rows + 1) * nodeCols;\n\t\tconst adj = Array.from({ length: nodeCount }, () => [] as { next: number; isHexagon: boolean; isBroken: boolean }[]);\n\t\tconst startNodes: number[] = [];\n\t\tconst endNodes: number[] = [];\n\t\tconst hexagonEdges = new Set<string>();\n\t\tconst hexagonNodes = new Set<number>();\n\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tconst u = r * nodeCols + c;\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Start) startNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.End) endNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Hexagon) hexagonNodes.add(u);\n\n\t\t\t\tif (c < cols) {\n\t\t\t\t\tconst v = u + 1;\n\t\t\t\t\tconst type = grid.hEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r }));\n\t\t\t\t}\n\t\t\t\tif (r < rows) {\n\t\t\t\t\tconst v = u + nodeCols;\n\t\t\t\t\tconst type = grid.vEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 }));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst fingerprints = new Set<string>();\n\t\tconst totalHexagons = hexagonEdges.size + hexagonNodes.size;\n\t\tconst externalCells = this.getExternalCells(grid);\n\n\t\t// \u30BB\u30EB\u30DE\u30FC\u30AF\uFF08\u56DB\u89D2\u3001\u661F\u3001\u30C6\u30C8\u30EA\u30B9\u3001\u6D88\u3057\u30B4\u30E0\uFF09\u304C\u3042\u308B\u304B\u4E8B\u524D\u306B\u30C1\u30A7\u30C3\u30AF\n\t\tlet hasCellMarks = false;\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tif (grid.cells[r][c].type !== CellType.None) {\n\t\t\t\t\thasCellMarks = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasCellMarks) break;\n\t\t}\n\n\t\tfor (const startIdx of startNodes) {\n\t\t\tconst startIsHex = hexagonNodes.has(startIdx) ? 1 : 0;\n\t\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\t\tlet visitedMask = 1n << BigInt(startIdx);\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snStart = this.getSymmetricalPointIndex(grid, startIdx);\n\t\t\t\tif (snStart === startIdx) continue;\n\t\t\t\tvisitedMask |= 1n << BigInt(snStart);\n\t\t\t}\n\t\t\tthis.findPathsOptimized(grid, startIdx, visitedMask, [startIdx], startIsHex, totalHexagons, adj, endNodes, fingerprints, limit, externalCells, hasCellMarks);\n\t\t}\n\t\treturn fingerprints.size;\n\t}\n\n\tprivate findPathsOptimized(grid: Grid, currIdx: number, visitedMask: bigint, path: number[], hexagonsOnPath: number, totalHexagons: number, adj: { next: number; isHexagon: boolean; isBroken: boolean }[][], endNodes: number[], fingerprints: Set<string>, limit: number, externalCells?: Set<string>, hasCellMarks: boolean = true): void {\n\t\tif (fingerprints.size >= limit) return;\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\n\t\tif (endNodes.includes(currIdx)) {\n\t\t\tif (hexagonsOnPath === totalHexagons) {\n\t\t\t\tconst points = path.map((idx) => ({ x: idx % (grid.cols + 1), y: Math.floor(idx / (grid.cols + 1)) }));\n\t\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\t\tconst snEnd = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\t\tconst nodeCols = grid.cols + 1;\n\t\t\t\t\tif (grid.nodes[Math.floor(snEnd / nodeCols)][snEnd % nodeCols].type !== NodeType.End) return;\n\t\t\t\t}\n\n\t\t\t\tconst symPathPoints = symmetry !== SymmetryType.None ? points.map((p) => this.getSymmetricalPoint(grid, p)) : [];\n\t\t\t\tif (!hasCellMarks) {\n\t\t\t\t\tfingerprints.add(this.getFingerprint(grid, points, symPathPoints, undefined, externalCells));\n\t\t\t\t} else {\n\t\t\t\t\tconst result = this.validateFast(grid, points, symPathPoints, externalCells);\n\t\t\t\t\tif (result.isValid) {\n\t\t\t\t\t\tfingerprints.add(this.getFingerprint(grid, points, symPathPoints, result.regions, externalCells));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (!this.canReachEndOptimized(currIdx, visitedMask, adj, endNodes)) return;\n\t\tfor (const edge of adj[currIdx]) {\n\t\t\tif (edge.isBroken) continue;\n\t\t\tif (visitedMask & (1n << BigInt(edge.next))) continue;\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snCurr = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\t\t\t\tif (edge.next === snNext) continue;\n\t\t\t\tif (currIdx === snNext && edge.next === snCurr) continue;\n\t\t\t}\n\n\t\t\tlet possible = true;\n\t\t\tfor (const otherEdge of adj[currIdx]) {\n\t\t\t\tif (otherEdge.isHexagon) {\n\t\t\t\t\tconst isAlreadyOnPath = path.length >= 2 && otherEdge.next === path[path.length - 2];\n\t\t\t\t\tconst isNextMove = otherEdge.next === edge.next;\n\t\t\t\t\tif (!isAlreadyOnPath && !isNextMove) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!possible) continue;\n\n\t\t\tconst nodeCols = grid.cols + 1;\n\t\t\tconst nodeIsHex = grid.nodes[Math.floor(edge.next / nodeCols)][edge.next % nodeCols].type === NodeType.Hexagon ? 1 : 0;\n\t\t\tpath.push(edge.next);\n\n\t\t\tlet nextVisitedMask = visitedMask | (1n << BigInt(edge.next));\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\t\t\t\tnextVisitedMask |= 1n << BigInt(snNext);\n\t\t\t}\n\n\t\t\tthis.findPathsOptimized(grid, edge.next, nextVisitedMask, path, hexagonsOnPath + (edge.isHexagon ? 1 : 0) + nodeIsHex, totalHexagons, adj, endNodes, fingerprints, limit, externalCells, hasCellMarks);\n\t\t\tpath.pop();\n\t\t\tif (fingerprints.size >= limit) return;\n\t\t}\n\t}\n\n\t/**\n\t * \u7D42\u7AEF\u307E\u3067\u5230\u9054\u53EF\u80FD\u304B\u30D3\u30C3\u30C8\u30DE\u30B9\u30AFBFS\u3067\u9AD8\u901F\u306B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate canReachEndOptimized(curr: number, visitedMask: bigint, adj: { next: number; isBroken: boolean }[][], endNodes: number[]): boolean {\n\t\tlet queue = [curr];\n\t\tlet localVisited = visitedMask;\n\t\tlet head = 0;\n\t\twhile (head < queue.length) {\n\t\t\tconst u = queue[head++];\n\t\t\tif (endNodes.includes(u)) return true;\n\t\t\tfor (const edge of adj[u])\n\t\t\t\tif (!edge.isBroken && !(localVisited & (1n << BigInt(edge.next)))) {\n\t\t\t\t\tlocalVisited |= 1n << BigInt(edge.next);\n\t\t\t\t\tqueue.push(edge.next);\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u30D1\u30B9\u306E\u8AD6\u7406\u7684\u306A\u6307\u7D0B\u3092\u53D6\u5F97\u3059\u308B\uFF08\u533A\u753B\u5206\u3051\u306B\u57FA\u3065\u304D\u3001\u540C\u4E00\u89E3\u3092\u6392\u9664\u3059\u308B\u305F\u3081\uFF09\n\t */\n\tprivate getFingerprint(grid: Grid, path: Point[], symPath: Point[], precalculatedRegions?: Point[][], externalCells?: Set<string>): string {\n\t\tconst regions = precalculatedRegions || this.calculateRegions(grid, path, symPath, externalCells);\n\t\tconst regionFingerprints = regions\n\t\t\t.map((region) => {\n\t\t\t\tlet regionStr = \"\";\n\t\t\t\tconst marks = [];\n\t\t\t\tfor (const p of region) {\n\t\t\t\t\tconst c = grid.cells[p.y][p.x];\n\t\t\t\t\tif (c.type !== CellType.None) {\n\t\t\t\t\t\tmarks.push((c.type << 8) | c.color);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmarks.sort((a, b) => a - b);\n\t\t\t\tfor (const m of marks) regionStr += m.toString(36) + \",\";\n\t\t\t\treturn regionStr;\n\t\t\t})\n\t\t\t.sort();\n\n\t\tlet finalFp = \"\";\n\t\tfor (const rf of regionFingerprints) {\n\t\t\tif (rf.length > 0) finalFp += rf + \"|\";\n\t\t}\n\t\treturn finalFp || \"empty\";\n\t}\n}\n", "import { Grid } from \"./grid\";\nimport { CellType, Color, type EdgeConstraint, EdgeType, type GenerationOptions, NodeType, type Point, SymmetryType } from \"./types\";\nimport { PuzzleValidator } from \"./validator\";\n\n/**\n * \u30D1\u30BA\u30EB\u3092\u81EA\u52D5\u751F\u6210\u3059\u308B\u30AF\u30E9\u30B9\n */\nexport class PuzzleGenerator {\n\tprivate isWorker: boolean;\n\n\tconstructor() {\n\t\tthis.isWorker = typeof self !== \"undefined\" && \"postMessage\" in self && !(\"document\" in self);\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u3092\u751F\u6210\u3059\u308B\n\t * @param rows \u884C\u6570\n\t * @param cols \u5217\u6570\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\n\t * @returns \u751F\u6210\u3055\u308C\u305F\u30B0\u30EA\u30C3\u30C9\n\t */\n\tpublic generate(rows: number, cols: number, options: GenerationOptions = {}): Grid {\n\t\tconst targetDifficulty = options.difficulty ?? 0.5;\n\t\tconst validator = new PuzzleValidator();\n\t\tlet bestGrid: Grid | null = null;\n\t\tlet bestScore = -1;\n\n\t\t// \u8A66\u884C\u56DE\u6570\u306E\u8A2D\u5B9A\n\t\t// Worker\u6642\u306F\u3001\u30E1\u30A4\u30F3\u30B9\u30EC\u30C3\u30C9\u3092\u6B62\u3081\u306A\u3044\u305F\u3081\u3001\u3088\u308A\u591A\u304F\u306E\u8A66\u884C\u3092\u9AD8\u901F\u306B\u884C\u3046\n\t\tconst maxAttempts = this.isWorker ? (rows * cols > 30 ? 150 : 120) : rows * cols > 30 ? 100 : 80;\n\t\tconst markAttemptsPerPath = this.isWorker ? 8 : 5;\n\n\t\tconst symmetry = options.symmetry || SymmetryType.None;\n\t\tlet startPoint: Point = { x: 0, y: rows };\n\t\tlet endPoint: Point = { x: cols, y: 0 };\n\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\t// \u5DE6\u53F3\u5BFE\u79F0\uFF1A\u30B9\u30BF\u30FC\u30C8\u3068\u540C\u3058\u5074\uFF08\u5DE6\u5074\uFF09\u306B\u30B4\u30FC\u30EB\u3092\u7F6E\u304F\u3053\u3068\u3067\u3001\u8EF8\u3092\u8DE8\u3050\u5FC5\u8981\u3092\u306A\u304F\u3059\n\t\t\tendPoint = { x: 0, y: 0 };\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\t// \u4E0A\u4E0B\u5BFE\u79F0\uFF1A\u30B9\u30BF\u30FC\u30C8\u3068\u540C\u3058\u5074\uFF08\u4E0B\u5074\uFF09\u306B\u30B4\u30FC\u30EB\u3092\u7F6E\u304F\n\t\t\tendPoint = { x: cols, y: rows };\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\t// \u70B9\u5BFE\u79F0\uFF1A\u70B9\u5BFE\u79F0\u306A\u30B9\u30BF\u30FC\u30C8\u3068\u30B4\u30FC\u30EB\u304C\u91CD\u306A\u3089\u306A\u3044\u3088\u3046\u306B\u914D\u7F6E\n\t\t\tendPoint = { x: cols, y: rows };\n\t\t}\n\n\t\tlet currentPath: Point[] | null = null;\n\t\tlet precalculatedRegions: Point[][] | null = null;\n\t\tlet precalculatedBoundaryEdges: { type: \"h\" | \"v\"; r: number; c: number }[][] | null = null;\n\n\t\tfor (let attempt = 0; attempt < maxAttempts; attempt++) {\n\t\t\t// \u4E00\u5B9A\u56DE\u6570\u3054\u3068\u306B\u65B0\u3057\u3044\u30D1\u30B9\u3092\u751F\u6210\u3059\u308B\n\t\t\tif (attempt % markAttemptsPerPath === 0) {\n\t\t\t\tcurrentPath = this.generateRandomPath(new Grid(rows, cols), startPoint, endPoint, options.pathLength, symmetry);\n\n\t\t\t\t// \u30D1\u30B9\u304C\u6C7A\u307E\u3063\u305F\u6642\u70B9\u3067\u3001\u533A\u753B\u3068\u5883\u754C\u30A8\u30C3\u30B8\u3092\u8A08\u7B97\u3057\u3066\u304A\u304F\uFF08\u30DE\u30FC\u30AF\u751F\u6210\u3067\u6D41\u7528\uFF09\n\t\t\t\tconst tempGrid = new Grid(rows, cols);\n\t\t\t\tconst symPath = symmetry !== SymmetryType.None ? currentPath.map((p) => this.getSymmetricalPoint(tempGrid, p, symmetry)) : [];\n\t\t\t\tprecalculatedRegions = this.calculateRegions(tempGrid, currentPath, symPath);\n\t\t\t\tprecalculatedBoundaryEdges = precalculatedRegions.map((region) => this.getRegionBoundaryEdges(tempGrid, region, currentPath!, symPath));\n\t\t\t}\n\n\t\t\tconst grid = this.generateFromPath(rows, cols, currentPath!, options, precalculatedRegions!, precalculatedBoundaryEdges!);\n\n\t\t\t// \u5FC5\u9808\u5236\u7D04\u304C\u542B\u307E\u308C\u3066\u3044\u308B\u304B\u78BA\u8A8D\n\t\t\tif (!this.checkAllRequestedConstraintsPresent(grid, options)) continue;\n\n\t\t\t// \u96E3\u6613\u5EA6\u306E\u7B97\u51FA\n\t\t\tconst difficulty = validator.calculateDifficulty(grid);\n\t\t\tif (difficulty === 0) continue;\n\n\t\t\tconst diffFromTarget = Math.abs(difficulty - targetDifficulty);\n\t\t\tif (bestGrid === null || diffFromTarget < Math.abs(bestScore - targetDifficulty)) {\n\t\t\t\tbestScore = difficulty;\n\t\t\t\tbestGrid = grid;\n\t\t\t}\n\n\t\t\t// \u30BF\u30FC\u30B2\u30C3\u30C8\u306B\u8FD1\u3044\u5834\u5408\u306F\u65E9\u671F\u7D42\u4E86\n\t\t\tif (targetDifficulty > 0.8 && difficulty > 0.8) break;\n\t\t\tif (diffFromTarget < 0.01) break; // \u3088\u308A\u53B3\u3057\u304F\u65E9\u671F\u7D42\u4E86\u5224\u5B9A\n\t\t}\n\n\t\t// \u898B\u3064\u304B\u3089\u306A\u304B\u3063\u305F\u5834\u5408\u306F\u6700\u5F8C\u306B\u751F\u6210\u3057\u305F\u3082\u306E\u3092\u8FD4\u3059\uFF08\u901A\u5E38\u306F\u3042\u308A\u3048\u306A\u3044\uFF09\n\t\tif (!bestGrid) {\n\t\t\tconst path = this.generateRandomPath(new Grid(rows, cols), startPoint, endPoint, options.pathLength, symmetry);\n\t\t\treturn this.generateFromPath(rows, cols, path, options);\n\t\t}\n\t\treturn bestGrid;\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u30D1\u30BA\u30EB\u3092\u69CB\u7BC9\u3059\u308B\n\t */\n\tprivate generateFromPath(rows: number, cols: number, solutionPath: Point[], options: GenerationOptions, precalculatedRegions?: Point[][], precalculatedBoundaryEdges?: { type: \"h\" | \"v\"; r: number; c: number }[][]): Grid {\n\t\tconst grid = new Grid(rows, cols);\n\t\tconst symmetry = options.symmetry || SymmetryType.None;\n\t\tgrid.symmetry = symmetry;\n\n\t\tlet startPoint: Point = { x: 0, y: rows };\n\t\tlet endPoint: Point = { x: cols, y: 0 };\n\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\tendPoint = { x: 0, y: 0 };\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\tendPoint = { x: cols, y: rows };\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\tendPoint = { x: cols, y: rows };\n\t\t}\n\n\t\tgrid.nodes[startPoint.y][startPoint.x].type = NodeType.Start;\n\t\tgrid.nodes[endPoint.y][endPoint.x].type = NodeType.End;\n\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tconst symStart = this.getSymmetricalPoint(grid, startPoint, symmetry);\n\t\t\tconst symEnd = this.getSymmetricalPoint(grid, endPoint, symmetry);\n\t\t\tgrid.nodes[symStart.y][symStart.x].type = NodeType.Start;\n\t\t\tgrid.nodes[symEnd.y][symEnd.x].type = NodeType.End;\n\t\t}\n\n\t\t// \u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u5236\u7D04\uFF08\u8A18\u53F7\uFF09\u3092\u914D\u7F6E\n\t\tconst symPath = symmetry !== SymmetryType.None ? solutionPath.map((p) => this.getSymmetricalPoint(grid, p, symmetry)) : [];\n\t\tthis.applyConstraintsBasedOnPath(grid, solutionPath, options, symPath, precalculatedRegions, precalculatedBoundaryEdges);\n\n\t\t// \u65AD\u7DDA\u30A8\u30C3\u30B8\u306E\u9069\u7528\n\t\tif (options.useBrokenEdges) {\n\t\t\tthis.applyBrokenEdges(grid, solutionPath, options);\n\t\t}\n\n\t\t// \u4E0D\u8981\u306A\u30A8\u30C3\u30B8\u306E\u524A\u9664\uFF08Absent\u5316\uFF09\u3068\u30AF\u30EA\u30FC\u30CB\u30F3\u30B0\n\t\tthis.cleanGrid(grid);\n\t\treturn grid;\n\t}\n\n\t/**\n\t * \u30E9\u30F3\u30C0\u30E0\u306A\u6B63\u89E3\u30D1\u30B9\u3092\u751F\u6210\u3059\u308B\n\t * @param targetLengthFactor 0.0 (\u6700\u77ED) - 1.0 (\u6700\u9577)\n\t */\n\tprivate generateRandomPath(grid: Grid, start: Point, end: Point, targetLengthFactor?: number, symmetry: SymmetryType = SymmetryType.None): Point[] {\n\t\tif (targetLengthFactor === undefined) {\n\t\t\treturn this.generateSingleRandomPath(grid, start, end, undefined, symmetry);\n\t\t}\n\n\t\t// \u6307\u5B9A\u3055\u308C\u305F\u9577\u3055\u306B\u8FD1\u3044\u30D1\u30B9\u3092\u63A2\u3059\n\t\tconst minLen = grid.rows + grid.cols;\n\t\tconst maxLen = (grid.rows + 1) * (grid.cols + 1) - 1;\n\t\tconst targetLen = minLen + targetLengthFactor * (maxLen - minLen);\n\n\t\tlet bestPath: Point[] = [];\n\t\tlet bestDiff = Infinity;\n\n\t\tconst attempts = grid.rows * grid.cols > 30 ? 30 : 50;\n\t\tfor (let i = 0; i < attempts; i++) {\n\t\t\t// \u6700\u521D\u306E\u65B9\u306E\u8A66\u884C\u306F\u30D0\u30A4\u30A2\u30B9\u3092\u5F37\u3081\u306B\u304B\u3051\u308B\n\t\t\tconst currentPath = this.generateSingleRandomPath(grid, start, end, targetLengthFactor, symmetry);\n\t\t\tif (currentPath.length === 0) continue;\n\n\t\t\tconst currentLen = currentPath.length - 1;\n\t\t\tconst diff = Math.abs(currentLen - targetLen);\n\n\t\t\tif (diff < bestDiff) {\n\t\t\t\tbestDiff = diff;\n\t\t\t\tbestPath = currentPath;\n\t\t\t}\n\n\t\t\t// \u5341\u5206\u306B\u8FD1\u3044\u30D1\u30B9\u304C\u898B\u3064\u304B\u3063\u305F\u3089\u7D42\u4E86\n\t\t\tif (bestDiff <= 2) break;\n\t\t}\n\n\t\treturn bestPath;\n\t}\n\n\t/**\n\t * 1\u672C\u306E\u30E9\u30F3\u30C0\u30E0\u30D1\u30B9\u3092\u751F\u6210\u3059\u308B\n\t */\n\tprivate generateSingleRandomPath(grid: Grid, start: Point, end: Point, biasFactor?: number, symmetry: SymmetryType = SymmetryType.None): Point[] {\n\t\tconst visited = new Set<string>();\n\t\tconst path: Point[] = [];\n\t\tlet nodesVisited = 0;\n\t\tconst limit = grid.rows * grid.cols * 20;\n\n\t\tconst findPath = (current: Point): boolean => {\n\t\t\tnodesVisited++;\n\t\t\tif (nodesVisited > limit) return false;\n\n\t\t\tvisited.add(`${current.x},${current.y}`);\n\t\t\tconst snCurrent = this.getSymmetricalPoint(grid, current, symmetry);\n\t\t\tvisited.add(`${snCurrent.x},${snCurrent.y}`);\n\n\t\t\tpath.push(current);\n\t\t\tif (current.x === end.x && current.y === end.y) return true;\n\n\t\t\tlet neighbors = this.getValidNeighbors(grid, current, visited);\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tneighbors = neighbors.filter((n) => {\n\t\t\t\t\tconst sn = this.getSymmetricalPoint(grid, n, symmetry);\n\t\t\t\t\tif (sn.x < 0 || sn.x > grid.cols || sn.y < 0 || sn.y > grid.rows) return false;\n\t\t\t\t\tif (visited.has(`${sn.x},${sn.y}`)) return false;\n\t\t\t\t\t// \u30CE\u30FC\u30C9\u885D\u7A81\uFF08\u73FE\u5728\u306E\u79FB\u52D5\u5148\u304C\u81EA\u5206\u81EA\u8EAB\u306E\u5BFE\u79F0\u70B9\u3067\u3042\u308B\u5834\u5408\u3082NG\uFF09\n\t\t\t\t\tif (n.x === sn.x && n.y === sn.y) return false;\n\t\t\t\t\t// \u30A8\u30C3\u30B8\u885D\u7A81\n\t\t\t\t\tconst edgeKey = this.getEdgeKey(current, n);\n\t\t\t\t\tconst symEdgeKey = this.getEdgeKey(snCurrent, sn);\n\t\t\t\t\tif (edgeKey === symEdgeKey) return false;\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (biasFactor !== undefined) {\n\t\t\t\tneighbors.sort((a, b) => {\n\t\t\t\t\tconst da = Math.abs(a.x - end.x) + Math.abs(a.y - end.y);\n\t\t\t\t\tconst db = Math.abs(b.x - end.x) + Math.abs(b.y - end.y);\n\t\t\t\t\tconst score = (da - db) * (1 - biasFactor * 2);\n\t\t\t\t\treturn score + (Math.random() - 0.5) * 1.5;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.shuffleArray(neighbors);\n\t\t\t}\n\n\t\t\tfor (const next of neighbors) {\n\t\t\t\tif (findPath(next)) return true;\n\t\t\t}\n\n\t\t\tpath.pop();\n\t\t\tvisited.delete(`${current.x},${current.y}`);\n\t\t\tvisited.delete(`${snCurrent.x},${snCurrent.y}`);\n\t\t\treturn false;\n\t\t};\n\t\tfindPath(start);\n\t\treturn path;\n\t}\n\n\tprivate getValidNeighbors(grid: Grid, p: Point, visited: Set<string>): Point[] {\n\t\tconst candidates: Point[] = [];\n\t\tconst directions = [\n\t\t\t{ x: 0, y: -1 },\n\t\t\t{ x: 1, y: 0 },\n\t\t\t{ x: 0, y: 1 },\n\t\t\t{ x: -1, y: 0 },\n\t\t];\n\t\tfor (const d of directions) {\n\t\t\tconst nx = p.x + d.x;\n\t\t\tconst ny = p.y + d.y;\n\t\t\tif (nx >= 0 && nx <= grid.cols && ny >= 0 && ny <= grid.rows) {\n\t\t\t\tif (!visited.has(`${nx},${ny}`)) candidates.push({ x: nx, y: ny });\n\t\t\t}\n\t\t}\n\t\treturn candidates;\n\t}\n\n\t/**\n\t * \u89E3\u30D1\u30B9\u304C\u901A\u3063\u3066\u3044\u306A\u3044\u5834\u6240\u306B\u30E9\u30F3\u30C0\u30E0\u306B\u65AD\u7DDA\uFF08Broken/Absent\uFF09\u3092\u914D\u7F6E\u3059\u308B\n\t */\n\tprivate applyBrokenEdges(grid: Grid, path: Point[], options: GenerationOptions) {\n\t\tconst complexity = options.complexity ?? 0.5;\n\t\tconst symmetry = options.symmetry ?? SymmetryType.None;\n\t\tconst pathEdges = new Set<string>();\n\n\t\t// \u30E1\u30A4\u30F3\u30D1\u30B9\u3068\u5BFE\u79F0\u30D1\u30B9\u306E\u4E21\u65B9\u306E\u30A8\u30C3\u30B8\u3092\u7981\u6B62\u30EA\u30B9\u30C8\u306B\u5165\u308C\u308B\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst p1 = this.getSymmetricalPoint(grid, path[i], symmetry);\n\t\t\t\tconst p2 = this.getSymmetricalPoint(grid, path[i + 1], symmetry);\n\t\t\t\tpathEdges.add(this.getEdgeKey(p1, p2));\n\t\t\t}\n\t\t}\n\n\t\tconst unusedEdges: { type: \"h\" | \"v\"; r: number; c: number; p1: Point; p2: Point }[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tconst p1 = { x: c, y: r };\n\t\t\t\tconst p2 = { x: c + 1, y: r };\n\t\t\t\tif (!pathEdges.has(this.getEdgeKey(p1, p2))) unusedEdges.push({ type: \"h\", r, c, p1, p2 });\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tconst p1 = { x: c, y: r };\n\t\t\t\tconst p2 = { x: c, y: r + 1 };\n\t\t\t\tif (!pathEdges.has(this.getEdgeKey(p1, p2))) unusedEdges.push({ type: \"v\", r, c, p1, p2 });\n\t\t\t}\n\t\t}\n\n\t\tthis.shuffleArray(unusedEdges);\n\t\t// \u76E4\u9762\u30B5\u30A4\u30BA\u306B\u5FDC\u3058\u3066\u65AD\u7DDA\u6570\u3092\u30B9\u30B1\u30FC\u30EB\u3055\u305B\u308B\n\t\tconst targetCount = Math.max(1, Math.floor((complexity * (grid.rows * grid.cols)) / 4));\n\t\tlet placed = 0;\n\t\tfor (const edge of unusedEdges) {\n\t\t\tif (placed >= targetCount) break;\n\t\t\t// \u307E\u305A\u306FBroken\u3068\u3057\u3066\u914D\u7F6E\n\t\t\tif (edge.type === \"h\") grid.hEdges[edge.r][edge.c].type = EdgeType.Broken;\n\t\t\telse grid.vEdges[edge.r][edge.c].type = EdgeType.Broken;\n\t\t\tplaced++;\n\t\t}\n\n\t\t// \u5916\u5468\u307E\u305F\u306FAbsent\u306B\u63A5\u89E6\u3057\u3066\u3044\u308BBroken\u3092Absent\u306B\u7F6E\u304D\u63DB\u3048\u308B\uFF08\u4F1D\u64AD\uFF09\n\t\tlet changed = true;\n\t\twhile (changed) {\n\t\t\tchanged = false;\n\t\t\t// Horizontal edges\n\t\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Broken) {\n\t\t\t\t\t\tif (this.canBecomeAbsent(grid, { type: \"h\", r, c })) {\n\t\t\t\t\t\t\tgrid.hEdges[r][c].type = EdgeType.Absent;\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Vertical edges\n\t\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Broken) {\n\t\t\t\t\t\tif (this.canBecomeAbsent(grid, { type: \"v\", r, c })) {\n\t\t\t\t\t\t\tgrid.vEdges[r][c].type = EdgeType.Absent;\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// \u5468\u56F2\u304C\u5168\u3066\u65AD\u7DDA\u3057\u3066\u3044\u308B\u30CE\u30FC\u30C9\u306E\u5168\u30A8\u30C3\u30B8\u3092Absent\u5316\u3059\u308B\uFF08\u65E2\u5B58\u30ED\u30B8\u30C3\u30AF\u306E\u7DAD\u6301\uFF09\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tconst edgesWithMeta: { e: EdgeConstraint; type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\t\t\tif (c > 0) edgesWithMeta.push({ e: grid.hEdges[r][c - 1], type: \"h\", r, c: c - 1 });\n\t\t\t\tif (c < grid.cols) edgesWithMeta.push({ e: grid.hEdges[r][c], type: \"h\", r, c });\n\t\t\t\tif (r > 0) edgesWithMeta.push({ e: grid.vEdges[r - 1][c], type: \"v\", r: r - 1, c });\n\t\t\t\tif (r < grid.rows) edgesWithMeta.push({ e: grid.vEdges[r][c], type: \"v\", r, c });\n\n\t\t\t\tif (edgesWithMeta.length > 0 && edgesWithMeta.every((m) => m.e.type === EdgeType.Broken || m.e.type === EdgeType.Absent)) {\n\t\t\t\t\tif (edgesWithMeta.every((m) => !this.isAdjacentToMark(grid, m))) {\n\t\t\t\t\t\tfor (const m of edgesWithMeta) m.e.type = EdgeType.Absent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u30A8\u30C3\u30B8\u304CAbsent\u306B\u5909\u63DB\u53EF\u80FD\u304B\u5224\u5B9A\u3059\u308B\n\t */\n\tprivate canBecomeAbsent(grid: Grid, edge: { type: \"h\" | \"v\"; r: number; c: number }): boolean {\n\t\t// \u30DE\u30FC\u30AF\u306B\u96A3\u63A5\u3057\u3066\u3044\u308B\u5834\u5408\u306FAbsent\u7981\u6B62\n\t\tif (this.isAdjacentToMark(grid, edge)) return false;\n\n\t\t// 1. \u5916\u5468\u306B\u3042\u308B\u304B\n\t\tif (edge.type === \"h\") {\n\t\t\tif (edge.r === 0 || edge.r === grid.rows) return true;\n\t\t} else {\n\t\t\tif (edge.c === 0 || edge.c === grid.cols) return true;\n\t\t}\n\n\t\t// 2. \u4ED6\u306EAbsent\u30A8\u30C3\u30B8\u306B\u63A5\u89E6\uFF08\u30CE\u30FC\u30C9\u3092\u5171\u6709\uFF09\u3057\u3066\u3044\u308B\u304B\n\t\tconst nodes =\n\t\t\tedge.type === \"h\"\n\t\t\t\t? [\n\t\t\t\t\t\t{ x: edge.c, y: edge.r },\n\t\t\t\t\t\t{ x: edge.c + 1, y: edge.r },\n\t\t\t\t\t]\n\t\t\t\t: [\n\t\t\t\t\t\t{ x: edge.c, y: edge.r },\n\t\t\t\t\t\t{ x: edge.c, y: edge.r + 1 },\n\t\t\t\t\t];\n\n\t\tfor (const node of nodes) {\n\t\t\tconst adjEdges = [\n\t\t\t\t{ type: \"h\", r: node.y, c: node.x - 1 },\n\t\t\t\t{ type: \"h\", r: node.y, c: node.x },\n\t\t\t\t{ type: \"v\", r: node.y - 1, c: node.x },\n\t\t\t\t{ type: \"v\", r: node.y, c: node.x },\n\t\t\t];\n\t\t\tfor (const adj of adjEdges) {\n\t\t\t\tif (adj.c >= 0 && adj.c <= grid.cols && adj.r >= 0 && adj.r <= grid.rows) {\n\t\t\t\t\tif (adj.type === \"h\" && adj.c < grid.cols) {\n\t\t\t\t\t\tif (grid.hEdges[adj.r][adj.c].type === EdgeType.Absent) return true;\n\t\t\t\t\t} else if (adj.type === \"v\" && adj.r < grid.rows) {\n\t\t\t\t\t\tif (grid.vEdges[adj.r][adj.c].type === EdgeType.Absent) return true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u5230\u9054\u4E0D\u53EF\u80FD\u306A\u30A8\u30EA\u30A2\u3092Absent\u5316\u3057\u3001\u5916\u90E8\u306B\u6F0F\u308C\u305F\u30BB\u30EB\u3092\u30AF\u30EA\u30A2\u3059\u308B\n\t */\n\tprivate cleanGrid(grid: Grid) {\n\t\tconst startNodes: { x: number; y: number }[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) if (grid.nodes[r][c].type === NodeType.Start) startNodes.push({ x: c, y: r });\n\t\t}\n\n\t\tconst reachableNodes = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [...startNodes];\n\t\tfor (const p of startNodes) reachableNodes.add(`${p.x},${p.y}`);\n\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.vEdges[curr.y - 1]?.[curr.x] },\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.vEdges[curr.y]?.[curr.x] },\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.hEdges[curr.y]?.[curr.x - 1] },\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.hEdges[curr.y]?.[curr.x] },\n\t\t\t];\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.edge && n.edge.type !== EdgeType.Absent) {\n\t\t\t\t\tif (!reachableNodes.has(`${n.nx},${n.ny}`)) {\n\t\t\t\t\t\treachableNodes.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) if (!reachableNodes.has(`${c},${r}`) || !reachableNodes.has(`${c + 1},${r}`)) grid.hEdges[r][c].type = EdgeType.Absent;\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) if (!reachableNodes.has(`${c},${r}`) || !reachableNodes.has(`${c},${r + 1}`)) grid.vEdges[r][c].type = EdgeType.Absent;\n\t\t}\n\n\t\tconst external = this.getExternalCells(grid);\n\t\tfor (const cellKey of external) {\n\t\t\tconst [c, r] = cellKey.split(\",\").map(Number);\n\t\t\tgrid.cells[r][c].type = CellType.None;\n\t\t}\n\t}\n\n\tprivate getExternalCells(grid: Grid): Set<string> {\n\t\tconst external = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [];\n\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\tif (grid.hEdges[0][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},0`)) {\n\t\t\t\t\texternal.add(`${c},0`);\n\t\t\t\t\tqueue.push({ x: c, y: 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.hEdges[grid.rows][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},${grid.rows - 1}`)) {\n\t\t\t\t\texternal.add(`${c},${grid.rows - 1}`);\n\t\t\t\t\tqueue.push({ x: c, y: grid.rows - 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tif (grid.vEdges[r][0].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`0,${r}`)) {\n\t\t\t\t\texternal.add(`0,${r}`);\n\t\t\t\t\tqueue.push({ x: 0, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.vEdges[r][grid.cols].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${grid.cols - 1},${r}`)) {\n\t\t\t\t\texternal.add(`${grid.cols - 1},${r}`);\n\t\t\t\t\tqueue.push({ x: grid.cols - 1, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.hEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.hEdges[curr.y + 1][curr.x] },\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x + 1] },\n\t\t\t];\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\tif (!external.has(`${n.nx},${n.ny}`) && n.edge.type === EdgeType.Absent) {\n\t\t\t\t\t\texternal.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn external;\n\t}\n\n\tprivate isAdjacentToMark(grid: Grid, edge: { type: \"h\" | \"v\"; r: number; c: number }): boolean {\n\t\tif (edge.type === \"h\") {\n\t\t\tif (edge.r > 0 && grid.cells[edge.r - 1][edge.c].type !== CellType.None) return true;\n\t\t\tif (edge.r < grid.rows && grid.cells[edge.r][edge.c].type !== CellType.None) return true;\n\t\t} else {\n\t\t\tif (edge.c > 0 && grid.cells[edge.r][edge.c - 1].type !== CellType.None) return true;\n\t\t\tif (edge.c < grid.cols && grid.cells[edge.r][edge.c].type !== CellType.None) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u30DE\u30FC\u30AF\u304C\u5B8C\u5168\u306B\u65AD\u7D76\u3055\u308C\u305F\u30BB\u30EB\u306B\u3044\u306A\u3044\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate hasIsolatedMark(grid: Grid): boolean {\n\t\tfor (let r = 0; r < grid.rows; r++)\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (grid.cells[r][c].type === CellType.None) continue;\n\t\t\t\tconst edges = [grid.hEdges[r][c], grid.hEdges[r + 1][c], grid.vEdges[r][c], grid.vEdges[r][c + 1]];\n\t\t\t\tif (edges.every((e) => e.type === EdgeType.Broken || e.type === EdgeType.Absent)) return true;\n\t\t\t}\n\t\treturn false;\n\t}\n\n\tprivate getSymmetricalPoint(grid: Grid, p: Point, symmetry: SymmetryType): Point {\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\treturn { x: grid.cols - p.x, y: p.y };\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\treturn { x: p.x, y: grid.rows - p.y };\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\treturn { x: grid.cols - p.x, y: grid.rows - p.y };\n\t\t}\n\t\treturn { ...p };\n\t}\n\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t}\n\n\tprivate TETRIS_SHAPES = [\n\t\t[[1]],\n\t\t[[1, 1]],\n\t\t[[1, 1, 1]],\n\t\t[[1, 1, 1, 1]],\n\t\t[[1, 1, 1, 1, 1]],\n\t\t[\n\t\t\t[1, 1],\n\t\t\t[1, 1],\n\t\t],\n\t\t[\n\t\t\t[1, 1],\n\t\t\t[1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[1, 0, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[0, 0, 1],\n\t\t],\n\t\t[\n\t\t\t[0, 1],\n\t\t\t[1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[0, 1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[0, 1, 0],\n\t\t\t[0, 1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 0],\n\t\t\t[0, 1, 1],\n\t\t],\n\t\t[\n\t\t\t[0, 1, 1],\n\t\t\t[1, 1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 0],\n\t\t\t[0, 1, 0],\n\t\t\t[0, 1, 1],\n\t\t],\n\t\t[\n\t\t\t[0, 1, 1],\n\t\t\t[0, 1, 0],\n\t\t\t[1, 1, 0],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[1, 0, 1],\n\t\t],\n\t\t[\n\t\t\t[0, 1, 0],\n\t\t\t[1, 0, 1],\n\t\t],\n\t\t[\n\t\t\t[1, 0, 0, 1],\n\t\t\t[1, 0, 0, 1],\n\t\t],\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[1, 0, 1],\n\t\t\t[1, 1, 1],\n\t\t],\n\t];\n\n\t/**\n\t * \u89E3\u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u5404\u533A\u753B\u306B\u30EB\u30FC\u30EB\u3092\u914D\u7F6E\u3059\u308B\n\t */\n\tprivate applyConstraintsBasedOnPath(grid: Grid, path: Point[], options: GenerationOptions, symPath: Point[] = [], precalculatedRegions?: Point[][], precalculatedBoundaryEdges?: { type: \"h\" | \"v\"; r: number; c: number }[][]) {\n\t\tconst complexity = options.complexity ?? 0.5;\n\t\tconst useHexagons = options.useHexagons ?? true;\n\t\tconst useSquares = options.useSquares ?? true;\n\t\tconst useStars = options.useStars ?? true;\n\t\tconst useTetris = options.useTetris ?? false;\n\t\tconst useEraser = options.useEraser ?? false;\n\n\t\tlet hexagonsPlaced = 0;\n\t\tlet squaresPlaced = 0;\n\t\tlet starsPlaced = 0;\n\t\tlet tetrisPlaced = 0;\n\t\tlet erasersPlaced = 0;\n\t\tlet totalTetrisArea = 0;\n\t\tconst maxTotalTetrisArea = Math.floor(grid.rows * grid.cols * 0.45);\n\n\t\t// \u516D\u89D2\u5F62\u306E\u914D\u7F6E\n\t\tif (useHexagons) {\n\t\t\tconst targetDifficulty = options.difficulty ?? 0.5;\n\t\t\t// \u30A8\u30C3\u30B8\u516D\u89D2\u5F62 (\u7DDA\u4E0A\u30FB\u4E2D\u5FC3)\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst neighbors = this.getValidNeighbors(grid, path[i], new Set());\n\t\t\t\tconst isBranching = neighbors.length > 2;\n\t\t\t\t// \u96E3\u6613\u5EA6\u304C\u4F4E\u3044\u3068\u304D\u306F\u30A8\u30C3\u30B8\u516D\u89D2\u5F62\u3092\u591A\u304F\u3057\u3066\u30AC\u30A4\u30C9\u306B\u3059\u308B\n\t\t\t\tlet prob = complexity * (targetDifficulty < 0.4 ? 0.6 : 0.3);\n\t\t\t\tif (isBranching) prob = targetDifficulty < 0.4 ? prob * 1.0 : prob * 0.5;\n\t\t\t\tif (Math.random() < prob) {\n\t\t\t\t\tthis.setEdgeHexagon(grid, path[i], path[i + 1]);\n\t\t\t\t\thexagonsPlaced++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// \u30CE\u30FC\u30C9\u516D\u89D2\u5F62 (\u7DDA\u4E0A\u30FB\u4EA4\u70B9)\n\t\t\tfor (let i = 0; i < path.length; i++) {\n\t\t\t\tconst node = path[i];\n\t\t\t\tif (grid.nodes[node.y][node.x].type !== NodeType.Normal) continue;\n\t\t\t\t// Edge\u306EHexagon\u3068\u96A3\u63A5\u3057\u3066\u3044\u308B\u5834\u5408\u306F\u30B9\u30AD\u30C3\u30D7\n\t\t\t\tif (this.hasIncidentHexagonEdge(grid, node)) continue;\n\n\t\t\t\t// \u96E3\u6613\u5EA6\u304C\u9AD8\u3044\u3068\u304D\u306B\u30CE\u30FC\u30C9\u516D\u89D2\u5F62\u3092\u914D\u7F6E\n\t\t\t\tlet prob = complexity * (targetDifficulty > 0.6 ? 0.15 : 0.05);\n\t\t\t\tif (Math.random() < prob) {\n\t\t\t\t\tgrid.nodes[node.y][node.x].type = NodeType.Hexagon;\n\t\t\t\t\thexagonsPlaced++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hexagonsPlaced === 0 && path.length >= 2) {\n\t\t\t\tconst idx = Math.floor(Math.random() * (path.length - 1));\n\t\t\t\tthis.setEdgeHexagon(grid, path[idx], path[idx + 1]);\n\t\t\t}\n\t\t}\n\n\t\t// \u533A\u753B\u30EB\u30FC\u30EB\u306E\u914D\u7F6E\n\t\tif (useSquares || useStars || useTetris || useEraser) {\n\t\t\tconst regions = precalculatedRegions || this.calculateRegions(grid, path, symPath);\n\t\t\tconst availableColors = options.availableColors ?? [Color.Black, Color.White, Color.Red, Color.Blue];\n\t\t\tconst defaultColors = options.defaultColors ?? {};\n\t\t\tconst getDefColor = (type: CellType, fallback: Color): Color => {\n\t\t\t\tif (defaultColors[type] !== undefined) return defaultColors[type] as Color;\n\t\t\t\tconst name = CellType[type] as keyof typeof CellType;\n\t\t\t\tif (name && defaultColors[name] !== undefined) return defaultColors[name] as Color;\n\t\t\t\treturn fallback;\n\t\t\t};\n\t\t\tconst regionIndices = Array.from({ length: regions.length }, (_, i) => i);\n\t\t\tthis.shuffleArray(regionIndices);\n\t\t\tconst squareColorsUsed = new Set<number>();\n\n\t\t\t// \u5FC5\u8981\u306A\u6700\u5C0F\u9650\u306E\u5236\u7D04\u3092\u5206\u6563\u3057\u3066\u914D\u7F6E\u3059\u308B\u305F\u3081\u306E\u30D5\u30E9\u30B0\n\t\t\tconst needs = {\n\t\t\t\tsquare: useSquares,\n\t\t\t\tstar: useStars,\n\t\t\t\ttetris: useTetris,\n\t\t\t\teraser: useEraser,\n\t\t\t};\n\n\t\t\tfor (let rIdx = 0; rIdx < regionIndices.length; rIdx++) {\n\t\t\t\tconst idx = regionIndices[rIdx];\n\t\t\t\tconst region = regions[idx];\n\n\t\t\t\t// \u76E4\u9762\u304C\u5927\u304D\u304F\u533A\u753B\u304C\u591A\u3044\u5834\u5408\u3001\u5F8C\u534A\u306B\u504F\u308B\u306E\u3092\u9632\u3050\u305F\u3081\u78BA\u7387\u3092\u8ABF\u6574\n\t\t\t\tconst remainingRegions = regionIndices.length - rIdx;\n\t\t\t\tconst forceOne = (needs.square && squaresPlaced === 0) || (needs.star && starsPlaced === 0) || (needs.tetris && tetrisPlaced === 0) || (needs.eraser && erasersPlaced === 0);\n\n\t\t\t\t// \u5FC5\u9808\u306A\u3082\u306E\u304C\u307E\u3060\u914D\u7F6E\u3055\u308C\u3066\u3044\u306A\u3044\u5834\u5408\u3001\u6B8B\u308A\u533A\u753B\u6570\u304C\u5C11\u306A\u304F\u306A\u3063\u3066\u304D\u305F\u3089\u78BA\u7387\u3092\u4E0A\u3052\u308B\n\t\t\t\tlet placementProb = 0.2 + complexity * 0.6;\n\t\t\t\tif (forceOne && remainingRegions <= 3) placementProb = 1.0;\n\t\t\t\telse if (forceOne && remainingRegions <= 6) placementProb = 0.7;\n\n\t\t\t\tif (Math.random() > placementProb) continue;\n\n\t\t\t\tconst potentialCells = [...region];\n\t\t\t\tthis.shuffleArray(potentialCells);\n\n\t\t\t\t// \u56DB\u89D2\u5F62\u306E\u914D\u7F6E\n\t\t\t\tlet squareColor = availableColors[Math.floor(Math.random() * availableColors.length)];\n\t\t\t\tif (useSquares && !useStars && remainingRegions <= 2 && squareColorsUsed.size === 1) {\n\t\t\t\t\tconst otherColors = availableColors.filter((c) => !squareColorsUsed.has(c));\n\t\t\t\t\tif (otherColors.length > 0) squareColor = otherColors[Math.floor(Math.random() * otherColors.length)];\n\t\t\t\t}\n\n\t\t\t\tlet shouldPlaceSquare = useSquares && Math.random() < 0.5 + complexity * 0.3;\n\t\t\t\tif (useSquares && squaresPlaced === 0 && remainingRegions <= 2) shouldPlaceSquare = true;\n\t\t\t\tif (useSquares && !useStars && remainingRegions <= 2 && squareColorsUsed.size < 2 && squaresPlaced > 0) shouldPlaceSquare = true;\n\n\t\t\t\tif (shouldPlaceSquare && potentialCells.length > 0) {\n\t\t\t\t\t// \u533A\u57DF\u306E\u5927\u304D\u3055\u306B\u5FDC\u3058\u3066\u914D\u7F6E\u3059\u308B\u6570\u3092\u5897\u3084\u3059\n\t\t\t\t\tconst maxSquares = Math.min(potentialCells.length, Math.max(4, Math.floor(region.length / 4)));\n\t\t\t\t\tconst numSquares = Math.floor(Math.random() * (maxSquares / 2)) + Math.ceil(maxSquares / 2);\n\t\t\t\t\tfor (let i = 0; i < numSquares; i++) {\n\t\t\t\t\t\tif (potentialCells.length === 0) break;\n\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Square;\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = squareColor;\n\t\t\t\t\t\tsquaresPlaced++;\n\t\t\t\t\t\tsquareColorsUsed.add(squareColor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// \u30C6\u30C8\u30EA\u30B9\u306E\u914D\u7F6E\n\t\t\t\tif (useTetris && totalTetrisArea < maxTotalTetrisArea) {\n\t\t\t\t\tlet shouldPlaceTetris = Math.random() < 0.1 + complexity * 0.4;\n\t\t\t\t\tif (tetrisPlaced === 0 && remainingRegions <= 2) shouldPlaceTetris = true;\n\t\t\t\t\tconst maxTetrisPerRegion = tetrisPlaced === 0 && remainingRegions <= 2 ? 6 : 4;\n\t\t\t\t\tif (shouldPlaceTetris && potentialCells.length > 0 && region.length <= maxTetrisPerRegion * 4 && totalTetrisArea + region.length <= maxTotalTetrisArea) {\n\t\t\t\t\t\tconst tiledPieces = this.generateTiling(region, maxTetrisPerRegion, options);\n\t\t\t\t\t\tif (tiledPieces) {\n\t\t\t\t\t\t\tfor (const p of tiledPieces) {\n\t\t\t\t\t\t\t\tif (potentialCells.length === 0) break;\n\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = p.isRotated ? CellType.TetrisRotated : CellType.Tetris;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].shape = p.isRotated ? p.displayShape : p.shape;\n\n\t\t\t\t\t\t\t\tlet tetrisColor = getDefColor(CellType.Tetris, Color.None);\n\t\t\t\t\t\t\t\tif (useStars && Math.random() < 0.5) {\n\t\t\t\t\t\t\t\t\tconst colors = availableColors.filter((c) => c !== Color.Blue && c !== tetrisColor);\n\t\t\t\t\t\t\t\t\tif (colors.length > 0) {\n\t\t\t\t\t\t\t\t\t\ttetrisColor = colors[Math.floor(Math.random() * colors.length)];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = tetrisColor;\n\t\t\t\t\t\t\t\ttetrisPlaced++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttotalTetrisArea += region.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// \u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF08\u30A8\u30E9\u30FC\u524A\u9664\uFF09\u306E\u914D\u7F6E\n\t\t\t\tif (useEraser && erasersPlaced < 1) {\n\t\t\t\t\tconst prob = 0.05 + complexity * 0.2;\n\t\t\t\t\tlet shouldPlaceEraser = Math.random() < prob;\n\t\t\t\t\tif (remainingRegions <= 2) shouldPlaceEraser = true;\n\n\t\t\t\t\tif (shouldPlaceEraser && potentialCells.length >= 1) {\n\t\t\t\t\t\tconst errorTypes: string[] = [];\n\t\t\t\t\t\tif (useStars) errorTypes.push(\"star\");\n\t\t\t\t\t\tif (useSquares) errorTypes.push(\"square\");\n\t\t\t\t\t\tlet boundaryEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\t\t\t\t\tif (useHexagons) {\n\t\t\t\t\t\t\tboundaryEdges = precalculatedBoundaryEdges ? precalculatedBoundaryEdges[idx] : this.getRegionBoundaryEdges(grid, region, path, symPath);\n\t\t\t\t\t\t\tif (boundaryEdges.length > 0) errorTypes.push(\"hexagon\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (useTetris) errorTypes.push(\"tetris\");\n\n\t\t\t\t\t\tlet errorType = errorTypes.length > 0 ? errorTypes[Math.floor(Math.random() * errorTypes.length)] : null;\n\n\t\t\t\t\t\t// eraser\u540C\u58EB\u306E\u6253\u3061\u6D88\u3057\u5408\u3044\u306F\u8D85\u4F4E\u78BA\u7387\u306B\u3059\u308B\n\t\t\t\t\t\tif (potentialCells.length >= 2 && (!errorType || Math.random() < 0.01)) errorType = \"eraser\";\n\n\t\t\t\t\t\tlet errorPlaced = false;\n\n\t\t\t\t\t\tif (errorType === \"hexagon\") {\n\t\t\t\t\t\t\t// Node\u306EHexagon\u3068\u96A3\u63A5\u3057\u306A\u3044Edge\u3092\u9078\u629E\n\t\t\t\t\t\t\tconst validEdges = boundaryEdges.filter((e) => !this.isEdgeAdjacentToHexagonNode(grid, e));\n\t\t\t\t\t\t\tif (validEdges.length > 0) {\n\t\t\t\t\t\t\t\tconst edge = validEdges[Math.floor(Math.random() * validEdges.length)];\n\t\t\t\t\t\t\t\tif (edge.type === \"h\") grid.hEdges[edge.r][edge.c].type = EdgeType.Hexagon;\n\t\t\t\t\t\t\t\telse grid.vEdges[edge.r][edge.c].type = EdgeType.Hexagon;\n\t\t\t\t\t\t\t\thexagonsPlaced++;\n\t\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (errorType === \"square\" && potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Square;\n\t\t\t\t\t\t\tconst existingSquare = region.find((p) => grid.cells[p.y][p.x].type === CellType.Square);\n\t\t\t\t\t\t\tconst existingSquareColor = existingSquare ? grid.cells[existingSquare.y][existingSquare.x].color : undefined;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = availableColors.find((c) => c !== existingSquareColor) || Color.Red;\n\t\t\t\t\t\t\tsquaresPlaced++;\n\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t} else if (errorType === \"star\" && potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Star;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = availableColors[Math.floor(Math.random() * availableColors.length)];\n\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t} else if (errorType === \"tetris\" && potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst tiledPieces = this.generateTiling(region, 4, options);\n\t\t\t\t\t\t\tlet piecesToPlace = [];\n\t\t\t\t\t\t\tif (tiledPieces && tiledPieces.length > 0) {\n\t\t\t\t\t\t\t\tlet currentArea = 0;\n\t\t\t\t\t\t\t\tfor (const p of tiledPieces) {\n\t\t\t\t\t\t\t\t\tconst area = this.getShapeArea(p.shape);\n\t\t\t\t\t\t\t\t\tif (currentArea + area < region.length) {\n\t\t\t\t\t\t\t\t\t\tpiecesToPlace.push(p);\n\t\t\t\t\t\t\t\t\t\tcurrentArea += area;\n\t\t\t\t\t\t\t\t\t} else break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (piecesToPlace.length === 0 && region.length > 1) {\n\t\t\t\t\t\t\t\t// \u9762\u7A4D\u4E0D\u4E00\u81F4\u306E\u30A8\u30E9\u30FC\u3092\u78BA\u5B9F\u306B\u4F5C\u6210\n\t\t\t\t\t\t\t\tpiecesToPlace = [{ shape: [[1]], displayShape: [[1]], isRotated: false }];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (piecesToPlace.length > 0) {\n\t\t\t\t\t\t\t\tfor (const p of piecesToPlace) {\n\t\t\t\t\t\t\t\t\tif (potentialCells.length < 2) break;\n\t\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = p.isRotated ? CellType.TetrisRotated : CellType.Tetris;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].shape = p.isRotated ? p.displayShape : p.shape;\n\n\t\t\t\t\t\t\t\t\tlet tetrisColor = Color.None;\n\t\t\t\t\t\t\t\t\tif (useStars && Math.random() < 0.3) {\n\t\t\t\t\t\t\t\t\t\tconst colors = availableColors.filter((c) => c !== Color.Blue);\n\t\t\t\t\t\t\t\t\t\ttetrisColor = colors[Math.floor(Math.random() * colors.length)];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = tetrisColor;\n\t\t\t\t\t\t\t\t\ttetrisPlaced++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (errorType === \"eraser\" && potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Eraser;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = getDefColor(CellType.Eraser, Color.White);\n\t\t\t\t\t\t\terasersPlaced++;\n\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// \u305D\u308C\u3067\u3082\u30A8\u30E9\u30FC\u304C\u914D\u7F6E\u3067\u304D\u306A\u304B\u3063\u305F\u5834\u5408\u306F\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\u540C\u58EB\u306E\u6253\u3061\u6D88\u3057\u3092\u8A66\u307F\u308B\n\t\t\t\t\t\tif (!errorPlaced && potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Eraser;\n\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = getDefColor(CellType.Eraser, Color.White);\n\t\t\t\t\t\t\terasersPlaced++;\n\t\t\t\t\t\t\terrorPlaced = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (errorPlaced) {\n\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Eraser;\n\t\t\t\t\t\t\tlet eraserColor = getDefColor(CellType.Eraser, Color.White);\n\t\t\t\t\t\t\tif (useStars && Math.random() < 0.4) {\n\t\t\t\t\t\t\t\tconst colors = availableColors.filter((c) => c !== eraserColor);\n\t\t\t\t\t\t\t\tif (colors.length > 0) {\n\t\t\t\t\t\t\t\t\teraserColor = colors[Math.floor(Math.random() * colors.length)];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = eraserColor;\n\t\t\t\t\t\t\terasersPlaced++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// \u661F\u306E\u914D\u7F6E\n\t\t\t\tif (useStars) {\n\t\t\t\t\t// \u533A\u57DF\u304C\u5341\u5206\u306B\u5927\u304D\u3051\u308C\u3070\u3001\u8907\u6570\u30DA\u30A2\u306E\u914D\u7F6E\u3092\u691C\u8A0E\u3059\u308B\n\t\t\t\t\tconst maxPairs = Math.max(1, Math.floor(region.length / 8));\n\t\t\t\t\tfor (let p = 0; p < maxPairs; p++) {\n\t\t\t\t\t\tfor (const color of availableColors) {\n\t\t\t\t\t\t\tif (potentialCells.length < 1) break;\n\t\t\t\t\t\t\tif (Math.random() > 0.3 + complexity * 0.4) continue;\n\t\t\t\t\t\t\tconst colorCount = region.filter((p) => grid.cells[p.y][p.x].color === color).length;\n\t\t\t\t\t\t\tif (colorCount === 1) {\n\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\n\t\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t\t} else if (colorCount === 0 && potentialCells.length >= 2) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < 2; i++) {\n\t\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\n\t\t\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// \u56DB\u89D2\u5F62\u306E\u8272\u304C1\u8272\u3057\u304B\u4F7F\u308F\u308C\u306A\u304B\u3063\u305F\u5834\u5408\u306E\u88DC\u6B63\n\t\t\tif (useSquares && !useStars && squareColorsUsed.size < 2) {\n\t\t\t\tfor (const region of regions) {\n\t\t\t\t\tif (region.every((p) => grid.cells[p.y][p.x].type === CellType.None)) {\n\t\t\t\t\t\tconst otherColor = availableColors.find((c) => !squareColorsUsed.has(c)) || Color.White;\n\t\t\t\t\t\tconst cell = region[Math.floor(Math.random() * region.length)];\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Square;\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = otherColor;\n\t\t\t\t\t\tsquareColorsUsed.add(otherColor);\n\t\t\t\t\t\tsquaresPlaced++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u533A\u753B\u5206\u3051\u3092\u884C\u3046\n\t */\n\tprivate calculateRegions(grid: Grid, path: Point[], symPath: Point[] = []): Point[][] {\n\t\tconst regions: Point[][] = [];\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst visitedCells = new Uint8Array(rows * cols);\n\n\t\tconst hEdgesMask = new Uint8Array((rows + 1) * cols);\n\t\tconst vEdgesMask = new Uint8Array(rows * (cols + 1));\n\n\t\tconst setEdge = (p1: Point, p2: Point) => {\n\t\t\tif (p1.x === p2.x) {\n\t\t\t\tvEdgesMask[Math.min(p1.y, p2.y) * (cols + 1) + p1.x] = 1;\n\t\t\t} else {\n\t\t\t\thEdgesMask[p1.y * cols + Math.min(p1.x, p2.x)] = 1;\n\t\t\t}\n\t\t};\n\n\t\tfor (let i = 0; i < path.length - 1; i++) setEdge(path[i], path[i + 1]);\n\t\tfor (let i = 0; i < symPath.length - 1; i++) setEdge(symPath[i], symPath[i + 1]);\n\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Absent) hEdgesMask[r * cols + c] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Absent) vEdgesMask[r * (cols + 1) + c] = 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tconst idx = r * cols + c;\n\t\t\t\tif (visitedCells[idx]) continue;\n\n\t\t\t\tconst region: Point[] = [];\n\t\t\t\tconst queue: number[] = [idx];\n\t\t\t\tvisitedCells[idx] = 1;\n\n\t\t\t\tlet head = 0;\n\t\t\t\twhile (head < queue.length) {\n\t\t\t\t\tconst currIdx = queue[head++];\n\t\t\t\t\tconst cx = currIdx % cols;\n\t\t\t\t\tconst cy = Math.floor(currIdx / cols);\n\t\t\t\t\tregion.push({ x: cx, y: cy });\n\n\t\t\t\t\tif (cy > 0 && !hEdgesMask[cy * cols + cx]) {\n\t\t\t\t\t\tconst nIdx = (cy - 1) * cols + cx;\n\t\t\t\t\t\tif (!visitedCells[nIdx]) {\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\n\t\t\t\t\t\t\tqueue.push(nIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cy < rows - 1 && !hEdgesMask[(cy + 1) * cols + cx]) {\n\t\t\t\t\t\tconst nIdx = (cy + 1) * cols + cx;\n\t\t\t\t\t\tif (!visitedCells[nIdx]) {\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\n\t\t\t\t\t\t\tqueue.push(nIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cx > 0 && !vEdgesMask[cy * (cols + 1) + cx]) {\n\t\t\t\t\t\tconst nIdx = cy * cols + (cx - 1);\n\t\t\t\t\t\tif (!visitedCells[nIdx]) {\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\n\t\t\t\t\t\t\tqueue.push(nIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cx < cols - 1 && !vEdgesMask[cy * (cols + 1) + (cx + 1)]) {\n\t\t\t\t\t\tconst nIdx = cy * cols + (cx + 1);\n\t\t\t\t\t\tif (!visitedCells[nIdx]) {\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\n\t\t\t\t\t\t\tqueue.push(nIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregions.push(region);\n\t\t\t}\n\t\t}\n\t\treturn regions;\n\t}\n\n\tprivate isAbsentEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\treturn grid.vEdges[y][p1.x].type === EdgeType.Absent;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\treturn grid.hEdges[p1.y][x].type === EdgeType.Absent;\n\t\t}\n\t}\n\n\t/**\n\t * \u533A\u753B\u306E\u5883\u754C\u30A8\u30C3\u30B8\u306E\u3046\u3061\u3001\u89E3\u30D1\u30B9\u304C\u901A\u3063\u3066\u3044\u306A\u3044\u3082\u306E\u3092\u53D6\u5F97\u3059\u308B\n\t */\n\tprivate getRegionBoundaryEdges(grid: Grid, region: Point[], path: Point[], symPath: Point[] = []): { type: \"h\" | \"v\"; r: number; c: number }[] {\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) pathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\tfor (let i = 0; i < symPath.length - 1; i++) pathEdges.add(this.getEdgeKey(symPath[i], symPath[i + 1]));\n\n\t\tconst boundary: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\tfor (const cell of region) {\n\t\t\tconst edges = [\n\t\t\t\t{ type: \"h\" as const, r: cell.y, c: cell.x },\n\t\t\t\t{ type: \"h\" as const, r: cell.y + 1, c: cell.x },\n\t\t\t\t{ type: \"v\" as const, r: cell.y, c: cell.x },\n\t\t\t\t{ type: \"v\" as const, r: cell.y, c: cell.x + 1 },\n\t\t\t];\n\t\t\tfor (const e of edges) {\n\t\t\t\tconst p1 = e.type === \"h\" ? { x: e.c, y: e.r } : { x: e.c, y: e.r };\n\t\t\t\tconst p2 = e.type === \"h\" ? { x: e.c + 1, y: e.r } : { x: e.c, y: e.r + 1 };\n\t\t\t\tconst key = this.getEdgeKey(p1, p2);\n\t\t\t\tif (!pathEdges.has(key) && !this.isAbsentEdge(grid, p1, p2)) {\n\t\t\t\t\tboundary.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// \u91CD\u8907\u3092\u524A\u9664\n\t\tconst unique = new Map<string, { type: \"h\" | \"v\"; r: number; c: number }>();\n\t\tfor (const e of boundary) unique.set(`${e.type},${e.r},${e.c}`, e);\n\t\treturn Array.from(unique.values());\n\t}\n\n\tprivate setEdgeHexagon(grid: Grid, p1: Point, p2: Point) {\n\t\tif (p1.x === p2.x) grid.vEdges[Math.min(p1.y, p2.y)][p1.x].type = EdgeType.Hexagon;\n\t\telse grid.hEdges[p1.y][Math.min(p1.x, p2.x)].type = EdgeType.Hexagon;\n\t}\n\n\tprivate hasIncidentHexagonEdge(grid: Grid, p: Point): boolean {\n\t\tif (p.x > 0 && grid.hEdges[p.y][p.x - 1].type === EdgeType.Hexagon) return true;\n\t\tif (p.x < grid.cols && grid.hEdges[p.y][p.x].type === EdgeType.Hexagon) return true;\n\t\tif (p.y > 0 && grid.vEdges[p.y - 1][p.x].type === EdgeType.Hexagon) return true;\n\t\tif (p.y < grid.rows && grid.vEdges[p.y][p.x].type === EdgeType.Hexagon) return true;\n\t\treturn false;\n\t}\n\n\tprivate isEdgeAdjacentToHexagonNode(grid: Grid, edge: { type: \"h\" | \"v\"; r: number; c: number }): boolean {\n\t\tif (edge.type === \"h\") {\n\t\t\treturn grid.nodes[edge.r][edge.c].type === NodeType.Hexagon || grid.nodes[edge.r][edge.c + 1].type === NodeType.Hexagon;\n\t\t} else {\n\t\t\treturn grid.nodes[edge.r][edge.c].type === NodeType.Hexagon || grid.nodes[edge.r + 1][edge.c].type === NodeType.Hexagon;\n\t\t}\n\t}\n\n\t/**\n\t * \u8981\u6C42\u3055\u308C\u305F\u5236\u7D04\u304C\u5168\u3066\u542B\u307E\u308C\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate checkAllRequestedConstraintsPresent(grid: Grid, options: GenerationOptions): boolean {\n\t\tconst useHexagons = options.useHexagons ?? true;\n\t\tconst useSquares = options.useSquares ?? true;\n\t\tconst useStars = options.useStars ?? true;\n\t\tconst useTetris = options.useTetris ?? false;\n\t\tconst useEraser = options.useEraser ?? false;\n\t\tconst useBrokenEdges = options.useBrokenEdges ?? false;\n\n\t\tif (useBrokenEdges) {\n\t\t\tlet found = false;\n\t\t\tfor (let r = 0; r <= grid.rows; r++)\n\t\t\t\tfor (let c = 0; c < grid.cols; c++)\n\t\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Broken || grid.hEdges[r][c].type === EdgeType.Absent) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tfor (let r = 0; r < grid.rows; r++)\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++)\n\t\t\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Broken || grid.vEdges[r][c].type === EdgeType.Absent) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (!found) return false;\n\t\t}\n\t\tif (useHexagons) {\n\t\t\tlet found = false;\n\t\t\tfor (let r = 0; r <= grid.rows; r++)\n\t\t\t\tfor (let c = 0; c < grid.cols; c++)\n\t\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tfor (let r = 0; r < grid.rows; r++)\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++)\n\t\t\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (!found)\n\t\t\t\tfor (let r = 0; r <= grid.rows; r++)\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++)\n\t\t\t\t\t\tif (grid.nodes[r][c].type === NodeType.Hexagon) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\tif (!found) return false;\n\t\t}\n\t\tif (useSquares || useStars || useTetris || useEraser) {\n\t\t\tlet fSq = false;\n\t\t\tlet fSt = false;\n\t\t\tlet fT = false;\n\t\t\tlet fE = false;\n\t\t\tconst sqC = new Set<number>();\n\t\t\tfor (let r = 0; r < grid.rows; r++)\n\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\t\tconst type = grid.cells[r][c].type;\n\t\t\t\t\tif (type === CellType.Square) {\n\t\t\t\t\t\tfSq = true;\n\t\t\t\t\t\tsqC.add(grid.cells[r][c].color);\n\t\t\t\t\t}\n\t\t\t\t\tif (type === CellType.Star) fSt = true;\n\t\t\t\t\tif (type === CellType.Tetris || type === CellType.TetrisRotated) fT = true;\n\t\t\t\t\tif (type === CellType.Eraser) fE = true;\n\t\t\t\t}\n\t\t\tif (useSquares && !fSq) return false;\n\t\t\tif (useStars && !fSt) return false;\n\t\t\tif (useTetris && !fT) return false;\n\t\t\tif (useEraser && !fE) return false;\n\t\t\tif (useSquares && fSq && !fSt && sqC.size < 2) return false;\n\t\t}\n\t\tif (this.hasIsolatedMark(grid)) return false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u533A\u753B\u3092\u30D4\u30FC\u30B9\u3067\u57CB\u3081\u5C3D\u304F\u3059\u30BF\u30A4\u30EA\u30F3\u30B0\u3092\u751F\u6210\u3059\u308B\n\t */\n\tprivate generateTiling(region: Point[], maxPieces: number, options: GenerationOptions): { shape: number[][]; displayShape: number[][]; isRotated: boolean }[] | null {\n\t\tconst minX = Math.min(...region.map((p) => p.x));\n\t\tconst minY = Math.min(...region.map((p) => p.y));\n\t\tconst maxX = Math.max(...region.map((p) => p.x));\n\t\tconst maxY = Math.max(...region.map((p) => p.y));\n\t\tconst width = maxX - minX + 1;\n\t\tconst height = maxY - minY + 1;\n\t\tconst regionGrid = Array.from({ length: height }, () => Array(width).fill(false));\n\t\tfor (const p of region) regionGrid[p.y - minY][p.x - minX] = true;\n\t\treturn this.tilingDfs(regionGrid, [], maxPieces, options);\n\t}\n\n\t/**\n\t * \u30BF\u30A4\u30EA\u30F3\u30B0\u3092\u6DF1\u3055\u512A\u5148\u63A2\u7D22\u3067\u751F\u6210\u3059\u308B\n\t */\n\tprivate tilingDfs(regionGrid: boolean[][], currentPieces: { shape: number[][]; displayShape: number[][]; isRotated: boolean }[], maxPieces: number, options: GenerationOptions): { shape: number[][]; displayShape: number[][]; isRotated: boolean }[] | null {\n\t\tlet r0 = -1;\n\t\tlet c0 = -1;\n\t\tfor (let r = 0; r < regionGrid.length; r++) {\n\t\t\tfor (let c = 0; c < regionGrid[0].length; c++)\n\t\t\t\tif (regionGrid[r][c]) {\n\t\t\t\t\tr0 = r;\n\t\t\t\t\tc0 = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (r0 !== -1) break;\n\t\t}\n\t\tif (r0 === -1) return currentPieces;\n\t\tif (currentPieces.length >= maxPieces) return null;\n\n\t\tconst difficulty = options.difficulty ?? 0.5;\n\t\tlet shapes = [...this.TETRIS_SHAPES];\n\t\tthis.shuffleArray(shapes);\n\t\tif (difficulty > 0.6) shapes.sort((a, b) => this.getShapeArea(b) - this.getShapeArea(a));\n\n\t\tfor (const baseShape of shapes) {\n\t\t\tconst isInv = this.isRotationallyInvariant(baseShape);\n\t\t\tconst rotations = isInv ? [baseShape] : this.getAllRotations(baseShape);\n\t\t\tthis.shuffleArray(rotations);\n\t\t\tfor (const shape of rotations) {\n\t\t\t\tconst blocks: { r: number; c: number }[] = [];\n\t\t\t\tfor (let pr = 0; pr < shape.length; pr++) for (let pc = 0; pc < shape[0].length; pc++) if (shape[pr][pc]) blocks.push({ r: pr, c: pc });\n\t\t\t\tfor (const anchor of blocks) {\n\t\t\t\t\tconst dr = r0 - anchor.r;\n\t\t\t\t\tconst dc = c0 - anchor.c;\n\t\t\t\t\tif (this.canPlace(regionGrid, shape, dr, dc)) {\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, false);\n\t\t\t\t\t\tconst result = this.tilingDfs(regionGrid, [...currentPieces, { shape, displayShape: baseShape, isRotated: !isInv && Math.random() < 0.3 + difficulty * 0.6 }], maxPieces, options);\n\t\t\t\t\t\tif (result) return result;\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate getShapeArea(shape: number[][]): number {\n\t\tlet area = 0;\n\t\tfor (const row of shape) for (const cell of row) if (cell) area++;\n\t\treturn area;\n\t}\n\tprivate isRotationallyInvariant(shape: number[][]): boolean {\n\t\tconst area = this.getShapeArea(shape);\n\t\treturn area === 1 || (area === 4 && shape.length === 2 && shape[0].length === 2);\n\t}\n\tprivate getAllRotations(shape: number[][]): number[][][] {\n\t\tconst results: number[][][] = [];\n\t\tconst keys = new Set<string>();\n\t\tlet curr = shape;\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tconst key = JSON.stringify(curr);\n\t\t\tif (!keys.has(key)) {\n\t\t\t\tresults.push(curr);\n\t\t\t\tkeys.add(key);\n\t\t\t}\n\t\t\tcurr = this.rotate90(curr);\n\t\t}\n\t\treturn results;\n\t}\n\tprivate rotate90(shape: number[][]): number[][] {\n\t\tconst rows = shape.length;\n\t\tconst cols = shape[0].length;\n\t\tconst newShape = Array.from({ length: cols }, () => Array(rows).fill(0));\n\t\tfor (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) newShape[c][rows - 1 - r] = shape[r][c];\n\t\treturn newShape;\n\t}\n\tprivate canPlace(regionGrid: boolean[][], shape: number[][], r: number, c: number): boolean {\n\t\tfor (let i = 0; i < shape.length; i++)\n\t\t\tfor (let j = 0; j < shape[0].length; j++)\n\t\t\t\tif (shape[i][j]) {\n\t\t\t\t\tconst nr = r + i,\n\t\t\t\t\t\tnc = c + j;\n\t\t\t\t\tif (nr < 0 || nr >= regionGrid.length || nc < 0 || nc >= regionGrid[0].length || !regionGrid[nr][nc]) return false;\n\t\t\t\t}\n\t\treturn true;\n\t}\n\tprivate placePiece(regionGrid: boolean[][], shape: number[][], r: number, c: number, value: boolean) {\n\t\tfor (let i = 0; i < shape.length; i++) for (let j = 0; j < shape[0].length; j++) if (shape[i][j]) regionGrid[r + i][c + j] = value;\n\t}\n\tprivate shuffleArray<T>(array: T[]) {\n\t\tfor (let i = array.length - 1; i > 0; i--) {\n\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t[array[i], array[j]] = [array[j], array[i]];\n\t\t}\n\t}\n}\n", "import type { CellConstraint, GenerationOptions, PuzzleData } from \"./types\";\n\n/* ================= Bit IO ================= */\n\nclass BitWriter {\n\tprivate bytes: number[] = [];\n\tprivate cur = 0;\n\tprivate bit = 0;\n\n\twrite(value: number, bits: number) {\n\t\tfor (let i = 0; i < bits; i++) {\n\t\t\tif (value & (1 << i)) this.cur |= 1 << this.bit;\n\t\t\tthis.bit++;\n\t\t\tif (this.bit === 8) {\n\t\t\t\tthis.bytes.push(this.cur);\n\t\t\t\tthis.cur = 0;\n\t\t\t\tthis.bit = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfinish(): Uint8Array {\n\t\tif (this.bit > 0) this.bytes.push(this.cur);\n\t\treturn new Uint8Array(this.bytes);\n\t}\n}\n\nclass BitReader {\n\tprivate i = 0;\n\tprivate bit = 0;\n\tconstructor(private buf: Uint8Array) {}\n\n\tread(bits: number): number {\n\t\tlet v = 0;\n\t\tfor (let i = 0; i < bits; i++) {\n\t\t\tif (this.buf[this.i] & (1 << this.bit)) v |= 1 << i;\n\t\t\tthis.bit++;\n\t\t\tif (this.bit === 8) {\n\t\t\t\tthis.bit = 0;\n\t\t\t\tthis.i++;\n\t\t\t}\n\t\t}\n\t\treturn v;\n\t}\n}\n\n/* ================= Utils ================= */\n\nfunction collectShapes(cells: CellConstraint[][]): number[][][] {\n\tconst map = new Map<string, number[][]>();\n\tfor (const row of cells) {\n\t\tfor (const c of row) {\n\t\t\tif (c.shape) {\n\t\t\t\tconst key = JSON.stringify(c.shape);\n\t\t\t\tif (!map.has(key)) map.set(key, c.shape);\n\t\t\t}\n\t\t}\n\t}\n\treturn [...map.values()];\n}\n\n/* ================= Serializer ================= */\n\nexport class PuzzleSerializer {\n\tstatic async serialize(puzzle: PuzzleData, options: GenerationOptions): Promise<string> {\n\t\tconst bw = new BitWriter();\n\n\t\tbw.write(puzzle.rows, 6);\n\t\tbw.write(puzzle.cols, 6);\n\t\tbw.write(puzzle.symmetry ?? 0, 2);\n\n\t\t/* ---- shapes ---- */\n\t\tconst shapes = collectShapes(puzzle.cells);\n\t\tbw.write(shapes.length, 5);\n\n\t\tfor (const s of shapes) {\n\t\t\tbw.write(s.length, 4);\n\t\t\tbw.write(s[0].length, 4);\n\t\t\tfor (const r of s) for (const v of r) bw.write(v, 1);\n\t\t}\n\n\t\tconst shapeIndex = new Map<string, number>();\n\t\tshapes.forEach((s, i) => shapeIndex.set(JSON.stringify(s), i));\n\n\t\t/* ---- cells ---- */\n\t\tfor (const row of puzzle.cells) {\n\t\t\tfor (const c of row) {\n\t\t\t\tbw.write(c.type, 3);\n\t\t\t\tbw.write(c.color, 3);\n\t\t\t\tif (c.shape) {\n\t\t\t\t\tbw.write(1, 1);\n\t\t\t\t\tbw.write(shapeIndex.get(JSON.stringify(c.shape))!, 5);\n\t\t\t\t} else {\n\t\t\t\t\tbw.write(0, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* ---- edges & nodes\uFF08\u30B5\u30A4\u30BA\u53B3\u5BC6\uFF09 ---- */\n\t\tfor (let y = 0; y < puzzle.rows; y++) for (let x = 0; x < puzzle.cols + 1; x++) bw.write(puzzle.vEdges[y][x].type, 2);\n\n\t\tfor (let y = 0; y < puzzle.rows + 1; y++) for (let x = 0; x < puzzle.cols; x++) bw.write(puzzle.hEdges[y][x].type, 2);\n\n\t\tfor (let y = 0; y < puzzle.rows + 1; y++) for (let x = 0; x < puzzle.cols + 1; x++) bw.write(puzzle.nodes[y][x].type, 2);\n\n\t\t/* ---- options ---- */\n\t\tbw.write(+!!options.useHexagons, 1);\n\t\tbw.write(+!!options.useSquares, 1);\n\t\tbw.write(+!!options.useStars, 1);\n\t\tbw.write(+!!options.useTetris, 1);\n\t\tbw.write(+!!options.useEraser, 1);\n\t\tbw.write(+!!options.useBrokenEdges, 1);\n\t\tbw.write(options.symmetry ?? 0, 2);\n\n\t\tbw.write(Math.round((options.complexity ?? 0) * 254), 8);\n\t\tbw.write(Math.round((options.difficulty ?? 0) * 254), 8);\n\t\tbw.write(Math.round((options.pathLength ?? 0) * 254), 8);\n\n\t\tconst raw = bw.finish();\n\n\t\tconst gz = new Uint8Array(await new Response(new Blob([raw.buffer as ArrayBuffer]).stream().pipeThrough(new CompressionStream(\"gzip\"))).arrayBuffer());\n\n\t\tlet parity = 0;\n\t\tfor (const b of gz) parity ^= b;\n\n\t\tconst final = new Uint8Array(gz.length + 1);\n\t\tfinal.set(gz);\n\t\tfinal[gz.length] = parity;\n\n\t\treturn btoa(String.fromCharCode(...final))\n\t\t\t.replace(/\\+/g, \"-\")\n\t\t\t.replace(/\\//g, \"_\")\n\t\t\t.replace(/=+$/, \"\");\n\t}\n\n\tstatic async deserialize(str: string): Promise<{ puzzle: PuzzleData; options: GenerationOptions }> {\n\t\tlet s = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\t\twhile (s.length % 4) s += \"=\";\n\n\t\tconst bin = atob(s);\n\t\tconst buf = Uint8Array.from(bin, (c) => c.charCodeAt(0));\n\n\t\tlet parity = 0;\n\t\tfor (let i = 0; i < buf.length - 1; i++) parity ^= buf[i];\n\t\tif (parity !== buf.at(-1)) throw new Error(\"Invalid parity data\");\n\n\t\tconst raw = new Uint8Array(await new Response(new Blob([buf.slice(0, -1).buffer]).stream().pipeThrough(new DecompressionStream(\"gzip\"))).arrayBuffer());\n\n\t\tconst br = new BitReader(raw);\n\n\t\tconst rows = br.read(6);\n\t\tconst cols = br.read(6);\n\t\tconst symmetry = br.read(2);\n\n\t\t/* ---- shapes ---- */\n\t\tconst shapeCount = br.read(5);\n\t\tconst shapes: number[][][] = [];\n\n\t\tfor (let i = 0; i < shapeCount; i++) {\n\t\t\tconst h = br.read(4);\n\t\t\tconst w = br.read(4);\n\t\t\tconst s: number[][] = [];\n\t\t\tfor (let y = 0; y < h; y++) {\n\t\t\t\tconst r: number[] = [];\n\t\t\t\tfor (let x = 0; x < w; x++) r.push(br.read(1));\n\t\t\t\ts.push(r);\n\t\t\t}\n\t\t\tshapes.push(s);\n\t\t}\n\n\t\t/* ---- cells ---- */\n\t\tconst cells: CellConstraint[][] = [];\n\t\tfor (let y = 0; y < rows; y++) {\n\t\t\tconst row: CellConstraint[] = [];\n\t\t\tfor (let x = 0; x < cols; x++) {\n\t\t\t\tconst type = br.read(3);\n\t\t\t\tconst color = br.read(3);\n\t\t\t\tconst hasShape = br.read(1);\n\n\t\t\t\tconst cell: CellConstraint = { type, color };\n\t\t\t\tif (hasShape) cell.shape = shapes[br.read(5)].map((r) => r.slice());\n\n\t\t\t\trow.push(cell);\n\t\t\t}\n\t\t\tcells.push(row);\n\t\t}\n\n\t\t/* ---- edges & nodes ---- */\n\t\tconst vEdges = Array.from({ length: rows }, () => Array.from({ length: cols + 1 }, () => ({ type: br.read(2) })));\n\n\t\tconst hEdges = Array.from({ length: rows + 1 }, () => Array.from({ length: cols }, () => ({ type: br.read(2) })));\n\n\t\tconst nodes = Array.from({ length: rows + 1 }, () => Array.from({ length: cols + 1 }, () => ({ type: br.read(2) })));\n\n\t\tconst readRatio = () => {\n\t\t\tconst v = br.read(8);\n\t\t\treturn Math.round((v / 254) * 1000) / 1000;\n\t\t};\n\n\t\tconst options: GenerationOptions = {};\n\n\t\tconst useHexagons = !!br.read(1);\n\t\tconst useSquares = !!br.read(1);\n\t\tconst useStars = !!br.read(1);\n\t\tconst useTetris = !!br.read(1);\n\t\tconst useEraser = !!br.read(1);\n\t\tconst useBroken = !!br.read(1);\n\t\tconst optSymmetry = br.read(2);\n\n\t\tif (useHexagons) options.useHexagons = true;\n\t\tif (useSquares) options.useSquares = true;\n\t\tif (useStars) options.useStars = true;\n\t\tif (useTetris) options.useTetris = true;\n\t\tif (useEraser) options.useEraser = true;\n\t\tif (useBroken) options.useBrokenEdges = true;\n\t\toptions.symmetry = optSymmetry;\n\n\t\tconst complexity = readRatio();\n\t\tconst difficulty = readRatio();\n\t\tconst pathLength = readRatio();\n\n\t\tif (complexity !== 0) options.complexity = complexity;\n\t\tif (difficulty !== 0) options.difficulty = difficulty;\n\t\tif (pathLength !== 0) options.pathLength = pathLength;\n\n\t\treturn { puzzle: { rows, cols, cells, vEdges, hEdges, nodes, symmetry }, options };\n\t}\n}\n", "import { CellType, Color, EdgeType, NodeType, SymmetryType, type CellConstraint, type Point, type PuzzleData } from \"./types\";\n\n/**\n * UI\u8868\u793A\u8A2D\u5B9A\n */\nexport interface WitnessUIOptions {\n\t/** \u30B0\u30EA\u30C3\u30C9\u5468\u56F2\u306E\u4F59\u767D */\n\tgridPadding?: number;\n\t/** \u30BB\u30EB1\u8FBA\u306E\u30B5\u30A4\u30BA */\n\tcellSize?: number;\n\t/** \u901A\u5E38\u30CE\u30FC\u30C9\u306E\u534A\u5F84 */\n\tnodeRadius?: number;\n\t/** \u958B\u59CB\u30CE\u30FC\u30C9\u306E\u534A\u5F84 */\n\tstartNodeRadius?: number;\n\t/** \u30D1\u30B9\u306E\u592A\u3055 */\n\tpathWidth?: number;\n\t/** \u51FA\u53E3\u306E\u9577\u3055 */\n\texitLength?: number;\n\t/** \u30D1\u30BA\u30EB\u306E\u30B5\u30A4\u30BA\u306B\u5408\u308F\u305B\u3066Canvas\u30B5\u30A4\u30BA\u3092\u81EA\u52D5\u8ABF\u6574\u3059\u308B\u304B */\n\tautoResize?: boolean;\n\t/** \u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u8A2D\u5B9A */\n\tanimations?: {\n\t\t/** \u70B9\u6EC5\u30FB\u524D\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u306E\u6642\u9593(ms) */\n\t\tblinkDuration: number;\n\t\t/** \u7121\u52B9\u5316\u30D5\u30A7\u30FC\u30C9\u306E\u6642\u9593(ms) */\n\t\tfadeDuration: number;\n\t\t/** \u70B9\u6EC5\u306E\u5468\u671F(ms) */\n\t\tblinkPeriod: number;\n\t};\n\t/** \u8272\u8A2D\u5B9A */\n\tcolors?: {\n\t\t/** \u901A\u5E38\u306E\u30D1\u30B9\u306E\u8272 */\n\t\tpath?: string;\n\t\t/** \u30A8\u30E9\u30FC\u6642\u306E\u8272 */\n\t\terror?: string;\n\t\t/** \u6210\u529F\u6642\u306E\u30D5\u30E9\u30C3\u30B7\u30E5/\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u7528 */\n\t\tsuccess?: string;\n\t\t/** \u5BFE\u79F0\u30D1\u30B9\u306E\u8272 */\n\t\tsymmetry?: string;\n\t\t/** \u9014\u4E2D\u3067\u96E2\u3057\u305F\u969B\u306E\u30D5\u30A7\u30FC\u30C9\u8272 */\n\t\tinterrupted?: string;\n\t\t/** \u30B0\u30EA\u30C3\u30C9\u306E\u8272 */\n\t\tgrid?: string;\n\t\t/** \u30CE\u30FC\u30C9\u306E\u8272 */\n\t\tnode?: string;\n\t\t/** \u516D\u89D2\u5F62\uFF08\u901A\u904E\u5FC5\u9808\uFF09\u306E\u8272 */\n\t\thexagon?: string;\n\t\t/** \u5404\u8272\u306E\u30AB\u30E9\u30FC\u30B3\u30FC\u30C9\u30DE\u30C3\u30D7 */\n\t\tcolorMap?: Record<number, string>;\n\t\t/** \u5404\u8272\u306E\u30AB\u30E9\u30FC\u30B3\u30FC\u30C9\u30EA\u30B9\u30C8\uFF08\u30A4\u30F3\u30C7\u30C3\u30AF\u30B9\u304CColor\u5024\u306B\u5BFE\u5FDC\uFF09 */\n\t\tcolorList?: string[];\n\t};\n\t/** \u30D1\u30B9\u304C\u5B8C\u4E86\uFF08\u51FA\u53E3\u306B\u5230\u9054\uFF09\u3057\u305F\u969B\u306E\u30B3\u30FC\u30EB\u30D0\u30C3\u30AF */\n\tonPathComplete?: (path: Point[]) => void;\n}\n\ntype WitnessContext = CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\n\n/**\n * the witness\u30D1\u30BA\u30EB\u306E\u63CF\u753B\u3068\u30E6\u30FC\u30B6\u30FC\u64CD\u4F5C\u3092\u7BA1\u7406\u3059\u308B\u30AF\u30E9\u30B9\n */\nexport class WitnessUI {\n\tprivate canvas: HTMLCanvasElement | OffscreenCanvas;\n\tprivate ctx: WitnessContext;\n\tprivate puzzle: PuzzleData | null = null;\n\tprivate options: Required<WitnessUIOptions>;\n\n\tprivate path: Point[] = [];\n\tprivate isDrawing = false;\n\tprivate currentMousePos: Point = { x: 0, y: 0 };\n\tprivate exitTipPos: Point | null = null;\n\tprivate isInvalidPath = false;\n\n\t// \u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u30FB\u72B6\u614B\u8868\u793A\u7528\n\tprivate invalidatedCells: Point[] = [];\n\tprivate invalidatedEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\tprivate invalidatedNodes: Point[] = [];\n\tprivate errorCells: Point[] = [];\n\tprivate errorEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\tprivate errorNodes: Point[] = [];\n\tprivate eraserAnimationStartTime = 0;\n\tprivate isFading = false;\n\tprivate fadeOpacity = 1.0;\n\tprivate fadeColor = \"#ff4444\";\n\tprivate fadingPath: Point[] = [];\n\tprivate fadingTipPos: Point | null = null;\n\n\tprivate isSuccessFading = false;\n\tprivate successFadeStartTime = 0;\n\tprivate startTime = Date.now();\n\n\t// \u900F\u904E\u63CF\u753B\u7528\u306E\u30AA\u30D5\u30B9\u30AF\u30EA\u30FC\u30F3Canvas\n\tprivate offscreenCanvas: HTMLCanvasElement | OffscreenCanvas | null = null;\n\tprivate offscreenCtx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D | null = null;\n\n\tprivate canvasRect: { left: number; top: number; width: number; height: number } | null = null;\n\n\tconstructor(canvasOrId: HTMLCanvasElement | OffscreenCanvas | string, puzzle?: PuzzleData, options: WitnessUIOptions = {}) {\n\t\tif (typeof canvasOrId === \"string\") {\n\t\t\tif (typeof document === \"undefined\") {\n\t\t\t\tthrow new Error(\"Cannot look up canvas by ID in a non-browser environment.\");\n\t\t\t}\n\t\t\tconst el = document.getElementById(canvasOrId);\n\t\t\tif (!(el instanceof HTMLCanvasElement)) {\n\t\t\t\tthrow new Error(`Element with id \"${canvasOrId}\" is not a canvas.`);\n\t\t\t}\n\t\t\tthis.canvas = el;\n\t\t} else {\n\t\t\tthis.canvas = canvasOrId;\n\t\t}\n\n\t\tconst context = (this.canvas as HTMLCanvasElement).getContext(\"2d\") as WitnessContext | null;\n\t\tif (!context) throw new Error(\"Could not get 2D context.\");\n\t\tthis.ctx = context;\n\t\tthis.ctx.imageSmoothingEnabled = false;\n\n\t\tthis.options = this.mergeOptions(options);\n\n\t\tif (puzzle) {\n\t\t\tthis.setPuzzle(puzzle);\n\t\t}\n\n\t\tthis.initEvents();\n\t\tthis.animate();\n\t}\n\n\tprivate mergeOptions(options: WitnessUIOptions): Required<WitnessUIOptions> {\n\t\tconst animations = {\n\t\t\tblinkDuration: options.animations?.blinkDuration ?? this.options?.animations?.blinkDuration ?? 1000,\n\t\t\tfadeDuration: options.animations?.fadeDuration ?? this.options?.animations?.fadeDuration ?? 1000,\n\t\t\tblinkPeriod: options.animations?.blinkPeriod ?? this.options?.animations?.blinkPeriod ?? 800,\n\t\t};\n\n\t\tconst colors = {\n\t\t\tpath: options.colors?.path ?? this.options?.colors?.path ?? \"#ffcc00\",\n\t\t\terror: options.colors?.error ?? this.options?.colors?.error ?? \"#ff4444\",\n\t\t\tsuccess: options.colors?.success ?? this.options?.colors?.success ?? \"#ffcc00\",\n\t\t\tsymmetry: options.colors?.symmetry ?? this.options?.colors?.symmetry ?? \"rgba(255, 255, 255, 0.5)\",\n\t\t\tinterrupted: options.colors?.interrupted ?? this.options?.colors?.interrupted ?? \"#ffcc00\",\n\t\t\tgrid: options.colors?.grid ?? this.options?.colors?.grid ?? \"#555\",\n\t\t\tnode: options.colors?.node ?? this.options?.colors?.node ?? \"#555\",\n\t\t\thexagon: options.colors?.hexagon ?? this.options?.colors?.hexagon ?? \"#000\",\n\t\t\tcolorMap: options.colors?.colorMap ??\n\t\t\t\tthis.options?.colors?.colorMap ?? {\n\t\t\t\t\t[Color.Black]: \"#000\",\n\t\t\t\t\t[Color.White]: \"#fff\",\n\t\t\t\t\t[Color.Red]: \"#f00\",\n\t\t\t\t\t[Color.Blue]: \"#00f\",\n\t\t\t\t\t[Color.None]: \"#ffcc00\",\n\t\t\t\t},\n\t\t\tcolorList: options.colors?.colorList ?? this.options?.colors?.colorList,\n\t\t};\n\n\t\treturn {\n\t\t\tgridPadding: options.gridPadding ?? this.options?.gridPadding ?? 60,\n\t\t\tcellSize: options.cellSize ?? this.options?.cellSize ?? 80,\n\t\t\tnodeRadius: options.nodeRadius ?? this.options?.nodeRadius ?? 6,\n\t\t\tstartNodeRadius: options.startNodeRadius ?? this.options?.startNodeRadius ?? 22,\n\t\t\tpathWidth: options.pathWidth ?? this.options?.pathWidth ?? 18,\n\t\t\texitLength: options.exitLength ?? this.options?.exitLength ?? 25,\n\t\t\tautoResize: options.autoResize ?? this.options?.autoResize ?? true,\n\t\t\tanimations,\n\t\t\tcolors,\n\t\t\tonPathComplete: options.onPathComplete ?? this.options?.onPathComplete ?? (() => {}),\n\t\t};\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\u3092\u8A2D\u5B9A\u3057\u3001\u518D\u63CF\u753B\u3059\u308B\n\t */\n\tpublic setPuzzle(puzzle: PuzzleData) {\n\t\tthis.puzzle = puzzle;\n\t\tthis.path = [];\n\t\tthis.isDrawing = false;\n\t\tthis.exitTipPos = null;\n\t\tthis.invalidatedCells = [];\n\t\tthis.invalidatedEdges = [];\n\t\tthis.invalidatedNodes = [];\n\t\tthis.errorCells = [];\n\t\tthis.errorEdges = [];\n\t\tthis.errorNodes = [];\n\t\tthis.cancelFade();\n\n\t\tif (this.options.autoResize) {\n\t\t\tthis.resizeCanvas();\n\t\t}\n\t\tthis.draw();\n\t}\n\n\t/**\n\t * \u8868\u793A\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u66F4\u65B0\u3059\u308B\n\t */\n\tpublic setOptions(options: WitnessUIOptions) {\n\t\tthis.options = this.mergeOptions({ ...this.options, ...options });\n\t\tif (this.options.autoResize && this.puzzle) {\n\t\t\tthis.resizeCanvas();\n\t\t}\n\t\tthis.draw();\n\t}\n\n\t/**\n\t * \u691C\u8A3C\u7D50\u679C\u3092\u53CD\u6620\u3055\u305B\u308B\uFF08\u4E0D\u6B63\u89E3\u6642\u306E\u8D64\u70B9\u6EC5\u3084\u3001\u6D88\u3057\u30B4\u30E0\u306B\u3088\u308B\u7121\u52B9\u5316\u306E\u8868\u793A\uFF09\n\t */\n\tpublic setValidationResult(isValid: boolean, invalidatedCells: Point[] = [], invalidatedEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [], errorCells: Point[] = [], errorEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [], invalidatedNodes: Point[] = [], errorNodes: Point[] = []) {\n\t\tthis.invalidatedCells = invalidatedCells;\n\t\tthis.invalidatedEdges = invalidatedEdges;\n\t\tthis.invalidatedNodes = invalidatedNodes;\n\t\tthis.errorCells = errorCells;\n\t\tthis.errorEdges = errorEdges;\n\t\tthis.errorNodes = errorNodes;\n\t\tthis.eraserAnimationStartTime = Date.now();\n\n\t\tif (isValid) {\n\t\t\tthis.isSuccessFading = true;\n\t\t\tthis.successFadeStartTime = Date.now();\n\t\t} else {\n\t\t\tthis.isInvalidPath = true;\n\t\t}\n\t}\n\n\tprivate resizeCanvas() {\n\t\tif (!this.puzzle || !this.canvas) return;\n\t\tthis.canvas.width = this.puzzle.cols * this.options.cellSize + this.options.gridPadding * 2;\n\t\tthis.canvas.height = this.puzzle.rows * this.options.cellSize + this.options.gridPadding * 2;\n\t}\n\n\t/**\n\t * Canvas\u306E\u8868\u793A\u4E0A\u306E\u77E9\u5F62\u60C5\u5831\u3092\u8A2D\u5B9A\u3059\u308B\uFF08Worker\u6642\u306A\u3069\u306B\u5FC5\u8981\uFF09\n\t */\n\tpublic setCanvasRect(rect: { left: number; top: number; width: number; height: number }) {\n\t\tthis.canvasRect = rect;\n\t}\n\n\tprivate initEvents() {\n\t\tif (typeof window === \"undefined\" || !(this.canvas instanceof HTMLCanvasElement)) return;\n\t\tthis.canvas.addEventListener(\"mousedown\", (e) => this.handleStart(e));\n\t\twindow.addEventListener(\"mousemove\", (e) => this.handleMove(e));\n\t\twindow.addEventListener(\"mouseup\", (e) => this.handleEnd(e));\n\n\t\tthis.canvas.addEventListener(\n\t\t\t\"touchstart\",\n\t\t\t(e) => {\n\t\t\t\tif (this.handleStart(e.touches[0])) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ passive: false },\n\t\t);\n\t\twindow.addEventListener(\n\t\t\t\"touchmove\",\n\t\t\t(e) => {\n\t\t\t\tif (this.isDrawing) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t\tthis.handleMove(e.touches[0]);\n\t\t\t},\n\t\t\t{ passive: false },\n\t\t);\n\t\twindow.addEventListener(\n\t\t\t\"touchend\",\n\t\t\t(e) => {\n\t\t\t\tif (this.isDrawing) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t\tthis.handleEnd(e.changedTouches[0]);\n\t\t\t},\n\t\t\t{ passive: false },\n\t\t);\n\t}\n\n\t// --- \u5EA7\u6A19\u5909\u63DB ---\n\n\tprivate getCanvasCoords(gridX: number, gridY: number): Point {\n\t\treturn {\n\t\t\tx: this.options.gridPadding + gridX * this.options.cellSize,\n\t\t\ty: this.options.gridPadding + gridY * this.options.cellSize,\n\t\t};\n\t}\n\n\tprivate getExitDir(x: number, y: number): Point | null {\n\t\tif (!this.puzzle) return null;\n\t\tif (this.puzzle.nodes[y]?.[x]?.type !== NodeType.End) return null;\n\t\tif (x === this.puzzle.cols) return { x: 1, y: 0 };\n\t\tif (x === 0) return { x: -1, y: 0 };\n\t\tif (y === 0) return { x: 0, y: -1 };\n\t\tif (y === this.puzzle.rows) return { x: 0, y: 1 };\n\t\treturn { x: 1, y: 0 };\n\t}\n\n\t// --- \u30A4\u30D9\u30F3\u30C8\u30CF\u30F3\u30C9\u30E9 ---\n\n\tpublic handleStart(e: { clientX: number; clientY: number }): boolean {\n\t\tif (!this.puzzle) return false;\n\n\t\tconst rect = this.canvasRect || (this.canvas instanceof HTMLCanvasElement ? this.canvas.getBoundingClientRect() : { left: 0, top: 0, width: this.canvas.width, height: this.canvas.height });\n\t\tconst mouseX = (e.clientX - rect.left) * (this.canvas.width / rect.width);\n\t\tconst mouseY = (e.clientY - rect.top) * (this.canvas.height / rect.height);\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tif (this.puzzle.nodes[r][c].type === NodeType.Start) {\n\t\t\t\t\tconst nodePos = this.getCanvasCoords(c, r);\n\t\t\t\t\tconst dist = Math.hypot(nodePos.x - mouseX, nodePos.y - mouseY);\n\t\t\t\t\tif (dist < this.options.startNodeRadius) {\n\t\t\t\t\t\t// \u30B9\u30BF\u30FC\u30C8\u5730\u70B9\u304C\u30AF\u30EA\u30C3\u30AF\u3055\u308C\u305F\u5834\u5408\u306E\u307F\u3001\u524D\u56DE\u306E\u72B6\u614B\u3092\u30EA\u30BB\u30C3\u30C8\u3057\u3066\u958B\u59CB\u3059\u308B\n\t\t\t\t\t\tthis.cancelFade();\n\t\t\t\t\t\tthis.isSuccessFading = false;\n\t\t\t\t\t\tthis.isInvalidPath = false;\n\t\t\t\t\t\tthis.invalidatedCells = [];\n\t\t\t\t\t\tthis.invalidatedEdges = [];\n\t\t\t\t\t\tthis.invalidatedNodes = [];\n\t\t\t\t\t\tthis.errorCells = [];\n\t\t\t\t\t\tthis.errorEdges = [];\n\t\t\t\t\t\tthis.errorNodes = [];\n\n\t\t\t\t\t\tthis.isDrawing = true;\n\t\t\t\t\t\tthis.path = [{ x: c, y: r }];\n\t\t\t\t\t\tthis.currentMousePos = nodePos;\n\t\t\t\t\t\tthis.exitTipPos = null;\n\t\t\t\t\t\tthis.draw();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic handleMove(e: { clientX: number; clientY: number }) {\n\t\tif (!this.puzzle || !this.isDrawing) return;\n\n\t\tconst rect = this.canvasRect || (this.canvas instanceof HTMLCanvasElement ? this.canvas.getBoundingClientRect() : { left: 0, top: 0, width: this.canvas.width, height: this.canvas.height });\n\t\tconst mouseX = (e.clientX - rect.left) * (this.canvas.width / rect.width);\n\t\tconst mouseY = (e.clientY - rect.top) * (this.canvas.height / rect.height);\n\n\t\tconst lastPoint = this.path[this.path.length - 1];\n\t\tconst lastPos = this.getCanvasCoords(lastPoint.x, lastPoint.y);\n\n\t\tconst dx = mouseX - lastPos.x;\n\t\tconst dy = mouseY - lastPos.y;\n\n\t\tconst symmetry = this.puzzle.symmetry || SymmetryType.None;\n\n\t\tconst exitDir = this.getExitDir(lastPoint.x, lastPoint.y);\n\t\tconst intendedDir = Math.abs(dx) > Math.abs(dy) ? { x: dx > 0 ? 1 : -1, y: 0 } : { x: 0, y: dy > 0 ? 1 : -1 };\n\n\t\t// \u30B4\u30FC\u30EB\u306E\u51FA\u3063\u5F35\u308A\u65B9\u5411\u3078\u306E\u79FB\u52D5\n\t\tif (exitDir && intendedDir.x === exitDir.x && intendedDir.y === exitDir.y) {\n\t\t\tconst dot = dx * exitDir.x + dy * exitDir.y;\n\t\t\tconst length = Math.max(0, Math.min(dot, this.options.exitLength));\n\t\t\tthis.currentMousePos = {\n\t\t\t\tx: lastPos.x + exitDir.x * length,\n\t\t\t\ty: lastPos.y + exitDir.y * length,\n\t\t\t};\n\t\t\tthis.draw();\n\t\t\treturn;\n\t\t}\n\n\t\tconst tryMoveTo = (target: Point, d: number) => {\n\t\t\tconst edgeType = this.getEdgeType(lastPoint, target);\n\t\t\tif (target.x < 0 || target.x > this.puzzle!.cols || target.y < 0 || target.y > this.puzzle!.rows || edgeType === EdgeType.Absent) {\n\t\t\t\tthis.currentMousePos = lastPos;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet maxMove = edgeType === EdgeType.Broken ? this.options.cellSize * 0.35 : this.options.cellSize;\n\n\t\t\t// \u81EA\u5DF1\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\uFF08\u30E1\u30A4\u30F3\u30D1\u30B9\u306E\u30A8\u30C3\u30B8\uFF09\n\t\t\tconst targetEdgeKey = this.getEdgeKey(lastPoint, target);\n\t\t\tconst isBacktracking = this.path.length >= 2 && target.x === this.path[this.path.length - 2].x && target.y === this.path[this.path.length - 2].y;\n\n\t\t\tif (!isBacktracking) {\n\t\t\t\tfor (let i = 0; i < this.path.length - 1; i++) {\n\t\t\t\t\tif (this.getEdgeKey(this.path[i], this.path[i + 1]) === targetEdgeKey) {\n\t\t\t\t\t\t// \u65E2\u306B\u4F7F\u7528\u4E2D\u306E\u30A8\u30C3\u30B8\u306B\u5411\u304B\u3046\u5834\u5408\u306F\u3001\u5373\u5EA7\u306B\u30D6\u30ED\u30C3\u30AF\uFF08\u623B\u308B\u52D5\u4F5C\u306F\u5225\u9014 handleMove \u3067 snap \u51E6\u7406\u3055\u308C\u308B\uFF09\n\t\t\t\t\t\tmaxMove = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// \u81EA\u5DF1\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\uFF08\u30E1\u30A4\u30F3\u30D1\u30B9\u306E\u30CE\u30FC\u30C9\uFF09\n\t\t\tconst isTargetInPath = this.path.some((p) => p.x === target.x && p.y === target.y);\n\t\t\tif (isTargetInPath && this.path.length >= 2) {\n\t\t\t\tconst secondToLast = this.path[this.path.length - 2];\n\t\t\t\tif (target.x !== secondToLast.x || target.y !== secondToLast.y) {\n\t\t\t\t\tmaxMove = Math.min(maxMove, this.options.cellSize * 0.5 - this.options.pathWidth * 0.5);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst symLast = this.getSymmetricalPoint(lastPoint);\n\t\t\t\tconst symTarget = this.getSymmetricalPoint(target);\n\t\t\t\tconst symEdgeType = this.getEdgeType(symLast, symTarget);\n\t\t\t\tconst symPath = this.getSymmetryPath(this.path);\n\t\t\t\tconst symEdgeKey = this.getEdgeKey(symLast, symTarget);\n\n\t\t\t\tif (symTarget.x < 0 || symTarget.x > this.puzzle!.cols || symTarget.y < 0 || symTarget.y > this.puzzle!.rows || symEdgeType === EdgeType.Absent) {\n\t\t\t\t\tthis.currentMousePos = lastPos;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (symEdgeType === EdgeType.Broken) {\n\t\t\t\t\tmaxMove = Math.min(maxMove, this.options.cellSize * 0.35);\n\t\t\t\t}\n\n\t\t\t\t// \u5BFE\u79F0\u30D1\u30B9\u3068\u306E\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\n\t\t\t\tconst isNodeOccupiedBySym = symPath.some((p) => p.x === target.x && p.y === target.y);\n\t\t\t\tconst isSymNodeOccupiedByMain = this.path.some((p) => p.x === symTarget.x && p.y === symTarget.y);\n\t\t\t\tconst isMeetingAtNode = target.x === symTarget.x && target.y === symTarget.y;\n\t\t\t\tconst isEdgeOccupiedBySym = symPath.some((p, i) => i < symPath.length - 1 && this.getEdgeKey(symPath[i], symPath[i + 1]) === targetEdgeKey);\n\t\t\t\tconst isMirrorEdgeOccupiedByMain = this.path.some((p, i) => i < this.path.length - 1 && this.getEdgeKey(this.path[i], this.path[i + 1]) === symEdgeKey);\n\t\t\t\tconst isSelfMirrorEdge = targetEdgeKey === symEdgeKey;\n\n\t\t\t\tif (isNodeOccupiedBySym || isSymNodeOccupiedByMain || isMeetingAtNode || isEdgeOccupiedBySym || isMirrorEdgeOccupiedByMain || isSelfMirrorEdge) {\n\t\t\t\t\tmaxMove = Math.min(maxMove, this.options.cellSize * 0.5 - this.options.pathWidth * 0.5);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (target.x !== lastPoint.x) {\n\t\t\t\tthis.currentMousePos = {\n\t\t\t\t\tx: lastPos.x + Math.max(-maxMove, Math.min(maxMove, d)),\n\t\t\t\t\ty: lastPos.y,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthis.currentMousePos = {\n\t\t\t\t\tx: lastPos.x,\n\t\t\t\t\ty: lastPos.y + Math.max(-maxMove, Math.min(maxMove, d)),\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\n\t\tif (Math.abs(dx) > Math.abs(dy)) {\n\t\t\tconst dir = dx > 0 ? 1 : -1;\n\t\t\ttryMoveTo({ x: lastPoint.x + dir, y: lastPoint.y }, dx);\n\t\t} else {\n\t\t\tconst dir = dy > 0 ? 1 : -1;\n\t\t\ttryMoveTo({ x: lastPoint.x, y: lastPoint.y + dir }, dy);\n\t\t}\n\n\t\tconst neighbors = [\n\t\t\t{ x: lastPoint.x + 1, y: lastPoint.y },\n\t\t\t{ x: lastPoint.x - 1, y: lastPoint.y },\n\t\t\t{ x: lastPoint.x, y: lastPoint.y + 1 },\n\t\t\t{ x: lastPoint.x, y: lastPoint.y - 1 },\n\t\t];\n\n\t\tconst symPath = this.getSymmetryPath(this.path);\n\n\t\tfor (const n of neighbors) {\n\t\t\tif (n.x >= 0 && n.x <= this.puzzle.cols && n.y >= 0 && n.y <= this.puzzle.rows) {\n\t\t\t\tconst nPos = this.getCanvasCoords(n.x, n.y);\n\t\t\t\tconst dist = Math.hypot(nPos.x - this.currentMousePos.x, nPos.y - this.currentMousePos.y);\n\n\t\t\t\tif (dist < this.options.cellSize * 0.3) {\n\t\t\t\t\tconst idx = this.path.findIndex((p) => p.x === n.x && p.y === n.y);\n\t\t\t\t\tif (idx === -1) {\n\t\t\t\t\t\t// \u885D\u7A81\u30C1\u30A7\u30C3\u30AF\n\t\t\t\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\t\t\t\tconst sn = this.getSymmetricalPoint(n);\n\t\t\t\t\t\t\t// \u30CE\u30FC\u30C9\u81EA\u4F53\u304C\u5BFE\u79F0\u70B9\u306E\u5834\u5408\n\t\t\t\t\t\t\tif (n.x === sn.x && n.y === sn.y) continue;\n\t\t\t\t\t\t\t// \u4ED6\u306E\u7DDA\u3078\u306E\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\n\t\t\t\t\t\t\tif (this.path.some((p) => p.x === sn.x && p.y === sn.y)) continue;\n\t\t\t\t\t\t\tif (symPath.some((p) => p.x === n.x && p.y === n.y)) continue;\n\t\t\t\t\t\t\t// \u30A8\u30C3\u30B8\u306E\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\n\t\t\t\t\t\t\tconst edgeKey = this.getEdgeKey(lastPoint, n);\n\t\t\t\t\t\t\tconst symEdgeKey = this.getEdgeKey(this.getSymmetricalPoint(lastPoint), sn);\n\t\t\t\t\t\t\tif (edgeKey === symEdgeKey) continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.path.push(n);\n\t\t\t\t\t} else if (idx === this.path.length - 2) {\n\t\t\t\t\t\tthis.path.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.draw();\n\t}\n\n\tpublic handleEnd(e: { clientX: number; clientY: number }) {\n\t\tif (!this.puzzle || !this.isDrawing) return;\n\t\tthis.isDrawing = false;\n\n\t\tconst lastPoint = this.path[this.path.length - 1];\n\t\tconst lastPos = this.getCanvasCoords(lastPoint.x, lastPoint.y);\n\t\tconst exitDir = this.getExitDir(lastPoint.x, lastPoint.y);\n\n\t\tif (exitDir) {\n\t\t\tconst dx_exit = this.currentMousePos.x - lastPos.x;\n\t\t\tconst dy_exit = this.currentMousePos.y - lastPos.y;\n\t\t\tconst dot = dx_exit * exitDir.x + dy_exit * exitDir.y;\n\n\t\t\tif (dot > 0) {\n\t\t\t\t// \u51FA\u3063\u5F35\u308A\u306E\u7BC4\u56F2\u306B\u5165\u3063\u3066\u3044\u308C\u3070\u3001\u6700\u5F8C\u307E\u3067\u4F38\u3070\u3057\u3066\u30B4\u30FC\u30EB\u3068\u3059\u308B\n\t\t\t\tthis.exitTipPos = {\n\t\t\t\t\tx: lastPos.x + exitDir.x * this.options.exitLength,\n\t\t\t\t\ty: lastPos.y + exitDir.y * this.options.exitLength,\n\t\t\t\t};\n\t\t\t\tthis.options.onPathComplete(this.path);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.exitTipPos = exitDir ? { ...this.currentMousePos } : null;\n\t\tthis.startFade(this.options.colors.interrupted); // \u9014\u4E2D\u3067\u96E2\u3057\u305F\u5834\u5408\u306F\u6307\u5B9A\u3055\u308C\u305F\u30D5\u30A7\u30FC\u30C9\u8272\u3067\u6D88\u3048\u308B\n\t}\n\n\tprivate getEdgeType(p1: Point, p2: Point): EdgeType {\n\t\tif (!this.puzzle) return EdgeType.Absent;\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\tif (y < 0 || y >= this.puzzle.rows) return EdgeType.Absent;\n\t\t\treturn this.puzzle.vEdges[y][p1.x].type;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\tif (x < 0 || x >= this.puzzle.cols) return EdgeType.Absent;\n\t\t\treturn this.puzzle.hEdges[p1.y][x].type;\n\t\t}\n\t}\n\n\tprivate startFade(color = \"#ff4444\") {\n\t\tthis.isFading = true;\n\t\tthis.fadeOpacity = 1.0;\n\t\tthis.fadeColor = color;\n\t\tthis.fadingPath = [...this.path];\n\t\tthis.fadingTipPos = this.exitTipPos ? { ...this.exitTipPos } : null;\n\t\tthis.path = [];\n\t}\n\n\tprivate cancelFade() {\n\t\tthis.isFading = false;\n\t}\n\n\tprivate animate() {\n\t\tif (typeof requestAnimationFrame === \"undefined\") {\n\t\t\tthis.draw();\n\t\t\treturn;\n\t\t}\n\t\tthis.draw();\n\n\t\tif (this.isFading) {\n\t\t\t// \u30D5\u30A7\u30FC\u30C9\u901F\u5EA6\u3092 fadeDuration \u306B\u57FA\u3065\u3044\u3066\u8A08\u7B97\n\t\t\tconst step = 1000 / (this.options.animations.fadeDuration * 60); // 60FPS\u60F3\u5B9A\n\t\t\tthis.fadeOpacity -= step;\n\t\t\tif (this.fadeOpacity <= 0) {\n\t\t\t\tthis.isFading = false;\n\t\t\t\tthis.fadeOpacity = 0;\n\t\t\t}\n\t\t}\n\n\t\trequestAnimationFrame(() => this.animate());\n\t}\n\n\t// --- Drawing Logic ---\n\n\tpublic draw() {\n\t\tif (!this.puzzle || !this.ctx) return;\n\n\t\tconst ctx = this.ctx;\n\t\tconst now = Date.now();\n\t\tctx.globalAlpha = 1.0;\n\t\tctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n\t\tthis.drawGrid(ctx);\n\t\tthis.drawConstraints(ctx);\n\t\tthis.drawNodes(ctx);\n\n\t\tif (this.path.length === 0 && !this.isDrawing) {\n\t\t\tthis.drawRipples(ctx);\n\t\t}\n\n\t\tif (this.isFading) {\n\t\t\tthis.drawPath(ctx, this.fadingPath, false, this.fadeColor, this.fadeOpacity, this.fadingTipPos);\n\t\t\tif (this.puzzle.symmetry !== undefined && this.puzzle.symmetry !== SymmetryType.None) {\n\t\t\t\tconst symFadingPath = this.getSymmetryPath(this.fadingPath);\n\t\t\t\tconst symColor = this.options.colors.symmetry as string;\n\t\t\t\tlet symTipPos: Point | null = null;\n\t\t\t\tif (this.fadingTipPos) {\n\t\t\t\t\tconst gridRelX = (this.fadingTipPos.x - this.options.gridPadding) / this.options.cellSize;\n\t\t\t\t\tconst gridRelY = (this.fadingTipPos.y - this.options.gridPadding) / this.options.cellSize;\n\t\t\t\t\tconst symGridRel = this.getSymmetricalPoint({ x: gridRelX, y: gridRelY });\n\t\t\t\t\tsymTipPos = {\n\t\t\t\t\t\tx: symGridRel.x * this.options.cellSize + this.options.gridPadding,\n\t\t\t\t\t\ty: symGridRel.y * this.options.cellSize + this.options.gridPadding,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// \u9014\u4E2D\u3067\u96E2\u3057\u305F\u5834\u5408\u306F\u30E1\u30A4\u30F3\u3068\u540C\u3058\u8272\u3067\u6D88\u3048\u3066\u3082\u826F\u3044\u304C\u3001\u4E00\u5FDC\u5BFE\u79F0\u5074\u306E\u8272\u3067\u30D5\u30A7\u30FC\u30C9\u3055\u305B\u308B\n\t\t\t\tthis.drawPath(ctx, symFadingPath, false, symColor, this.fadeOpacity, symTipPos);\n\t\t\t}\n\t\t} else if (this.path.length > 0) {\n\t\t\tlet color = this.isInvalidPath ? (this.options.colors.error as string) : (this.options.colors.path as string);\n\n\t\t\t// \u6210\u529F\u6642\u306F\u6210\u529F\u6642\u306E\u8272\u3092\u30C7\u30D5\u30A9\u30EB\u30C8\u3068\u3059\u308B\uFF08\u5BFE\u79F0\u30E2\u30FC\u30C9\u6642\u306F\u5143\u306E\u8272\u3092\u7DAD\u6301\uFF09\n\t\t\tif (this.isSuccessFading && !this.puzzle.symmetry) {\n\t\t\t\tcolor = this.options.colors.success as string;\n\t\t\t}\n\n\t\t\t// Eraser\u7121\u52B9\u5316\u524D\u306E\u70B9\u6EC5\u6642\u306A\u3069\u306E\u8272\u5236\u5FA1\n\t\t\tif (!this.isDrawing && this.exitTipPos && !this.isInvalidPath) {\n\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\t\t\t\tif (elapsed < blinkDuration) {\n\t\t\t\t\tif (this.isSuccessFading) {\n\t\t\t\t\t\tconst hasNegation = this.invalidatedCells.length > 0 || this.invalidatedEdges.length > 0 || this.invalidatedNodes.length > 0;\n\t\t\t\t\t\tif (hasNegation) {\n\t\t\t\t\t\t\t// \u6D88\u3057\u30B4\u30E0\u7121\u52B9\u5316\u304C\u3042\u308B\u6210\u529F\u6642\u306F\u3001\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u4E2D\u306E\u307F\u8D64\u8272\uFF08\u4E00\u77AC\u3067\u5207\u308A\u66FF\u3048\uFF09\n\t\t\t\t\t\t\tcolor = this.options.colors.error as string;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// \u5931\u6557\u6642\uFF08Eraser\u3042\u308A\uFF09\u306F\u70B9\u6EC5\u3055\u305B\u308B\n\t\t\t\t\t\t// \u958B\u59CB\u3068\u7D42\u4E86\u3092\u6ED1\u3089\u304B\u306B\u3059\u308B\n\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\n\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\n\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\n\n\t\t\t\t\t\tconst blinkFactor = (Math.sin((now * Math.PI * 2) / this.options.animations.blinkPeriod!) + 1) / 2;\n\t\t\t\t\t\tcolor = this.lerpColor(this.options.colors.path as string, this.options.colors.error as string, blinkFactor * transitionFactor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.drawPath(ctx, this.path, this.isDrawing, color, 1.0, this.isDrawing ? this.currentMousePos : this.exitTipPos);\n\n\t\t\tif (this.puzzle.symmetry !== undefined && this.puzzle.symmetry !== SymmetryType.None) {\n\t\t\t\tconst symPath = this.getSymmetryPath(this.path);\n\t\t\t\tlet symColor = this.options.colors.symmetry as string;\n\n\t\t\t\t// \u30A8\u30E9\u30FC\u6642\u3084\u6210\u529F\u6642\u306F\u8272\u3092\u4E0A\u66F8\u304D\uFF08\u5BFE\u79F0\u30E2\u30FC\u30C9\u6210\u529F\u6642\u306F\u5143\u306E\u8272\u3092\u7DAD\u6301\uFF09\n\t\t\t\tif (this.isInvalidPath) {\n\t\t\t\t\tsymColor = this.options.colors.error as string;\n\t\t\t\t}\n\n\t\t\t\tif (!this.isDrawing && this.exitTipPos && !this.isInvalidPath) {\n\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\t\t\t\t\tif (elapsed < blinkDuration) {\n\t\t\t\t\t\tif (this.isSuccessFading) {\n\t\t\t\t\t\t\tconst hasNegation = this.invalidatedCells.length > 0 || this.invalidatedEdges.length > 0 || this.invalidatedNodes.length > 0;\n\t\t\t\t\t\t\tif (hasNegation) {\n\t\t\t\t\t\t\t\tsymColor = this.options.colors.error as string;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\n\t\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\n\t\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\n\t\t\t\t\t\t\tconst blinkFactor = (Math.sin((now * Math.PI * 2) / this.options.animations.blinkPeriod!) + 1) / 2;\n\t\t\t\t\t\t\tsymColor = this.lerpColor(this.options.colors.symmetry as string, this.options.colors.error as string, blinkFactor * transitionFactor);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet symTipPos: Point | null = null;\n\t\t\t\tif (this.isDrawing || this.exitTipPos) {\n\t\t\t\t\tconst tip = this.isDrawing ? this.currentMousePos : this.exitTipPos!;\n\t\t\t\t\t// Canvas\u5EA7\u6A19\u304B\u3089\u30B0\u30EA\u30C3\u30C9\u76F8\u5BFE\u5EA7\u6A19\u306B\u5909\u63DB\u3057\u3066\u5BFE\u79F0\u70B9\u3092\u6C42\u3081\u3001\u518D\u5EA6Canvas\u5EA7\u6A19\u306B\u623B\u3059\n\t\t\t\t\tconst gridRelX = (tip.x - this.options.gridPadding) / this.options.cellSize;\n\t\t\t\t\tconst gridRelY = (tip.y - this.options.gridPadding) / this.options.cellSize;\n\t\t\t\t\tconst symGridRel = this.getSymmetricalPoint({ x: gridRelX, y: gridRelY }, true);\n\t\t\t\t\tsymTipPos = {\n\t\t\t\t\t\tx: symGridRel.x * this.options.cellSize + this.options.gridPadding,\n\t\t\t\t\t\ty: symGridRel.y * this.options.cellSize + this.options.gridPadding,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tthis.drawPath(ctx, symPath, this.isDrawing, symColor, 1.0, symTipPos);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate drawRipples(ctx: WitnessContext) {\n\t\tif (!this.puzzle) return;\n\t\tconst time = (Date.now() - this.startTime) / 500;\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tconst node = this.puzzle.nodes[r][c];\n\t\t\t\tif (node.type === NodeType.End) {\n\t\t\t\t\tconst pos = this.getCanvasCoords(c, r);\n\t\t\t\t\tconst dir = this.getExitDir(c, r);\n\t\t\t\t\tif (!dir) continue;\n\t\t\t\t\tconst exitPos = {\n\t\t\t\t\t\tx: pos.x + dir.x * this.options.exitLength,\n\t\t\t\t\t\ty: pos.y + dir.y * this.options.exitLength,\n\t\t\t\t\t};\n\n\t\t\t\t\tconst t = time % 4.0;\n\t\t\t\t\tconst radius = t * 5;\n\t\t\t\t\tconst opacity = Math.max(0, 1 - t / 3.0);\n\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(exitPos.x, exitPos.y, radius, 0, Math.PI * 2);\n\t\t\t\t\tctx.strokeStyle = `rgba(170, 170, 170, ${opacity * 0.4})`;\n\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate drawGrid(ctx: WitnessContext) {\n\t\tif (!this.puzzle || !this.options.colors.grid) return;\n\t\tctx.strokeStyle = this.options.colors.grid;\n\t\tctx.lineWidth = 12;\n\t\tctx.lineCap = \"round\";\n\n\t\tconst drawEdge = (p1: Point, p2: Point, type: EdgeType) => {\n\t\t\tif (type === EdgeType.Absent) return;\n\n\t\t\tif (type === EdgeType.Broken) {\n\t\t\t\tconst gapSize = 0.15;\n\t\t\t\tconst q1 = {\n\t\t\t\t\tx: p1.x + (p2.x - p1.x) * (0.5 - gapSize),\n\t\t\t\t\ty: p1.y + (p2.y - p1.y) * (0.5 - gapSize),\n\t\t\t\t};\n\t\t\t\tconst q2 = {\n\t\t\t\t\tx: p1.x + (p2.x - p1.x) * (0.5 + gapSize),\n\t\t\t\t\ty: p1.y + (p2.y - p1.y) * (0.5 + gapSize),\n\t\t\t\t};\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(p1.x, p1.y);\n\t\t\t\tctx.lineTo(q1.x, q1.y);\n\t\t\t\tctx.stroke();\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(q2.x, q2.y);\n\t\t\t\tctx.lineTo(p2.x, p2.y);\n\t\t\t\tctx.stroke();\n\t\t\t} else {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(p1.x, p1.y);\n\t\t\t\tctx.lineTo(p2.x, p2.y);\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t};\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c < this.puzzle.cols; c++) {\n\t\t\t\tdrawEdge(this.getCanvasCoords(c, r), this.getCanvasCoords(c + 1, r), this.puzzle.hEdges[r][c].type);\n\t\t\t}\n\t\t}\n\n\t\tfor (let r = 0; r < this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tdrawEdge(this.getCanvasCoords(c, r), this.getCanvasCoords(c, r + 1), this.puzzle.vEdges[r][c].type);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate drawConstraints(ctx: WitnessContext) {\n\t\tif (!this.puzzle) return;\n\t\tconst now = Date.now();\n\t\tconst blinkFactor = (Math.sin((now * Math.PI * 2) / this.options.animations.blinkPeriod!) + 1) / 2;\n\n\t\tfor (let r = 0; r < this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c < this.puzzle.cols; c++) {\n\t\t\t\tconst cell = this.puzzle.cells[r][c];\n\t\t\t\tconst pos = this.getCanvasCoords(c + 0.5, r + 0.5);\n\n\t\t\t\tconst isInvalidated = this.invalidatedCells.some((p) => p.x === c && p.y === r);\n\t\t\t\tconst isError = this.errorCells.some((p) => p.x === c && p.y === r);\n\n\t\t\t\tlet opacity = 1.0;\n\t\t\t\tlet overrideColor: string | undefined = undefined;\n\n\t\t\t\tconst originalColor = this.getColorCode(cell.color);\n\t\t\t\tconst errorColor = this.options.colors.error as string;\n\n\t\t\t\tif (isError) {\n\t\t\t\t\toverrideColor = this.lerpColor(originalColor, errorColor, blinkFactor);\n\t\t\t\t}\n\n\t\t\t\tif (isInvalidated) {\n\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\n\t\t\t\t\tif (this.isFading) {\n\t\t\t\t\t\topacity = this.fadeOpacity;\n\t\t\t\t\t} else if (elapsed < blinkDuration) {\n\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\n\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\n\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\n\t\t\t\t\t\toverrideColor = this.lerpColor(originalColor, errorColor, blinkFactor * transitionFactor);\n\t\t\t\t\t} else {\n\t\t\t\t\t\topacity = Math.max(0.3, 1.0 - (elapsed - blinkDuration) / this.options.animations.fadeDuration!);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (opacity < 1.0 || overrideColor) {\n\t\t\t\t\tconst { canvas: tempCanvas, ctx: tempCtx } = this.prepareOffscreen();\n\t\t\t\t\tthis.drawConstraintItem(tempCtx, cell, pos, overrideColor);\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.globalAlpha = opacity;\n\t\t\t\t\tctx.drawImage(tempCanvas, 0, 0);\n\t\t\t\t\tctx.restore();\n\t\t\t\t} else {\n\t\t\t\t\tthis.drawConstraintItem(ctx, cell, pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tctx.lineWidth = 2;\n\t\tconst hexRadius = 8;\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c < this.puzzle.cols; c++) {\n\t\t\t\tif (this.puzzle.hEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst pos = this.getCanvasCoords(c + 0.5, r);\n\t\t\t\t\tctx.save();\n\t\t\t\t\tconst isInvalidated = this.invalidatedEdges.some((e) => e.type === \"h\" && e.r === r && e.c === c);\n\t\t\t\t\tconst isError = this.errorEdges.some((e) => e.type === \"h\" && e.r === r && e.c === c);\n\n\t\t\t\t\tif (isError) {\n\t\t\t\t\t\tconst color = this.lerpColor(this.options.colors.hexagon as string, this.options.colors.error as string, blinkFactor);\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t} else if (isInvalidated) {\n\t\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\t\t\t\t\t\tif (this.isFading) ctx.globalAlpha *= this.fadeOpacity;\n\t\t\t\t\t\telse if (elapsed < blinkDuration) {\n\t\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\n\t\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\n\t\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\n\t\t\t\t\t\t\tconst color = this.lerpColor(this.options.colors.hexagon as string, this.options.colors.error as string, blinkFactor * transitionFactor);\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.globalAlpha *= Math.max(0.3, 1.0 - (elapsed - blinkDuration) / this.options.animations.fadeDuration!);\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius);\n\t\t\t\t\t}\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tif (this.puzzle.vEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst pos = this.getCanvasCoords(c, r + 0.5);\n\t\t\t\t\tctx.save();\n\t\t\t\t\tconst isInvalidated = this.invalidatedEdges.some((e) => e.type === \"v\" && e.r === r && e.c === c);\n\t\t\t\t\tconst isError = this.errorEdges.some((e) => e.type === \"v\" && e.r === r && e.c === c);\n\n\t\t\t\t\tif (isError) {\n\t\t\t\t\t\tconst color = this.lerpColor(this.options.colors.hexagon as string, this.options.colors.error as string, blinkFactor);\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t} else if (isInvalidated) {\n\t\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\t\t\t\t\t\tif (this.isFading) ctx.globalAlpha *= this.fadeOpacity;\n\t\t\t\t\t\telse if (elapsed < blinkDuration) {\n\t\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\n\t\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\n\t\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\n\t\t\t\t\t\t\tconst color = this.lerpColor(this.options.colors.hexagon as string, this.options.colors.error as string, blinkFactor * transitionFactor);\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.globalAlpha *= Math.max(0.3, 1.0 - (elapsed - blinkDuration) / this.options.animations.fadeDuration!);\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius);\n\t\t\t\t\t}\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tif (this.puzzle.nodes[r][c].type === NodeType.Hexagon) {\n\t\t\t\t\tconst pos = this.getCanvasCoords(c, r);\n\t\t\t\t\tctx.save();\n\t\t\t\t\tconst isInvalidated = this.invalidatedNodes.some((p) => p.x === c && p.y === r);\n\t\t\t\t\tconst isError = this.errorNodes.some((p) => p.x === c && p.y === r);\n\n\t\t\t\t\tif (isError) {\n\t\t\t\t\t\tconst color = this.lerpColor(this.options.colors.hexagon as string, this.options.colors.error as string, blinkFactor);\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t} else if (isInvalidated) {\n\t\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\n\t\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\n\t\t\t\t\t\tif (this.isFading) ctx.globalAlpha *= this.fadeOpacity;\n\t\t\t\t\t\telse if (elapsed < blinkDuration) {\n\t\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\n\t\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\n\t\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\n\t\t\t\t\t\t\tconst color = this.lerpColor(this.options.colors.hexagon as string, this.options.colors.error as string, blinkFactor * transitionFactor);\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.globalAlpha *= Math.max(0.3, 1.0 - (elapsed - blinkDuration) / this.options.animations.fadeDuration!);\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius);\n\t\t\t\t\t}\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u5358\u4E00\u306E\u5236\u7D04\u30A2\u30A4\u30C6\u30E0\u3092\u63CF\u753B\uFF08\u5EA7\u6A19\u306F\u30AD\u30E3\u30F3\u30D0\u30B9\u5168\u4F53\u306B\u5BFE\u3059\u308B\u7D76\u5BFE\u5EA7\u6A19\uFF09\n\t */\n\tprivate drawConstraintItem(ctx: WitnessContext, cell: CellConstraint, pos: Point, overrideColor?: string) {\n\t\tif (cell.type === CellType.Square) {\n\t\t\tconst size = 26;\n\t\t\tconst radius = 8;\n\t\t\tctx.fillStyle = overrideColor || this.getColorCode(cell.color);\n\t\t\tthis.drawRoundedRect(ctx, pos.x - size / 2, pos.y - size / 2, size, size, radius);\n\t\t} else if (cell.type === CellType.Star) {\n\t\t\tthis.drawStar(ctx, pos.x, pos.y, 12, 16, 8, cell.color, overrideColor);\n\t\t} else if (cell.type === CellType.Tetris || cell.type === CellType.TetrisRotated) {\n\t\t\tthis.drawTetris(ctx, pos.x, pos.y, cell.shape || [], cell.type === CellType.TetrisRotated, cell.color, overrideColor);\n\t\t} else if (cell.type === CellType.Eraser) {\n\t\t\tthis.drawEraser(ctx, pos.x, pos.y, 14, 3, cell.color, overrideColor);\n\t\t}\n\t}\n\n\tprivate drawNodes(ctx: WitnessContext) {\n\t\tif (!this.puzzle) return;\n\t\tconst isNodeIsolated = (c: number, r: number) => {\n\t\t\tconst connectedEdges: EdgeType[] = [];\n\t\t\tif (c > 0) connectedEdges.push(this.puzzle!.hEdges[r][c - 1].type);\n\t\t\tif (c < this.puzzle!.cols) connectedEdges.push(this.puzzle!.hEdges[r][c].type);\n\t\t\tif (r > 0) connectedEdges.push(this.puzzle!.vEdges[r - 1][c].type);\n\t\t\tif (r < this.puzzle!.rows) connectedEdges.push(this.puzzle!.vEdges[r][c].type);\n\t\t\treturn connectedEdges.length > 0 && connectedEdges.every((e) => e === EdgeType.Absent);\n\t\t};\n\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\n\t\t\t\tif (isNodeIsolated(c, r)) continue;\n\n\t\t\t\tconst node = this.puzzle.nodes[r][c];\n\t\t\t\tif (node.type === NodeType.Hexagon) continue;\n\n\t\t\t\tconst pos = this.getCanvasCoords(c, r);\n\n\t\t\t\tif (node.type === NodeType.Start) {\n\t\t\t\t\tif (this.options.colors.node) ctx.fillStyle = this.options.colors.node;\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(pos.x, pos.y, this.options.startNodeRadius, 0, Math.PI * 2);\n\t\t\t\t\tctx.fill();\n\t\t\t\t} else if (node.type === NodeType.End) {\n\t\t\t\t\tconst dir = this.getExitDir(c, r);\n\t\t\t\t\tif (!dir) continue;\n\t\t\t\t\tif (this.options.colors.node) ctx.strokeStyle = this.options.colors.node;\n\t\t\t\t\tctx.lineWidth = 12;\n\t\t\t\t\tctx.lineCap = \"round\";\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(pos.x, pos.y);\n\t\t\t\t\tctx.lineTo(pos.x + dir.x * this.options.exitLength, pos.y + dir.y * this.options.exitLength);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t} else {\n\t\t\t\t\tif (this.options.colors.node) ctx.fillStyle = this.options.colors.node;\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(pos.x, pos.y, this.options.nodeRadius, 0, Math.PI * 2);\n\t\t\t\t\tctx.fill();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate drawPath(ctx: WitnessContext, path: Point[], isDrawing: boolean, color: string | undefined, opacity: number, tipPos: Point | null = null) {\n\t\tif (path.length === 0 || !color) return;\n\n\t\tlet finalOpacity = opacity;\n\t\tlet finalColor = color;\n\t\tif (color.startsWith(\"rgba\")) {\n\t\t\tconst match = color.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\n\t\t\tif (match) {\n\t\t\t\tconst r = match[1];\n\t\t\t\tconst g = match[2];\n\t\t\t\tconst b = match[3];\n\t\t\t\tconst a = match[4] ? parseFloat(match[4]) : 1.0;\n\t\t\t\tfinalColor = `rgb(${r},${g},${b})`;\n\t\t\t\tfinalOpacity *= a;\n\t\t\t}\n\t\t} else if (color === \"transparent\") {\n\t\t\treturn;\n\t\t}\n\n\t\t// \u91CD\u306A\u308A\u90E8\u5206\u306E\u8272\u304C\u6FC3\u304F\u306A\u308B\u306E\u3092\u9632\u3050\u305F\u3081\u3001\u5E38\u306B\u30AA\u30D5\u30B9\u30AF\u30EA\u30FC\u30F3\u3067\u4E0D\u900F\u660E\u306B\u63CF\u753B\u3057\u3066\u304B\u3089\u900F\u904E\u3067\u5408\u6210\u3059\u308B\n\t\tconst { canvas: tempCanvas, ctx: tempCtx } = this.prepareOffscreen();\n\t\tthis.drawPathInternal(tempCtx, path, isDrawing, finalColor, tipPos);\n\t\tctx.save();\n\t\tctx.globalAlpha = finalOpacity;\n\t\tctx.drawImage(tempCanvas, 0, 0);\n\t\tctx.restore();\n\t}\n\n\tprivate drawPathInternal(ctx: WitnessContext, path: Point[], isDrawing: boolean, color: string, tipPos: Point | null = null) {\n\t\tctx.save();\n\t\tctx.strokeStyle = color;\n\t\tctx.fillStyle = color;\n\t\tctx.lineWidth = this.options.pathWidth;\n\t\tctx.lineCap = \"round\";\n\t\tctx.lineJoin = \"round\";\n\n\t\tctx.beginPath();\n\t\tconst startPos = this.getCanvasCoords(path[0].x, path[0].y);\n\t\tctx.moveTo(startPos.x, startPos.y);\n\n\t\tfor (let i = 1; i < path.length; i++) {\n\t\t\tconst pos = this.getCanvasCoords(path[i].x, path[i].y);\n\t\t\tctx.lineTo(pos.x, pos.y);\n\t\t}\n\n\t\tconst actualTipPos = tipPos || this.currentMousePos;\n\t\tif (isDrawing || tipPos) {\n\t\t\tctx.lineTo(actualTipPos.x, actualTipPos.y);\n\t\t}\n\n\t\tctx.stroke();\n\n\t\tctx.beginPath();\n\t\tctx.arc(startPos.x, startPos.y, this.options.startNodeRadius, 0, Math.PI * 2);\n\t\tctx.fill();\n\n\t\tif (isDrawing || tipPos) {\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(actualTipPos.x, actualTipPos.y, this.options.pathWidth / 2, 0, Math.PI * 2);\n\t\t\tctx.fill();\n\t\t}\n\t\tctx.restore();\n\t}\n\n\tprivate drawRoundedRect(ctx: WitnessContext, x: number, y: number, width: number, height: number, radius: number) {\n\t\tctx.beginPath();\n\t\tctx.moveTo(x + radius, y);\n\t\tctx.lineTo(x + width - radius, y);\n\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\tctx.lineTo(x + width, y + height - radius);\n\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\tctx.lineTo(x + radius, y + height);\n\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\tctx.lineTo(x, y + radius);\n\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\tctx.closePath();\n\t\tctx.fill();\n\t}\n\n\tprivate drawHexagon(ctx: WitnessContext, x: number, y: number, radius: number, overrideColor?: string) {\n\t\tif (!this.options.colors.hexagon && !overrideColor) return;\n\t\tctx.fillStyle = (overrideColor || this.options.colors.hexagon) as string;\n\t\tctx.beginPath();\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tconst angle = (Math.PI / 3) * i;\n\t\t\tconst px = x + radius * Math.cos(angle);\n\t\t\tconst py = y + radius * Math.sin(angle);\n\t\t\tif (i === 0) ctx.moveTo(px, py);\n\t\t\telse ctx.lineTo(px, py);\n\t\t}\n\t\tctx.closePath();\n\t\tctx.fill();\n\t}\n\n\tprivate drawEraser(ctx: WitnessContext, x: number, y: number, radius: number, points: number, colorEnum: Color, overrideColor?: string) {\n\t\tctx.strokeStyle = overrideColor || this.getColorCode(colorEnum);\n\t\tctx.lineWidth = radius * 0.5;\n\t\tctx.lineCap = \"butt\";\n\t\tconst rotation = 0.5;\n\t\tctx.beginPath();\n\t\tfor (let i = 0; i < points; i++) {\n\t\t\tconst angle = ((Math.PI * 2) / points) * i + rotation;\n\t\t\tconst px = x + radius * Math.cos(angle);\n\t\t\tconst py = y + radius * Math.sin(angle);\n\n\t\t\tctx.moveTo(x, y);\n\t\t\tctx.lineTo(px, py);\n\t\t}\n\t\tctx.stroke();\n\t}\n\n\tprivate drawStar(ctx: WitnessContext, x: number, y: number, innerRadius: number, outerRadius: number, points: number, colorEnum: Color, overrideColor?: string) {\n\t\tctx.fillStyle = overrideColor || this.getColorCode(colorEnum);\n\t\tctx.beginPath();\n\t\tfor (let i = 0; i < points * 2; i++) {\n\t\t\tconst radius = i % 2 === 0 ? outerRadius : innerRadius;\n\t\t\tconst angle = (Math.PI / points) * i;\n\t\t\tconst px = x + radius * Math.cos(angle);\n\t\t\tconst py = y + radius * Math.sin(angle);\n\t\t\tif (i === 0) ctx.moveTo(px, py);\n\t\t\telse ctx.lineTo(px, py);\n\t\t}\n\t\tctx.closePath();\n\t\tctx.fill();\n\t}\n\n\tprivate drawTetris(ctx: WitnessContext, x: number, y: number, shape: number[][], rotated: boolean, colorEnum: Color, overrideColor?: string) {\n\t\tif (!shape || shape.length === 0) return;\n\t\tconst cellSize = 12;\n\t\tconst gap = 2;\n\t\tconst totalW = shape[0].length * cellSize + (shape[0].length - 1) * gap;\n\t\tconst totalH = shape.length * cellSize + (shape.length - 1) * gap;\n\n\t\tctx.save();\n\t\tctx.translate(x, y);\n\t\tif (rotated) {\n\t\t\tctx.rotate(Math.PI / 8);\n\t\t}\n\t\t// overrideColor\u304C\u3042\u308B\u5834\u5408\u306F\u305D\u308C\u3092\u512A\u5148\u3001\u306A\u3051\u308C\u3070Color.None\u304B\u3064\u30C7\u30D5\u30A9\u30EB\u30C8\u30AB\u30E9\u30FC\u8A2D\u5B9A\u304C\u306A\u3044\u5834\u5408\u306F\u9EC4\u8272(#ffcc00)\n\t\tctx.fillStyle = overrideColor || this.getColorCode(colorEnum, \"#ffcc00\");\n\n\t\tfor (let r = 0; r < shape.length; r++) {\n\t\t\tfor (let c = 0; c < shape[r].length; c++) {\n\t\t\t\tif (shape[r][c]) {\n\t\t\t\t\tconst px = c * (cellSize + gap) - totalW / 2;\n\t\t\t\t\tconst py = r * (cellSize + gap) - totalH / 2;\n\t\t\t\t\tctx.fillRect(px, py, cellSize, cellSize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx.restore();\n\t}\n\n\tprivate getColorCode(colorEnum: Color, defaultFallback = \"#666\"): string {\n\t\tif (this.options.colors.colorList && this.options.colors.colorList[colorEnum] !== undefined) {\n\t\t\treturn this.options.colors.colorList[colorEnum];\n\t\t}\n\t\tif (this.options.colors.colorMap && this.options.colors.colorMap[colorEnum] !== undefined) {\n\t\t\treturn this.options.colors.colorMap[colorEnum];\n\t\t}\n\t\treturn defaultFallback;\n\t}\n\n\tprivate hexToRgb(hex: string): { r: number; g: number; b: number } {\n\t\tlet c = hex.startsWith(\"#\") ? hex.slice(1) : hex;\n\t\tif (c.length === 3) {\n\t\t\tc = c\n\t\t\t\t.split(\"\")\n\t\t\t\t.map((s) => s + s)\n\t\t\t\t.join(\"\");\n\t\t}\n\t\tconst i = parseInt(c, 16);\n\t\treturn {\n\t\t\tr: (i >> 16) & 255,\n\t\t\tg: (i >> 8) & 255,\n\t\t\tb: i & 255,\n\t\t};\n\t}\n\n\tprivate rgbToHex(r: number, g: number, b: number): string {\n\t\treturn \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n\t}\n\n\tprivate lerpColor(c1: string, c2: string, t: number): string {\n\t\ttry {\n\t\t\tconst rgb1 = this.hexToRgb(c1);\n\t\t\tconst rgb2 = this.hexToRgb(c2);\n\t\t\treturn this.rgbToHex(Math.round(rgb1.r + (rgb2.r - rgb1.r) * t), Math.round(rgb1.g + (rgb2.g - rgb1.g) * t), Math.round(rgb1.b + (rgb2.b - rgb1.b) * t));\n\t\t} catch (e) {\n\t\t\treturn c1;\n\t\t}\n\t}\n\n\tprivate getSymmetryPath(path: Point[]): Point[] {\n\t\tif (!this.puzzle || !this.puzzle.symmetry) return [];\n\t\treturn path.map((p) => this.getSymmetricalPoint(p));\n\t}\n\n\tprivate getSymmetricalPoint(p: Point, isFloat = false): Point {\n\t\tif (!this.puzzle || !this.puzzle.symmetry) return { ...p };\n\t\tconst { cols, rows, symmetry } = this.puzzle;\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\treturn { x: cols - p.x, y: p.y };\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\treturn { x: p.x, y: rows - p.y };\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\treturn { x: cols - p.x, y: rows - p.y };\n\t\t}\n\t\treturn { ...p };\n\t}\n\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t}\n\n\tprivate prepareOffscreen(): { canvas: HTMLCanvasElement | OffscreenCanvas; ctx: WitnessContext } {\n\t\tif (!this.offscreenCanvas) {\n\t\t\tif (typeof document !== \"undefined\") {\n\t\t\t\tthis.offscreenCanvas = document.createElement(\"canvas\");\n\t\t\t} else if (typeof OffscreenCanvas !== \"undefined\") {\n\t\t\t\tthis.offscreenCanvas = new OffscreenCanvas(this.canvas.width, this.canvas.height);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Offscreen canvas not supported in this environment.\");\n\t\t\t}\n\t\t\tthis.offscreenCtx = (this.offscreenCanvas as HTMLCanvasElement).getContext(\"2d\") as WitnessContext | null;\n\t\t}\n\t\tif (this.offscreenCanvas.width !== this.canvas.width || this.offscreenCanvas.height !== this.canvas.height) {\n\t\t\tthis.offscreenCanvas.width = this.canvas.width;\n\t\t\tthis.offscreenCanvas.height = this.canvas.height;\n\t\t}\n\t\tif (!this.offscreenCtx) throw new Error(\"Could not get offscreen 2D context.\");\n\t\tthis.offscreenCtx.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);\n\t\treturn { canvas: this.offscreenCanvas, ctx: this.offscreenCtx };\n\t}\n}\n", "import { PuzzleGenerator } from \"./generator\";\nimport { Grid } from \"./grid\";\nimport type { GenerationOptions, PuzzleData, SolutionPath, ValidationResult } from \"./types\";\nimport { PuzzleValidator } from \"./validator\";\n\n// \u30E9\u30A4\u30D6\u30E9\u30EA\u306E\u30D5\u30A1\u30B5\u30FC\u30C9\u30AF\u30E9\u30B9\nexport { PuzzleGenerator } from \"./generator\";\nexport { Grid } from \"./grid\";\nexport { PuzzleSerializer } from \"./serializer\";\nexport { WitnessUI } from \"./ui\";\nexport { PuzzleValidator } from \"./validator\";\n\nexport class WitnessCore {\n\tprivate generator: PuzzleGenerator;\n\tprivate validator: PuzzleValidator;\n\n\tconstructor() {\n\t\tthis.generator = new PuzzleGenerator();\n\t\tthis.validator = new PuzzleValidator();\n\t}\n\n\t/**\n\t * \u65B0\u3057\u3044\u30D1\u30BA\u30EB\u3092\u751F\u6210\u3057\u3066\u30C7\u30FC\u30BF\u3092\u8FD4\u3059\n\t */\n\tpublic createPuzzle(rows: number, cols: number, options: GenerationOptions = {}): PuzzleData {\n\t\tconst grid = this.generator.generate(rows, cols, options);\n\t\treturn grid.export();\n\t}\n\n\t/**\n\t * \u89E3\u7B54\u3092\u691C\u8A3C\u3059\u308B\n\t */\n\tpublic validateSolution(puzzleData: PuzzleData, solution: SolutionPath): ValidationResult {\n\t\tconst grid = Grid.fromData(puzzleData);\n\t\treturn this.validator.validate(grid, solution);\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u306E\u96E3\u6613\u5EA6\u3092\u8A08\u7B97\u3059\u308B\n\t */\n\tpublic calculateDifficulty(puzzleData: PuzzleData): number {\n\t\tconst grid = Grid.fromData(puzzleData);\n\t\treturn this.validator.calculateDifficulty(grid);\n\t}\n}\n\n// \u30D6\u30E9\u30A6\u30B6/Node.js\u74B0\u5883\u4E21\u5BFE\u5FDC\u306E\u305F\u3081\u306E\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\nexport * from \"./types\";\n"],
  "mappings": "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",
  "names": ["Direction", "CellType", "EdgeType", "NodeType", "SymmetryType", "errorCells", "nodeCols", "p", "s", "symPath"]
}
