{
  "version": 3,
  "sources": ["../src/types.ts", "../src/grid.ts", "../src/rng.ts", "../src/validator.ts", "../src/generator.ts", "../src/ui.ts", "../src/serializer.ts", "../src/index.ts"],
  "sourcesContent": ["export enum Direction {\n\tUp = 0,\n\tRight = 1,\n\tDown = 2,\n\tLeft = 3,\n}\n\nexport enum CellType {\n\tNone = 0,\n\t/** \u8272\u5206\u3051\u304C\u5FC5\u8981\u306A\u30D6\u30ED\u30C3\u30AF */\n\tSquare = 1,\n\t/** \u540C\u3058\u8272\u306E\u30DA\u30A2\u4F5C\u6210 (\u661F) */\n\tStar = 2,\n\t/** \u30C6\u30C8\u30EA\u30B9 */\n\tTetris = 3,\n\t/** \u30C6\u30C8\u30EA\u30B9\uFF08\u56DE\u8EE2\u53EF\u80FD\uFF09 */\n\tTetrisRotated = 4,\n\t/** \u30C6\u30C8\u30EA\u30B9 (\u6E1B\u7B97) */\n\tTetrisNegative = 5,\n\t/** \u30C6\u30C8\u30EA\u30B9 (\u6E1B\u7B97\u30FB\u56DE\u8EE2\u53EF\u80FD) */\n\tTetrisNegativeRotated = 6,\n\t/** \u30C6\u30C8\u30E9\u30DD\u30C3\u30C9 (\u30A8\u30E9\u30FC\u524A\u9664) */\n\tEraser = 7,\n\t/** \u4E09\u89D2\u5F62 (\u901A\u904E\u8FBA\u6570\u6307\u5B9A) */\n\tTriangle = 8,\n}\n\nexport enum EdgeType {\n\tNormal = 0,\n\t/** \u7DDA\u306E\u771F\u3093\u4E2D\u3067\u65AD\u7DDA (\u901A\u884C\u4E0D\u53EF) */\n\tBroken = 1,\n\t/** \u305D\u3082\u305D\u3082\u5206\u5C90\u3082\u306A\u3057 (\u901A\u884C\u4E0D\u53EF) */\n\tAbsent = 2,\n\t/** \u901A\u904E\u5FC5\u9808 (\u30EF\u30A4\u30EB\u30C9\u30AB\u30FC\u30C9) */\n\tHexagon = 3,\n\t/** \u30E1\u30A4\u30F3\u7DDA\u306E\u307F\u901A\u904E\u5FC5\u9808 */\n\tHexagonMain = 4,\n\t/** \u5BFE\u79F0\u7DDA\u306E\u307F\u901A\u904E\u5FC5\u9808 */\n\tHexagonSymmetry = 5,\n}\n\nexport enum NodeType {\n\tNormal = 0,\n\tStart = 1,\n\tEnd = 2,\n\t/** \u901A\u904E\u5FC5\u9808 (\u30EF\u30A4\u30EB\u30C9\u30AB\u30FC\u30C9) */\n\tHexagon = 3,\n\t/** \u30E1\u30A4\u30F3\u7DDA\u306E\u307F\u901A\u904E\u5FC5\u9808 */\n\tHexagonMain = 4,\n\t/** \u5BFE\u79F0\u7DDA\u306E\u307F\u901A\u904E\u5FC5\u9808 */\n\tHexagonSymmetry = 5,\n}\n\nexport enum SymmetryType {\n\tNone = 0,\n\t/** \u5DE6\u53F3\u5BFE\u79F0 */\n\tHorizontal = 1,\n\t/** \u4E0A\u4E0B\u5BFE\u79F0 */\n\tVertical = 2,\n\t/** \u70B9\u5BFE\u79F0 */\n\tRotational = 3,\n}\n\n/**\n * \u4F7F\u7528\u53EF\u80FD\u8272\n * Core\u5185\u90E8\u3067\u306F\u6570\u5024\u3067\u7BA1\u7406\u3057\u3001UI\u3067\u5B9F\u969B\u306E\u8272\uFF08\u6587\u5B57\u5217\uFF09\u3068\u7D10\u4ED8\u3051\u308B\n */\nexport type Color = number;\nexport const Color = {\n\tNone: 0 as Color,\n\tBlack: 1 as Color,\n\tWhite: 2 as Color,\n\tRed: 3 as Color,\n\tBlue: 4 as Color,\n} as const;\n\nexport interface Point {\n\tx: number;\n\ty: number;\n}\n\nexport interface CellConstraint {\n\ttype: CellType;\n\tcolor: Color;\n\tshape?: number[][]; // [row][col] 0 or 1\n\tcount?: number; // Triangle count (1-3)\n}\n\nexport interface EdgeConstraint {\n\ttype: EdgeType;\n}\n\nexport interface NodeConstraint {\n\ttype: NodeType;\n}\n\n/**\n * \u30D1\u30BA\u30EB\u306E\u9759\u7684\u306A\u5B9A\u7FA9\u30C7\u30FC\u30BF\n */\nexport interface PuzzleData {\n\trows: number;\n\tcols: number;\n\tcells: CellConstraint[][]; // [row][col]\n\tvEdges: EdgeConstraint[][]; // Vertical edges [row][col] (row: 0..rows-1, col: 0..cols)\n\thEdges: EdgeConstraint[][]; // Horizontal edges [row][col] (row: 0..rows, col: 0..cols-1)\n\tnodes: NodeConstraint[][]; // [row][col]\n\tsymmetry?: SymmetryType;\n\t/** \u30D1\u30BA\u30EB\u751F\u6210\u306B\u4F7F\u7528\u3055\u308C\u305F\u4E71\u6570\u30B7\u30FC\u30C9 (16\u9032\u6570\u6587\u5B57\u5217) */\n\tseed?: string;\n}\n\n/**\n * \u30E6\u30FC\u30B6\u30FC\u306E\u5165\u529B\uFF08\u56DE\u7B54\u30D1\u30B9\uFF09\n */\nexport interface SolutionPath {\n\tpoints: Point[]; // \u901A\u904E\u3057\u305F\u30CE\u30FC\u30C9\u306E\u5EA7\u6A19\u914D\u5217\n}\n\nexport interface ValidationResult {\n\tisValid: boolean;\n\terrorReason?: string;\n\tinvalidatedCells?: Point[];\n\tinvalidatedEdges?: { type: \"h\" | \"v\"; r: number; c: number }[];\n\tinvalidatedNodes?: Point[];\n\terrorCells?: Point[];\n\terrorEdges?: { type: \"h\" | \"v\"; r: number; c: number }[];\n\terrorNodes?: Point[];\n\tregions?: Point[][];\n}\n\n/**\n * \u30D1\u30BA\u30EB\u751F\u6210\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\n */\nexport interface GenerationOptions {\n\trows?: number;\n\tcols?: number;\n\tuseHexagons?: boolean;\n\tuseSquares?: boolean;\n\tuseStars?: boolean;\n\tuseTetris?: boolean;\n\tuseTetrisNegative?: boolean;\n\tuseEraser?: boolean;\n\tuseTriangles?: boolean;\n\tuseBrokenEdges?: boolean;\n\tcomplexity?: number; // 0.0 - 1.0 (\u5236\u7D04\u306E\u5BC6\u5EA6)\n\tdifficulty?: number; // 0.0 (Easy) - 1.0 (Hard) (\u89E3\u30D1\u30BF\u30FC\u30F3\u306E\u6570\u306B\u57FA\u3065\u304F)\n\tpathLength?: number; // 0.0 (Shortest) - 1.0 (Longest)\n\tsymmetry?: SymmetryType;\n\t/** \u56DB\u89D2\u5F62\u3084\u661F\u306A\u3069\u306E\u8A18\u53F7\u306B\u4F7F\u7528\u53EF\u80FD\u306A\u8272\u306E\u30EA\u30B9\u30C8\u3002\u6307\u5B9A\u304C\u306A\u3044\u5834\u5408\u306F\u30C7\u30D5\u30A9\u30EB\u30C8\uFF08\u9ED2\u30FB\u767D\u30FB\u8D64\u30FB\u9752\uFF09\u304C\u4F7F\u7528\u3055\u308C\u308B\u3002 */\n\tavailableColors?: Color[];\n\t/** \u5404\u8A18\u53F7\u30BF\u30A4\u30D7\u306E\u30C7\u30D5\u30A9\u30EB\u30C8\u30AB\u30E9\u30FC\u3002\u6307\u5B9A\u304C\u306A\u3044\u5834\u5408\u306F\u305D\u308C\u305E\u308C\u306E\u8A18\u53F7\u306E\u6A19\u6E96\u8272\u304C\u4F7F\u7528\u3055\u308C\u308B\u3002\n\t * \u30AD\u30FC\u306B\u306F CellType \u306E\u6570\u5024\u3001\u307E\u305F\u306F \"Square\", \"Tetris\" \u306A\u3069\u306E\u6587\u5B57\u5217\u304C\u4F7F\u7528\u53EF\u80FD\u3067\u3059\u3002\n\t */\n\tdefaultColors?: Partial<Record<CellType | keyof typeof CellType, Color>>;\n\t/** \u30D1\u30BA\u30EB\u751F\u6210\u306B\u4F7F\u7528\u3059\u308B\u4E71\u6570\u30B7\u30FC\u30C9 (16\u9032\u6570\u6587\u5B57\u5217) */\n\tseed?: string;\n\t/** \u4F7F\u7528\u3059\u308B\u4E71\u6570\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0 */\n\trngType?: RngType;\n\t/** \u56FA\u5B9A\u3057\u305F\u3044\u30B9\u30BF\u30FC\u30C8\u5730\u70B9\u306E\u30EA\u30B9\u30C8 */\n\tstarts?: Point[];\n\t/** \u56FA\u5B9A\u3057\u305F\u3044\u30B4\u30FC\u30EB\u5730\u70B9\u306E\u30EA\u30B9\u30C8 */\n\tends?: Point[];\n}\n\nexport enum RngType {\n\tMulberry32 = 0,\n\tXorShift128Plus = 1,\n\tMathRandom = 2,\n}\n\n/**\n * \u30B7\u30EA\u30A2\u30E9\u30A4\u30BA\u6642\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\n */\nexport interface SerializationOptions {\n\t/** \u30D1\u30BA\u30EB\u69CB\u9020\u30C7\u30FC\u30BF\u3092\u542B\u3081\u308B\u304B */\n\tpuzzle?: PuzzleData;\n\t/** \u30B7\u30FC\u30C9\u60C5\u5831\u3092\u542B\u3081\u308B\u304B */\n\tseed?: { type: RngType; value: string };\n\t/** \u751F\u6210\u8A2D\u5B9A\u3092\u542B\u3081\u308B\u304B */\n\toptions?: GenerationOptions;\n\t/** \u89E3\u7B54\u30D1\u30B9\u3092\u542B\u3081\u308B\u304B */\n\tpath?: SolutionPath;\n\t/** UI\u306E\u30AB\u30E9\u30FC\u30D5\u30A3\u30EB\u30BF\u30FC\u8A2D\u5B9A\u3092\u542B\u3081\u308B\u304B */\n\tfilter?: {\n\t\tenabled?: boolean;\n\t\tmode?: \"custom\" | \"rgb\";\n\t\tcustomColor?: string;\n\t\trgbColors?: [string, string, string];\n\t\trgbIndex?: 0 | 1 | 2;\n\t\tthreshold?: number;\n\t};\n\t/** \u30D1\u30EA\u30C6\u30A3\u30E2\u30FC\u30C9 ('detection': \u7834\u640D\u691C\u77E5\u306E\u307F, 'recovery': \u90E8\u5206\u5FA9\u5143\u53EF\u80FD) */\n\tparityMode?: \"detection\" | \"recovery\";\n}\n\n/**\n * \u30C7\u30B7\u30EA\u30A2\u30E9\u30A4\u30BA\u3055\u308C\u305F\u30C7\u30FC\u30BF\n */\nexport interface DeserializedData {\n\tpuzzle?: PuzzleData;\n\tseed?: { type: RngType; value: string };\n\toptions?: GenerationOptions;\n\tpath?: SolutionPath;\n\tfilter?: {\n\t\tenabled?: boolean;\n\t\tmode?: \"custom\" | \"rgb\";\n\t\tcustomColor?: string;\n\t\trgbColors?: [string, string, string];\n\t\trgbIndex?: 0 | 1 | 2;\n\t\tthreshold?: number;\n\t};\n}\n", "import { type CellConstraint, CellType, Color, type EdgeConstraint, EdgeType, type NodeConstraint, NodeType, type PuzzleData } from \"./types\";\n\n/**\n * \u30D1\u30BA\u30EB\u306E\u30B0\u30EA\u30C3\u30C9\u69CB\u9020\u3068\u72B6\u614B\u3092\u7BA1\u7406\u3059\u308B\u30AF\u30E9\u30B9\n */\nexport class Grid {\n\t/** \u884C\u6570 */\n\tpublic readonly rows: number;\n\t/** \u5217\u6570 */\n\tpublic readonly cols: number;\n\n\t/** \u30BB\u30EB\u306E\u5236\u7D04\uFF08\u8A18\u53F7\uFF09\u30DE\u30C8\u30EA\u30AF\u30B9 */\n\tpublic cells: CellConstraint[][] = [];\n\t/** \u6C34\u5E73\u30A8\u30C3\u30B8\u306E\u5236\u7D04\u30DE\u30C8\u30EA\u30AF\u30B9 */\n\tpublic hEdges: EdgeConstraint[][] = [];\n\t/** \u5782\u76F4\u30A8\u30C3\u30B8\u306E\u5236\u7D04\u30DE\u30C8\u30EA\u30AF\u30B9 */\n\tpublic vEdges: EdgeConstraint[][] = [];\n\t/** \u30CE\u30FC\u30C9\u306E\u5236\u7D04\u30DE\u30C8\u30EA\u30AF\u30B9 */\n\tpublic nodes: NodeConstraint[][] = [];\n\t/** \u5BFE\u79F0\u6027\u306E\u8A2D\u5B9A (SymmetryType) */\n\tpublic symmetry: number = 0;\n\t/** \u30D1\u30BA\u30EB\u751F\u6210\u306B\u4F7F\u7528\u3055\u308C\u305F\u4E71\u6570\u30B7\u30FC\u30C9 (16\u9032\u6570\u6587\u5B57\u5217) */\n\tpublic seed?: string;\n\n\t/**\n\t * \u65B0\u3057\u3044\u30B0\u30EA\u30C3\u30C9\u3092\u521D\u671F\u5316\u3059\u308B\n\t * @param rows \u884C\u6570\n\t * @param cols \u5217\u6570\n\t */\n\tconstructor(rows: number, cols: number) {\n\t\tthis.rows = rows;\n\t\tthis.cols = cols;\n\t\tthis.initializeGrid();\n\t}\n\n\t/**\n\t * \u30B0\u30EA\u30C3\u30C9\u306E\u5404\u8981\u7D20\u3092\u521D\u671F\u72B6\u614B\uFF08\u5236\u7D04\u306A\u3057\uFF09\u3067\u751F\u6210\u3059\u308B\n\t */\n\tprivate initializeGrid() {\n\t\t// Cells: rows * cols\n\t\tthis.cells = Array.from({ length: this.rows }, () => Array.from({ length: this.cols }, () => ({ type: CellType.None, color: Color.None })));\n\n\t\t// H-Edges: (rows + 1) * cols\n\t\tthis.hEdges = Array.from({ length: this.rows + 1 }, () => Array.from({ length: this.cols }, () => ({ type: EdgeType.Normal })));\n\n\t\t// V-Edges: rows * (cols + 1)\n\t\tthis.vEdges = Array.from({ length: this.rows }, () => Array.from({ length: this.cols + 1 }, () => ({ type: EdgeType.Normal })));\n\n\t\t// Nodes: (rows + 1) * (cols + 1)\n\t\tthis.nodes = Array.from({ length: this.rows + 1 }, () => Array.from({ length: this.cols + 1 }, () => ({ type: NodeType.Normal })));\n\t}\n\n\t/**\n\t * \u30B0\u30EA\u30C3\u30C9\u306E\u72B6\u614B\u3092 PuzzleData \u5F62\u5F0F\u3067\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3059\u308B\n\t * @returns \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\n\t */\n\tpublic export(): PuzzleData {\n\t\t// \u30C7\u30FC\u30BF\u306E\u30C7\u30A3\u30FC\u30D7\u30B3\u30D4\u30FC\u3092\u8FD4\u3059\n\t\treturn JSON.parse(\n\t\t\tJSON.stringify({\n\t\t\t\trows: this.rows,\n\t\t\t\tcols: this.cols,\n\t\t\t\tcells: this.cells,\n\t\t\t\tvEdges: this.vEdges,\n\t\t\t\thEdges: this.hEdges,\n\t\t\t\tnodes: this.nodes,\n\t\t\t\tsymmetry: this.symmetry,\n\t\t\t\tseed: this.seed,\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * PuzzleData \u304B\u3089 Grid \u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u3092\u751F\u6210\u3059\u308B\n\t * @param data \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\n\t * @returns Grid \u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\n\t */\n\tpublic static fromData(data: PuzzleData): Grid {\n\t\tconst grid = new Grid(data.rows, data.cols);\n\t\tgrid.cells = data.cells;\n\t\tgrid.vEdges = data.vEdges;\n\t\tgrid.hEdges = data.hEdges;\n\t\tgrid.nodes = data.nodes;\n\t\tgrid.symmetry = data.symmetry || 0;\n\t\tgrid.seed = data.seed;\n\t\treturn grid;\n\t}\n}\n", "export enum RngType {\n\tMulberry32 = 0,\n\tXorShift128Plus = 1,\n\tMathRandom = 2,\n}\n\nexport interface IRng {\n\tnext(): number;\n}\n\nexport class Mulberry32 implements IRng {\n\tprivate state: number;\n\tconstructor(seed: number) {\n\t\tthis.state = seed >>> 0;\n\t}\n\tnext(): number {\n\t\tlet t = (this.state += 0x6d2b79f5) | 0;\n\t\tt = Math.imul(t ^ (t >>> 15), t | 1);\n\t\tt ^= t + Math.imul(t ^ (t >>> 7), t | 61);\n\t\treturn ((t ^ (t >>> 14)) >>> 0) / 4294967296;\n\t}\n}\n\nexport class XorShift128Plus implements IRng {\n\tprivate s0: number;\n\tprivate s1: number;\n\tconstructor(seedLo: number, seedHi: number) {\n\t\tthis.s0 = seedLo >>> 0;\n\t\tthis.s1 = seedHi >>> 0;\n\t\tif (this.s0 === 0 && this.s1 === 0) {\n\t\t\tthis.s1 = 1;\n\t\t}\n\t}\n\tnext(): number {\n\t\tlet x = this.s0;\n\t\tconst y = this.s1;\n\t\tthis.s0 = y;\n\t\tx ^= x << 23;\n\t\tthis.s1 = x ^ y ^ (x >>> 17) ^ (y >>> 26);\n\t\treturn ((this.s1 + y) >>> 0) / 4294967296;\n\t}\n}\n\nexport class MathRandomRng implements IRng {\n\tnext(): number {\n\t\treturn Math.random();\n\t}\n}\n\nexport function createRng(type: RngType, seed: bigint): IRng {\n\tswitch (type) {\n\t\tcase RngType.Mulberry32:\n\t\t\treturn new Mulberry32(Number(seed & 0xffffffffn));\n\t\tcase RngType.XorShift128Plus:\n\t\t\treturn new XorShift128Plus(Number(seed & 0xffffffffn), Number((seed >> 32n) & 0xffffffffn));\n\t\tcase RngType.MathRandom:\n\t\t\treturn new MathRandomRng();\n\t\tdefault:\n\t\t\treturn new Mulberry32(Number(seed & 0xffffffffn));\n\t}\n}\n", "import { Grid } from \"./grid\";\nimport type { IRng } from \"./rng\";\nimport { CellType, Color, EdgeType, NodeType, SymmetryType, type Point, type SolutionPath, type ValidationResult } from \"./types\";\n\n/**\n * \u30D1\u30BA\u30EB\u306E\u56DE\u7B54\u3092\u691C\u8A3C\u3059\u308B\u30AF\u30E9\u30B9\n */\nexport class PuzzleValidator {\n\tprivate tetrisCache: Map<string, boolean> = new Map();\n\tprivate reachabilityCache: Map<string, boolean> = new Map();\n\tprivate rng: IRng | null = null;\n\n\tpublic setRng(rng: IRng | null) {\n\t\tthis.rng = rng;\n\t}\n\n\t/**\n\t * \u4E0E\u3048\u3089\u308C\u305F\u30B0\u30EA\u30C3\u30C9\u3068\u56DE\u7B54\u30D1\u30B9\u304C\u6B63\u5F53\u304B\u3069\u3046\u304B\u3092\u691C\u8A3C\u3059\u308B\n\t * @param grid \u30D1\u30BA\u30EB\u306E\u30B0\u30EA\u30C3\u30C9\u30C7\u30FC\u30BF\n\t * @param solution \u56DE\u7B54\u30D1\u30B9\n\t * @param externalCellsPrecalculated \u65E2\u77E5\u306E\u5916\u90E8\u30BB\u30EB\uFF08\u9AD8\u901F\u5316\u7528\uFF09\n\t * @returns \u691C\u8A3C\u7D50\u679C\uFF08\u6B63\u8AA4\u3001\u30A8\u30E9\u30FC\u7406\u7531\u3001\u7121\u52B9\u5316\u3055\u308C\u305F\u8A18\u53F7\u306A\u3069\uFF09\n\t */\n\tpublic validate(grid: Grid, solution: SolutionPath, externalCellsPrecalculated?: Set<string>): ValidationResult {\n\t\tconst path = solution.points;\n\t\tif (path.length < 2) return { isValid: false, errorReason: \"Path too short\" };\n\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\tconst symPath: Point[] = [];\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tfor (const p of path) {\n\t\t\t\tsymPath.push(this.getSymmetricalPoint(grid, p));\n\t\t\t}\n\t\t}\n\n\t\tconst start = path[0];\n\t\tconst end = path[path.length - 1];\n\n\t\t// \u958B\u59CB\u30CE\u30FC\u30C9\u3068\u7D42\u4E86\u30CE\u30FC\u30C9\u306E\u30C1\u30A7\u30C3\u30AF\n\t\tif (grid.nodes[start.y][start.x].type !== NodeType.Start) return { isValid: false, errorReason: \"Must start at Start Node\" };\n\t\tif (grid.nodes[end.y][end.x].type !== NodeType.End) return { isValid: false, errorReason: \"Must end at End Node\" };\n\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tconst symStart = symPath[0];\n\t\t\tconst symEnd = symPath[symPath.length - 1];\n\t\t\tif (grid.nodes[symStart.y][symStart.x].type !== NodeType.Start) return { isValid: false, errorReason: \"Symmetrical path must start at Start Node\" };\n\t\t\tif (grid.nodes[symEnd.y][symEnd.x].type !== NodeType.End) return { isValid: false, errorReason: \"Symmetrical path must end at End Node\" };\n\t\t}\n\n\t\t// \u30D1\u30B9\u306E\u9023\u7D9A\u6027\u3068\u81EA\u5DF1\u4EA4\u5DEE\u3001\u65AD\u7DDA\u30C1\u30A7\u30C3\u30AF\n\t\tconst visitedNodes = new Set<string>();\n\t\tconst visitedEdges = new Set<string>();\n\t\tvisitedNodes.add(`${start.x},${start.y}`);\n\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tconst symStart = symPath[0];\n\t\t\tif (visitedNodes.has(`${symStart.x},${symStart.y}`)) return { isValid: false, errorReason: \"Paths collide at start\" };\n\t\t\tvisitedNodes.add(`${symStart.x},${symStart.y}`);\n\t\t}\n\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst p1 = path[i];\n\t\t\tconst p2 = path[i + 1];\n\t\t\tconst dist = Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n\t\t\tif (dist !== 1) return { isValid: false, errorReason: \"Invalid jump in path\" };\n\n\t\t\tconst key = `${p2.x},${p2.y}`;\n\t\t\tif (visitedNodes.has(key)) return { isValid: false, errorReason: \"Self-intersecting path or path collision\" };\n\t\t\tvisitedNodes.add(key);\n\n\t\t\tif (this.isBrokenEdge(grid, p1, p2)) return { isValid: false, errorReason: \"Passed through broken edge\" };\n\t\t\tvisitedEdges.add(this.getEdgeKey(p1, p2));\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst sp1 = symPath[i];\n\t\t\t\tconst sp2 = symPath[i + 1];\n\t\t\t\tconst symKey = `${sp2.x},${sp2.y}`;\n\n\t\t\t\tif (visitedNodes.has(symKey)) return { isValid: false, errorReason: \"Path collision\" };\n\t\t\t\tvisitedNodes.add(symKey);\n\n\t\t\t\tif (this.isBrokenEdge(grid, sp1, sp2)) return { isValid: false, errorReason: \"Symmetrical path passed through broken edge\" };\n\n\t\t\t\tconst edgeKey = this.getEdgeKey(sp1, sp2);\n\t\t\t\tif (visitedEdges.has(edgeKey)) return { isValid: false, errorReason: \"Paths cross the same edge\" };\n\t\t\t\tvisitedEdges.add(edgeKey);\n\t\t\t}\n\t\t}\n\n\t\t// \u533A\u753B\u306E\u8A08\u7B97\n\t\tconst regions = this.calculateRegions(grid, path, symPath, externalCellsPrecalculated);\n\t\t// \u901A\u904E\u3057\u306A\u304B\u3063\u305F\u516D\u89D2\u5F62\u306E\u53D6\u5F97\n\t\tconst missed = this.getMissedHexagons(grid, path, symPath);\n\n\t\t// \u30D1\u30B9\u304C\u901A\u3063\u305F\u30A8\u30C3\u30B8\u3092\u8A18\u9332 (\u4E09\u89D2\u5F62\u306E\u30D0\u30EA\u30C7\u30FC\u30B7\u30E7\u30F3\u7528)\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t}\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tfor (let i = 0; i < symPath.length - 1; i++) {\n\t\t\t\tpathEdges.add(this.getEdgeKey(symPath[i], symPath[i + 1]));\n\t\t\t}\n\t\t}\n\n\t\t// \u30A8\u30E9\u30FC\u524A\u9664\uFF08\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF09\u3092\u8003\u616E\u3057\u305F\u5236\u7D04\u691C\u8A3C\n\t\tconst result = this.validateWithErasers(grid, regions, missed.edges, missed.nodes, pathEdges);\n\t\tresult.regions = regions;\n\t\treturn result;\n\t}\n\n\t/**\n\t * \u9AD8\u901F\u5316\u3055\u308C\u305F\u691C\u8A3C\uFF08\u5185\u90E8\u63A2\u7D22\u7528\uFF09\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param path \u30E1\u30A4\u30F3\u30D1\u30B9\n\t * @param symPath \u5BFE\u79F0\u30D1\u30B9\n\t * @param externalCells \u5916\u90E8\u30BB\u30EB\u306E\u30AD\u30E3\u30C3\u30B7\u30E5\n\t * @returns \u691C\u8A3C\u7D50\u679C\n\t */\n\tprivate validateFast(grid: Grid, path: Point[], symPath: Point[], externalCells?: Set<string>): ValidationResult {\n\t\tconst regions = this.calculateRegions(grid, path, symPath, externalCells);\n\t\tconst missed = this.getMissedHexagons(grid, path, symPath);\n\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t}\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\tif (symmetry !== SymmetryType.None) {\n\t\t\tfor (let i = 0; i < symPath.length - 1; i++) {\n\t\t\t\tpathEdges.add(this.getEdgeKey(symPath[i], symPath[i + 1]));\n\t\t\t}\n\t\t}\n\n\t\treturn this.validateWithErasers(grid, regions, missed.edges, missed.nodes, pathEdges);\n\t}\n\n\t/**\n\t * \u4E8C\u70B9\u9593\u304C\u65AD\u7DDA\uFF08Broken or Absent\uFF09\u3057\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param p1 \u70B91\n\t * @param p2 \u70B92\n\t * @returns \u65AD\u7DDA\u3057\u3066\u3044\u308B\u304B\u3069\u3046\u304B\n\t */\n\tprivate isBrokenEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tlet type: EdgeType;\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\ttype = grid.vEdges[y][p1.x].type;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\ttype = grid.hEdges[p1.y][x].type;\n\t\t}\n\t\treturn type === EdgeType.Broken || type === EdgeType.Absent;\n\t}\n\n\t/**\n\t * \u4E8C\u70B9\u9593\u304C Absent\uFF08\u5B58\u5728\u3057\u306A\u3044\uFF09\u30A8\u30C3\u30B8\u304B\u78BA\u8A8D\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param p1 \u70B91\n\t * @param p2 \u70B92\n\t * @returns \u5B58\u5728\u3057\u306A\u3044\u304B\u3069\u3046\u304B\n\t */\n\tprivate isAbsentEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\treturn grid.vEdges[y][p1.x].type === EdgeType.Absent;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\treturn grid.hEdges[p1.y][x].type === EdgeType.Absent;\n\t\t}\n\t}\n\n\t/**\n\t * \u56DE\u7B54\u30D1\u30B9\u304C\u901A\u904E\u3057\u306A\u304B\u3063\u305F\u516D\u89D2\u5F62\uFF08\u30A8\u30C3\u30B8\u30FB\u30CE\u30FC\u30C9\uFF09\u3092\u30EA\u30B9\u30C8\u30A2\u30C3\u30D7\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param path \u30E1\u30A4\u30F3\u30D1\u30B9\n\t * @param symPath \u5BFE\u79F0\u30D1\u30B9\n\t * @returns \u901A\u904E\u3057\u306A\u304B\u3063\u305F\u516D\u89D2\u5F62\u306E\u30EA\u30B9\u30C8\n\t */\n\tprivate getMissedHexagons(grid: Grid, path: Point[], symPath: Point[] = []): { edges: { type: \"h\" | \"v\"; r: number; c: number }[]; nodes: Point[] } {\n\t\tconst mainPathEdges = new Set<string>();\n\t\tconst mainPathNodes = new Set<string>();\n\t\tfor (let i = 0; i < path.length; i++) {\n\t\t\tmainPathNodes.add(`${path[i].x},${path[i].y}`);\n\t\t\tif (i < path.length - 1) {\n\t\t\t\tmainPathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t\t}\n\t\t}\n\n\t\tconst symPathEdges = new Set<string>();\n\t\tconst symPathNodes = new Set<string>();\n\t\tfor (let i = 0; i < symPath.length; i++) {\n\t\t\tsymPathNodes.add(`${symPath[i].x},${symPath[i].y}`);\n\t\t\tif (i < symPath.length - 1) {\n\t\t\t\tsymPathEdges.add(this.getEdgeKey(symPath[i], symPath[i + 1]));\n\t\t\t}\n\t\t}\n\n\t\tconst missedEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tconst type = grid.hEdges[r][c].type;\n\t\t\t\tif (type === EdgeType.Hexagon || type === EdgeType.HexagonMain || type === EdgeType.HexagonSymmetry) {\n\t\t\t\t\tconst key = this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r });\n\t\t\t\t\tlet passed = false;\n\t\t\t\t\tif (type === EdgeType.Hexagon) passed = mainPathEdges.has(key) || symPathEdges.has(key);\n\t\t\t\t\telse if (type === EdgeType.HexagonMain) passed = mainPathEdges.has(key);\n\t\t\t\t\telse if (type === EdgeType.HexagonSymmetry) passed = symPathEdges.has(key);\n\n\t\t\t\t\tif (!passed) missedEdges.push({ type: \"h\", r, c });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tconst type = grid.vEdges[r][c].type;\n\t\t\t\tif (type === EdgeType.Hexagon || type === EdgeType.HexagonMain || type === EdgeType.HexagonSymmetry) {\n\t\t\t\t\tconst key = this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 });\n\t\t\t\t\tlet passed = false;\n\t\t\t\t\tif (type === EdgeType.Hexagon) passed = mainPathEdges.has(key) || symPathEdges.has(key);\n\t\t\t\t\telse if (type === EdgeType.HexagonMain) passed = mainPathEdges.has(key);\n\t\t\t\t\telse if (type === EdgeType.HexagonSymmetry) passed = symPathEdges.has(key);\n\n\t\t\t\t\tif (!passed) missedEdges.push({ type: \"v\", r, c });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst missedNodes: Point[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tconst type = grid.nodes[r][c].type;\n\t\t\t\tif (type === NodeType.Hexagon || type === NodeType.HexagonMain || type === NodeType.HexagonSymmetry) {\n\t\t\t\t\tconst posKey = `${c},${r}`;\n\t\t\t\t\tlet passed = false;\n\t\t\t\t\tif (type === NodeType.Hexagon) passed = mainPathNodes.has(posKey) || symPathNodes.has(posKey);\n\t\t\t\t\telse if (type === NodeType.HexagonMain) passed = mainPathNodes.has(posKey);\n\t\t\t\t\telse if (type === NodeType.HexagonSymmetry) passed = symPathNodes.has(posKey);\n\n\t\t\t\t\tif (!passed) missedNodes.push({ x: c, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { edges: missedEdges, nodes: missedNodes };\n\t}\n\n\t/**\n\t * \u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF08\u30A8\u30E9\u30FC\u524A\u9664\uFF09\u3092\u8003\u616E\u3057\u3066\u30D1\u30BA\u30EB\u306E\u5404\u5236\u7D04\u3092\u691C\u8A3C\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param regions \u533A\u753B\u30EA\u30B9\u30C8\n\t * @param missedHexagons \u901A\u904E\u3057\u306A\u304B\u3063\u305F\u30A8\u30C3\u30B8\u516D\u89D2\u5F62\n\t * @param missedNodeHexagons \u901A\u904E\u3057\u306A\u304B\u3063\u305F\u30CE\u30FC\u30C9\u516D\u89D2\u5F62\n\t * @returns \u691C\u8A3C\u7D50\u679C\n\t */\n\tprivate validateWithErasers(grid: Grid, regions: Point[][], missedHexagons: { type: \"h\" | \"v\"; r: number; c: number }[], missedNodeHexagons: Point[], pathEdges: Set<string>): ValidationResult {\n\t\tconst regionResults: { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] }[][] = [];\n\t\tlet allRegionsPossiblyValid = true;\n\n\t\tfor (let i = 0; i < regions.length; i++) {\n\t\t\tconst region = regions[i];\n\t\t\tconst erasers = region.filter((p) => grid.cells[p.y][p.x].type === CellType.Eraser);\n\t\t\tconst otherMarks = region.filter((p) => grid.cells[p.y][p.x].type !== CellType.None && grid.cells[p.y][p.x].type !== CellType.Eraser);\n\n\t\t\tconst adjacentMissedHexagons: number[] = [];\n\t\t\tfor (let j = 0; j < missedHexagons.length; j++) {\n\t\t\t\tif (this.isHexagonAdjacentToRegion(grid, missedHexagons[j], region)) adjacentMissedHexagons.push(j);\n\t\t\t}\n\n\t\t\tconst adjacentMissedNodeHexagons: number[] = [];\n\t\t\tfor (let j = 0; j < missedNodeHexagons.length; j++) {\n\t\t\t\tif (this.isNodeHexagonAdjacentToRegion(grid, missedNodeHexagons[j], region)) adjacentMissedNodeHexagons.push(j);\n\t\t\t}\n\n\t\t\t// \u5404\u533A\u753B\u3067\u30A8\u30E9\u30FC\u524A\u9664\u306E\u5168\u7D44\u307F\u5408\u308F\u305B\u3092\u8A66\u884C\n\t\t\tconst possible = this.getPossibleErasures(grid, region, erasers, otherMarks, adjacentMissedHexagons, adjacentMissedNodeHexagons, pathEdges);\n\t\t\tif (possible.length === 0) {\n\t\t\t\tallRegionsPossiblyValid = false;\n\t\t\t\t// \u30A8\u30E9\u30FC\u7B87\u6240\u3092\u7279\u5B9A\u3059\u308B\u305F\u3081\u306E\u30D9\u30B9\u30C8\u30A8\u30D5\u30A9\u30FC\u30C8\uFF08\u30E9\u30F3\u30C0\u30E0\u306A\u524A\u9664\uFF09\n\t\t\t\tconst bestEffort = this.getBestEffortErasures(grid, region, erasers, otherMarks, adjacentMissedHexagons, adjacentMissedNodeHexagons, pathEdges);\n\t\t\t\tregionResults.push([bestEffort]);\n\t\t\t} else {\n\t\t\t\t// \u6700\u5C0F\u306E\u524A\u9664\u6570\u3092\u6301\u3064\u89E3\u6C7A\u7B56\u3092\u512A\u5148\u3059\u308B\n\t\t\t\tpossible.sort((a, b) => {\n\t\t\t\t\tconst costA = a.invalidatedCells.length + a.invalidatedHexagons.length + a.invalidatedNodeHexagons.length;\n\t\t\t\t\tconst costB = b.invalidatedCells.length + b.invalidatedHexagons.length + b.invalidatedNodeHexagons.length;\n\t\t\t\t\tif (costA !== costB) return costA - costB;\n\n\t\t\t\t\t// \u540C\u30B3\u30B9\u30C8\u306A\u3089\u516D\u89D2\u5F62\uFF08\u30A8\u30C3\u30B8/\u30CE\u30FC\u30C9\uFF09\u3092\u512A\u5148\u3057\u3066\u7121\u52B9\u5316\u3059\u308B\n\t\t\t\t\tconst hexPriorityA = a.invalidatedHexagons.length + a.invalidatedNodeHexagons.length;\n\t\t\t\t\tconst hexPriorityB = b.invalidatedHexagons.length + b.invalidatedNodeHexagons.length;\n\t\t\t\t\tif (hexPriorityA !== hexPriorityB) return hexPriorityB - hexPriorityA;\n\n\t\t\t\t\treturn a.invalidatedCells.length - b.invalidatedCells.length;\n\t\t\t\t});\n\t\t\t\tregionResults.push(possible);\n\t\t\t}\n\t\t}\n\n\t\tif (allRegionsPossiblyValid) {\n\t\t\t// \u8907\u6570\u306E\u533A\u753B\u306B\u307E\u305F\u304C\u308B\u516D\u89D2\u5F62\u306E\u30A8\u30E9\u30FC\u524A\u9664\u5272\u308A\u5F53\u3066\u3092\u6C7A\u5B9A\n\t\t\tconst assignment = this.findGlobalAssignment(regionResults, missedHexagons.length, missedNodeHexagons.length);\n\t\t\tif (assignment) {\n\t\t\t\treturn {\n\t\t\t\t\tisValid: true,\n\t\t\t\t\tinvalidatedCells: assignment.invalidatedCells,\n\t\t\t\t\tinvalidatedEdges: assignment.invalidatedHexIndices.map((idx) => missedHexagons[idx]),\n\t\t\t\t\tinvalidatedNodes: assignment.invalidatedNodeHexIndices.map((idx) => missedNodeHexagons[idx]),\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// \u5931\u6557\u6642\uFF1A\u30A8\u30E9\u30FC\u7B87\u6240\u306E\u53CE\u96C6\n\t\tconst errorCells: Point[] = [];\n\t\tconst invalidatedCells: Point[] = [];\n\t\tconst invalidatedHexIndices = new Set<number>();\n\t\tconst invalidatedNodeHexIndices = new Set<number>();\n\n\t\tfor (const options of regionResults) {\n\t\t\tconst best = options[0]; // \u6700\u521D\u306E\uFF08\u6700\u3082\u30B3\u30B9\u30C8\u306E\u4F4E\u3044\u3001\u307E\u305F\u306F\u30D9\u30B9\u30C8\u30A8\u30D5\u30A9\u30FC\u30C8\u306A\uFF09\u3082\u306E\u3092\u9078\u629E\n\t\t\terrorCells.push(...best.errorCells);\n\t\t\tinvalidatedCells.push(...best.invalidatedCells);\n\t\t\tfor (const idx of best.invalidatedHexagons) invalidatedHexIndices.add(idx);\n\t\t\tfor (const idx of best.invalidatedNodeHexagons) invalidatedNodeHexIndices.add(idx);\n\t\t}\n\n\t\t// \u7121\u52B9\u5316\u3055\u308C\u306A\u304B\u3063\u305F\u516D\u89D2\u5F62\u3082\u30A8\u30E9\u30FC\u3068\u3059\u308B\n\t\tconst errorEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\tfor (let i = 0; i < missedHexagons.length; i++) {\n\t\t\tif (!invalidatedHexIndices.has(i)) {\n\t\t\t\terrorEdges.push(missedHexagons[i]);\n\t\t\t}\n\t\t}\n\t\tconst errorNodes: Point[] = [];\n\t\tfor (let i = 0; i < missedNodeHexagons.length; i++) {\n\t\t\tif (!invalidatedNodeHexIndices.has(i)) {\n\t\t\t\terrorNodes.push(missedNodeHexagons[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tisValid: false,\n\t\t\terrorReason: \"Constraints failed\",\n\t\t\terrorCells,\n\t\t\terrorEdges,\n\t\t\terrorNodes,\n\t\t\tinvalidatedCells,\n\t\t\tinvalidatedEdges: Array.from(invalidatedHexIndices).map((idx) => missedHexagons[idx]),\n\t\t\tinvalidatedNodes: Array.from(invalidatedNodeHexIndices).map((idx) => missedNodeHexagons[idx]),\n\t\t};\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30A8\u30C3\u30B8\u304C\u7279\u5B9A\u306E\u533A\u753B\u306B\u96A3\u63A5\u3057\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param hex \u516D\u89D2\u5F62\u30A8\u30C3\u30B8\n\t * @param region \u533A\u753B\n\t * @returns \u96A3\u63A5\u3057\u3066\u3044\u308B\u304B\u3069\u3046\u304B\n\t */\n\tprivate isHexagonAdjacentToRegion(grid: Grid, hex: { type: \"h\" | \"v\"; r: number; c: number }, region: Point[]): boolean {\n\t\tconst regionCells = new Set(region.map((p) => `${p.x},${p.y}`));\n\t\tif (hex.type === \"h\") {\n\t\t\tif (hex.r > 0 && regionCells.has(`${hex.c},${hex.r - 1}`)) return true;\n\t\t\tif (hex.r < grid.rows && regionCells.has(`${hex.c},${hex.r}`)) return true;\n\t\t} else {\n\t\t\tif (hex.c > 0 && regionCells.has(`${hex.c - 1},${hex.r}`)) return true;\n\t\t\tif (hex.c < grid.cols && regionCells.has(`${hex.c},${hex.r}`)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30CE\u30FC\u30C9\u304C\u7279\u5B9A\u306E\u533A\u753B\u306B\u96A3\u63A5\u3057\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param node \u30CE\u30FC\u30C9\u5EA7\u6A19\n\t * @param region \u533A\u753B\n\t * @returns \u96A3\u63A5\u3057\u3066\u3044\u308B\u304B\u3069\u3046\u304B\n\t */\n\tprivate isNodeHexagonAdjacentToRegion(grid: Grid, node: Point, region: Point[]): boolean {\n\t\tconst regionCells = new Set(region.map((p) => `${p.x},${p.y}`));\n\t\t// \u30CE\u30FC\u30C9\u306E\u5468\u56F24\u3064\u306E\u30BB\u30EB\u306E\u3044\u305A\u308C\u304B\u304C\u533A\u753B\u306B\u542B\u307E\u308C\u3066\u3044\u308C\u3070\u96A3\u63A5\n\t\tconst adjCells = [\n\t\t\t{ x: node.x - 1, y: node.y - 1 },\n\t\t\t{ x: node.x, y: node.y - 1 },\n\t\t\t{ x: node.x - 1, y: node.y },\n\t\t\t{ x: node.x, y: node.y },\n\t\t];\n\t\tfor (const cell of adjCells) {\n\t\t\tif (cell.x >= 0 && cell.x < grid.cols && cell.y >= 0 && cell.y < grid.rows) {\n\t\t\t\tif (regionCells.has(`${cell.x},${cell.y}`)) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u533A\u753B\u5185\u306E\u30A8\u30E9\u30FC\u524A\u9664\u53EF\u80FD\u306A\u5168\u30D1\u30BF\u30FC\u30F3\u3092\u53D6\u5F97\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param region \u533A\u753B\n\t * @param erasers \u6D88\u3057\u30B4\u30E0\u306E\u30EA\u30B9\u30C8\n\t * @param otherMarks \u4ED6\u306E\u8A18\u53F7\u306E\u30EA\u30B9\u30C8\n\t * @param adjacentMissedHexagons \u96A3\u63A5\u3059\u308B\u672A\u901A\u904E\u30A8\u30C3\u30B8\u516D\u89D2\u5F62\n\t * @param adjacentMissedNodeHexagons \u96A3\u63A5\u3059\u308B\u672A\u901A\u904E\u30CE\u30FC\u30C9\u516D\u89D2\u5F62\n\t * @returns \u53EF\u80FD\u306A\u524A\u9664\u30D1\u30BF\u30FC\u30F3\u306E\u30EA\u30B9\u30C8\n\t */\n\tprivate getPossibleErasures(grid: Grid, region: Point[], erasers: Point[], otherMarks: Point[], adjacentMissedHexagons: number[], adjacentMissedNodeHexagons: number[], pathEdges: Set<string>): { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] }[] {\n\t\tconst results: { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] }[] = [];\n\t\tconst numErasers = erasers.length;\n\t\tif (numErasers === 0) {\n\t\t\tconst errorCells = this.getRegionErrors(grid, region, [], pathEdges);\n\t\t\tif (errorCells.length === 0 && adjacentMissedHexagons.length === 0 && adjacentMissedNodeHexagons.length === 0) {\n\t\t\t\tresults.push({ invalidatedCells: [], invalidatedHexagons: [], invalidatedNodeHexagons: [], isValid: true, errorCells: [] });\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\n\t\tconst itemsToNegate = [...otherMarks.map((p) => ({ type: \"cell\" as const, pos: p })), ...adjacentMissedHexagons.map((idx) => ({ type: \"hex\" as const, index: idx })), ...adjacentMissedNodeHexagons.map((idx) => ({ type: \"nodeHex\" as const, index: idx }))];\n\n\t\t// \u521D\u671F\u72B6\u614B\u3067\u30A8\u30E9\u30FC\u304C\u3042\u308B\u304B\u78BA\u8A8D\n\t\tconst initiallyValid = this.getRegionErrors(grid, region, [], pathEdges).length === 0 && adjacentMissedHexagons.length === 0 && adjacentMissedNodeHexagons.length === 0;\n\n\t\tfor (let N = 0; N <= numErasers; N++) {\n\t\t\tconst negatedEraserCombinations = this.getNCombinations(erasers, N);\n\t\t\tfor (const negatedErasers of negatedEraserCombinations) {\n\t\t\t\tconst negatedErasersSet = new Set(negatedErasers.map((e) => `${e.x},${e.y}`));\n\t\t\t\tconst activeErasers = erasers.filter((e) => !negatedErasersSet.has(`${e.x},${e.y}`));\n\n\t\t\t\tfor (let K = 0; K <= itemsToNegate.length; K++) {\n\t\t\t\t\tif (activeErasers.length !== N + K) continue;\n\n\t\t\t\t\tconst itemCombinations = this.getNCombinations(itemsToNegate, K);\n\t\t\t\t\tfor (const negatedItems of itemCombinations) {\n\t\t\t\t\t\tconst negatedCells = negatedItems.filter((it) => it.type === \"cell\").map((it) => it.pos as Point);\n\t\t\t\t\t\tconst negatedHexIndices = negatedItems.filter((it) => it.type === \"hex\").map((it) => it.index as number);\n\t\t\t\t\t\tconst negatedNodeHexIndices = negatedItems.filter((it) => it.type === \"nodeHex\").map((it) => it.index as number);\n\n\t\t\t\t\t\tconst errorCells = this.getRegionErrors(grid, region, [...negatedCells, ...negatedErasers], pathEdges);\n\t\t\t\t\t\tconst isValid = errorCells.length === 0;\n\n\t\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\t\tlet isUseful = true;\n\t\t\t\t\t\t\tif (initiallyValid) {\n\t\t\t\t\t\t\t\tif (K > 0) isUseful = false;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < negatedItems.length; i++) {\n\t\t\t\t\t\t\t\t\tconst subset = [...negatedItems.slice(0, i), ...negatedItems.slice(i + 1)];\n\t\t\t\t\t\t\t\t\tconst subsetCells = subset.filter((it) => it.type === \"cell\").map((it) => it.pos as Point);\n\t\t\t\t\t\t\t\t\tconst subsetHexIndices = new Set(subset.filter((it) => it.type === \"hex\").map((it) => it.index as number));\n\t\t\t\t\t\t\t\t\tconst subsetNodeHexIndices = new Set(subset.filter((it) => it.type === \"nodeHex\").map((it) => it.index as number));\n\n\t\t\t\t\t\t\t\t\tconst allHexSatisfied = adjacentMissedHexagons.every((idx) => subsetHexIndices.has(idx));\n\t\t\t\t\t\t\t\t\tconst allNodeHexSatisfied = adjacentMissedNodeHexagons.every((idx) => subsetNodeHexIndices.has(idx));\n\n\t\t\t\t\t\t\t\t\tif (this.getRegionErrors(grid, region, subsetCells, pathEdges).length === 0 && allHexSatisfied && allNodeHexSatisfied) {\n\t\t\t\t\t\t\t\t\t\tisUseful = false;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (isUseful) {\n\t\t\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\t\t\tinvalidatedCells: [...negatedCells, ...negatedErasers],\n\t\t\t\t\t\t\t\t\tinvalidatedHexagons: negatedHexIndices,\n\t\t\t\t\t\t\t\t\tinvalidatedNodeHexagons: negatedNodeHexIndices,\n\t\t\t\t\t\t\t\t\tisValid: true,\n\t\t\t\t\t\t\t\t\terrorCells: [],\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * \u30A8\u30E9\u30FC\u304C\u89E3\u6D88\u3067\u304D\u306A\u304B\u3063\u305F\u5834\u5408\u306E\u30D9\u30B9\u30C8\u30A8\u30D5\u30A9\u30FC\u30C8\u306A\u524A\u9664\uFF08\u53EF\u80FD\u306A\u9650\u308A\u6D88\u3057\u30B4\u30E0\u3092\u9069\u7528\uFF09\u3092\u53D6\u5F97\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param region \u533A\u753B\n\t * @param erasers \u6D88\u3057\u30B4\u30E0\u306E\u30EA\u30B9\u30C8\n\t * @param otherMarks \u4ED6\u306E\u8A18\u53F7\u306E\u30EA\u30B9\u30C8\n\t * @param adjacentMissedHexagons \u96A3\u63A5\u3059\u308B\u672A\u901A\u904E\u30A8\u30C3\u30B8\u516D\u89D2\u5F62\n\t * @param adjacentMissedNodeHexagons \u96A3\u63A5\u3059\u308B\u672A\u901A\u904E\u30CE\u30FC\u30C9\u516D\u89D2\u5F62\n\t * @returns \u30D9\u30B9\u30C8\u30A8\u30D5\u30A9\u30FC\u30C8\u306A\u524A\u9664\u7D50\u679C\n\t */\n\tprivate getBestEffortErasures(grid: Grid, region: Point[], erasers: Point[], otherMarks: Point[], adjacentMissedHexagons: number[], adjacentMissedNodeHexagons: number[], pathEdges: Set<string>): { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] } {\n\t\tconst naturalErrors = this.getRegionErrors(grid, region, [], pathEdges);\n\t\tconst initiallyValid = naturalErrors.length === 0 && adjacentMissedHexagons.length === 0 && adjacentMissedNodeHexagons.length === 0;\n\n\t\t// \u521D\u671F\u72B6\u614B\u3067\u6709\u52B9\u306A\u3089\u3001\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\u81EA\u4F53\u304C\u30A8\u30E9\u30FC\u3002\n\t\tif (initiallyValid) {\n\t\t\treturn {\n\t\t\t\tinvalidatedCells: [],\n\t\t\t\tinvalidatedHexagons: [],\n\t\t\t\tinvalidatedNodeHexagons: [],\n\t\t\t\tisValid: false,\n\t\t\t\terrorCells: [...erasers],\n\t\t\t};\n\t\t}\n\n\t\tif (erasers.length > 0) {\n\t\t\tconst itemsToNegate = [...otherMarks.map((p) => ({ type: \"cell\" as const, pos: p })), ...adjacentMissedHexagons.map((idx) => ({ type: \"hex\" as const, index: idx })), ...adjacentMissedNodeHexagons.map((idx) => ({ type: \"nodeHex\" as const, index: idx }))];\n\n\t\t\t// \u30A8\u30E9\u30FC\u89E3\u6D88\u30D1\u30BF\u30FC\u30F3\u3092\u3044\u304F\u3064\u304B\u8A66\u3057\u3001\u6700\u3082\u30A8\u30E9\u30FC\u304C\u5C11\u306A\u304F\u306A\u308B\u3082\u306E\u3092\u63A1\u7528\u3059\u308B\n\t\t\tlet bestResult: { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean; errorCells: Point[] } | null = null;\n\t\t\tlet minErrorCount = Infinity;\n\n\t\t\t// \u5358\u7D14\u306A\u512A\u5148\u9806\u4F4D\u306B\u57FA\u3065\u304F\u30D1\u30BF\u30FC\u30F3\n\t\t\tconst tryNegate = (priorityItems: ({ type: \"cell\"; pos: Point } | { type: \"hex\"; index: number } | { type: \"nodeHex\"; index: number })[]) => {\n\t\t\t\tconst toInvalidateCells: Point[] = [];\n\t\t\t\tconst toInvalidateHexagons: number[] = [];\n\t\t\t\tconst toInvalidateNodeHexagons: number[] = [];\n\t\t\t\tlet usedErasersCount = 0;\n\n\t\t\t\tfor (const item of priorityItems) {\n\t\t\t\t\tif (usedErasersCount < erasers.length) {\n\t\t\t\t\t\tif (item.type === \"cell\") toInvalidateCells.push(item.pos);\n\t\t\t\t\t\telse if (item.type === \"hex\") toInvalidateHexagons.push(item.index);\n\t\t\t\t\t\telse toInvalidateNodeHexagons.push(item.index);\n\t\t\t\t\t\tusedErasersCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// \u6B8B\u308A\u306E\u6D88\u3057\u30B4\u30E0\u306F\u30DA\u30A2\u306B\u3057\u3066\u7121\u52B9\u5316\u3092\u8A66\u307F\u308B\n\t\t\t\tconst remainingForPairs = erasers.length - usedErasersCount;\n\t\t\t\tconst N = Math.floor(remainingForPairs / 2);\n\t\t\t\tconst negatedErasers = erasers.slice(usedErasersCount, usedErasersCount + N);\n\t\t\t\tusedErasersCount += N * 2;\n\n\t\t\t\t// \u6D88\u3057\u30B4\u30E0\u81EA\u8EAB\u304C\u30A8\u30E9\u30FC\u304B\u3069\u3046\u304B\u3092\u5224\u5B9A\u3059\u308B\u305F\u3081\u3001getRegionErrors\u3092\u547C\u3076\n\t\t\t\t// \u6D88\u3057\u30B4\u30E0\u81EA\u8EAB\u306F\uFF08\u6D88\u3057\u5408\u3063\u305F\u30DA\u30A2\u3092\u9664\u304D\uFF09\u30DE\u30FC\u30AF\u3068\u3057\u3066\u6B8B\u308B\n\t\t\t\tconst errorCells = this.getRegionErrors(grid, region, [...toInvalidateCells, ...negatedErasers], pathEdges);\n\t\t\t\t// \u4F7F\u308F\u308C\u306A\u304B\u3063\u305F\u6D88\u3057\u30B4\u30E0\u306F\u30A8\u30E9\u30FC\n\t\t\t\tfor (let i = usedErasersCount; i < erasers.length; i++) {\n\t\t\t\t\terrorCells.push(erasers[i]);\n\t\t\t\t}\n\n\t\t\t\tconst unresolvedHexagons = Math.max(0, adjacentMissedHexagons.length - toInvalidateHexagons.length);\n\t\t\t\tconst unresolvedNodeHexagons = Math.max(0, adjacentMissedNodeHexagons.length - toInvalidateNodeHexagons.length);\n\t\t\t\tconst totalErrorCount = errorCells.length + unresolvedHexagons + unresolvedNodeHexagons;\n\n\t\t\t\tif (totalErrorCount < minErrorCount) {\n\t\t\t\t\tminErrorCount = totalErrorCount;\n\n\t\t\t\t\tbestResult = {\n\t\t\t\t\t\tinvalidatedCells: [...toInvalidateCells, ...negatedErasers],\n\t\t\t\t\t\tinvalidatedHexagons: toInvalidateHexagons,\n\t\t\t\t\t\tinvalidatedNodeHexagons: toInvalidateNodeHexagons,\n\t\t\t\t\t\tisValid: false,\n\t\t\t\t\t\terrorCells,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// \u30D1\u30BF\u30FC\u30F31: \u81EA\u7136\u767A\u751F\u3057\u305F\u30A8\u30E9\u30FC\u3092\u512A\u5148\n\t\t\ttryNegate([...naturalErrors.map((p) => ({ type: \"cell\" as const, pos: p })), ...adjacentMissedHexagons.map((idx) => ({ type: \"hex\" as const, index: idx })), ...adjacentMissedNodeHexagons.map((idx) => ({ type: \"nodeHex\" as const, index: idx }))]);\n\t\t\t// \u30D1\u30BF\u30FC\u30F32: \u5168\u3066\u306E\u30A2\u30A4\u30C6\u30E0\u3092\u9806\u756A\u306B\n\t\t\ttryNegate(itemsToNegate);\n\t\t\t// \u30D1\u30BF\u30FC\u30F33: \u81EA\u7136\u767A\u751F\u3057\u305F\u5404\u30A8\u30E9\u30FC\u3092\u500B\u5225\u306B1\u3064\u305A\u3064\u6D88\u3057\u3066\u307F\u308B\n\t\t\tfor (const errCell of naturalErrors) {\n\t\t\t\ttryNegate([{ type: \"cell\", pos: errCell }]);\n\t\t\t}\n\n\t\t\tif (bestResult) return bestResult;\n\t\t}\n\n\t\tconst errorCells = [...naturalErrors, ...erasers];\n\t\treturn {\n\t\t\tinvalidatedCells: [],\n\t\t\tinvalidatedHexagons: [],\n\t\t\tinvalidatedNodeHexagons: [],\n\t\t\tisValid: false,\n\t\t\terrorCells,\n\t\t};\n\t}\n\n\t/**\n\t * \u914D\u5217\u304B\u3089N\u500B\u9078\u3076\u7D44\u307F\u5408\u308F\u305B\u3092\u53D6\u5F97\u3059\u308B\n\t * @param items \u914D\u5217\n\t * @param n \u9078\u629E\u3059\u308B\u6570\n\t * @returns \u7D44\u307F\u5408\u308F\u305B\u306E\u30EA\u30B9\u30C8\n\t */\n\tprivate getNCombinations<T>(items: T[], n: number): T[][] {\n\t\tconst results: T[][] = [];\n\t\tconst backtrack = (start: number, current: T[]) => {\n\t\t\tif (current.length === n) {\n\t\t\t\tresults.push([...current]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (let i = start; i < items.length; i++) {\n\t\t\t\tcurrent.push(items[i]);\n\t\t\t\tbacktrack(i + 1, current);\n\t\t\t\tcurrent.pop();\n\t\t\t}\n\t\t};\n\t\tbacktrack(0, []);\n\t\treturn results;\n\t}\n\n\t/**\n\t * \u7279\u5B9A\u306E\u524A\u9664\u30FB\u7121\u52B9\u5316\u3092\u9069\u7528\u3057\u305F\u72B6\u614B\u3067\u3001\u533A\u753B\u5185\u306E\u5236\u7D04\u304C\u6E80\u305F\u3055\u308C\u3066\u3044\u308B\u304B\u691C\u8A3C\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param region \u533A\u753B\n\t * @param erasedCells \u7121\u52B9\u5316\u3055\u308C\u305F\u30BB\u30EB\u306E\u30EA\u30B9\u30C8\n\t * @returns \u6709\u52B9\u304B\u3069\u3046\u304B\n\t */\n\tprivate checkRegionValid(grid: Grid, region: Point[], erasedCells: Point[], pathEdges: Set<string>): boolean {\n\t\treturn this.getRegionErrors(grid, region, erasedCells, pathEdges).length === 0;\n\t}\n\n\t/**\n\t * \u533A\u753B\u5185\u306E\u30A8\u30E9\u30FC\u3068\u306A\u3063\u3066\u3044\u308B\u30BB\u30EB\u3092\u7279\u5B9A\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param region \u533A\u753B\n\t * @param erasedCells \u7121\u52B9\u5316\u3055\u308C\u305F\u30BB\u30EB\u306E\u30EA\u30B9\u30C8\n\t * @returns \u30A8\u30E9\u30FC\u30BB\u30EB\u306E\u30EA\u30B9\u30C8\n\t */\n\tprivate getRegionErrors(grid: Grid, region: Point[], erasedCells: Point[], pathEdges: Set<string>): Point[] {\n\t\tconst erasedSet = new Set(erasedCells.map((p) => `${p.x},${p.y}`));\n\t\tconst colorCounts = new Map<number, number>();\n\t\tconst colorCells = new Map<number, Point[]>();\n\t\tconst starColors = new Set<number>();\n\t\tconst squareColors = new Set<number>();\n\t\tconst tetrisPieces: { shape: number[][]; rotatable: boolean; pos: Point }[] = [];\n\t\tconst tetrisNegativePieces: { shape: number[][]; rotatable: boolean; pos: Point }[] = [];\n\t\tconst triangleCells: { count: number; pos: Point }[] = [];\n\n\t\tfor (const cell of region) {\n\t\t\tif (erasedSet.has(`${cell.x},${cell.y}`)) continue;\n\t\t\tconst constraint = grid.cells[cell.y][cell.x];\n\t\t\tif (constraint.type === CellType.None) continue;\n\n\t\t\tconst color = constraint.color;\n\t\t\tif (color !== Color.None) {\n\t\t\t\tcolorCounts.set(color, (colorCounts.get(color) || 0) + 1);\n\t\t\t\tif (!colorCells.has(color)) colorCells.set(color, []);\n\t\t\t\tcolorCells.get(color)!.push(cell);\n\t\t\t}\n\n\t\t\tif (constraint.type === CellType.Square) squareColors.add(color);\n\t\t\telse if (constraint.type === CellType.Star) starColors.add(color);\n\t\t\telse if (constraint.type === CellType.Tetris || constraint.type === CellType.TetrisRotated) {\n\t\t\t\tif (constraint.shape) tetrisPieces.push({ shape: constraint.shape, rotatable: constraint.type === CellType.TetrisRotated, pos: cell });\n\t\t\t} else if (constraint.type === CellType.TetrisNegative || constraint.type === CellType.TetrisNegativeRotated) {\n\t\t\t\tif (constraint.shape) tetrisNegativePieces.push({ shape: constraint.shape, rotatable: constraint.type === CellType.TetrisNegativeRotated, pos: cell });\n\t\t\t} else if (constraint.type === CellType.Triangle) {\n\t\t\t\ttriangleCells.push({ count: constraint.count || 0, pos: cell });\n\t\t\t}\n\t\t}\n\n\t\tconst errorCells: Point[] = [];\n\t\t// \u56DB\u89D2\u5F62\u306E\u30EB\u30FC\u30EB\uFF1A\u540C\u533A\u753B\u5185\u306F\u540C\u3058\u8272\n\t\tif (squareColors.size > 1) {\n\t\t\tfor (const cell of region) {\n\t\t\t\tif (erasedSet.has(`${cell.x},${cell.y}`)) continue;\n\t\t\t\tif (grid.cells[cell.y][cell.x].type === CellType.Square) errorCells.push(cell);\n\t\t\t}\n\t\t}\n\n\t\t// \u661F\u306E\u30EB\u30FC\u30EB\uFF1A\u540C\u8272\u306E\u8A18\u53F7\u304C\u3061\u3087\u3046\u30692\u3064\n\t\tfor (const color of starColors) {\n\t\t\tif (colorCounts.get(color) !== 2) {\n\t\t\t\tconst cells = colorCells.get(color) || [];\n\t\t\t\tfor (const p of cells) {\n\t\t\t\t\tconst type = grid.cells[p.y][p.x].type;\n\t\t\t\t\tif (type === CellType.Star) {\n\t\t\t\t\t\terrorCells.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// \u4E09\u89D2\u5F62\u306E\u30EB\u30FC\u30EB\uFF1A\u901A\u904E\u8FBA\u6570\n\t\tfor (const tri of triangleCells) {\n\t\t\tlet passedEdges = 0;\n\t\t\tconst cellEdges = [this.getEdgeKey({ x: tri.pos.x, y: tri.pos.y }, { x: tri.pos.x + 1, y: tri.pos.y }), this.getEdgeKey({ x: tri.pos.x, y: tri.pos.y + 1 }, { x: tri.pos.x + 1, y: tri.pos.y + 1 }), this.getEdgeKey({ x: tri.pos.x, y: tri.pos.y }, { x: tri.pos.x, y: tri.pos.y + 1 }), this.getEdgeKey({ x: tri.pos.x + 1, y: tri.pos.y }, { x: tri.pos.x + 1, y: tri.pos.y + 1 })];\n\t\t\tfor (const edge of cellEdges) {\n\t\t\t\tif (pathEdges.has(edge)) passedEdges++;\n\t\t\t}\n\t\t\tif (passedEdges !== tri.count) {\n\t\t\t\terrorCells.push(tri.pos);\n\t\t\t}\n\t\t}\n\n\t\t// \u30C6\u30C8\u30EA\u30B9\u306E\u30EB\u30FC\u30EB\uFF1A\u30BF\u30A4\u30EA\u30F3\u30B0\u53EF\u80FD\n\t\tif (tetrisPieces.length > 0 || tetrisNegativePieces.length > 0) {\n\t\t\tif (\n\t\t\t\t!this.checkTetrisConstraint(\n\t\t\t\t\tgrid,\n\t\t\t\t\tregion,\n\t\t\t\t\ttetrisPieces.map((p) => ({ shape: p.shape, rotatable: p.rotatable })),\n\t\t\t\t\ttetrisNegativePieces.map((p) => ({ shape: p.shape, rotatable: p.rotatable })),\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tfor (const p of tetrisPieces) errorCells.push(p.pos);\n\t\t\t\tfor (const p of tetrisNegativePieces) errorCells.push(p.pos);\n\t\t\t}\n\t\t}\n\t\treturn errorCells;\n\t}\n\n\t/**\n\t * \u30B0\u30ED\u30FC\u30D0\u30EB\u306A\u5236\u7D04\uFF08\u516D\u89D2\u5F62\uFF09\u306E\u5272\u308A\u5F53\u3066\u3092\u30D0\u30C3\u30AF\u30C8\u30E9\u30C3\u30AD\u30F3\u30B0\u3067\u63A2\u7D22\u3059\u308B\n\t * @param regionResults \u5404\u533A\u753B\u306E\u524A\u9664\u5019\u88DC\u30EA\u30B9\u30C8\n\t * @param totalMissedHexagons \u5408\u8A08\u672A\u901A\u904E\u30A8\u30C3\u30B8\u516D\u89D2\u5F62\u6570\n\t * @param totalMissedNodeHexagons \u5408\u8A08\u672A\u901A\u904E\u30CE\u30FC\u30C9\u516D\u89D2\u5F62\u6570\n\t * @returns \u6210\u529F\u3057\u305F\u5834\u5408\u306F\u5272\u308A\u5F53\u3066\u7D50\u679C\u3001\u5931\u6557\u3057\u305F\u5834\u5408\u306Fnull\n\t */\n\tprivate findGlobalAssignment(regionResults: { invalidatedCells: Point[]; invalidatedHexagons: number[]; invalidatedNodeHexagons: number[]; isValid: boolean }[][], totalMissedHexagons: number, totalMissedNodeHexagons: number): { invalidatedCells: Point[]; invalidatedHexIndices: number[]; invalidatedNodeHexIndices: number[] } | null {\n\t\tconst numRegions = regionResults.length;\n\t\tconst currentHexErasures = new Array(totalMissedHexagons).fill(0);\n\t\tconst currentNodeHexErasures = new Array(totalMissedNodeHexagons).fill(0);\n\t\tconst allInvalidatedCells: Point[] = [];\n\t\tconst allInvalidatedHexIndices: number[] = [];\n\t\tconst allInvalidatedNodeHexIndices: number[] = [];\n\n\t\tconst backtrack = (regionIdx: number): boolean => {\n\t\t\tif (regionIdx === numRegions) return currentHexErasures.every((count) => count === 1) && currentNodeHexErasures.every((count) => count === 1);\n\t\t\tfor (const option of regionResults[regionIdx]) {\n\t\t\t\tlet possible = true;\n\t\t\t\tfor (const hexIdx of option.invalidatedHexagons)\n\t\t\t\t\tif (currentHexErasures[hexIdx] > 0) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (possible) {\n\t\t\t\t\tfor (const hexIdx of option.invalidatedNodeHexagons)\n\t\t\t\t\t\tif (currentNodeHexErasures[hexIdx] > 0) {\n\t\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (possible) {\n\t\t\t\t\tfor (const hexIdx of option.invalidatedHexagons) {\n\t\t\t\t\t\tcurrentHexErasures[hexIdx]++;\n\t\t\t\t\t\tallInvalidatedHexIndices.push(hexIdx);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const hexIdx of option.invalidatedNodeHexagons) {\n\t\t\t\t\t\tcurrentNodeHexErasures[hexIdx]++;\n\t\t\t\t\t\tallInvalidatedNodeHexIndices.push(hexIdx);\n\t\t\t\t\t}\n\t\t\t\t\tallInvalidatedCells.push(...option.invalidatedCells);\n\t\t\t\t\tif (backtrack(regionIdx + 1)) return true;\n\n\t\t\t\t\tfor (const hexIdx of option.invalidatedHexagons) {\n\t\t\t\t\t\tcurrentHexErasures[hexIdx]--;\n\t\t\t\t\t\tallInvalidatedHexIndices.pop();\n\t\t\t\t\t}\n\t\t\t\t\tfor (const hexIdx of option.invalidatedNodeHexagons) {\n\t\t\t\t\t\tcurrentNodeHexErasures[hexIdx]--;\n\t\t\t\t\t\tallInvalidatedNodeHexIndices.pop();\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < option.invalidatedCells.length; i++) allInvalidatedCells.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tif (backtrack(0))\n\t\t\treturn {\n\t\t\t\tinvalidatedCells: allInvalidatedCells,\n\t\t\t\tinvalidatedHexIndices: allInvalidatedHexIndices,\n\t\t\t\tinvalidatedNodeHexIndices: allInvalidatedNodeHexIndices,\n\t\t\t};\n\t\treturn null;\n\t}\n\n\t/**\n\t * \u30C6\u30C8\u30EA\u30B9\u5236\u7D04\u306E\u691C\u8A3C\n\t * \u9818\u57DF\u5185\u306E\u5168\u3066\u306E\u30C6\u30C8\u30EA\u30B9\u30D4\u30FC\u30B9\uFF08\u6B63\u30FB\u8CA0\uFF09\u3092\u76E4\u9762\u5185\u306B\u914D\u7F6E\u3057\u3001\n\t * \u5404\u30BB\u30EB\u306E\u5408\u8A08\u5024\u304C\u300C\u9818\u57DF\u5185\u306A\u30891\u3001\u9818\u57DF\u5916\u306A\u30890\u300D\u306B\u306A\u308B\u914D\u7F6E\u304C\u5B58\u5728\u3059\u308B\u304B\u3092\u78BA\u8A8D\u3059\u308B\u3002\n\t * \u91CD\u306A\u308A\u306F\u8A31\u5BB9\u3055\u308C\u308B\u304C\u3001\u6700\u7D42\u7684\u306A\u5408\u8A08\u304C\u30DE\u30A4\u30CA\u30B9\u306B\u306A\u308B\u3053\u3068\u306F\u8A31\u3055\u308C\u306A\u3044\u3002\n\t * \u307E\u305F\u3001\u5168\u3066\u306E\u30D4\u30FC\u30B9\u306F\u30D1\u30BA\u30EB\uFF08\u30B0\u30EA\u30C3\u30C9\uFF09\u306E\u7BC4\u56F2\u5185\u306B\u53CE\u307E\u3063\u3066\u3044\u308B\u5FC5\u8981\u304C\u3042\u308B\u3002\n\t * @param gridObj \u30B0\u30EA\u30C3\u30C9\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\n\t * @param region \u533A\u753B\n\t * @param pieces \u6B63\u306E\u30C6\u30C8\u30EA\u30B9\u30D4\u30FC\u30B9\n\t * @param negativePieces \u8CA0\u306E\u30C6\u30C8\u30EA\u30B9\u30D4\u30FC\u30B9\n\t */\n\tprivate checkTetrisConstraint(gridObj: Grid, region: Point[], pieces: { shape: number[][]; rotatable: boolean }[], negativePieces: { shape: number[][]; rotatable: boolean }[] = []): boolean {\n\t\tconst positiveArea = pieces.reduce((sum, p) => sum + this.getShapeArea(p.shape), 0);\n\t\tconst negativeArea = negativePieces.reduce((sum, p) => sum + this.getShapeArea(p.shape), 0);\n\t\tconst netArea = positiveArea - negativeArea;\n\n\t\tif (netArea < 0) return false;\n\t\tif (netArea !== 0 && netArea !== region.length) return false;\n\n\t\tconst rows = gridObj.rows;\n\t\tconst cols = gridObj.cols;\n\n\t\t// \u30AD\u30E3\u30C3\u30B7\u30E5\u306E\u78BA\u8A8D (\u30E1\u30E2\u30EA\u30EA\u30FC\u30AF\u9632\u6B62\u306E\u305F\u3081\u30B5\u30A4\u30BA\u3092\u5236\u9650)\n\t\tif (this.tetrisCache.size > 10000) this.tetrisCache.clear();\n\n\t\tconst regionMask = new Uint8Array(rows * cols);\n\t\tfor (const p of region) regionMask[p.y * cols + p.x] = 1;\n\t\tconst pieceKey = (p: { shape: number[][]; rotatable: boolean }, sign: number) => `${this.getShapeKey(p.shape)}-${p.rotatable}-${sign}`;\n\t\tconst piecesKey = [...pieces.map((p) => pieceKey(p, 1)), ...negativePieces.map((p) => pieceKey(p, -1))].sort().join(\"|\");\n\t\tconst cacheKey = `${rows}x${cols}:${regionMask.join(\"\")}:${piecesKey}`;\n\t\tif (this.tetrisCache.has(cacheKey)) return this.tetrisCache.get(cacheKey)!;\n\n\t\tconst target = new Int8Array(rows * cols);\n\t\tif (netArea > 0) {\n\t\t\tfor (let i = 0; i < regionMask.length; i++) target[i] = regionMask[i];\n\t\t}\n\t\tconst current = new Int8Array(rows * cols);\n\n\t\t// \u540C\u4E00\u30D4\u30FC\u30B9\u306E\u30B0\u30EB\u30FC\u30D7\u5316\n\t\tconst pieceGroups: {\n\t\t\trotations: { shape: number[][]; h: number; w: number }[];\n\t\t\tsign: number;\n\t\t\tarea: number;\n\t\t\tcount: number;\n\t\t}[] = [];\n\n\t\tconst allPieces = [...pieces.map((p) => ({ ...p, sign: 1 })), ...negativePieces.map((p) => ({ ...p, sign: -1 }))];\n\t\tfor (const p of allPieces) {\n\t\t\tconst rotations = p.rotatable ? this.getAllRotations(p.shape) : [p.shape];\n\t\t\tconst baseShapeKey = this.getShapeKey(rotations[0]);\n\n\t\t\tlet group = pieceGroups.find((g) => g.sign === p.sign && (p.rotatable ? g.rotations.length > 1 : g.rotations.length === 1) && this.getShapeKey(g.rotations[0].shape) === baseShapeKey);\n\n\t\t\tif (group) {\n\t\t\t\tgroup.count++;\n\t\t\t} else {\n\t\t\t\tpieceGroups.push({\n\t\t\t\t\trotations: rotations.map((r) => ({ shape: r, h: r.length, w: r[0].length })),\n\t\t\t\t\tsign: p.sign,\n\t\t\t\t\tarea: this.getShapeArea(p.shape),\n\t\t\t\t\tcount: 1,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// \u6B63\u306E\u30D4\u30FC\u30B9\u3001\u304B\u3064\u9762\u7A4D\u304C\u5927\u304D\u3044\u9806\u306B\u30BD\u30FC\u30C8\u3057\u3066\u679D\u5208\u308A\u52B9\u7387\u3092\u4E0A\u3052\u308B\n\t\tpieceGroups.sort((a, b) => b.sign - a.sign || b.area - a.area);\n\n\t\tlet posMismatch = netArea > 0 ? region.length : 0;\n\t\tlet negMismatch = 0;\n\t\tlet totalPositiveAreaLeft = positiveArea;\n\t\tlet totalNegativeAreaLeft = negativeArea;\n\n\t\tconst backtrack = (groupIdx: number, countInGroup: number, lastPos: number): boolean => {\n\t\t\t// \u9762\u7A4D\u30D9\u30FC\u30B9\u306E\u679D\u5208\u308A\n\t\t\tif (posMismatch > totalPositiveAreaLeft || negMismatch > totalNegativeAreaLeft) return false;\n\n\t\t\tif (groupIdx === pieceGroups.length) {\n\t\t\t\treturn posMismatch === 0 && negMismatch === 0;\n\t\t\t}\n\n\t\t\tconst group = pieceGroups[groupIdx];\n\t\t\tconst nextCount = countInGroup + 1;\n\t\t\tconst isLastInGroup = nextCount === group.count;\n\n\t\t\tif (group.sign === 1) totalPositiveAreaLeft -= group.area;\n\t\t\telse totalNegativeAreaLeft -= group.area;\n\n\t\t\tfor (const rot of group.rotations) {\n\t\t\t\tconst h = rot.h;\n\t\t\t\tconst w = rot.w;\n\t\t\t\tconst startPos = countInGroup === 0 ? 0 : lastPos;\n\n\t\t\t\tfor (let pos = startPos; pos <= rows * cols - (h > 0 ? (h - 1) * cols + w : 0); pos++) {\n\t\t\t\t\tconst r = Math.floor(pos / cols);\n\t\t\t\t\tconst c = pos % cols;\n\t\t\t\t\tif (r > rows - h || c > cols - w) continue;\n\n\t\t\t\t\tlet possible = true;\n\t\t\t\t\tconst placedIndices: number[] = [];\n\n\t\t\t\t\tfor (let pr = 0; pr < h; pr++) {\n\t\t\t\t\t\tfor (let pc = 0; pc < w; pc++) {\n\t\t\t\t\t\t\tif (rot.shape[pr][pc]) {\n\t\t\t\t\t\t\t\tconst tidx = (r + pr) * cols + (c + pc);\n\n\t\t\t\t\t\t\t\t// Incremental mismatch update\n\t\t\t\t\t\t\t\tif (group.sign === 1) {\n\t\t\t\t\t\t\t\t\tif (current[tidx] < target[tidx]) posMismatch--;\n\t\t\t\t\t\t\t\t\telse negMismatch++;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (current[tidx] <= target[tidx]) posMismatch++;\n\t\t\t\t\t\t\t\t\telse negMismatch--;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcurrent[tidx] += group.sign;\n\t\t\t\t\t\t\t\tplacedIndices.push(tidx);\n\n\t\t\t\t\t\t\t\tif (current[tidx] < 0) possible = false;\n\t\t\t\t\t\t\t\tif (group.sign === 1 && current[tidx] > 1 + negativeArea) possible = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!possible) break;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (possible) {\n\t\t\t\t\t\tif (isLastInGroup) {\n\t\t\t\t\t\t\tif (backtrack(groupIdx + 1, 0, 0)) {\n\t\t\t\t\t\t\t\tfor (const tidx of placedIndices) {\n\t\t\t\t\t\t\t\t\tcurrent[tidx] -= group.sign;\n\t\t\t\t\t\t\t\t\tif (group.sign === 1) {\n\t\t\t\t\t\t\t\t\t\tif (current[tidx] < target[tidx]) posMismatch++;\n\t\t\t\t\t\t\t\t\t\telse negMismatch--;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif (current[tidx] <= target[tidx]) posMismatch--;\n\t\t\t\t\t\t\t\t\t\telse negMismatch++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (group.sign === 1) totalPositiveAreaLeft += group.area;\n\t\t\t\t\t\t\t\telse totalNegativeAreaLeft += group.area;\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (backtrack(groupIdx, nextCount, pos)) {\n\t\t\t\t\t\t\t\tfor (const tidx of placedIndices) {\n\t\t\t\t\t\t\t\t\tcurrent[tidx] -= group.sign;\n\t\t\t\t\t\t\t\t\tif (group.sign === 1) {\n\t\t\t\t\t\t\t\t\t\tif (current[tidx] < target[tidx]) posMismatch++;\n\t\t\t\t\t\t\t\t\t\telse negMismatch--;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif (current[tidx] <= target[tidx]) posMismatch--;\n\t\t\t\t\t\t\t\t\t\telse negMismatch++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (group.sign === 1) totalPositiveAreaLeft += group.area;\n\t\t\t\t\t\t\t\telse totalNegativeAreaLeft += group.area;\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const tidx of placedIndices) {\n\t\t\t\t\t\tcurrent[tidx] -= group.sign;\n\t\t\t\t\t\tif (group.sign === 1) {\n\t\t\t\t\t\t\tif (current[tidx] < target[tidx]) posMismatch++;\n\t\t\t\t\t\t\telse negMismatch--;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (current[tidx] <= target[tidx]) posMismatch--;\n\t\t\t\t\t\t\telse negMismatch++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (group.sign === 1) totalPositiveAreaLeft += group.area;\n\t\t\telse totalNegativeAreaLeft += group.area;\n\t\t\treturn false;\n\t\t};\n\n\t\tconst res = backtrack(0, 0, 0);\n\t\tthis.tetrisCache.set(cacheKey, res);\n\t\treturn res;\n\t}\n\n\tprivate getShapeArea(shape: number[][]): number {\n\t\tlet area = 0;\n\t\tfor (const row of shape) for (const cell of row) if (cell) area++;\n\t\treturn area;\n\t}\n\n\tprivate getShapeKey(shape: number[][]): string {\n\t\treturn JSON.stringify(shape);\n\t}\n\n\t/**\n\t * \u518D\u5E30\u7684\u306B\u30BF\u30A4\u30EA\u30F3\u30B0\u3092\u8A66\u307F\u308B\n\t * @param regionGrid \u9818\u57DF\u306E\u30B0\u30EA\u30C3\u30C9\u8868\u73FE\n\t * @param pieces \u6B8B\u308A\u306E\u30D4\u30FC\u30B9\n\t * @returns \u30BF\u30A4\u30EA\u30F3\u30B0\u53EF\u80FD\u304B\u3069\u3046\u304B\n\t */\n\n\tprivate getAllRotations(shape: number[][]): number[][][] {\n\t\tconst results: number[][][] = [];\n\t\tconst keys = new Set<string>();\n\t\tlet curr = shape;\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tconst key = this.getShapeKey(curr);\n\t\t\tif (!keys.has(key)) {\n\t\t\t\tresults.push(curr);\n\t\t\t\tkeys.add(key);\n\t\t\t}\n\t\t\tcurr = this.rotate90(curr);\n\t\t}\n\t\treturn results;\n\t}\n\n\tprivate rotate90(shape: number[][]): number[][] {\n\t\tconst rows = shape.length;\n\t\tconst cols = shape[0].length;\n\t\tconst newShape = Array.from({ length: cols }, () => Array(rows).fill(0));\n\t\tfor (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) newShape[c][rows - 1 - r] = shape[r][c];\n\t\treturn newShape;\n\t}\n\n\t/**\n\t * \u56DE\u7B54\u30D1\u30B9\u306B\u3088\u3063\u3066\u5206\u5272\u3055\u308C\u305F\u5404\u533A\u753B\u306E\u30BB\u30EB\u30EA\u30B9\u30C8\u3092\u53D6\u5F97\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param path \u30E1\u30A4\u30F3\u30D1\u30B9\n\t * @param symPath \u5BFE\u79F0\u30D1\u30B9\n\t * @param externalCellsPrecalculated \u5916\u90E8\u30BB\u30EB\u306E\u30AD\u30E3\u30C3\u30B7\u30E5\n\t * @returns \u533A\u753B\u30EA\u30B9\u30C8\n\t */\n\tprivate calculateRegions(grid: Grid, path: Point[], symPath: Point[] = [], externalCellsPrecalculated?: Set<string>): Point[][] {\n\t\tconst regions: Point[][] = [];\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst visitedCells = new Uint8Array(rows * cols);\n\n\t\t// \u30A8\u30C3\u30B8\u306E\u30DE\u30B9\u30AF\u4F5C\u6210 (\u9AD8\u901F\u5316)\n\t\tconst hEdgesMask = new Uint8Array((rows + 1) * cols);\n\t\tconst vEdgesMask = new Uint8Array(rows * (cols + 1));\n\n\t\tconst setEdge = (p1: Point, p2: Point) => {\n\t\t\tif (p1.x === p2.x) {\n\t\t\t\tvEdgesMask[Math.min(p1.y, p2.y) * (cols + 1) + p1.x] = 1;\n\t\t\t} else {\n\t\t\t\thEdgesMask[p1.y * cols + Math.min(p1.x, p2.x)] = 1;\n\t\t\t}\n\t\t};\n\n\t\tfor (let i = 0; i < path.length - 1; i++) setEdge(path[i], path[i + 1]);\n\t\tfor (let i = 0; i < symPath.length - 1; i++) setEdge(symPath[i], symPath[i + 1]);\n\n\t\t// Absent\u30A8\u30C3\u30B8\u3082\u30DE\u30B9\u30AF\u306B\u8FFD\u52A0\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Absent) hEdgesMask[r * cols + c] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Absent) vEdgesMask[r * (cols + 1) + c] = 1;\n\t\t\t}\n\t\t}\n\n\t\tconst externalCells = externalCellsPrecalculated || this.getExternalCells(grid);\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tconst idx = r * cols + c;\n\t\t\t\tif (visitedCells[idx] || (externalCells && externalCells.has(`${c},${r}`))) continue;\n\n\t\t\t\tconst region: Point[] = [];\n\t\t\t\tconst queue: number[] = [idx];\n\t\t\t\tvisitedCells[idx] = 1;\n\n\t\t\t\tlet head = 0;\n\t\t\t\twhile (head < queue.length) {\n\t\t\t\t\tconst currIdx = queue[head++];\n\t\t\t\t\tconst cx = currIdx % cols;\n\t\t\t\t\tconst cy = Math.floor(currIdx / cols);\n\t\t\t\t\tregion.push({ x: cx, y: cy });\n\n\t\t\t\t\t// Neighbors: Up, Down, Left, Right\n\t\t\t\t\t// Up\n\t\t\t\t\tif (cy > 0 && !hEdgesMask[cy * cols + cx]) {\n\t\t\t\t\t\tconst nIdx = (cy - 1) * cols + cx;\n\t\t\t\t\t\tif (!visitedCells[nIdx] && (!externalCells || !externalCells.has(`${cx},${cy - 1}`))) {\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\n\t\t\t\t\t\t\tqueue.push(nIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Down\n\t\t\t\t\tif (cy < rows - 1 && !hEdgesMask[(cy + 1) * cols + cx]) {\n\t\t\t\t\t\tconst nIdx = (cy + 1) * cols + cx;\n\t\t\t\t\t\tif (!visitedCells[nIdx] && (!externalCells || !externalCells.has(`${cx},${cy + 1}`))) {\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\n\t\t\t\t\t\t\tqueue.push(nIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Left\n\t\t\t\t\tif (cx > 0 && !vEdgesMask[cy * (cols + 1) + cx]) {\n\t\t\t\t\t\tconst nIdx = cy * cols + (cx - 1);\n\t\t\t\t\t\tif (!visitedCells[nIdx] && (!externalCells || !externalCells.has(`${cx - 1},${cy}`))) {\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\n\t\t\t\t\t\t\tqueue.push(nIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Right\n\t\t\t\t\tif (cx < cols - 1 && !vEdgesMask[cy * (cols + 1) + (cx + 1)]) {\n\t\t\t\t\t\tconst nIdx = cy * cols + (cx + 1);\n\t\t\t\t\t\tif (!visitedCells[nIdx] && (!externalCells || !externalCells.has(`${cx + 1},${cy}`))) {\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\n\t\t\t\t\t\t\tqueue.push(nIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregions.push(region);\n\t\t\t}\n\t\t}\n\t\treturn regions;\n\t}\n\n\t/**\n\t * \u30A8\u30C3\u30B8\uFF08Absent\uFF09\u306B\u3088\u3063\u3066\u5916\u90E8\u306B\u7E4B\u304C\u3063\u3066\u3044\u308B\u30BB\u30EB\u3092\u7279\u5B9A\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @returns \u5916\u90E8\u30BB\u30EB\u306E\u30BB\u30C3\u30C8\n\t */\n\tprivate getExternalCells(grid: Grid): Set<string> {\n\t\tconst external = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [];\n\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\tif (grid.hEdges[0][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},0`)) {\n\t\t\t\t\texternal.add(`${c},0`);\n\t\t\t\t\tqueue.push({ x: c, y: 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.hEdges[grid.rows][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},${grid.rows - 1}`)) {\n\t\t\t\t\texternal.add(`${c},${grid.rows - 1}`);\n\t\t\t\t\tqueue.push({ x: c, y: grid.rows - 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tif (grid.vEdges[r][0].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`0,${r}`)) {\n\t\t\t\t\texternal.add(`0,${r}`);\n\t\t\t\t\tqueue.push({ x: 0, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.vEdges[r][grid.cols].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${grid.cols - 1},${r}`)) {\n\t\t\t\t\texternal.add(`${grid.cols - 1},${r}`);\n\t\t\t\t\tqueue.push({ x: grid.cols - 1, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.hEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.hEdges[curr.y + 1][curr.x] },\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x + 1] },\n\t\t\t];\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\tif (!external.has(`${n.nx},${n.ny}`) && n.edge.type === EdgeType.Absent) {\n\t\t\t\t\t\texternal.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn external;\n\t}\n\n\tprivate getSymmetricalPoint(grid: Grid, p: Point): Point {\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\treturn { x: grid.cols - p.x, y: p.y };\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\treturn { x: p.x, y: grid.rows - p.y };\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\treturn { x: grid.cols - p.x, y: grid.rows - p.y };\n\t\t}\n\t\treturn { ...p };\n\t}\n\n\tprivate getSymmetricalPointIndex(grid: Grid, idx: number): number {\n\t\tconst nodeCols = grid.cols + 1;\n\t\tconst r = Math.floor(idx / nodeCols);\n\t\tconst c = idx % nodeCols;\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\tlet sr = r,\n\t\t\tsc = c;\n\t\tif (symmetry === SymmetryType.Horizontal) {\n\t\t\tsc = grid.cols - c;\n\t\t} else if (symmetry === SymmetryType.Vertical) {\n\t\t\tsr = grid.rows - r;\n\t\t} else if (symmetry === SymmetryType.Rotational) {\n\t\t\tsc = grid.cols - c;\n\t\t\tsr = grid.rows - r;\n\t\t}\n\t\treturn sr * nodeCols + sc;\n\t}\n\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u306E\u96E3\u6613\u5EA6\u30B9\u30B3\u30A2(0.0-1.0)\u3092\u7B97\u51FA\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param starts \u63A2\u7D22\u3092\u958B\u59CB\u3059\u308B\u30B9\u30BF\u30FC\u30C8\u30CE\u30FC\u30C9\u306E\u30EA\u30B9\u30C8\uFF08\u7701\u7565\u6642\u306F\u5168\u30B9\u30BF\u30FC\u30C8\u30CE\u30FC\u30C9\uFF09\n\t */\n\tpublic calculateDifficulty(grid: Grid, starts?: Point[]): number {\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst nodeCols = cols + 1;\n\t\tconst nodeCount = (rows + 1) * nodeCols;\n\t\tconst adj = Array.from({ length: nodeCount }, () => [] as { next: number; hexType: EdgeType; isBroken: boolean }[]);\n\t\tconst startNodes: number[] = [];\n\t\tconst endNodes: number[] = [];\n\t\tconst isEndNode = Array(nodeCount).fill(false);\n\t\tconst hexIdMap = new Map<string, number>();\n\t\tlet nextHexId = 0;\n\t\tconst hexagonEdges = new Set<string>();\n\t\tconst hexagonNodes = new Set<number>();\n\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tconst u = r * nodeCols + c;\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Start) startNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.End) {\n\t\t\t\t\tendNodes.push(u);\n\t\t\t\t\tisEndNode[u] = true;\n\t\t\t\t}\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Hexagon || grid.nodes[r][c].type === NodeType.HexagonMain || grid.nodes[r][c].type === NodeType.HexagonSymmetry) {\n\t\t\t\t\thexIdMap.set(`n${c},${r}`, nextHexId++);\n\t\t\t\t\thexagonNodes.add(u);\n\t\t\t\t}\n\n\t\t\t\tif (c < cols) {\n\t\t\t\t\tconst v = u + 1;\n\t\t\t\t\tconst type = grid.hEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon || type === EdgeType.HexagonMain || type === EdgeType.HexagonSymmetry;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, hexType: type, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, hexType: type, isBroken });\n\t\t\t\t\tif (isHexagon) {\n\t\t\t\t\t\thexIdMap.set(`eh${c},${r}`, nextHexId++);\n\t\t\t\t\t\thexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r }));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (r < rows) {\n\t\t\t\t\tconst v = u + nodeCols;\n\t\t\t\t\tconst type = grid.vEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon || type === EdgeType.HexagonMain || type === EdgeType.HexagonSymmetry;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, hexType: type, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, hexType: type, isBroken });\n\t\t\t\t\tif (isHexagon) {\n\t\t\t\t\t\thexIdMap.set(`ev${c},${r}`, nextHexId++);\n\t\t\t\t\t\thexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 }));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst stats = { totalNodesVisited: 0, branchingPoints: 0, solutions: 0, maxDepth: 0, backtracks: 0 };\n\t\tconst totalHexagons = nextHexId;\n\t\tconst fingerprints = new Set<string>();\n\n\t\t// \u76E4\u9762\u306E\u5927\u304D\u3055\u306B\u5408\u308F\u305B\u3066\u63A2\u7D22\u30EA\u30DF\u30C3\u30C8\u3092\u8ABF\u6574\n\t\tconst searchLimit = Math.max(1000, rows * cols * 200);\n\t\tconst externalCells = this.getExternalCells(grid);\n\n\t\t// \u30BB\u30EB\u30DE\u30FC\u30AF\uFF08\u56DB\u89D2\u3001\u661F\u3001\u30C6\u30C8\u30EA\u30B9\u3001\u6D88\u3057\u30B4\u30E0\uFF09\u304C\u3042\u308B\u304B\u4E8B\u524D\u306B\u30C1\u30A7\u30C3\u30AF\n\t\tlet hasCellMarks = false;\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tif (grid.cells[r][c].type !== CellType.None) {\n\t\t\t\t\thasCellMarks = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasCellMarks) break;\n\t\t}\n\n\t\tthis.tetrisCache.clear();\n\t\tthis.reachabilityCache.clear();\n\n\t\tconst targetStartIndices = starts ? starts.map((p) => p.y * nodeCols + p.x) : startNodes;\n\n\t\tfor (const startIdx of targetStartIndices) {\n\t\t\tconst nodeCols = grid.cols + 1;\n\t\t\tconst r = Math.floor(startIdx / nodeCols);\n\t\t\tconst c = startIdx % nodeCols;\n\t\t\tlet startHexMask = 0n;\n\t\t\tconst nodeType = grid.nodes[r][c].type;\n\t\t\tif (nodeType === NodeType.Hexagon || nodeType === NodeType.HexagonMain) {\n\t\t\t\tstartHexMask |= 1n << BigInt(hexIdMap.get(`n${c},${r}`)!);\n\t\t\t}\n\n\t\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snStart = this.getSymmetricalPointIndex(grid, startIdx);\n\t\t\t\tconst snR = Math.floor(snStart / nodeCols);\n\t\t\t\tconst snC = snStart % nodeCols;\n\t\t\t\tconst snNodeType = grid.nodes[snR][snC].type;\n\t\t\t\tif (snNodeType === NodeType.Hexagon || snNodeType === NodeType.HexagonSymmetry) {\n\t\t\t\t\tstartHexMask |= 1n << BigInt(hexIdMap.get(`n${snC},${snR}`)!);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet visitedMask = 1n << BigInt(startIdx);\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snStart = this.getSymmetricalPointIndex(grid, startIdx);\n\t\t\t\tif (snStart === startIdx) continue;\n\t\t\t\tvisitedMask |= 1n << BigInt(snStart);\n\t\t\t}\n\n\t\t\tthis.exploreSearchSpace(grid, startIdx, visitedMask, [startIdx], startHexMask, totalHexagons, adj, endNodes, isEndNode, fingerprints, stats, searchLimit, externalCells, hasCellMarks, hexIdMap);\n\t\t}\n\n\t\tif (stats.solutions === 0) return 0;\n\n\t\tlet constraintCount = hexagonEdges.size + hexagonNodes.size;\n\t\tconst constraintTypes = new Set<number>();\n\t\tif (hexagonEdges.size > 0) constraintTypes.add(999);\n\n\t\tlet tetrisCount = 0;\n\t\tlet rotatedTetrisCount = 0;\n\t\tlet triangleCount = 0;\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tconst cell = grid.cells[r][c];\n\t\t\t\tif (cell.type !== CellType.None) {\n\t\t\t\t\tconstraintCount++;\n\t\t\t\t\tconstraintTypes.add(cell.type);\n\t\t\t\t\tif (cell.type === CellType.Tetris) tetrisCount++;\n\t\t\t\t\telse if (cell.type === CellType.TetrisRotated) {\n\t\t\t\t\t\ttetrisCount++;\n\t\t\t\t\t\trotatedTetrisCount++;\n\t\t\t\t\t} else if (cell.type === CellType.Triangle) {\n\t\t\t\t\t\ttriangleCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst branchingFactor = stats.branchingPoints / (stats.totalNodesVisited || 1);\n\t\tconst searchComplexity = Math.log10(stats.totalNodesVisited + 1);\n\t\t// \u89E3\u306E\u6570\u304C\u591A\u3044\u307B\u3069\u96E3\u6613\u5EA6\u3092\u4E0B\u3052\u308B\u3002\u30B9\u30B1\u30FC\u30EB\u3092\u8ABF\u6574\n\t\tlet difficulty = (branchingFactor * 10 + searchComplexity * 1.5) / (Math.log2(stats.solutions + 1) * 0.5 + 1);\n\n\t\t// \u30A8\u30C3\u30B8\u306E\u516D\u89D2\u5F62\u304C\u591A\u3044\u307B\u3069\u7C21\u5358\u306B\u306A\u308B\uFF08\u30AC\u30A4\u30C9\u306B\u306A\u308B\u305F\u3081\uFF09\n\t\tdifficulty -= hexagonEdges.size * 0.05;\n\t\t// \u30CE\u30FC\u30C9\u306E\u516D\u89D2\u5F62\u306F\u96E3\u6613\u5EA6\u3092\u4E0A\u3052\u308B\uFF08\u901A\u904E\u304C\u5F37\u5236\u3055\u308C\u308B\u305F\u3081\uFF09\n\t\tdifficulty += hexagonNodes.size * 0.12;\n\n\t\tif (tetrisCount > 0) {\n\t\t\t// \u56DE\u8EE2\u4E0D\u53EF\u304C\u591A\u3044\u307B\u3069\u96E3\u3057\u304F\u3001\u56DE\u8EE2\u53EF\u80FD\u304C\u591A\u3044\u307B\u3069\u7C21\u5358\n\t\t\tdifficulty += (tetrisCount - rotatedTetrisCount) * 0.5;\n\t\t\tdifficulty += rotatedTetrisCount * 0.2;\n\t\t}\n\n\t\t// \u6E1B\u7B97\u30C6\u30C8\u30EA\u30B9\uFF08\u67A0\uFF09\u306E\u96E3\u6613\u5EA6\u8A55\u4FA1\n\t\tlet negTetrisCount = 0;\n\t\tlet rotatedNegTetrisCount = 0;\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tconst cell = grid.cells[r][c];\n\t\t\t\tif (cell.type === CellType.TetrisNegative) negTetrisCount++;\n\t\t\t\telse if (cell.type === CellType.TetrisNegativeRotated) {\n\t\t\t\t\tnegTetrisCount++;\n\t\t\t\t\trotatedNegTetrisCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (negTetrisCount > 0) {\n\t\t\tdifficulty += (negTetrisCount - rotatedNegTetrisCount) * 0.6; // \u6E1B\u7B97\u306F\u914D\u7F6E\u304C\u3088\u308A\u30B7\u30D3\u30A2\u306A\u305F\u3081\u5C11\u3057\u9AD8\u3081\u306B\u8A2D\u5B9A\n\t\t\tdifficulty += rotatedNegTetrisCount * 0.3;\n\t\t}\n\n\t\tif (triangleCount > 0) {\n\t\t\tdifficulty += triangleCount * 0.25;\n\t\t}\n\n\t\tconst cellCount = rows * cols;\n\t\tconst density = constraintCount / cellCount;\n\t\t// \u5BC6\u5EA6\u304C\u4F4E\u3059\u304E\u308B\u3068\u6025\u6FC0\u306B\u96E3\u6613\u5EA6\u304C\u4E0B\u304C\u308B\u3088\u3046\u306B\u8ABF\u6574\u3002\u3088\u308A\u53B3\u3057\u304F\u3002\n\t\tconst densityFactor = density < 0.25 ? Math.pow(density / 0.25, 4) : 1.0;\n\t\tconst typeFactor = constraintTypes.size <= 1 ? 0.5 : 1.0;\n\n\t\tdifficulty *= densityFactor * typeFactor;\n\t\t// \u76E4\u9762\u30B5\u30A4\u30BA\u306B\u3088\u308B\u88DC\u6B63\u3092\u7DE9\u3084\u304B\u306B\n\t\tconst sizeFactor = Math.log2(cellCount) / 5;\n\t\tdifficulty *= sizeFactor;\n\n\t\treturn Math.max(0.01, Math.min(1.0, difficulty / 4));\n\t}\n\n\t/**\n\t * \u63A2\u7D22\u7A7A\u9593\u3092\u8D70\u67FB\u3057\u3066\u7D71\u8A08\u60C5\u5831\u3092\u53CE\u96C6\u3059\u308B\n\t */\n\tprivate exploreSearchSpace(\n\t\tgrid: Grid,\n\t\tcurrIdx: number,\n\t\tvisitedMask: bigint,\n\t\tpath: number[],\n\t\thexMask: bigint,\n\t\ttotalHexagons: number,\n\t\tadj: { next: number; hexType: EdgeType; isBroken: boolean }[][],\n\t\tendNodes: number[],\n\t\tisEndNode: boolean[],\n\t\tfingerprints: Set<string>,\n\t\tstats: { totalNodesVisited: number; branchingPoints: number; solutions: number; maxDepth: number; backtracks: number },\n\t\tlimit: number,\n\t\texternalCells?: Set<string>,\n\t\thasCellMarks: boolean = true,\n\t\thexIdMap?: Map<string, number>,\n\t): void {\n\t\tstats.totalNodesVisited++;\n\t\tstats.maxDepth = Math.max(stats.maxDepth, path.length);\n\t\tif (stats.totalNodesVisited > limit) return;\n\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\n\t\tif (isEndNode[currIdx]) {\n\t\t\tlet setBits = 0;\n\t\t\tlet temp = hexMask;\n\t\t\twhile (temp > 0n) {\n\t\t\t\tif (temp & 1n) setBits++;\n\t\t\t\ttemp >>= 1n;\n\t\t\t}\n\n\t\t\tif (setBits === totalHexagons) {\n\t\t\t\tconst points = path.map((idx) => ({ x: idx % (grid.cols + 1), y: Math.floor(idx / (grid.cols + 1)) }));\n\t\t\t\tconst solutionPath = { points };\n\t\t\t\t// symmetry\u30E2\u30FC\u30C9\u306E\u969B\u3001\u3082\u3046\u4E00\u65B9\u3082EndNode\u306B\u3044\u308B\u5FC5\u8981\u304C\u3042\u308B\n\t\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\t\tconst snEnd = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\t\tconst nodeCols = grid.cols + 1;\n\t\t\t\t\tif (grid.nodes[Math.floor(snEnd / nodeCols)][snEnd % nodeCols].type !== NodeType.End) return;\n\t\t\t\t}\n\n\t\t\t\tconst symPathPoints = symmetry !== SymmetryType.None ? points.map((p) => this.getSymmetricalPoint(grid, p)) : [];\n\t\t\t\t// \u30BB\u30EB\u30DE\u30FC\u30AF\u304C\u306A\u3044\u5834\u5408\u306F\u3001\u3053\u306E\u6642\u70B9\u3067\u6709\u52B9\u306A\u89E3\u3068\u3057\u3066\u78BA\u5B9A\u3067\u304D\u308B\uFF08DFS\u306B\u3088\u308A\u30D1\u30B9\u306E\u6B63\u5F53\u6027\u3068\u5168\u516D\u89D2\u5F62\u901A\u904E\u306F\u4FDD\u8A3C\u6E08\u307F\uFF09\n\t\t\t\tif (!hasCellMarks) {\n\t\t\t\t\tconst fp = this.getFingerprint(grid, points, symPathPoints, undefined, externalCells);\n\t\t\t\t\tif (!fingerprints.has(fp)) {\n\t\t\t\t\t\tfingerprints.add(fp);\n\t\t\t\t\t\tstats.solutions++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// \u30BB\u30EB\u30DE\u30FC\u30AF\u304C\u3042\u308B\u5834\u5408\u306F\u8A73\u7D30\u306A\u691C\u8A3C\u3092\u884C\u3046\n\t\t\t\t\tconst result = this.validateFast(grid, points, symPathPoints, externalCells);\n\t\t\t\t\tif (result.isValid) {\n\t\t\t\t\t\tconst fp = this.getFingerprint(grid, points, symPathPoints, result.regions, externalCells);\n\t\t\t\t\t\tif (!fingerprints.has(fp)) {\n\t\t\t\t\t\t\tfingerprints.add(fp);\n\t\t\t\t\t\t\tstats.solutions++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.canReachEndOptimized(currIdx, visitedMask, adj, isEndNode)) {\n\t\t\tstats.backtracks++;\n\t\t\treturn;\n\t\t}\n\n\t\tconst validMoves = [];\n\t\tfor (const edge of adj[currIdx]) {\n\t\t\tif (edge.isBroken) continue;\n\t\t\tif (visitedMask & (1n << BigInt(edge.next))) continue;\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snCurr = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\n\t\t\t\t// \u5BFE\u79F0\u70B9\u3068\u306E\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\n\t\t\t\tif (edge.next === snNext) continue; // \u30CE\u30FC\u30C9\u885D\u7A81\n\t\t\t\tif (currIdx === snNext && edge.next === snCurr) continue; // \u30A8\u30C3\u30B8\u885D\u7A81\uFF08\u53CD\u5BFE\u5411\u304D\uFF09\n\t\t\t}\n\n\t\t\t// \u516D\u89D2\u5F62\u306E\u679D\u5208\u308A\n\t\t\tlet possible = true;\n\t\t\tfor (const otherEdge of adj[currIdx]) {\n\t\t\t\tconst isMandatoryForMain = otherEdge.hexType === EdgeType.Hexagon || otherEdge.hexType === EdgeType.HexagonMain;\n\t\t\t\tif (isMandatoryForMain) {\n\t\t\t\t\tconst isAlreadyOnPath = path.length >= 2 && otherEdge.next === path[path.length - 2];\n\t\t\t\t\tconst isNextMove = otherEdge.next === edge.next;\n\t\t\t\t\tif (!isAlreadyOnPath && !isNextMove) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!possible) continue;\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snCurr = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\t\t\t\tfor (const otherEdge of adj[snCurr]) {\n\t\t\t\t\tconst isMandatoryForSym = otherEdge.hexType === EdgeType.Hexagon || otherEdge.hexType === EdgeType.HexagonSymmetry;\n\t\t\t\t\tif (isMandatoryForSym) {\n\t\t\t\t\t\tconst snPrev = path.length >= 2 ? this.getSymmetricalPointIndex(grid, path[path.length - 2]) : -1;\n\t\t\t\t\t\tconst isAlreadyOnSymPath = otherEdge.next === snPrev;\n\t\t\t\t\t\tconst isSymNextMove = otherEdge.next === snNext;\n\t\t\t\t\t\tif (!isAlreadyOnSymPath && !isSymNextMove) {\n\t\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (possible) validMoves.push(edge);\n\t\t}\n\n\t\tif (validMoves.length > 1) stats.branchingPoints++;\n\n\t\t// \u5927\u304D\u306A\u76E4\u9762\u3067\u306F\u63A2\u7D22\u304C\u30EA\u30DF\u30C3\u30C8\u306B\u9054\u3057\u3084\u3059\u3044\u305F\u3081\u3001\u63A2\u7D22\u9806\u5E8F\u3092\u30E9\u30F3\u30C0\u30E0\u5316\u3057\u3066\n\t\t// \u5C11\u306A\u304F\u3068\u3082\u3044\u304F\u3064\u304B\u306E\u89E3\u3092\u898B\u3064\u3051\u3084\u3059\u304F\u3059\u308B\n\t\tif (grid.rows * grid.cols > 30) {\n\t\t\tfor (let i = validMoves.length - 1; i > 0; i--) {\n\t\t\t\tconst rnd = this.rng ? this.rng.next() : Math.random();\n\t\t\t\tconst j = Math.floor(rnd * (i + 1));\n\t\t\t\t[validMoves[i], validMoves[j]] = [validMoves[j], validMoves[i]];\n\t\t\t}\n\t\t}\n\n\t\tconst nodeCols = grid.cols + 1;\n\t\tfor (const move of validMoves) {\n\t\t\tlet nextHexMask = hexMask;\n\t\t\tconst r = Math.floor(move.next / nodeCols);\n\t\t\tconst c = move.next % nodeCols;\n\t\t\tconst nodeType = grid.nodes[r][c].type;\n\n\t\t\tif (nodeType === NodeType.Hexagon || nodeType === NodeType.HexagonMain) {\n\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`n${c},${r}`)!);\n\t\t\t}\n\n\t\t\t// \u30A8\u30C3\u30B8\u306E\u30C1\u30A7\u30C3\u30AF\n\t\t\tconst prevIdx = path[path.length - 1];\n\t\t\tconst pr = Math.floor(prevIdx / nodeCols);\n\t\t\tconst pc = prevIdx % nodeCols;\n\t\t\tif (pr === r) {\n\t\t\t\tconst ec = Math.min(pc, c);\n\t\t\t\tif (move.hexType === EdgeType.Hexagon || move.hexType === EdgeType.HexagonMain) {\n\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`eh${ec},${r}`)!);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst er = Math.min(pr, r);\n\t\t\t\tif (move.hexType === EdgeType.Hexagon || move.hexType === EdgeType.HexagonMain) {\n\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`ev${c},${er}`)!);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, move.next);\n\t\t\t\tconst snR = Math.floor(snNext / nodeCols);\n\t\t\t\tconst snC = snNext % nodeCols;\n\t\t\t\tconst snNodeType = grid.nodes[snR][snC].type;\n\t\t\t\tif (snNodeType === NodeType.Hexagon || snNodeType === NodeType.HexagonSymmetry) {\n\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`n${snC},${snR}`)!);\n\t\t\t\t}\n\n\t\t\t\tconst snPrev = this.getSymmetricalPointIndex(grid, prevIdx);\n\t\t\t\tconst spr = Math.floor(snPrev / nodeCols);\n\t\t\t\tconst spc = snPrev % nodeCols;\n\t\t\t\tif (spr === snR) {\n\t\t\t\t\tconst ec = Math.min(spc, snC);\n\t\t\t\t\tconst et = grid.hEdges[snR][ec].type;\n\t\t\t\t\tif (et === EdgeType.Hexagon || et === EdgeType.HexagonSymmetry) {\n\t\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`eh${ec},${snR}`)!);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst er = Math.min(spr, snR);\n\t\t\t\t\tconst et = grid.vEdges[er][snC].type;\n\t\t\t\t\tif (et === EdgeType.Hexagon || et === EdgeType.HexagonSymmetry) {\n\t\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`ev${snC},${er}`)!);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpath.push(move.next);\n\n\t\t\tlet nextVisitedMask = visitedMask | (1n << BigInt(move.next));\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, move.next);\n\t\t\t\tnextVisitedMask |= 1n << BigInt(snNext);\n\t\t\t}\n\n\t\t\tthis.exploreSearchSpace(grid, move.next, nextVisitedMask, path, nextHexMask, totalHexagons, adj, endNodes, isEndNode, fingerprints, stats, limit, externalCells, hasCellMarks, hexIdMap);\n\t\t\tpath.pop();\n\t\t\tif (stats.totalNodesVisited > limit) return;\n\t\t}\n\t}\n\n\t/**\n\t * \u6B63\u89E3\u6570\u3092\u30AB\u30A6\u30F3\u30C8\u3059\u308B\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\n\t * @param limit \u30AB\u30A6\u30F3\u30C8\u30EA\u30DF\u30C3\u30C8\n\t * @param starts \u63A2\u7D22\u3092\u958B\u59CB\u3059\u308B\u30B9\u30BF\u30FC\u30C8\u30CE\u30FC\u30C9\u306E\u30EA\u30B9\u30C8\uFF08\u7701\u7565\u6642\u306F\u5168\u30B9\u30BF\u30FC\u30C8\u30CE\u30FC\u30C9\uFF09\n\t */\n\tpublic countSolutions(grid: Grid, limit: number = 100, starts?: Point[]): number {\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst nodeCols = cols + 1;\n\t\tconst nodeCount = (rows + 1) * nodeCols;\n\t\tconst adj = Array.from({ length: nodeCount }, () => [] as { next: number; hexType: EdgeType; isBroken: boolean }[]);\n\t\tconst startNodes: number[] = [];\n\t\tconst endNodes: number[] = [];\n\t\tconst isEndNode = Array(nodeCount).fill(false);\n\t\tconst hexIdMap = new Map<string, number>();\n\t\tlet nextHexId = 0;\n\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tconst u = r * nodeCols + c;\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Start) startNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.End) {\n\t\t\t\t\tendNodes.push(u);\n\t\t\t\t\tisEndNode[u] = true;\n\t\t\t\t}\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Hexagon || grid.nodes[r][c].type === NodeType.HexagonMain || grid.nodes[r][c].type === NodeType.HexagonSymmetry) {\n\t\t\t\t\thexIdMap.set(`n${c},${r}`, nextHexId++);\n\t\t\t\t}\n\n\t\t\t\tif (c < cols) {\n\t\t\t\t\tconst v = u + 1;\n\t\t\t\t\tconst type = grid.hEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon || type === EdgeType.HexagonMain || type === EdgeType.HexagonSymmetry;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, hexType: type, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, hexType: type, isBroken });\n\t\t\t\t\tif (isHexagon) hexIdMap.set(`eh${c},${r}`, nextHexId++);\n\t\t\t\t}\n\t\t\t\tif (r < rows) {\n\t\t\t\t\tconst v = u + nodeCols;\n\t\t\t\t\tconst type = grid.vEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon || type === EdgeType.HexagonMain || type === EdgeType.HexagonSymmetry;\n\t\t\t\t\tconst isBroken = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, hexType: type, isBroken });\n\t\t\t\t\tadj[v].push({ next: u, hexType: type, isBroken });\n\t\t\t\t\tif (isHexagon) hexIdMap.set(`ev${c},${r}`, nextHexId++);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst fingerprints = new Set<string>();\n\t\tconst totalHexagons = nextHexId;\n\t\tconst externalCells = this.getExternalCells(grid);\n\n\t\t// \u30BB\u30EB\u30DE\u30FC\u30AF\uFF08\u56DB\u89D2\u3001\u661F\u3001\u30C6\u30C8\u30EA\u30B9\u3001\u6D88\u3057\u30B4\u30E0\uFF09\u304C\u3042\u308B\u304B\u4E8B\u524D\u306B\u30C1\u30A7\u30C3\u30AF\n\t\tlet hasCellMarks = false;\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tif (grid.cells[r][c].type !== CellType.None) {\n\t\t\t\t\thasCellMarks = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasCellMarks) break;\n\t\t}\n\n\t\tthis.tetrisCache.clear();\n\t\tthis.reachabilityCache.clear();\n\n\t\tconst targetStartIndices = starts ? starts.map((p) => p.y * nodeCols + p.x) : startNodes;\n\n\t\tfor (const startIdx of targetStartIndices) {\n\t\t\tconst nodeCols = grid.cols + 1;\n\t\t\tconst r = Math.floor(startIdx / nodeCols);\n\t\t\tconst c = startIdx % nodeCols;\n\t\t\tlet startHexMask = 0n;\n\t\t\tconst nodeType = grid.nodes[r][c].type;\n\t\t\tif (nodeType === NodeType.Hexagon || nodeType === NodeType.HexagonMain) {\n\t\t\t\tstartHexMask |= 1n << BigInt(hexIdMap.get(`n${c},${r}`)!);\n\t\t\t}\n\n\t\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snStart = this.getSymmetricalPointIndex(grid, startIdx);\n\t\t\t\tconst snR = Math.floor(snStart / nodeCols);\n\t\t\t\tconst snC = snStart % nodeCols;\n\t\t\t\tconst snNodeType = grid.nodes[snR][snC].type;\n\t\t\t\tif (snNodeType === NodeType.Hexagon || snNodeType === NodeType.HexagonSymmetry) {\n\t\t\t\t\tstartHexMask |= 1n << BigInt(hexIdMap.get(`n${snC},${snR}`)!);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet visitedMask = 1n << BigInt(startIdx);\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snStart = this.getSymmetricalPointIndex(grid, startIdx);\n\t\t\t\tif (snStart === startIdx) continue;\n\t\t\t\tvisitedMask |= 1n << BigInt(snStart);\n\t\t\t}\n\t\t\tthis.findPathsOptimized(grid, startIdx, visitedMask, [startIdx], startHexMask, totalHexagons, adj, endNodes, isEndNode, fingerprints, limit, externalCells, hasCellMarks, hexIdMap);\n\t\t}\n\t\treturn fingerprints.size;\n\t}\n\n\tprivate findPathsOptimized(grid: Grid, currIdx: number, visitedMask: bigint, path: number[], hexMask: bigint, totalHexagons: number, adj: { next: number; hexType: EdgeType; isBroken: boolean }[][], endNodes: number[], isEndNode: boolean[], fingerprints: Set<string>, limit: number, externalCells?: Set<string>, hasCellMarks: boolean = true, hexIdMap?: Map<string, number>): void {\n\t\tif (fingerprints.size >= limit) return;\n\t\tconst symmetry = grid.symmetry || SymmetryType.None;\n\n\t\tif (isEndNode[currIdx]) {\n\t\t\tlet setBits = 0;\n\t\t\tlet temp = hexMask;\n\t\t\twhile (temp > 0n) {\n\t\t\t\tif (temp & 1n) setBits++;\n\t\t\t\ttemp >>= 1n;\n\t\t\t}\n\t\t\tif (setBits === totalHexagons) {\n\t\t\t\tconst points = path.map((idx) => ({ x: idx % (grid.cols + 1), y: Math.floor(idx / (grid.cols + 1)) }));\n\t\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\t\tconst snEnd = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\t\tconst nodeCols = grid.cols + 1;\n\t\t\t\t\tif (grid.nodes[Math.floor(snEnd / nodeCols)][snEnd % nodeCols].type !== NodeType.End) return;\n\t\t\t\t}\n\n\t\t\t\tconst symPathPoints = symmetry !== SymmetryType.None ? points.map((p) => this.getSymmetricalPoint(grid, p)) : [];\n\t\t\t\tif (!hasCellMarks) {\n\t\t\t\t\tfingerprints.add(this.getFingerprint(grid, points, symPathPoints, undefined, externalCells));\n\t\t\t\t} else {\n\t\t\t\t\tconst result = this.validateFast(grid, points, symPathPoints, externalCells);\n\t\t\t\t\tif (result.isValid) {\n\t\t\t\t\t\tfingerprints.add(this.getFingerprint(grid, points, symPathPoints, result.regions, externalCells));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (!this.canReachEndOptimized(currIdx, visitedMask, adj, isEndNode)) return;\n\t\tfor (const edge of adj[currIdx]) {\n\t\t\tif (edge.isBroken) continue;\n\t\t\tif (visitedMask & (1n << BigInt(edge.next))) continue;\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snCurr = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\t\t\t\tif (edge.next === snNext) continue;\n\t\t\t\tif (currIdx === snNext && edge.next === snCurr) continue;\n\t\t\t}\n\n\t\t\tlet possible = true;\n\t\t\tfor (const otherEdge of adj[currIdx]) {\n\t\t\t\tconst isMandatoryForMain = otherEdge.hexType === EdgeType.Hexagon || otherEdge.hexType === EdgeType.HexagonMain;\n\t\t\t\tif (isMandatoryForMain) {\n\t\t\t\t\tconst isAlreadyOnPath = path.length >= 2 && otherEdge.next === path[path.length - 2];\n\t\t\t\t\tconst isNextMove = otherEdge.next === edge.next;\n\t\t\t\t\tif (!isAlreadyOnPath && !isNextMove) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!possible) continue;\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snCurr = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\t\t\t\tfor (const otherEdge of adj[snCurr]) {\n\t\t\t\t\tconst isMandatoryForSym = otherEdge.hexType === EdgeType.Hexagon || otherEdge.hexType === EdgeType.HexagonSymmetry;\n\t\t\t\t\tif (isMandatoryForSym) {\n\t\t\t\t\t\tconst snPrev = path.length >= 2 ? this.getSymmetricalPointIndex(grid, path[path.length - 2]) : -1;\n\t\t\t\t\t\tconst isAlreadyOnSymPath = otherEdge.next === snPrev;\n\t\t\t\t\t\tconst isSymNextMove = otherEdge.next === snNext;\n\t\t\t\t\t\tif (!isAlreadyOnSymPath && !isSymNextMove) {\n\t\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!possible) continue;\n\n\t\t\tconst nodeCols = grid.cols + 1;\n\t\t\tlet nextHexMask = hexMask;\n\t\t\tconst r = Math.floor(edge.next / nodeCols);\n\t\t\tconst c = edge.next % nodeCols;\n\t\t\tconst nodeType = grid.nodes[r][c].type;\n\n\t\t\tif (nodeType === NodeType.Hexagon || nodeType === NodeType.HexagonMain) {\n\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`n${c},${r}`)!);\n\t\t\t}\n\n\t\t\t// \u30A8\u30C3\u30B8\u306E\u30C1\u30A7\u30C3\u30AF\n\t\t\tconst pr = Math.floor(currIdx / nodeCols);\n\t\t\tconst pc = currIdx % nodeCols;\n\t\t\tif (pr === r) {\n\t\t\t\tconst ec = Math.min(pc, c);\n\t\t\t\tif (edge.hexType === EdgeType.Hexagon || edge.hexType === EdgeType.HexagonMain) {\n\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`eh${ec},${r}`)!);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst er = Math.min(pr, r);\n\t\t\t\tif (edge.hexType === EdgeType.Hexagon || edge.hexType === EdgeType.HexagonMain) {\n\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`ev${c},${er}`)!);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\t\t\t\tconst snR = Math.floor(snNext / nodeCols);\n\t\t\t\tconst snC = snNext % nodeCols;\n\t\t\t\tconst snNodeType = grid.nodes[snR][snC].type;\n\t\t\t\tif (snNodeType === NodeType.Hexagon || snNodeType === NodeType.HexagonSymmetry) {\n\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`n${snC},${snR}`)!);\n\t\t\t\t}\n\n\t\t\t\tconst snCurr = this.getSymmetricalPointIndex(grid, currIdx);\n\t\t\t\tconst spr = Math.floor(snCurr / nodeCols);\n\t\t\t\tconst spc = snCurr % nodeCols;\n\t\t\t\tif (spr === snR) {\n\t\t\t\t\tconst ec = Math.min(spc, snC);\n\t\t\t\t\tconst et = grid.hEdges[snR][ec].type;\n\t\t\t\t\tif (et === EdgeType.Hexagon || et === EdgeType.HexagonSymmetry) {\n\t\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`eh${ec},${snR}`)!);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst er = Math.min(spr, snR);\n\t\t\t\t\tconst et = grid.vEdges[er][snC].type;\n\t\t\t\t\tif (et === EdgeType.Hexagon || et === EdgeType.HexagonSymmetry) {\n\t\t\t\t\t\tnextHexMask |= 1n << BigInt(hexIdMap!.get(`ev${snC},${er}`)!);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpath.push(edge.next);\n\n\t\t\tlet nextVisitedMask = visitedMask | (1n << BigInt(edge.next));\n\t\t\tif (symmetry !== SymmetryType.None) {\n\t\t\t\tconst snNext = this.getSymmetricalPointIndex(grid, edge.next);\n\t\t\t\tnextVisitedMask |= 1n << BigInt(snNext);\n\t\t\t}\n\n\t\t\tthis.findPathsOptimized(grid, edge.next, nextVisitedMask, path, nextHexMask, totalHexagons, adj, endNodes, isEndNode, fingerprints, limit, externalCells, hasCellMarks, hexIdMap);\n\t\t\tpath.pop();\n\t\t\tif (fingerprints.size >= limit) return;\n\t\t}\n\t}\n\n\t/**\n\t * \u7D42\u7AEF\u307E\u3067\u5230\u9054\u53EF\u80FD\u304B\u30D3\u30C3\u30C8\u30DE\u30B9\u30AFBFS\u3067\u9AD8\u901F\u306B\u78BA\u8A8D\u3059\u308B\n\t */\n\tprivate canReachEndOptimized(curr: number, visitedMask: bigint, adj: { next: number; isBroken: boolean }[][], isEndNode: boolean[]): boolean {\n\t\tconst cacheKey = `${curr}:${visitedMask.toString()}`;\n\t\tconst cached = this.reachabilityCache.get(cacheKey);\n\t\tif (cached !== undefined) return cached;\n\t\tlet queue = [curr];\n\t\tlet localVisited = visitedMask;\n\t\tlet head = 0;\n\t\twhile (head < queue.length) {\n\t\t\tconst u = queue[head++];\n\t\t\tif (isEndNode[u]) {\n\t\t\t\tthis.reachabilityCache.set(cacheKey, true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (const edge of adj[u])\n\t\t\t\tif (!edge.isBroken && !(localVisited & (1n << BigInt(edge.next)))) {\n\t\t\t\t\tlocalVisited |= 1n << BigInt(edge.next);\n\t\t\t\t\tqueue.push(edge.next);\n\t\t\t\t}\n\t\t}\n\t\tthis.reachabilityCache.set(cacheKey, false);\n\t\treturn false;\n\t}\n\n\t/**\n\t * \u30D1\u30B9\u306E\u8AD6\u7406\u7684\u306A\u6307\u7D0B\u3092\u53D6\u5F97\u3059\u308B\uFF08\u533A\u753B\u5206\u3051\u306B\u57FA\u3065\u304D\u3001\u540C\u4E00\u89E3\u3092\u6392\u9664\u3059\u308B\u305F\u3081\uFF09\n\t */\n\tprivate getFingerprint(grid: Grid, path: Point[], symPath: Point[], precalculatedRegions?: Point[][], externalCells?: Set<string>): string {\n\t\tconst regions = precalculatedRegions || this.calculateRegions(grid, path, symPath, externalCells);\n\t\tconst regionFingerprints = regions\n\t\t\t.map((region) => {\n\t\t\t\tlet regionStr = \"\";\n\t\t\t\tconst marks = [];\n\t\t\t\tfor (const p of region) {\n\t\t\t\t\tconst c = grid.cells[p.y][p.x];\n\t\t\t\t\tif (c.type !== CellType.None) {\n\t\t\t\t\t\tmarks.push((c.type << 8) | c.color);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmarks.sort((a, b) => a - b);\n\t\t\t\tfor (const m of marks) regionStr += m.toString(36) + \",\";\n\t\t\t\treturn regionStr;\n\t\t\t})\n\t\t\t.sort();\n\n\t\tlet finalFp = \"\";\n\t\tfor (const rf of regionFingerprints) {\n\t\t\tif (rf.length > 0) finalFp += rf + \"|\";\n\t\t}\n\t\treturn finalFp || \"empty\";\n\t}\n}\n", "import { Grid } from \"./grid\";\r\nimport { IRng, createRng } from \"./rng\";\r\nimport { CellType, Color, type EdgeConstraint, EdgeType, type GenerationOptions, NodeType, type Point, RngType, SymmetryType } from \"./types\";\r\nimport { PuzzleValidator } from \"./validator\";\r\n\r\ninterface TiledPiece {\r\n\tshape: number[][];\r\n\tdisplayShape: number[][];\r\n\tisRotated: boolean;\r\n\tisNegative?: boolean;\r\n}\r\n\r\n/**\r\n * \u30D1\u30BA\u30EB\u3092\u81EA\u52D5\u751F\u6210\u3059\u308B\u30AF\u30E9\u30B9\r\n */\r\nexport class PuzzleGenerator {\r\n\tprivate isWorker: boolean;\r\n\tprivate TETRIS_SHAPES_WITH_ROTATIONS: number[][][][] = [];\r\n\tprivate rng: IRng | null = null;\r\n\r\n\tconstructor() {\r\n\t\tthis.isWorker = typeof self !== \"undefined\" && \"postMessage\" in self && !(\"document\" in self);\r\n\t\t// \u30C6\u30C8\u30EA\u30B9\u30D4\u30FC\u30B9\u306E\u5168\u56DE\u8EE2\u30D1\u30BF\u30FC\u30F3\u3092\u4E8B\u524D\u306B\u8A08\u7B97\u3057\u3066\u304A\u304F\r\n\t\tfor (const shape of this.TETRIS_SHAPES) {\r\n\t\t\tthis.TETRIS_SHAPES_WITH_ROTATIONS.push(this.getAllRotations(shape));\r\n\t\t}\r\n\t}\r\n\r\n\tprivate stringToSeed(seedStr: string): bigint {\r\n\t\ttry {\r\n\t\t\tif (/^[0-9a-fA-F]+$/.test(seedStr)) {\r\n\t\t\t\treturn BigInt(\"0x\" + seedStr);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\t// ignore\r\n\t\t}\r\n\t\t// \u6587\u5B57\u30B3\u30FC\u30C9\u5909\u63DB\r\n\t\tlet seed = 0n;\r\n\t\tfor (let i = 0; i < seedStr.length; i++) {\r\n\t\t\tseed = (seed << 5n) - seed + BigInt(seedStr.charCodeAt(i));\r\n\t\t}\r\n\t\treturn seed;\r\n\t}\r\n\r\n\t/**\r\n\t * \u30D1\u30BA\u30EB\u3092\u751F\u6210\u3059\u308B\r\n\t * @param rows \u884C\u6570\r\n\t * @param cols \u5217\u6570\r\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\r\n\t * @returns \u751F\u6210\u3055\u308C\u305F\u30B0\u30EA\u30C3\u30C9\r\n\t */\r\n\tpublic generate(rows: number, cols: number, options: GenerationOptions = {}): Grid {\r\n\t\tconst rngType = options.rngType ?? RngType.Mulberry32;\r\n\t\tlet currentSeedStr = options.seed;\r\n\t\tif (!currentSeedStr) {\r\n\t\t\tcurrentSeedStr = Math.floor(Math.random() * 0xffffffff).toString(16);\r\n\t\t}\r\n\t\tconst initialSeedStr = currentSeedStr;\r\n\t\tlet currentSeed = this.stringToSeed(currentSeedStr);\r\n\r\n\t\tconst targetDifficulty = options.difficulty ?? 0.5;\r\n\t\tconst validator = new PuzzleValidator();\r\n\t\tlet bestGrid: Grid | null = null;\r\n\t\tlet bestScore = -1;\r\n\r\n\t\t// \u8A66\u884C\u56DE\u6570\u306E\u8A2D\u5B9A\r\n\t\t// Worker\u6642\u306F\u3001\u30E1\u30A4\u30F3\u30B9\u30EC\u30C3\u30C9\u3092\u6B62\u3081\u306A\u3044\u305F\u3081\u3001\u3088\u308A\u591A\u304F\u306E\u8A66\u884C\u3092\u9AD8\u901F\u306B\u884C\u3046\r\n\t\t// \u5C0F\u3055\u306A\u76E4\u9762\u3084\u5236\u7D04\u304C\u591A\u3044\u5834\u5408\u306F\u5931\u6557\u3057\u3084\u3059\u3044\u305F\u3081\u3001\u8A66\u884C\u56DE\u6570\u3092\u8ABF\u6574\r\n\t\tconst isSmall = rows * cols <= 16;\r\n\t\tconst maxAttempts = this.isWorker ? (rows * cols > 30 ? 120 : isSmall ? 250 : 150) : rows * cols > 30 ? 80 : isSmall ? 200 : 100;\r\n\t\tconst markAttemptsPerPath = this.isWorker ? 8 : isSmall ? 12 : 6;\r\n\r\n\t\tconst symmetry = options.symmetry || SymmetryType.None;\r\n\r\n\t\t// \u30B9\u30BF\u30FC\u30C8\u5730\u70B9\u306E\u8A2D\u5B9A\r\n\t\tlet starts = options.starts ? [...options.starts] : [{ x: 0, y: rows }];\r\n\t\t// \u5BFE\u79F0\u30E2\u30FC\u30C9\u306E\u5834\u5408\u306F\u5BFE\u79F0\u70B9\u3082\u30B9\u30BF\u30FC\u30C8\u5730\u70B9\u306B\u542B\u3081\u308B\r\n\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\tconst symStarts: Point[] = [];\r\n\t\t\tfor (const s of starts) {\r\n\t\t\t\tconst ss = this.getSymmetricalPoint({ rows, cols } as any, s, symmetry);\r\n\t\t\t\tif (!starts.some((p) => p.x === ss.x && p.y === ss.y)) symStarts.push(ss);\r\n\t\t\t}\r\n\t\t\tstarts.push(...symStarts);\r\n\t\t}\r\n\r\n\t\t// \u30B4\u30FC\u30EB\u5730\u70B9\u306E\u8A2D\u5B9A\r\n\t\tlet ends = options.ends ? [...options.ends] : [];\r\n\t\tif (ends.length === 0) {\r\n\t\t\tif (symmetry === SymmetryType.Horizontal) {\r\n\t\t\t\tends = [{ x: 0, y: 0 }];\r\n\t\t\t} else if (symmetry === SymmetryType.Vertical) {\r\n\t\t\t\tends = [{ x: cols, y: rows }];\r\n\t\t\t} else if (symmetry === SymmetryType.Rotational) {\r\n\t\t\t\tends = [{ x: cols, y: rows }];\r\n\t\t\t} else {\r\n\t\t\t\tends = [{ x: cols, y: 0 }];\r\n\t\t\t}\r\n\t\t}\r\n\t\t// \u5BFE\u79F0\u30E2\u30FC\u30C9\u306E\u5834\u5408\u306F\u5BFE\u79F0\u70B9\u3082\u30B4\u30FC\u30EB\u5730\u70B9\u306B\u542B\u3081\u308B\r\n\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\tconst symEnds: Point[] = [];\r\n\t\t\tfor (const e of ends) {\r\n\t\t\t\tconst se = this.getSymmetricalPoint({ rows, cols } as any, e, symmetry);\r\n\t\t\t\tif (!ends.some((p) => p.x === se.x && p.y === se.y)) symEnds.push(se);\r\n\t\t\t}\r\n\t\t\tends.push(...symEnds);\r\n\t\t}\r\n\r\n\t\tlet currentPath: Point[] | null = null;\r\n\t\tlet precalculatedRegions: Point[][] | null = null;\r\n\t\tlet precalculatedBoundaryEdges: { type: \"h\" | \"v\"; r: number; c: number }[][] | null = null;\r\n\r\n\t\tfor (let attempt = 0; attempt < maxAttempts; attempt++) {\r\n\t\t\tconst nextSeed = (currentSeed ^ 0x5deece66dn) + 0xbn;\r\n\t\t\tthis.rng = createRng(rngType, currentSeed ^ 0x5deece66dn);\r\n\t\t\tvalidator.setRng(this.rng);\r\n\t\t\t// \u4E00\u5B9A\u56DE\u6570\u3054\u3068\u306B\u65B0\u3057\u3044\u30D1\u30B9\u3092\u751F\u6210\u3059\u308B\r\n\t\t\tif (attempt % markAttemptsPerPath === 0) {\r\n\t\t\t\tcurrentPath = this.generateRandomPath(new Grid(rows, cols), starts, ends, options.pathLength, symmetry);\r\n\r\n\t\t\t\t// \u30D1\u30B9\u304C\u6C7A\u307E\u3063\u305F\u6642\u70B9\u3067\u3001\u533A\u753B\u3068\u5883\u754C\u30A8\u30C3\u30B8\u3092\u8A08\u7B97\u3057\u3066\u304A\u304F\uFF08\u30DE\u30FC\u30AF\u751F\u6210\u3067\u6D41\u7528\uFF09\r\n\t\t\t\tconst tempGrid = new Grid(rows, cols);\r\n\t\t\t\tconst symPath = symmetry !== SymmetryType.None ? currentPath.map((p) => this.getSymmetricalPoint(tempGrid, p, symmetry)) : [];\r\n\t\t\t\tprecalculatedRegions = this.calculateRegions(tempGrid, currentPath, symPath);\r\n\t\t\t\tprecalculatedBoundaryEdges = precalculatedRegions.map((region) => this.getRegionBoundaryEdges(tempGrid, region, currentPath!, symPath));\r\n\t\t\t}\r\n\r\n\t\t\tconst grid = this.generateFromPath(rows, cols, currentPath!, options, starts, ends, precalculatedRegions!, precalculatedBoundaryEdges!);\r\n\r\n\t\t\t// \u610F\u56F3\u3057\u305F\u30D1\u30B9\u3067\u30AF\u30EA\u30A2\u53EF\u80FD\u304B\u691C\u8A3C\r\n\t\t\tconst validation = validator.validate(grid, { points: currentPath! });\r\n\t\t\tif (!validation.isValid) {\r\n\t\t\t\tcurrentSeed = nextSeed;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// \u4ED6\u306E\u30B9\u30BF\u30FC\u30C8\u5730\u70B9\u304B\u3089\u306E\u89E3\u3092\u30C1\u30A7\u30C3\u30AF\r\n\t\t\tconst chosenStart = currentPath![0];\r\n\t\t\tconst validStarts = [chosenStart];\r\n\t\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\t\tconst ss = this.getSymmetricalPoint(grid, chosenStart, symmetry);\r\n\t\t\t\tif (ss.x !== chosenStart.x || ss.y !== chosenStart.y) validStarts.push(ss);\r\n\t\t\t}\r\n\t\t\tconst otherStarts = starts.filter((s) => !validStarts.some((v) => v.x === s.x && v.y === s.y));\r\n\t\t\tif (otherStarts.length > 0) {\r\n\t\t\t\t// \u4ED6\u306E\u30B9\u30BF\u30FC\u30C8\u304B\u3089\u7C21\u5358\u306B\u89E3\u3051\u3066\u3057\u307E\u3046\u5834\u5408\u306F\u30EA\u30C8\u30E9\u30A4\r\n\t\t\t\tconst otherSolutions = validator.countSolutions(grid, 10, otherStarts);\r\n\t\t\t\tif (otherSolutions > 2) {\r\n\t\t\t\t\tcurrentSeed = nextSeed;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// \u5FC5\u9808\u5236\u7D04\u304C\u542B\u307E\u308C\u3066\u3044\u308B\u304B\u78BA\u8A8D\r\n\t\t\tif (!this.checkAllRequestedConstraintsPresent(grid, options)) {\r\n\t\t\t\tcurrentSeed = nextSeed;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// \u96E3\u6613\u5EA6\u306E\u7B97\u51FA\r\n\t\t\tconst difficulty = validator.calculateDifficulty(grid);\r\n\t\t\tif (difficulty === 0) {\r\n\t\t\t\tcurrentSeed = nextSeed;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tconst diffFromTarget = Math.abs(difficulty - targetDifficulty);\r\n\t\t\tif (bestGrid === null || diffFromTarget < Math.abs(bestScore - targetDifficulty)) {\r\n\t\t\t\tbestScore = difficulty;\r\n\t\t\t\tbestGrid = grid;\r\n\t\t\t\tbestGrid.seed = initialSeedStr;\r\n\t\t\t}\r\n\r\n\t\t\t// \u30BF\u30FC\u30B2\u30C3\u30C8\u306B\u8FD1\u3044\u5834\u5408\u306F\u65E9\u671F\u7D42\u4E86\r\n\t\t\tif (targetDifficulty > 0.8 && difficulty > 0.8) {\r\n\t\t\t\tbestGrid.seed = initialSeedStr;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (diffFromTarget < 0.01) {\r\n\t\t\t\tbestGrid.seed = initialSeedStr;\r\n\t\t\t\tbreak; // \u3088\u308A\u53B3\u3057\u304F\u65E9\u671F\u7D42\u4E86\u5224\u5B9A\r\n\t\t\t}\r\n\r\n\t\t\t// \u6B21\u306E\u8A66\u884C\u3078\u5411\u3051\u3066\u30B7\u30FC\u30C9\u3092\u66F4\u65B0\r\n\t\t\tcurrentSeed = nextSeed;\r\n\t\t}\r\n\r\n\t\t// \u898B\u3064\u304B\u3089\u306A\u304B\u3063\u305F\u5834\u5408\u306F\u6700\u5F8C\u306B\u751F\u6210\u306B\u6210\u529F\u3057\u305F\u3082\u306E\u3092\u8FD4\u3059\r\n\t\tif (!bestGrid) {\r\n\t\t\t// \u6700\u4F4E1\u56DE\u306F\u6210\u529F\u3059\u308B\u307E\u3067\u30EB\u30FC\u30D7\uFF08\u901A\u5E38\u306F\u6570\u56DE\u3067\u7D42\u308F\u308B\uFF09\r\n\t\t\tfor (let i = 0; i < 50; i++) {\r\n\t\t\t\tthis.rng = createRng(rngType, currentSeed);\r\n\t\t\t\tvalidator.setRng(this.rng);\r\n\t\t\t\tconst path = this.generateRandomPath(new Grid(rows, cols), starts, ends, options.pathLength, symmetry);\r\n\t\t\t\tconst grid = this.generateFromPath(rows, cols, path, options, starts, ends);\r\n\t\t\t\tif (validator.validate(grid, { points: path }).isValid) {\r\n\t\t\t\t\tgrid.seed = initialSeedStr;\r\n\t\t\t\t\treturn grid;\r\n\t\t\t\t}\r\n\t\t\t\tcurrentSeed = (currentSeed ^ 0x5deece66dn) + 0xbn;\r\n\t\t\t}\r\n\t\t\t// \u305D\u308C\u3067\u3082\u30C0\u30E1\u306A\u5834\u5408\u306F\u305D\u308C\u3063\u307D\u3044\u76E4\u9762\u3092\u8FD4\u3059\r\n\t\t\tthis.rng = createRng(rngType, currentSeed);\r\n\t\t\tvalidator.setRng(this.rng);\r\n\t\t\tconst path = this.generateRandomPath(new Grid(rows, cols), starts, ends, options.pathLength, symmetry);\r\n\t\t\tconst grid = this.generateFromPath(rows, cols, path, options, starts, ends);\r\n\t\t\tgrid.seed = initialSeedStr;\r\n\t\t\treturn grid;\r\n\t\t}\r\n\t\treturn bestGrid;\r\n\t}\r\n\r\n\t/**\r\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u30D1\u30BA\u30EB\u3092\u69CB\u7BC9\u3059\u308B\r\n\t * @param rows \u884C\u6570\r\n\t * @param cols \u5217\u6570\r\n\t * @param solutionPath \u89E3\u7B54\u30D1\u30B9\r\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\r\n\t * @param starts \u5168\u3066\u306E\u30B9\u30BF\u30FC\u30C8\u5730\u70B9\r\n\t * @param ends \u5168\u3066\u306E\u30B4\u30FC\u30EB\u5730\u70B9\r\n\t * @param precalculatedRegions \u4E8B\u524D\u8A08\u7B97\u3055\u308C\u305F\u533A\u753B\r\n\t * @param precalculatedBoundaryEdges \u4E8B\u524D\u8A08\u7B97\u3055\u308C\u305F\u5883\u754C\u30A8\u30C3\u30B8\r\n\t * @returns \u69CB\u7BC9\u3055\u308C\u305F\u30B0\u30EA\u30C3\u30C9\r\n\t */\r\n\tprivate generateFromPath(rows: number, cols: number, solutionPath: Point[], options: GenerationOptions, starts: Point[], ends: Point[], precalculatedRegions?: Point[][], precalculatedBoundaryEdges?: { type: \"h\" | \"v\"; r: number; c: number }[][]): Grid {\r\n\t\tconst grid = new Grid(rows, cols);\r\n\t\tconst symmetry = options.symmetry || SymmetryType.None;\r\n\t\tgrid.symmetry = symmetry;\r\n\r\n\t\tfor (const s of starts) {\r\n\t\t\tgrid.nodes[s.y][s.x].type = NodeType.Start;\r\n\t\t}\r\n\t\tfor (const e of ends) {\r\n\t\t\tgrid.nodes[e.y][e.x].type = NodeType.End;\r\n\t\t}\r\n\r\n\t\t// \u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u5236\u7D04\uFF08\u8A18\u53F7\uFF09\u3092\u914D\u7F6E\r\n\t\tconst symPath = symmetry !== SymmetryType.None ? solutionPath.map((p) => this.getSymmetricalPoint(grid, p, symmetry)) : [];\r\n\t\tthis.applyConstraintsBasedOnPath(grid, solutionPath, options, symPath, precalculatedRegions, precalculatedBoundaryEdges);\r\n\r\n\t\t// \u65AD\u7DDA\u30A8\u30C3\u30B8\u306E\u9069\u7528\r\n\t\tif (options.useBrokenEdges) {\r\n\t\t\tthis.applyBrokenEdges(grid, solutionPath, options);\r\n\t\t}\r\n\r\n\t\t// \u4E0D\u8981\u306A\u30A8\u30C3\u30B8\u306E\u524A\u9664\uFF08Absent\u5316\uFF09\u3068\u30AF\u30EA\u30FC\u30CB\u30F3\u30B0\r\n\t\tthis.cleanGrid(grid);\r\n\t\treturn grid;\r\n\t}\r\n\r\n\t/**\r\n\t * \u30E9\u30F3\u30C0\u30E0\u306A\u6B63\u89E3\u30D1\u30B9\u3092\u751F\u6210\u3059\u308B\r\n\t * @param targetLengthFactor 0.0 (\u6700\u77ED) - 1.0 (\u6700\u9577)\r\n\t */\r\n\tprivate generateRandomPath(grid: Grid, starts: Point[], ends: Point[], targetLengthFactor?: number, symmetry: SymmetryType = SymmetryType.None): Point[] {\r\n\t\tif (targetLengthFactor === undefined) {\r\n\t\t\treturn this.generateSingleRandomPath(grid, starts, ends, undefined, symmetry);\r\n\t\t}\r\n\r\n\t\t// \u6307\u5B9A\u3055\u308C\u305F\u9577\u3055\u306B\u8FD1\u3044\u30D1\u30B9\u3092\u63A2\u3059\r\n\t\tconst minLen = grid.rows + grid.cols;\r\n\t\tconst maxLen = (grid.rows + 1) * (grid.cols + 1) - 1;\r\n\t\tconst targetLen = minLen + targetLengthFactor * (maxLen - minLen);\r\n\r\n\t\tlet bestPath: Point[] = [];\r\n\t\tlet bestDiff = Infinity;\r\n\r\n\t\tconst attempts = grid.rows * grid.cols > 30 ? 30 : 50;\r\n\t\tfor (let i = 0; i < attempts; i++) {\r\n\t\t\t// \u6700\u521D\u306E\u65B9\u306E\u8A66\u884C\u306F\u30D0\u30A4\u30A2\u30B9\u3092\u5F37\u3081\u306B\u304B\u3051\u308B\r\n\t\t\tconst currentPath = this.generateSingleRandomPath(grid, starts, ends, targetLengthFactor, symmetry);\r\n\t\t\tif (currentPath.length === 0) continue;\r\n\r\n\t\t\tconst currentLen = currentPath.length - 1;\r\n\t\t\tconst diff = Math.abs(currentLen - targetLen);\r\n\r\n\t\t\tif (diff < bestDiff) {\r\n\t\t\t\tbestDiff = diff;\r\n\t\t\t\tbestPath = currentPath;\r\n\t\t\t}\r\n\r\n\t\t\t// \u5341\u5206\u306B\u8FD1\u3044\u30D1\u30B9\u304C\u898B\u3064\u304B\u3063\u305F\u3089\u7D42\u4E86\r\n\t\t\tif (bestDiff <= 2) break;\r\n\t\t}\r\n\r\n\t\treturn bestPath;\r\n\t}\r\n\r\n\t/**\r\n\t * 1\u672C\u306E\u30E9\u30F3\u30C0\u30E0\u30D1\u30B9\u3092\u751F\u6210\u3059\u308B\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t * @param starts \u958B\u59CB\u5019\u88DC\u70B9\u30EA\u30B9\u30C8\r\n\t * @param ends \u7D42\u4E86\u5019\u88DC\u70B9\u30EA\u30B9\u30C8\r\n\t * @param biasFactor \u9577\u3055\u306E\u30D0\u30A4\u30A2\u30B9\r\n\t * @param symmetry \u5BFE\u79F0\u6027\r\n\t * @returns \u751F\u6210\u3055\u308C\u305F\u30D1\u30B9\r\n\t */\r\n\tprivate generateSingleRandomPath(grid: Grid, starts: Point[], ends: Point[], biasFactor?: number, symmetry: SymmetryType = SymmetryType.None): Point[] {\r\n\t\tconst pointCount = (grid.rows + 1) * (grid.cols + 1);\r\n\t\tconst visited = new Array<boolean>(pointCount).fill(false);\r\n\t\tconst path: Point[] = [];\r\n\t\tlet nodesVisited = 0;\r\n\t\t// \u63A2\u7D22\u30EA\u30DF\u30C3\u30C8\u3092\u5927\u5E45\u306B\u5F15\u304D\u4E0A\u3052\u3001\u7279\u306B\u5BFE\u79F0\u30D1\u30BA\u30EB\u3067\u306E\u5230\u9054\u53EF\u80FD\u6027\u3092\u9AD8\u3081\u308B\r\n\t\tconst limit = grid.rows * grid.cols * 200;\r\n\r\n\t\tconst start = starts[Math.floor(this.rng!.next() * starts.length)];\r\n\t\tconst endLookup = new Array<boolean>(pointCount).fill(false);\r\n\t\tfor (const end of ends) endLookup[this.toPointIndex(grid, end.x, end.y)] = true;\r\n\r\n\t\tconst findPath = (current: Point): boolean => {\r\n\t\t\tnodesVisited++;\r\n\t\t\tif (nodesVisited > limit) return false;\r\n\r\n\t\t\tconst currentIndex = this.toPointIndex(grid, current.x, current.y);\r\n\t\t\tvisited[currentIndex] = true;\r\n\t\t\tconst snCurrent = this.getSymmetricalPoint(grid, current, symmetry);\r\n\t\t\tconst snCurrentIndex = this.toPointIndex(grid, snCurrent.x, snCurrent.y);\r\n\t\t\tvisited[snCurrentIndex] = true;\r\n\r\n\t\t\tpath.push(current);\r\n\r\n\t\t\tif (endLookup[currentIndex]) {\r\n\t\t\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\t\t\tif (endLookup[snCurrentIndex]) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet neighbors = this.getValidNeighbors(grid, current, visited);\r\n\r\n\t\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\t\tneighbors = neighbors.filter((n) => {\r\n\t\t\t\t\tconst sn = this.getSymmetricalPoint(grid, n, symmetry);\r\n\t\t\t\t\tif (sn.x < 0 || sn.x > grid.cols || sn.y < 0 || sn.y > grid.rows) return false;\r\n\t\t\t\t\tif (visited[this.toPointIndex(grid, sn.x, sn.y)]) return false;\r\n\t\t\t\t\t// \u30CE\u30FC\u30C9\u885D\u7A81\uFF08\u73FE\u5728\u306E\u79FB\u52D5\u5148\u304C\u81EA\u5206\u81EA\u8EAB\u306E\u5BFE\u79F0\u70B9\u3067\u3042\u308B\u5834\u5408\u3082NG\uFF09\r\n\t\t\t\t\tif (n.x === sn.x && n.y === sn.y) return false;\r\n\t\t\t\t\t// \u30A8\u30C3\u30B8\u885D\u7A81\r\n\t\t\t\t\tconst edgeKey = this.getEdgeKey(current, n);\r\n\t\t\t\t\tconst symEdgeKey = this.getEdgeKey(snCurrent, sn);\r\n\t\t\t\t\tif (edgeKey === symEdgeKey) return false;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tif (biasFactor !== undefined) {\r\n\t\t\t\tneighbors.sort((a, b) => {\r\n\t\t\t\t\tconst getMinDist = (p: Point) => Math.min(...ends.map((e) => Math.abs(p.x - e.x) + Math.abs(p.y - e.y)));\r\n\t\t\t\t\tconst da = getMinDist(a);\r\n\t\t\t\t\tconst db = getMinDist(b);\r\n\t\t\t\t\tconst score = (da - db) * (1 - biasFactor * 2);\r\n\t\t\t\t\treturn score + (this.rng!.next() - 0.5) * 1.5;\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tthis.shuffleArray(neighbors);\r\n\t\t\t}\r\n\r\n\t\t\tfor (const next of neighbors) {\r\n\t\t\t\tif (findPath(next)) return true;\r\n\t\t\t}\r\n\r\n\t\t\tpath.pop();\r\n\t\t\tvisited[currentIndex] = false;\r\n\t\t\tvisited[snCurrentIndex] = false;\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\tfindPath(start);\r\n\t\treturn path;\r\n\t}\r\n\r\n\tprivate toPointIndex(grid: Grid, x: number, y: number): number {\r\n\t\treturn y * (grid.cols + 1) + x;\r\n\t}\r\n\r\n\tprivate getValidNeighbors(grid: Grid, p: Point, visited?: boolean[]): Point[] {\r\n\t\tconst candidates: Point[] = [];\r\n\t\tconst directions = [\r\n\t\t\t{ x: 0, y: -1 },\r\n\t\t\t{ x: 1, y: 0 },\r\n\t\t\t{ x: 0, y: 1 },\r\n\t\t\t{ x: -1, y: 0 },\r\n\t\t];\r\n\t\tfor (const d of directions) {\r\n\t\t\tconst nx = p.x + d.x;\r\n\t\t\tconst ny = p.y + d.y;\r\n\t\t\tif (nx >= 0 && nx <= grid.cols && ny >= 0 && ny <= grid.rows) {\r\n\t\t\t\tif (!visited || !visited[this.toPointIndex(grid, nx, ny)]) candidates.push({ x: nx, y: ny });\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn candidates;\r\n\t}\r\n\r\n\t/**\r\n\t * \u89E3\u30D1\u30B9\u304C\u901A\u3063\u3066\u3044\u306A\u3044\u5834\u6240\u306B\u30E9\u30F3\u30C0\u30E0\u306B\u65AD\u7DDA\uFF08Broken/Absent\uFF09\u3092\u914D\u7F6E\u3059\u308B\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t * @param path \u89E3\u7B54\u30D1\u30B9\r\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\r\n\t */\r\n\tprivate applyBrokenEdges(grid: Grid, path: Point[], options: GenerationOptions) {\r\n\t\tconst complexity = options.complexity ?? 0.5;\r\n\t\tconst symmetry = options.symmetry ?? SymmetryType.None;\r\n\t\tconst pathEdges = new Set<string>();\r\n\r\n\t\t// \u30E1\u30A4\u30F3\u30D1\u30B9\u3068\u5BFE\u79F0\u30D1\u30B9\u306E\u4E21\u65B9\u306E\u30A8\u30C3\u30B8\u3092\u7981\u6B62\u30EA\u30B9\u30C8\u306B\u5165\u308C\u308B\r\n\t\tfor (let i = 0; i < path.length - 1; i++) {\r\n\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\r\n\t\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\t\tconst p1 = this.getSymmetricalPoint(grid, path[i], symmetry);\r\n\t\t\t\tconst p2 = this.getSymmetricalPoint(grid, path[i + 1], symmetry);\r\n\t\t\t\tpathEdges.add(this.getEdgeKey(p1, p2));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst unusedEdges: { type: \"h\" | \"v\"; r: number; c: number; p1: Point; p2: Point }[] = [];\r\n\t\tfor (let r = 0; r <= grid.rows; r++) {\r\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\r\n\t\t\t\tconst p1 = { x: c, y: r };\r\n\t\t\t\tconst p2 = { x: c + 1, y: r };\r\n\t\t\t\tif (!pathEdges.has(this.getEdgeKey(p1, p2))) unusedEdges.push({ type: \"h\", r, c, p1, p2 });\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let r = 0; r < grid.rows; r++) {\r\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\r\n\t\t\t\tconst p1 = { x: c, y: r };\r\n\t\t\t\tconst p2 = { x: c, y: r + 1 };\r\n\t\t\t\tif (!pathEdges.has(this.getEdgeKey(p1, p2))) unusedEdges.push({ type: \"v\", r, c, p1, p2 });\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.shuffleArray(unusedEdges);\r\n\t\t// \u76E4\u9762\u30B5\u30A4\u30BA\u306B\u5FDC\u3058\u3066\u65AD\u7DDA\u6570\u3092\u30B9\u30B1\u30FC\u30EB\u3055\u305B\u308B\r\n\t\tconst targetCount = Math.max(1, Math.floor((complexity * (grid.rows * grid.cols)) / 4));\r\n\t\tlet placed = 0;\r\n\t\tfor (const edge of unusedEdges) {\r\n\t\t\tif (placed >= targetCount) break;\r\n\t\t\t// \u307E\u305A\u306FBroken\u3068\u3057\u3066\u914D\u7F6E\r\n\t\t\tif (edge.type === \"h\") grid.hEdges[edge.r][edge.c].type = EdgeType.Broken;\r\n\t\t\telse grid.vEdges[edge.r][edge.c].type = EdgeType.Broken;\r\n\t\t\tplaced++;\r\n\t\t}\r\n\r\n\t\t// \u5916\u5468\u307E\u305F\u306FAbsent\u306B\u63A5\u89E6\u3057\u3066\u3044\u308BBroken\u3092Absent\u306B\u7F6E\u304D\u63DB\u3048\u308B\uFF08\u4F1D\u64AD\uFF09\r\n\t\tlet changed = true;\r\n\t\twhile (changed) {\r\n\t\t\tchanged = false;\r\n\t\t\t// Horizontal edges\r\n\t\t\tfor (let r = 0; r <= grid.rows; r++) {\r\n\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\r\n\t\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Broken) {\r\n\t\t\t\t\t\tif (this.canBecomeAbsent(grid, { type: \"h\", r, c })) {\r\n\t\t\t\t\t\t\tgrid.hEdges[r][c].type = EdgeType.Absent;\r\n\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Vertical edges\r\n\t\t\tfor (let r = 0; r < grid.rows; r++) {\r\n\t\t\t\tfor (let c = 0; c <= grid.cols; c++) {\r\n\t\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Broken) {\r\n\t\t\t\t\t\tif (this.canBecomeAbsent(grid, { type: \"v\", r, c })) {\r\n\t\t\t\t\t\t\tgrid.vEdges[r][c].type = EdgeType.Absent;\r\n\t\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// \u5468\u56F2\u304C\u5168\u3066\u65AD\u7DDA\u3057\u3066\u3044\u308B\u30CE\u30FC\u30C9\u306E\u5168\u30A8\u30C3\u30B8\u3092Absent\u5316\u3059\u308B\uFF08\u65E2\u5B58\u30ED\u30B8\u30C3\u30AF\u306E\u7DAD\u6301\uFF09\r\n\t\tfor (let r = 0; r <= grid.rows; r++) {\r\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\r\n\t\t\t\tconst edgesWithMeta: { e: EdgeConstraint; type: \"h\" | \"v\"; r: number; c: number }[] = [];\r\n\t\t\t\tif (c > 0) edgesWithMeta.push({ e: grid.hEdges[r][c - 1], type: \"h\", r, c: c - 1 });\r\n\t\t\t\tif (c < grid.cols) edgesWithMeta.push({ e: grid.hEdges[r][c], type: \"h\", r, c });\r\n\t\t\t\tif (r > 0) edgesWithMeta.push({ e: grid.vEdges[r - 1][c], type: \"v\", r: r - 1, c });\r\n\t\t\t\tif (r < grid.rows) edgesWithMeta.push({ e: grid.vEdges[r][c], type: \"v\", r, c });\r\n\r\n\t\t\t\tif (edgesWithMeta.length > 0 && edgesWithMeta.every((m) => m.e.type === EdgeType.Broken || m.e.type === EdgeType.Absent)) {\r\n\t\t\t\t\tif (edgesWithMeta.every((m) => !this.isAdjacentToMark(grid, m))) {\r\n\t\t\t\t\t\tfor (const m of edgesWithMeta) m.e.type = EdgeType.Absent;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u30A8\u30C3\u30B8\u304CAbsent\u306B\u5909\u63DB\u53EF\u80FD\u304B\u5224\u5B9A\u3059\u308B\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t * @param edge \u5224\u5B9A\u5BFE\u8C61\u306E\u30A8\u30C3\u30B8\r\n\t * @returns \u5909\u63DB\u53EF\u80FD\u304B\u3069\u3046\u304B\r\n\t */\r\n\tprivate canBecomeAbsent(grid: Grid, edge: { type: \"h\" | \"v\"; r: number; c: number }): boolean {\r\n\t\t// \u30DE\u30FC\u30AF\u306B\u96A3\u63A5\u3057\u3066\u3044\u308B\u5834\u5408\u306FAbsent\u7981\u6B62\r\n\t\tif (this.isAdjacentToMark(grid, edge)) return false;\r\n\r\n\t\t// 1. \u5916\u5468\u306B\u3042\u308B\u304B\r\n\t\tif (edge.type === \"h\") {\r\n\t\t\tif (edge.r === 0 || edge.r === grid.rows) return true;\r\n\t\t} else {\r\n\t\t\tif (edge.c === 0 || edge.c === grid.cols) return true;\r\n\t\t}\r\n\r\n\t\t// 2. \u4ED6\u306EAbsent\u30A8\u30C3\u30B8\u306B\u63A5\u89E6\uFF08\u30CE\u30FC\u30C9\u3092\u5171\u6709\uFF09\u3057\u3066\u3044\u308B\u304B\r\n\t\tconst nodes =\r\n\t\t\tedge.type === \"h\"\r\n\t\t\t\t? [\r\n\t\t\t\t\t\t{ x: edge.c, y: edge.r },\r\n\t\t\t\t\t\t{ x: edge.c + 1, y: edge.r },\r\n\t\t\t\t\t]\r\n\t\t\t\t: [\r\n\t\t\t\t\t\t{ x: edge.c, y: edge.r },\r\n\t\t\t\t\t\t{ x: edge.c, y: edge.r + 1 },\r\n\t\t\t\t\t];\r\n\r\n\t\tfor (const node of nodes) {\r\n\t\t\tconst adjEdges = [\r\n\t\t\t\t{ type: \"h\", r: node.y, c: node.x - 1 },\r\n\t\t\t\t{ type: \"h\", r: node.y, c: node.x },\r\n\t\t\t\t{ type: \"v\", r: node.y - 1, c: node.x },\r\n\t\t\t\t{ type: \"v\", r: node.y, c: node.x },\r\n\t\t\t];\r\n\t\t\tfor (const adj of adjEdges) {\r\n\t\t\t\tif (adj.c >= 0 && adj.c <= grid.cols && adj.r >= 0 && adj.r <= grid.rows) {\r\n\t\t\t\t\tif (adj.type === \"h\" && adj.c < grid.cols) {\r\n\t\t\t\t\t\tif (grid.hEdges[adj.r][adj.c].type === EdgeType.Absent) return true;\r\n\t\t\t\t\t} else if (adj.type === \"v\" && adj.r < grid.rows) {\r\n\t\t\t\t\t\tif (grid.vEdges[adj.r][adj.c].type === EdgeType.Absent) return true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * \u5230\u9054\u4E0D\u53EF\u80FD\u306A\u30A8\u30EA\u30A2\u3092Absent\u5316\u3057\u3001\u5916\u90E8\u306B\u6F0F\u308C\u305F\u30BB\u30EB\u3092\u30AF\u30EA\u30A2\u3059\u308B\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t */\r\n\tprivate cleanGrid(grid: Grid) {\r\n\t\tconst startNodes: { x: number; y: number }[] = [];\r\n\t\tfor (let r = 0; r <= grid.rows; r++) {\r\n\t\t\tfor (let c = 0; c <= grid.cols; c++) if (grid.nodes[r][c].type === NodeType.Start) startNodes.push({ x: c, y: r });\r\n\t\t}\r\n\r\n\t\tconst reachableNodes = new Set<string>();\r\n\t\tconst queue: { x: number; y: number }[] = [...startNodes];\r\n\t\tfor (const p of startNodes) reachableNodes.add(`${p.x},${p.y}`);\r\n\r\n\t\twhile (queue.length > 0) {\r\n\t\t\tconst curr = queue.shift()!;\r\n\t\t\tconst neighbors = [\r\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.vEdges[curr.y - 1]?.[curr.x] },\r\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.vEdges[curr.y]?.[curr.x] },\r\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.hEdges[curr.y]?.[curr.x - 1] },\r\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.hEdges[curr.y]?.[curr.x] },\r\n\t\t\t];\r\n\t\t\tfor (const n of neighbors) {\r\n\t\t\t\tif (n.edge && n.edge.type !== EdgeType.Absent) {\r\n\t\t\t\t\tif (!reachableNodes.has(`${n.nx},${n.ny}`)) {\r\n\t\t\t\t\t\treachableNodes.add(`${n.nx},${n.ny}`);\r\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (let r = 0; r <= grid.rows; r++) {\r\n\t\t\tfor (let c = 0; c < grid.cols; c++) if (!reachableNodes.has(`${c},${r}`) || !reachableNodes.has(`${c + 1},${r}`)) grid.hEdges[r][c].type = EdgeType.Absent;\r\n\t\t}\r\n\t\tfor (let r = 0; r < grid.rows; r++) {\r\n\t\t\tfor (let c = 0; c <= grid.cols; c++) if (!reachableNodes.has(`${c},${r}`) || !reachableNodes.has(`${c},${r + 1}`)) grid.vEdges[r][c].type = EdgeType.Absent;\r\n\t\t}\r\n\r\n\t\tconst external = this.getExternalCells(grid);\r\n\t\tfor (const cellKey of external) {\r\n\t\t\tconst [c, r] = cellKey.split(\",\").map(Number);\r\n\t\t\tgrid.cells[r][c].type = CellType.None;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate getExternalCells(grid: Grid): Set<string> {\r\n\t\tconst external = new Set<string>();\r\n\t\tconst queue: { x: number; y: number }[] = [];\r\n\t\tfor (let c = 0; c < grid.cols; c++) {\r\n\t\t\tif (grid.hEdges[0][c].type === EdgeType.Absent) {\r\n\t\t\t\tif (!external.has(`${c},0`)) {\r\n\t\t\t\t\texternal.add(`${c},0`);\r\n\t\t\t\t\tqueue.push({ x: c, y: 0 });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (grid.hEdges[grid.rows][c].type === EdgeType.Absent) {\r\n\t\t\t\tif (!external.has(`${c},${grid.rows - 1}`)) {\r\n\t\t\t\t\texternal.add(`${c},${grid.rows - 1}`);\r\n\t\t\t\t\tqueue.push({ x: c, y: grid.rows - 1 });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let r = 0; r < grid.rows; r++) {\r\n\t\t\tif (grid.vEdges[r][0].type === EdgeType.Absent) {\r\n\t\t\t\tif (!external.has(`0,${r}`)) {\r\n\t\t\t\t\texternal.add(`0,${r}`);\r\n\t\t\t\t\tqueue.push({ x: 0, y: r });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (grid.vEdges[r][grid.cols].type === EdgeType.Absent) {\r\n\t\t\t\tif (!external.has(`${grid.cols - 1},${r}`)) {\r\n\t\t\t\t\texternal.add(`${grid.cols - 1},${r}`);\r\n\t\t\t\t\tqueue.push({ x: grid.cols - 1, y: r });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile (queue.length > 0) {\r\n\t\t\tconst curr = queue.shift()!;\r\n\t\t\tconst neighbors = [\r\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.hEdges[curr.y][curr.x] },\r\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.hEdges[curr.y + 1][curr.x] },\r\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x] },\r\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x + 1] },\r\n\t\t\t];\r\n\t\t\tfor (const n of neighbors) {\r\n\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\r\n\t\t\t\t\tif (!external.has(`${n.nx},${n.ny}`) && n.edge.type === EdgeType.Absent) {\r\n\t\t\t\t\t\texternal.add(`${n.nx},${n.ny}`);\r\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn external;\r\n\t}\r\n\r\n\tprivate isAdjacentToMark(grid: Grid, edge: { type: \"h\" | \"v\"; r: number; c: number }): boolean {\r\n\t\tif (edge.type === \"h\") {\r\n\t\t\tif (edge.r > 0 && grid.cells[edge.r - 1][edge.c].type !== CellType.None) return true;\r\n\t\t\tif (edge.r < grid.rows && grid.cells[edge.r][edge.c].type !== CellType.None) return true;\r\n\t\t} else {\r\n\t\t\tif (edge.c > 0 && grid.cells[edge.r][edge.c - 1].type !== CellType.None) return true;\r\n\t\t\tif (edge.c < grid.cols && grid.cells[edge.r][edge.c].type !== CellType.None) return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * \u30DE\u30FC\u30AF\u304C\u5B8C\u5168\u306B\u65AD\u7D76\u3055\u308C\u305F\u30BB\u30EB\u306B\u3044\u306A\u3044\u304B\u78BA\u8A8D\u3059\u308B\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t * @returns \u5B64\u7ACB\u3057\u305F\u30DE\u30FC\u30AF\u304C\u3042\u308B\u304B\u3069\u3046\u304B\r\n\t */\r\n\tprivate hasIsolatedMark(grid: Grid): boolean {\r\n\t\tfor (let r = 0; r < grid.rows; r++)\r\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\r\n\t\t\t\tif (grid.cells[r][c].type === CellType.None) continue;\r\n\t\t\t\tconst edges = [grid.hEdges[r][c], grid.hEdges[r + 1][c], grid.vEdges[r][c], grid.vEdges[r][c + 1]];\r\n\t\t\t\tif (edges.every((e) => e.type === EdgeType.Broken || e.type === EdgeType.Absent)) return true;\r\n\t\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprivate getSymmetricalPoint(grid: Grid, p: Point, symmetry: SymmetryType): Point {\r\n\t\tif (symmetry === SymmetryType.Horizontal) {\r\n\t\t\treturn { x: grid.cols - p.x, y: p.y };\r\n\t\t} else if (symmetry === SymmetryType.Vertical) {\r\n\t\t\treturn { x: p.x, y: grid.rows - p.y };\r\n\t\t} else if (symmetry === SymmetryType.Rotational) {\r\n\t\t\treturn { x: grid.cols - p.x, y: grid.rows - p.y };\r\n\t\t}\r\n\t\treturn { ...p };\r\n\t}\r\n\r\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\r\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\r\n\t}\r\n\r\n\tprivate TETRIS_SHAPES = [\r\n\t\t[[1]],\r\n\t\t[[1, 1]],\r\n\t\t[[1, 1, 1]],\r\n\t\t[[1, 1, 1, 1]],\r\n\t\t[[1, 1, 1, 1, 1]],\r\n\t\t[\r\n\t\t\t[1, 1],\r\n\t\t\t[1, 1],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1],\r\n\t\t\t[1, 0],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1, 1],\r\n\t\t\t[1, 0, 0],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1, 1],\r\n\t\t\t[0, 0, 1],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[0, 1],\r\n\t\t\t[1, 0],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1, 1],\r\n\t\t\t[0, 1, 0],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1, 1],\r\n\t\t\t[0, 1, 0],\r\n\t\t\t[0, 1, 0],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1, 0],\r\n\t\t\t[0, 1, 1],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[0, 1, 1],\r\n\t\t\t[1, 1, 0],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1, 0],\r\n\t\t\t[0, 1, 0],\r\n\t\t\t[0, 1, 1],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[0, 1, 1],\r\n\t\t\t[0, 1, 0],\r\n\t\t\t[1, 1, 0],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1, 1],\r\n\t\t\t[1, 0, 1],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[0, 1, 0],\r\n\t\t\t[1, 0, 1],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 0, 0, 1],\r\n\t\t\t[1, 0, 0, 1],\r\n\t\t],\r\n\t\t[\r\n\t\t\t[1, 1, 1],\r\n\t\t\t[1, 0, 1],\r\n\t\t\t[1, 1, 1],\r\n\t\t],\r\n\t];\r\n\r\n\t/**\r\n\t * \u89E3\u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u5404\u533A\u753B\u306B\u30EB\u30FC\u30EB\u3092\u914D\u7F6E\u3059\u308B\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t * @param path \u89E3\u7B54\u30D1\u30B9\r\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\r\n\t * @param symPath \u5BFE\u79F0\u30D1\u30B9\r\n\t * @param precalculatedRegions \u4E8B\u524D\u8A08\u7B97\u3055\u308C\u305F\u533A\u753B\r\n\t * @param precalculatedBoundaryEdges \u4E8B\u524D\u8A08\u7B97\u3055\u308C\u305F\u5883\u754C\u30A8\u30C3\u30B8\r\n\t */\r\n\tprivate applyConstraintsBasedOnPath(grid: Grid, path: Point[], options: GenerationOptions, symPath: Point[] = [], precalculatedRegions?: Point[][], precalculatedBoundaryEdges?: { type: \"h\" | \"v\"; r: number; c: number }[][]) {\r\n\t\tconst complexity = options.complexity ?? 0.5;\r\n\t\tconst useHexagons = options.useHexagons ?? true;\r\n\t\tconst useSquares = options.useSquares ?? true;\r\n\t\tconst useStars = options.useStars ?? true;\r\n\t\tconst useTetris = options.useTetris ?? false;\r\n\t\tconst useTetrisNegative = options.useTetrisNegative ?? false;\r\n\t\tconst useEraser = options.useEraser ?? false;\r\n\t\tconst useTriangles = options.useTriangles ?? false;\r\n\r\n\t\tlet hexagonsPlaced = 0;\r\n\t\tlet squaresPlaced = 0;\r\n\t\tlet starsPlaced = 0;\r\n\t\tlet tetrisPlaced = 0;\r\n\t\tlet erasersPlaced = 0;\r\n\t\tlet totalTetrisArea = 0;\r\n\t\tconst maxTotalTetrisArea = Math.floor(grid.rows * grid.cols * 0.6);\r\n\r\n\t\t// \u516D\u89D2\u5F62\u306E\u914D\u7F6E\r\n\t\tif (useHexagons) {\r\n\t\t\tconst targetDifficulty = options.difficulty ?? 0.5;\r\n\t\t\tconst symmetry = options.symmetry || SymmetryType.None;\r\n\r\n\t\t\t// \u30A8\u30C3\u30B8\u516D\u89D2\u5F62 (\u7DDA\u4E0A\u30FB\u4E2D\u5FC3)\r\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\r\n\t\t\t\tconst neighbors = this.getValidNeighbors(grid, path[i]);\r\n\t\t\t\tconst isBranching = neighbors.length > 2;\r\n\t\t\t\t// \u96E3\u6613\u5EA6\u304C\u4F4E\u3044\u3068\u304D\u306F\u30A8\u30C3\u30B8\u516D\u89D2\u5F62\u3092\u591A\u304F\u3057\u3066\u30AC\u30A4\u30C9\u306B\u3059\u308B\r\n\t\t\t\tlet prob = complexity * (targetDifficulty < 0.4 ? 0.6 : 0.3);\r\n\t\t\t\tif (isBranching) prob = targetDifficulty < 0.4 ? prob * 1.0 : prob * 0.5;\r\n\t\t\t\tif (this.rng!.next() < prob) {\r\n\t\t\t\t\tlet type = EdgeType.Hexagon;\r\n\t\t\t\t\tlet p1 = path[i];\r\n\t\t\t\t\tlet p2 = path[i + 1];\r\n\r\n\t\t\t\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\t\t\t\tconst r = this.rng!.next();\r\n\t\t\t\t\t\tif (r < 0.3) type = EdgeType.HexagonMain;\r\n\t\t\t\t\t\telse if (r < 0.6) {\r\n\t\t\t\t\t\t\ttype = EdgeType.HexagonSymmetry;\r\n\t\t\t\t\t\t\tp1 = this.getSymmetricalPoint(grid, path[i], symmetry);\r\n\t\t\t\t\t\t\tp2 = this.getSymmetricalPoint(grid, path[i + 1], symmetry);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.setEdgeHexagon(grid, p1, p2, type);\r\n\t\t\t\t\thexagonsPlaced++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// \u30CE\u30FC\u30C9\u516D\u89D2\u5F62 (\u7DDA\u4E0A\u30FB\u4EA4\u70B9)\r\n\t\t\tfor (let i = 0; i < path.length; i++) {\r\n\t\t\t\tconst node = path[i];\r\n\t\t\t\tif (grid.nodes[node.y][node.x].type !== NodeType.Normal) continue;\r\n\t\t\t\t// Edge\u306EHexagon\u3068\u96A3\u63A5\u3057\u3066\u3044\u308B\u5834\u5408\u306F\u30B9\u30AD\u30C3\u30D7\r\n\t\t\t\tif (this.hasIncidentHexagonEdge(grid, node)) continue;\r\n\r\n\t\t\t\t// \u96E3\u6613\u5EA6\u304C\u9AD8\u3044\u3068\u304D\u306B\u30CE\u30FC\u30C9\u516D\u89D2\u5F62\u3092\u914D\u7F6E\r\n\t\t\t\tlet prob = complexity * (targetDifficulty > 0.6 ? 0.15 : 0.05);\r\n\t\t\t\tif (this.rng!.next() < prob) {\r\n\t\t\t\t\tlet type = NodeType.Hexagon;\r\n\t\t\t\t\tlet targetNode = node;\r\n\r\n\t\t\t\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\t\t\t\tconst r = this.rng!.next();\r\n\t\t\t\t\t\tif (r < 0.3) type = NodeType.HexagonMain;\r\n\t\t\t\t\t\telse if (r < 0.6) {\r\n\t\t\t\t\t\t\ttype = NodeType.HexagonSymmetry;\r\n\t\t\t\t\t\t\ttargetNode = this.getSymmetricalPoint(grid, node, symmetry);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgrid.nodes[targetNode.y][targetNode.x].type = type;\r\n\t\t\t\t\thexagonsPlaced++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (hexagonsPlaced === 0 && path.length >= 2) {\r\n\t\t\t\tconst idx = Math.floor(this.rng!.next() * (path.length - 1));\r\n\t\t\t\tconst symmetry = options.symmetry || SymmetryType.None;\r\n\t\t\t\tlet type = EdgeType.Hexagon;\r\n\t\t\t\tlet p1 = path[idx];\r\n\t\t\t\tlet p2 = path[idx + 1];\r\n\r\n\t\t\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\t\t\tconst r = this.rng!.next();\r\n\t\t\t\t\tif (r < 0.3) type = EdgeType.HexagonMain;\r\n\t\t\t\t\telse if (r < 0.6) {\r\n\t\t\t\t\t\ttype = EdgeType.HexagonSymmetry;\r\n\t\t\t\t\t\tp1 = this.getSymmetricalPoint(grid, path[idx], symmetry);\r\n\t\t\t\t\t\tp2 = this.getSymmetricalPoint(grid, path[idx + 1], symmetry);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.setEdgeHexagon(grid, p1, p2, type);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// \u533A\u753B\u30EB\u30FC\u30EB\u306E\u914D\u7F6E\r\n\t\tif (useSquares || useStars || useTetris || useEraser || useTriangles) {\r\n\t\t\tconst regions = precalculatedRegions || this.calculateRegions(grid, path, symPath);\r\n\t\t\tconst availableColors = options.availableColors ?? [Color.Black, Color.White, Color.Red, Color.Blue];\r\n\t\t\tconst defaultColors = options.defaultColors ?? {};\r\n\t\t\tconst getDefColor = (type: CellType, fallback: Color): Color => {\r\n\t\t\t\tif (defaultColors[type] !== undefined) return defaultColors[type] as Color;\r\n\t\t\t\tconst name = CellType[type] as keyof typeof CellType;\r\n\t\t\t\tif (name && defaultColors[name] !== undefined) return defaultColors[name] as Color;\r\n\r\n\t\t\t\t// Rotated variants fallback to their base types\r\n\t\t\t\tif (type === CellType.TetrisRotated) return getDefColor(CellType.Tetris, fallback);\r\n\t\t\t\tif (type === CellType.TetrisNegativeRotated) return getDefColor(CellType.TetrisNegative, fallback);\r\n\r\n\t\t\t\treturn fallback;\r\n\t\t\t};\r\n\t\t\tconst regionIndices = Array.from({ length: regions.length }, (_, i) => i);\r\n\t\t\tthis.shuffleArray(regionIndices);\r\n\t\t\tconst squareColorsUsed = new Set<number>();\r\n\r\n\t\t\t// \u5FC5\u8981\u306A\u6700\u5C0F\u9650\u306E\u5236\u7D04\u3092\u5206\u6563\u3057\u3066\u914D\u7F6E\u3059\u308B\u305F\u3081\u306E\u30D5\u30E9\u30B0\r\n\t\t\tconst needs = {\r\n\t\t\t\tsquare: useSquares,\r\n\t\t\t\tstar: useStars,\r\n\t\t\t\ttetris: useTetris,\r\n\t\t\t\ttetrisNegative: useTetrisNegative,\r\n\t\t\t\teraser: useEraser,\r\n\t\t\t\ttriangle: useTriangles,\r\n\t\t\t};\r\n\r\n\t\t\tlet tetrisNegativePlaced = 0;\r\n\t\t\tlet trianglesPlaced = 0;\r\n\r\n\t\t\tconst pathEdges = new Set<string>();\r\n\t\t\tfor (let i = 0; i < path.length - 1; i++) pathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\r\n\t\t\tfor (let i = 0; i < symPath.length - 1; i++) pathEdges.add(this.getEdgeKey(symPath[i], symPath[i + 1]));\r\n\r\n\t\t\tfor (let rIdx = 0; rIdx < regionIndices.length; rIdx++) {\r\n\t\t\t\tconst idx = regionIndices[rIdx];\r\n\t\t\t\tconst region = regions[idx];\r\n\r\n\t\t\t\t// \u76E4\u9762\u304C\u5927\u304D\u304F\u533A\u753B\u304C\u591A\u3044\u5834\u5408\u3001\u5F8C\u534A\u306B\u504F\u308B\u306E\u3092\u9632\u3050\u305F\u3081\u78BA\u7387\u3092\u8ABF\u6574\r\n\t\t\t\tconst remainingRegions = regionIndices.length - rIdx;\r\n\t\t\t\tconst forceOne = (needs.square && squaresPlaced === 0) || (needs.star && starsPlaced === 0) || (needs.tetris && tetrisPlaced === 0) || (needs.tetrisNegative && tetrisNegativePlaced === 0) || (needs.eraser && erasersPlaced === 0) || (needs.triangle && trianglesPlaced === 0);\r\n\r\n\t\t\t\t// \u5FC5\u9808\u306A\u3082\u306E\u304C\u307E\u3060\u914D\u7F6E\u3055\u308C\u3066\u3044\u306A\u3044\u5834\u5408\u3001\u6B8B\u308A\u533A\u753B\u6570\u304C\u5C11\u306A\u304F\u306A\u3063\u3066\u304D\u305F\u3089\u78BA\u7387\u3092\u4E0A\u3052\u308B\r\n\t\t\t\tlet placementProb = 0.2 + complexity * 0.6;\r\n\t\t\t\tif (forceOne && remainingRegions <= 3) placementProb = 1.0;\r\n\t\t\t\telse if (forceOne && remainingRegions <= 6) placementProb = 0.7;\r\n\r\n\t\t\t\tif (this.rng!.next() > placementProb) continue;\r\n\r\n\t\t\t\tconst potentialCells = [...region];\r\n\t\t\t\tthis.shuffleArray(potentialCells);\r\n\t\t\t\t// \u3053\u306E\u533A\u753B\u5185\u3067\u610F\u56F3\u7684\u306B\uFF08\u30C8\u30B2\u3068\u306E\u30DA\u30A2\u30EA\u30F3\u30B0\u7B49\u306E\u305F\u3081\u306B\uFF09\u5272\u308A\u5F53\u3066\u3089\u308C\u305F\u975E\u30C7\u30D5\u30A9\u30EB\u30C8\u8272\r\n\t\t\t\tconst intendedColors = new Set<number>();\r\n\r\n\t\t\t\t// \u56DB\u89D2\u5F62\u306E\u914D\u7F6E\r\n\t\t\t\tlet squareColor = availableColors[Math.floor(this.rng!.next() * availableColors.length)];\r\n\t\t\t\t// \u5FC5\u9808\u304B\u3064\u672A\u914D\u7F6E\u306E\u5834\u5408\u306F\u3001\u307E\u3060\u4F7F\u3063\u3066\u3044\u306A\u3044\u8272\u3092\u512A\u5148\u7684\u306B\u9078\u3076\r\n\t\t\t\tif (useSquares && squareColorsUsed.size < 2) {\r\n\t\t\t\t\tconst unusedColors = availableColors.filter((c) => !squareColorsUsed.has(c));\r\n\t\t\t\t\tif (unusedColors.length > 0) {\r\n\t\t\t\t\t\tsquareColor = unusedColors[Math.floor(this.rng!.next() * unusedColors.length)];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet shouldPlaceSquare = useSquares && this.rng!.next() < 0.5 + complexity * 0.3;\r\n\t\t\t\tif (useSquares && squaresPlaced === 0 && remainingRegions <= 2) shouldPlaceSquare = true;\r\n\t\t\t\tif (useSquares && !useStars && remainingRegions <= 2 && squareColorsUsed.size < 2 && squaresPlaced > 0) shouldPlaceSquare = true;\r\n\r\n\t\t\t\tif (shouldPlaceSquare && potentialCells.length > 0) {\r\n\t\t\t\t\t// \u533A\u57DF\u306E\u5927\u304D\u3055\u306B\u5FDC\u3058\u3066\u914D\u7F6E\u3059\u308B\u6570\u3092\u5897\u3084\u3059\r\n\t\t\t\t\tconst maxSquares = Math.min(potentialCells.length, Math.max(4, Math.floor(region.length / 4)));\r\n\t\t\t\t\tconst numSquares = Math.floor(this.rng!.next() * (maxSquares / 2)) + Math.ceil(maxSquares / 2);\r\n\t\t\t\t\tfor (let i = 0; i < numSquares; i++) {\r\n\t\t\t\t\t\tif (potentialCells.length === 0) break;\r\n\t\t\t\t\t\tconst cell = potentialCells.pop()!;\r\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Square;\r\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = squareColor;\r\n\t\t\t\t\t\tsquaresPlaced++;\r\n\t\t\t\t\t\tsquareColorsUsed.add(squareColor);\r\n\t\t\t\t\t\tintendedColors.add(squareColor);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// \u30C6\u30C8\u30EA\u30B9\u306E\u914D\u7F6E\r\n\t\t\t\tif (useTetris || useTetrisNegative) {\r\n\t\t\t\t\tlet shouldPlaceTetris = this.rng!.next() < 0.1 + complexity * 0.4;\r\n\t\t\t\t\t// \u672A\u914D\u7F6E\u306E\u5834\u5408\u306F\u78BA\u7387\u3092\u4E0A\u3052\u308B\r\n\t\t\t\t\tif (tetrisPlaced === 0 && remainingRegions <= 3) shouldPlaceTetris = true;\r\n\t\t\t\t\tif (useTetrisNegative && tetrisNegativePlaced === 0 && remainingRegions <= 2) shouldPlaceTetris = true;\r\n\r\n\t\t\t\t\tconst maxTetrisPerRegion = tetrisPlaced === 0 && remainingRegions <= 2 ? 6 : 4;\r\n\r\n\t\t\t\t\t// \u9762\u7A4D\u5236\u9650\u306E\u7DE9\u548C: \u5FC5\u9808\u304B\u3064\u672A\u914D\u7F6E\u306E\u5834\u5408\u306F\u5236\u9650\u3092\u7121\u8996\u3059\u308B\u3002\u305F\u3060\u3057\u63A2\u7D22\u7206\u767A\u3092\u9632\u3050\u305F\u3081\u6700\u592730\u30BB\u30EB\u7A0B\u5EA6\u306B\u5236\u9650\r\n\t\t\t\t\tconst isAreaOk = totalTetrisArea + region.length <= maxTotalTetrisArea || (forceOne && useTetris && tetrisPlaced === 0 && region.length <= 30) || (forceOne && useTetrisNegative && tetrisNegativePlaced === 0 && region.length <= 30);\r\n\r\n\t\t\t\t\tif (shouldPlaceTetris && potentialCells.length > 0 && isAreaOk) {\r\n\t\t\t\t\t\t// \u5DE8\u5927\u306A\u9818\u57DF\u3067\u306E\u30BF\u30A4\u30EA\u30F3\u30B0\u63A2\u7D22\u306F\u975E\u5E38\u306B\u91CD\u3044\u305F\u3081\u3001\u5236\u9650\u3092\u304B\u3051\u308B\r\n\t\t\t\t\t\tlet tiledPieces = region.length <= 25 ? (this.generateTiling(region, maxTetrisPerRegion, options) as TiledPiece[] | null) : null;\r\n\t\t\t\t\t\tif (tiledPieces) {\r\n\t\t\t\t\t\t\t// \u6E1B\u7B97\u30C6\u30C8\u30EA\u30B9\u306E\u9069\u7528\r\n\t\t\t\t\t\t\tconst negativePiecesToPlace: TiledPiece[] = [];\r\n\t\t\t\t\t\t\t// \u672A\u914D\u7F6E\u306E\u5834\u5408\u306F\u78BA\u7387\u3092\u4E0A\u3052\u308B\r\n\t\t\t\t\t\t\tlet negProb = 0.2 + complexity * 0.3;\r\n\t\t\t\t\t\t\tif (useTetrisNegative && tetrisNegativePlaced === 0 && remainingRegions <= 3) negProb = 0.9;\r\n\r\n\t\t\t\t\t\t\tif (useTetrisNegative && this.rng!.next() < negProb) {\r\n\t\t\t\t\t\t\t\tconst difficulty = options.difficulty ?? 0.5;\r\n\t\t\t\t\t\t\t\tconst prob0 = 0.1; // area-0 case probability\r\n\t\t\t\t\t\t\t\tif (this.rng!.next() < prob0 && potentialCells.length >= 2) {\r\n\t\t\t\t\t\t\t\t\t// Case: Net area 0.\r\n\t\t\t\t\t\t\t\t\tlet complexFound = false;\r\n\t\t\t\t\t\t\t\t\tif (potentialCells.length >= 3 && this.rng!.next() < 0.8) {\r\n\t\t\t\t\t\t\t\t\t\t// Try 2:1 or 1:2 complex cancellation\r\n\t\t\t\t\t\t\t\t\t\tconst is2pos1neg = this.rng!.next() < 0.5;\r\n\t\t\t\t\t\t\t\t\t\tconst baseArea = 1 + Math.floor(this.rng!.next() * 2); // 1 or 2\r\n\t\t\t\t\t\t\t\t\t\tconst baseShapes = this.TETRIS_SHAPES.filter((s) => this.getShapeArea(s) === baseArea);\r\n\t\t\t\t\t\t\t\t\t\tconst base = baseShapes[Math.floor(this.rng!.next() * baseShapes.length)];\r\n\r\n\t\t\t\t\t\t\t\t\t\tconst triple = this.findStandardTriple(base);\r\n\t\t\t\t\t\t\t\t\t\tif (triple) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (is2pos1neg) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// P1(base) + P2(triple.n) = N(triple.p)\r\n\t\t\t\t\t\t\t\t\t\t\t\ttiledPieces.push({ shape: base, displayShape: base, isRotated: !this.isRotationallyInvariant(base) && this.rng!.next() < difficulty * 0.7, isNegative: false });\r\n\t\t\t\t\t\t\t\t\t\t\t\ttiledPieces.push({ shape: triple.n, displayShape: triple.n, isRotated: !this.isRotationallyInvariant(triple.n) && this.rng!.next() < difficulty * 0.7, isNegative: false });\r\n\t\t\t\t\t\t\t\t\t\t\t\tnegativePiecesToPlace.push({ shape: triple.p, displayShape: triple.p, isRotated: !this.isRotationallyInvariant(triple.p) && this.rng!.next() < difficulty * 0.7, isNegative: true });\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// P(triple.p) = N1(base) + N2(triple.n)\r\n\t\t\t\t\t\t\t\t\t\t\t\ttiledPieces.push({ shape: triple.p, displayShape: triple.p, isRotated: !this.isRotationallyInvariant(triple.p) && this.rng!.next() < difficulty * 0.7, isNegative: false });\r\n\t\t\t\t\t\t\t\t\t\t\t\tnegativePiecesToPlace.push({ shape: base, displayShape: base, isRotated: !this.isRotationallyInvariant(base) && this.rng!.next() < difficulty * 0.7, isNegative: true });\r\n\t\t\t\t\t\t\t\t\t\t\t\tnegativePiecesToPlace.push({ shape: triple.n, displayShape: triple.n, isRotated: !this.isRotationallyInvariant(triple.n) && this.rng!.next() < difficulty * 0.7, isNegative: true });\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tcomplexFound = true;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tif (!complexFound) {\r\n\t\t\t\t\t\t\t\t\t\t// Case: 1:1 Net area 0.\r\n\t\t\t\t\t\t\t\t\t\t// To cancel to zero, combined shapes must match.\r\n\t\t\t\t\t\t\t\t\t\tconst area = 3 + Math.floor(this.rng!.next() * 2); // area 3 or 4\r\n\t\t\t\t\t\t\t\t\t\tconst candidates = this.TETRIS_SHAPES.filter((s) => this.getShapeArea(s) === area);\r\n\t\t\t\t\t\t\t\t\t\tthis.shuffleArray(candidates);\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (candidates.length > 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tconst pShape = candidates[0];\r\n\t\t\t\t\t\t\t\t\t\t\tconst nShape = candidates[0];\r\n\t\t\t\t\t\t\t\t\t\t\ttiledPieces.push({ shape: pShape, displayShape: pShape, isRotated: !this.isRotationallyInvariant(pShape) && this.rng!.next() < difficulty * 0.7, isNegative: false });\r\n\t\t\t\t\t\t\t\t\t\t\tnegativePiecesToPlace.push({ shape: nShape, displayShape: nShape, isRotated: !this.isRotationallyInvariant(nShape) && this.rng!.next() < difficulty * 0.7, isNegative: true });\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else if (tiledPieces.length > 0) {\r\n\t\t\t\t\t\t\t\t\t// Case: Net area > 0 using standard triples\r\n\t\t\t\t\t\t\t\t\tconst numSubtractions = this.rng!.next() < 0.3 ? 2 : 1;\r\n\t\t\t\t\t\t\t\t\tfor (let i = 0; i < numSubtractions; i++) {\r\n\t\t\t\t\t\t\t\t\t\tif (potentialCells.length < 1) break;\r\n\t\t\t\t\t\t\t\t\t\tconst targetIdx = Math.floor(this.rng!.next() * tiledPieces.length);\r\n\t\t\t\t\t\t\t\t\t\tconst original = tiledPieces[targetIdx];\r\n\t\t\t\t\t\t\t\t\t\tif (original.isNegative) continue;\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Occasionally try a 1:2 subtraction (P = T + N1 + N2)\r\n\t\t\t\t\t\t\t\t\t\tlet complexSubtraction = false;\r\n\t\t\t\t\t\t\t\t\t\tif (potentialCells.length >= 2 && this.rng!.next() < 0.2) {\r\n\t\t\t\t\t\t\t\t\t\t\tconst triple1 = this.findStandardTriple(original.shape);\r\n\t\t\t\t\t\t\t\t\t\t\tif (triple1) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tconst triple2 = this.findStandardTriple(triple1.p);\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (triple2) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// T(orig) + N1(triple1.n) + N2(triple2.n) = P(triple2.p)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// So P - N1 - N2 = T\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ttiledPieces[targetIdx] = { shape: triple2.p, displayShape: triple2.p, isRotated: !this.isRotationallyInvariant(triple2.p) && this.rng!.next() < difficulty * 0.7, isNegative: false };\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tnegativePiecesToPlace.push({ shape: triple1.n, displayShape: triple1.n, isRotated: !this.isRotationallyInvariant(triple1.n) && this.rng!.next() < difficulty * 0.7, isNegative: true });\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tnegativePiecesToPlace.push({ shape: triple2.n, displayShape: triple2.n, isRotated: !this.isRotationallyInvariant(triple2.n) && this.rng!.next() < difficulty * 0.7, isNegative: true });\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcomplexSubtraction = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (!complexSubtraction) {\r\n\t\t\t\t\t\t\t\t\t\t\tconst triple = this.findStandardTriple(original.shape);\r\n\t\t\t\t\t\t\t\t\t\t\tif (triple) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Check if triple.n matches any existing positive piece in tiledPieces to avoid triviality\r\n\t\t\t\t\t\t\t\t\t\t\t\tconst isDuplicate = tiledPieces.some((tp) => !tp.isNegative && this.isSameShape(tp.shape, triple.n));\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (!isDuplicate) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ttiledPieces[targetIdx] = {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape: triple.p,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdisplayShape: triple.p,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tisRotated: !this.isRotationallyInvariant(triple.p) && this.rng!.next() < difficulty * 0.7,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tisNegative: false,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tnegativePiecesToPlace.push({\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape: triple.n,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdisplayShape: triple.n,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tisRotated: !this.isRotationallyInvariant(triple.n) && this.rng!.next() < difficulty * 0.7,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tisNegative: true,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tconst allPieces: TiledPiece[] = [...tiledPieces, ...negativePiecesToPlace];\r\n\t\t\t\t\t\t\tif (allPieces.length > potentialCells.length) continue;\r\n\t\t\t\t\t\t\tfor (const p of allPieces) {\r\n\t\t\t\t\t\t\t\tif (potentialCells.length === 0) break;\r\n\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\tconst isNeg = p.isNegative;\r\n\r\n\t\t\t\t\t\t\t\tif (isNeg) {\r\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = p.isRotated ? CellType.TetrisNegativeRotated : CellType.TetrisNegative;\r\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = getDefColor(CellType.TetrisNegative, Color.None);\r\n\t\t\t\t\t\t\t\t\ttetrisNegativePlaced++;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = p.isRotated ? CellType.TetrisRotated : CellType.Tetris;\r\n\t\t\t\t\t\t\t\t\tconst defColor = getDefColor(CellType.Tetris, Color.None);\r\n\t\t\t\t\t\t\t\t\tlet tetrisColor = defColor;\r\n\t\t\t\t\t\t\t\t\t// \u30C8\u30B2(Star)\u3068\u306E\u30DA\u30A2\u30EA\u30F3\u30B0\u3092\u610F\u56F3\u3059\u308B\u5834\u5408\u306E\u307F\u8272\u3092\u4ED8\u3051\u308B\r\n\t\t\t\t\t\t\t\t\tif (useStars && this.rng!.next() < 0.3) {\r\n\t\t\t\t\t\t\t\t\t\tconst candidates = availableColors.filter((c) => c !== defColor && !intendedColors.has(c));\r\n\t\t\t\t\t\t\t\t\t\tif (candidates.length > 0) {\r\n\t\t\t\t\t\t\t\t\t\t\ttetrisColor = candidates[Math.floor(this.rng!.next() * candidates.length)];\r\n\t\t\t\t\t\t\t\t\t\t\tintendedColors.add(tetrisColor);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = tetrisColor;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].shape = p.isRotated ? p.displayShape : p.shape;\r\n\t\t\t\t\t\t\t\ttetrisPlaced++;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\ttotalTetrisArea += region.length;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// \u4E09\u89D2\u5F62\u306E\u914D\u7F6E\r\n\t\t\t\tif (useTriangles) {\r\n\t\t\t\t\tlet shouldPlaceTriangle = this.rng!.next() < 0.2 + complexity * 0.5;\r\n\t\t\t\t\tif (trianglesPlaced === 0 && remainingRegions <= 2) shouldPlaceTriangle = true;\r\n\r\n\t\t\t\t\tif (shouldPlaceTriangle && potentialCells.length > 0) {\r\n\t\t\t\t\t\tthis.shuffleArray(potentialCells);\r\n\t\t\t\t\t\tconst numToTry = Math.min(potentialCells.length, Math.max(1, Math.floor(region.length / 3)));\r\n\t\t\t\t\t\tlet placedInRegion = 0;\r\n\r\n\t\t\t\t\t\tfor (let i = 0; i < potentialCells.length && placedInRegion < numToTry; i++) {\r\n\t\t\t\t\t\t\tconst cell = potentialCells[i];\r\n\t\t\t\t\t\t\tconst cellEdges = [this.getEdgeKey({ x: cell.x, y: cell.y }, { x: cell.x + 1, y: cell.y }), this.getEdgeKey({ x: cell.x, y: cell.y + 1 }, { x: cell.x + 1, y: cell.y + 1 }), this.getEdgeKey({ x: cell.x, y: cell.y }, { x: cell.x, y: cell.y + 1 }), this.getEdgeKey({ x: cell.x + 1, y: cell.y }, { x: cell.x + 1, y: cell.y + 1 })];\r\n\t\t\t\t\t\t\tlet count = 0;\r\n\t\t\t\t\t\t\tfor (const edge of cellEdges) {\r\n\t\t\t\t\t\t\t\tif (pathEdges.has(edge)) count++;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (count >= 1 && count <= 3) {\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Triangle;\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].count = count;\r\n\r\n\t\t\t\t\t\t\t\tconst defColor = getDefColor(CellType.Triangle, Color.None);\r\n\t\t\t\t\t\t\t\tlet triangleColor = defColor;\r\n\t\t\t\t\t\t\t\tif (useStars && this.rng!.next() < 0.3) {\r\n\t\t\t\t\t\t\t\t\tconst candidates = availableColors.filter((c) => c !== defColor && !intendedColors.has(c));\r\n\t\t\t\t\t\t\t\t\tif (candidates.length > 0) {\r\n\t\t\t\t\t\t\t\t\t\ttriangleColor = candidates[Math.floor(this.rng!.next() * candidates.length)];\r\n\t\t\t\t\t\t\t\t\t\tintendedColors.add(triangleColor);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = triangleColor;\r\n\r\n\t\t\t\t\t\t\t\tpotentialCells.splice(i, 1);\r\n\t\t\t\t\t\t\t\ti--;\r\n\t\t\t\t\t\t\t\ttrianglesPlaced++;\r\n\t\t\t\t\t\t\t\tplacedInRegion++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// \u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF08\u30A8\u30E9\u30FC\u524A\u9664\uFF09\u306E\u914D\u7F6E\r\n\t\t\t\tif (useEraser && erasersPlaced < 1) {\r\n\t\t\t\t\tconst prob = 0.05 + complexity * 0.2;\r\n\t\t\t\t\tlet shouldPlaceEraser = this.rng!.next() < prob;\r\n\t\t\t\t\tif (remainingRegions <= 2) shouldPlaceEraser = true;\r\n\r\n\t\t\t\t\tif (shouldPlaceEraser && potentialCells.length >= 1) {\r\n\t\t\t\t\t\tlet errorTypes: string[] = [];\r\n\t\t\t\t\t\tif (useStars) errorTypes.push(\"star\");\r\n\t\t\t\t\t\tif (useSquares) errorTypes.push(\"square\");\r\n\t\t\t\t\t\tlet boundaryEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\r\n\t\t\t\t\t\tif (useHexagons) {\r\n\t\t\t\t\t\t\tboundaryEdges = precalculatedBoundaryEdges ? precalculatedBoundaryEdges[idx] : this.getRegionBoundaryEdges(grid, region, path, symPath);\r\n\t\t\t\t\t\t\tif (boundaryEdges.length > 0) errorTypes.push(\"hexagon\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (useTetris) errorTypes.push(\"tetris\");\r\n\t\t\t\t\t\tif (useTetrisNegative) errorTypes.push(\"tetrisNegative\");\r\n\t\t\t\t\t\tif (useTriangles) errorTypes.push(\"triangle\");\r\n\r\n\t\t\t\t\t\tthis.shuffleArray(errorTypes);\r\n\t\t\t\t\t\tif (potentialCells.length >= 2) errorTypes.push(\"eraser\");\r\n\r\n\t\t\t\t\t\tlet errorPlaced = false;\r\n\r\n\t\t\t\t\t\tfor (const errorType of errorTypes) {\r\n\t\t\t\t\t\t\tif (errorPlaced) break;\r\n\r\n\t\t\t\t\t\t\tif (errorType === \"hexagon\") {\r\n\t\t\t\t\t\t\t\tconst validEdges = boundaryEdges.filter((e) => !this.isEdgeAdjacentToHexagonNode(grid, e));\r\n\t\t\t\t\t\t\t\tif (validEdges.length > 0) {\r\n\t\t\t\t\t\t\t\t\tconst edge = validEdges[Math.floor(this.rng!.next() * validEdges.length)];\r\n\t\t\t\t\t\t\t\t\tif (edge.type === \"h\") grid.hEdges[edge.r][edge.c].type = EdgeType.Hexagon;\r\n\t\t\t\t\t\t\t\t\telse grid.vEdges[edge.r][edge.c].type = EdgeType.Hexagon;\r\n\t\t\t\t\t\t\t\t\thexagonsPlaced++;\r\n\t\t\t\t\t\t\t\t\terrorPlaced = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else if (errorType === \"square\" && potentialCells.length >= 2) {\r\n\t\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Square;\r\n\t\t\t\t\t\t\t\tconst existingSquare = region.find((p) => grid.cells[p.y][p.x].type === CellType.Square);\r\n\t\t\t\t\t\t\t\tconst existingSquareColor = existingSquare ? grid.cells[existingSquare.y][existingSquare.x].color : undefined;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = availableColors.find((c) => c !== existingSquareColor) || Color.Red;\r\n\t\t\t\t\t\t\t\tsquaresPlaced++;\r\n\t\t\t\t\t\t\t\terrorPlaced = true;\r\n\t\t\t\t\t\t\t} else if (errorType === \"star\" && potentialCells.length >= 2) {\r\n\t\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Star;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = availableColors[Math.floor(this.rng!.next() * availableColors.length)];\r\n\t\t\t\t\t\t\t\tstarsPlaced++;\r\n\t\t\t\t\t\t\t\terrorPlaced = true;\r\n\t\t\t\t\t\t\t} else if (errorType === \"tetris\" && potentialCells.length >= 2) {\r\n\t\t\t\t\t\t\t\tconst tiledPieces = this.generateTiling(region, 4, options);\r\n\t\t\t\t\t\t\t\tlet piecesToPlace = [];\r\n\t\t\t\t\t\t\t\tif (tiledPieces && tiledPieces.length > 0) {\r\n\t\t\t\t\t\t\t\t\tlet currentArea = 0;\r\n\t\t\t\t\t\t\t\t\tfor (const p of tiledPieces) {\r\n\t\t\t\t\t\t\t\t\t\tconst area = this.getShapeArea(p.shape);\r\n\t\t\t\t\t\t\t\t\t\tif (currentArea + area < region.length) {\r\n\t\t\t\t\t\t\t\t\t\t\tpiecesToPlace.push(p);\r\n\t\t\t\t\t\t\t\t\t\t\tcurrentArea += area;\r\n\t\t\t\t\t\t\t\t\t\t} else break;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (piecesToPlace.length === 0 && region.length > 1) {\r\n\t\t\t\t\t\t\t\t\tpiecesToPlace = [{ shape: [[1]], displayShape: [[1]], isRotated: false }];\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (piecesToPlace.length > 0) {\r\n\t\t\t\t\t\t\t\t\tfor (const p of piecesToPlace) {\r\n\t\t\t\t\t\t\t\t\t\tif (potentialCells.length < 2) break;\r\n\t\t\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = p.isRotated ? CellType.TetrisRotated : CellType.Tetris;\r\n\t\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].shape = p.isRotated ? p.displayShape : p.shape;\r\n\t\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = getDefColor(grid.cells[cell.y][cell.x].type, Color.None);\r\n\t\t\t\t\t\t\t\t\t\ttetrisPlaced++;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\terrorPlaced = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else if (errorType === \"tetrisNegative\" && this.canPlaceGeneratedTetrisNegative(grid, region, potentialCells)) {\r\n\t\t\t\t\t\t\t\tif (!this.hasRegionTetrisSymbol(grid, region)) {\r\n\t\t\t\t\t\t\t\t\tconst posCell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\t\tgrid.cells[posCell.y][posCell.x].type = CellType.Tetris;\r\n\t\t\t\t\t\t\t\t\tgrid.cells[posCell.y][posCell.x].shape = [[1]];\r\n\t\t\t\t\t\t\t\t\tgrid.cells[posCell.y][posCell.x].color = getDefColor(CellType.Tetris, Color.None);\r\n\t\t\t\t\t\t\t\t\ttetrisPlaced++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.TetrisNegative;\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].shape = [[1]];\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = getDefColor(CellType.TetrisNegative, Color.None);\r\n\t\t\t\t\t\t\t\ttetrisNegativePlaced++;\r\n\t\t\t\t\t\t\t} else if (errorType === \"triangle\" && potentialCells.length >= 2) {\r\n\t\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Triangle;\r\n\t\t\t\t\t\t\t\tconst cellEdges = [this.getEdgeKey({ x: errCell.x, y: errCell.y }, { x: errCell.x + 1, y: errCell.y }), this.getEdgeKey({ x: errCell.x, y: errCell.y + 1 }, { x: errCell.x + 1, y: errCell.y + 1 }), this.getEdgeKey({ x: errCell.x, y: errCell.y }, { x: errCell.x, y: errCell.y + 1 }), this.getEdgeKey({ x: errCell.x + 1, y: errCell.y }, { x: errCell.x + 1, y: errCell.y + 1 })];\r\n\t\t\t\t\t\t\t\tlet actualCount = 0;\r\n\t\t\t\t\t\t\t\tfor (const edge of cellEdges) if (pathEdges.has(edge)) actualCount++;\r\n\r\n\t\t\t\t\t\t\t\t// \u5B9F\u969B\u306E\u6570\u3068\u7570\u306A\u308B\u6570\u3092\u8A2D\u5B9A\r\n\t\t\t\t\t\t\t\tlet errorCount = (actualCount + 1) % 4;\r\n\t\t\t\t\t\t\t\tif (errorCount === 0) errorCount = 1;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].count = errorCount;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = getDefColor(CellType.Triangle, Color.None);\r\n\t\t\t\t\t\t\t\ttrianglesPlaced++;\r\n\t\t\t\t\t\t\t\terrorPlaced = true;\r\n\t\t\t\t\t\t\t} else if (errorType === \"eraser\" && this.canPlaceGeneratedEraser(grid, region, potentialCells)) {\r\n\t\t\t\t\t\t\t\tconst errCell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].type = CellType.Eraser;\r\n\t\t\t\t\t\t\t\tgrid.cells[errCell.y][errCell.x].color = getDefColor(CellType.Eraser, Color.White);\r\n\t\t\t\t\t\t\t\terasersPlaced++;\r\n\t\t\t\t\t\t\t\terrorPlaced = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (errorPlaced && this.canPlaceGeneratedEraser(grid, region, potentialCells)) {\r\n\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Eraser;\r\n\t\t\t\t\t\t\tconst defColor = getDefColor(CellType.Eraser, Color.White);\r\n\t\t\t\t\t\t\tlet eraserColor = defColor;\r\n\t\t\t\t\t\t\t// \u30C8\u30B2(Star)\u3068\u306E\u30DA\u30A2\u30EA\u30F3\u30B0\u3092\u610F\u56F3\u3059\u308B\u5834\u5408\u306E\u307F\u8272\u3092\u4ED8\u3051\u308B\r\n\t\t\t\t\t\t\tif (useStars && this.rng!.next() < 0.3) {\r\n\t\t\t\t\t\t\t\tconst candidates = availableColors.filter((c) => c !== defColor && !intendedColors.has(c));\r\n\t\t\t\t\t\t\t\tif (candidates.length > 0) {\r\n\t\t\t\t\t\t\t\t\teraserColor = candidates[Math.floor(this.rng!.next() * candidates.length)];\r\n\t\t\t\t\t\t\t\t\tintendedColors.add(eraserColor);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = eraserColor;\r\n\t\t\t\t\t\t\terasersPlaced++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// \u661F\u306E\u914D\u7F6E\r\n\t\t\t\tif (useStars) {\r\n\t\t\t\t\t// 1. \u307E\u305A\u975E\u30C7\u30D5\u30A9\u30EB\u30C8\u8272\u306E\u8A18\u53F7\u3001\u307E\u305F\u306F\u610F\u56F3\u7684\u306B\u8272\u4ED8\u3051\u3055\u308C\u305F\u8A18\u53F7\u3092\u30C8\u30B2\u3067\u30DA\u30A2\u30EA\u30F3\u30B0\u3059\u308B\uFF08\u5FC5\u9808\uFF09\r\n\t\t\t\t\tfor (const color of availableColors) {\r\n\t\t\t\t\t\tif (potentialCells.length < 1) break;\r\n\t\t\t\t\t\tconst colorCount = region.filter((p) => grid.cells[p.y][p.x].color === color).length;\r\n\t\t\t\t\t\t// \u975E\u30C7\u30D5\u30A9\u30EB\u30C8\u8272\u3001\u307E\u305F\u306F\u610F\u56F3\u7684\u306B\u5272\u308A\u5F53\u3066\u3089\u308C\u305F\u8272\u304C1\u3064\u3060\u3051\u3042\u308B\u5834\u5408\u3001\u30C8\u30B2\u3092\u8FFD\u52A0\u3057\u3066\u30DA\u30A2\u306B\u3059\u308B\r\n\t\t\t\t\t\tif (colorCount === 1 && (color !== Color.White || intendedColors.has(color))) {\r\n\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\r\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\r\n\t\t\t\t\t\t\tstarsPlaced++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// 2. \u8FFD\u52A0\u3067\u30C8\u30B2\u306E\u30DA\u30A2\u3092\u914D\u7F6E\u3059\u308B\uFF08\u30E9\u30F3\u30C0\u30E0\uFF09\r\n\t\t\t\t\tconst maxPairs = Math.max(1, Math.floor(region.length / 8));\r\n\t\t\t\t\tfor (let p = 0; p < maxPairs; p++) {\r\n\t\t\t\t\t\tif (potentialCells.length < 2) break;\r\n\t\t\t\t\t\tfor (const color of availableColors) {\r\n\t\t\t\t\t\t\tif (potentialCells.length < 2) break;\r\n\t\t\t\t\t\t\tif (this.rng!.next() > 0.3 + complexity * 0.4) continue;\r\n\r\n\t\t\t\t\t\t\tconst colorCount = region.filter((p) => grid.cells[p.y][p.x].color === color).length;\r\n\t\t\t\t\t\t\tif (colorCount === 0) {\r\n\t\t\t\t\t\t\t\tfor (let i = 0; i < 2; i++) {\r\n\t\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\r\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\r\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\r\n\t\t\t\t\t\t\t\t\tstarsPlaced++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// \u56DB\u89D2\u5F62\u306E\u8272\u304C1\u8272\u3057\u304B\u4F7F\u308F\u308C\u306A\u304B\u3063\u305F\u5834\u5408\u306E\u88DC\u6B63\r\n\t\t\tif (useSquares && squareColorsUsed.size < 2) {\r\n\t\t\t\tconst onlyColor = squareColorsUsed.values().next().value;\r\n\t\t\t\tconst hasMatchingStar =\r\n\t\t\t\t\tonlyColor !== undefined &&\r\n\t\t\t\t\tstarsPlaced > 0 &&\r\n\t\t\t\t\tArray.from({ length: grid.rows * grid.cols }).some((_, i) => {\r\n\t\t\t\t\t\tconst r = Math.floor(i / grid.cols);\r\n\t\t\t\t\t\tconst c = i % grid.cols;\r\n\t\t\t\t\t\treturn grid.cells[r][c].type === CellType.Star && grid.cells[r][c].color === onlyColor;\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\tif (!hasMatchingStar) {\r\n\t\t\t\t\tfor (const region of regions) {\r\n\t\t\t\t\t\tif (squareColorsUsed.size >= 2) break;\r\n\t\t\t\t\t\tif (region.some((p) => grid.cells[p.y][p.x].type === CellType.Square)) continue;\r\n\r\n\t\t\t\t\t\tconst availableCells = region.filter((p) => grid.cells[p.y][p.x].type === CellType.None);\r\n\t\t\t\t\t\tif (availableCells.length > 0) {\r\n\t\t\t\t\t\t\tconst otherColor = availableColors.find((c) => !squareColorsUsed.has(c)) || Color.White;\r\n\t\t\t\t\t\t\tconst cell = availableCells[Math.floor(this.rng!.next() * availableCells.length)];\r\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Square;\r\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = otherColor;\r\n\t\t\t\t\t\t\tsquareColorsUsed.add(otherColor);\r\n\t\t\t\t\t\t\tsquaresPlaced++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// \u307E\u30601\u8272\u306E\u5834\u5408\u306F\u3001\u540C\u8272\u306E\u661F\u3092\u7121\u7406\u3084\u308A\u7F6E\u304F\r\n\t\t\t\t\tif (squareColorsUsed.size < 2 && useStars && onlyColor !== undefined) {\r\n\t\t\t\t\t\tfor (const region of regions) {\r\n\t\t\t\t\t\t\tconst availableCells = region.filter((p) => grid.cells[p.y][p.x].type === CellType.None);\r\n\t\t\t\t\t\t\tif (availableCells.length > 0) {\r\n\t\t\t\t\t\t\t\tconst cell = availableCells[Math.floor(this.rng!.next() * availableCells.length)];\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\r\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = onlyColor;\r\n\t\t\t\t\t\t\t\tstarsPlaced++;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u533A\u753B\u5206\u3051\u3092\u884C\u3046\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t * @param path \u89E3\u7B54\u30D1\u30B9\r\n\t * @param symPath \u5BFE\u79F0\u30D1\u30B9\r\n\t * @returns \u533A\u753B\u30EA\u30B9\u30C8\r\n\t */\r\n\tprivate calculateRegions(grid: Grid, path: Point[], symPath: Point[] = []): Point[][] {\r\n\t\tconst regions: Point[][] = [];\r\n\t\tconst rows = grid.rows;\r\n\t\tconst cols = grid.cols;\r\n\t\tconst visitedCells = new Uint8Array(rows * cols);\r\n\r\n\t\tconst hEdgesMask = new Uint8Array((rows + 1) * cols);\r\n\t\tconst vEdgesMask = new Uint8Array(rows * (cols + 1));\r\n\r\n\t\tconst setEdge = (p1: Point, p2: Point) => {\r\n\t\t\tif (p1.x === p2.x) {\r\n\t\t\t\tvEdgesMask[Math.min(p1.y, p2.y) * (cols + 1) + p1.x] = 1;\r\n\t\t\t} else {\r\n\t\t\t\thEdgesMask[p1.y * cols + Math.min(p1.x, p2.x)] = 1;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfor (let i = 0; i < path.length - 1; i++) setEdge(path[i], path[i + 1]);\r\n\t\tfor (let i = 0; i < symPath.length - 1; i++) setEdge(symPath[i], symPath[i + 1]);\r\n\r\n\t\tfor (let r = 0; r <= rows; r++) {\r\n\t\t\tfor (let c = 0; c < cols; c++) {\r\n\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Absent) hEdgesMask[r * cols + c] = 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let r = 0; r < rows; r++) {\r\n\t\t\tfor (let c = 0; c <= cols; c++) {\r\n\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Absent) vEdgesMask[r * (cols + 1) + c] = 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (let r = 0; r < rows; r++) {\r\n\t\t\tfor (let c = 0; c < cols; c++) {\r\n\t\t\t\tconst idx = r * cols + c;\r\n\t\t\t\tif (visitedCells[idx]) continue;\r\n\r\n\t\t\t\tconst region: Point[] = [];\r\n\t\t\t\tconst queue: number[] = [idx];\r\n\t\t\t\tvisitedCells[idx] = 1;\r\n\r\n\t\t\t\tlet head = 0;\r\n\t\t\t\twhile (head < queue.length) {\r\n\t\t\t\t\tconst currIdx = queue[head++];\r\n\t\t\t\t\tconst cx = currIdx % cols;\r\n\t\t\t\t\tconst cy = Math.floor(currIdx / cols);\r\n\t\t\t\t\tregion.push({ x: cx, y: cy });\r\n\r\n\t\t\t\t\tif (cy > 0 && !hEdgesMask[cy * cols + cx]) {\r\n\t\t\t\t\t\tconst nIdx = (cy - 1) * cols + cx;\r\n\t\t\t\t\t\tif (!visitedCells[nIdx]) {\r\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\r\n\t\t\t\t\t\t\tqueue.push(nIdx);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (cy < rows - 1 && !hEdgesMask[(cy + 1) * cols + cx]) {\r\n\t\t\t\t\t\tconst nIdx = (cy + 1) * cols + cx;\r\n\t\t\t\t\t\tif (!visitedCells[nIdx]) {\r\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\r\n\t\t\t\t\t\t\tqueue.push(nIdx);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (cx > 0 && !vEdgesMask[cy * (cols + 1) + cx]) {\r\n\t\t\t\t\t\tconst nIdx = cy * cols + (cx - 1);\r\n\t\t\t\t\t\tif (!visitedCells[nIdx]) {\r\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\r\n\t\t\t\t\t\t\tqueue.push(nIdx);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (cx < cols - 1 && !vEdgesMask[cy * (cols + 1) + (cx + 1)]) {\r\n\t\t\t\t\t\tconst nIdx = cy * cols + (cx + 1);\r\n\t\t\t\t\t\tif (!visitedCells[nIdx]) {\r\n\t\t\t\t\t\t\tvisitedCells[nIdx] = 1;\r\n\t\t\t\t\t\t\tqueue.push(nIdx);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tregions.push(region);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn regions;\r\n\t}\r\n\r\n\tprivate isAbsentEdge(grid: Grid, p1: Point, p2: Point): boolean {\r\n\t\tif (p1.x === p2.x) {\r\n\t\t\tconst y = Math.min(p1.y, p2.y);\r\n\t\t\treturn grid.vEdges[y][p1.x].type === EdgeType.Absent;\r\n\t\t} else {\r\n\t\t\tconst x = Math.min(p1.x, p2.x);\r\n\t\t\treturn grid.hEdges[p1.y][x].type === EdgeType.Absent;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u533A\u753B\u306E\u5883\u754C\u30A8\u30C3\u30B8\u306E\u3046\u3061\u3001\u89E3\u30D1\u30B9\u304C\u901A\u3063\u3066\u3044\u306A\u3044\u3082\u306E\u3092\u53D6\u5F97\u3059\u308B\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t * @param region \u533A\u753B\r\n\t * @param path \u89E3\u7B54\u30D1\u30B9\r\n\t * @param symPath \u5BFE\u79F0\u30D1\u30B9\r\n\t * @returns \u5883\u754C\u30A8\u30C3\u30B8\u306E\u30EA\u30B9\u30C8\r\n\t */\r\n\tprivate getRegionBoundaryEdges(grid: Grid, region: Point[], path: Point[], symPath: Point[] = []): { type: \"h\" | \"v\"; r: number; c: number }[] {\r\n\t\tconst pathEdges = new Set<string>();\r\n\t\tfor (let i = 0; i < path.length - 1; i++) pathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\r\n\t\tfor (let i = 0; i < symPath.length - 1; i++) pathEdges.add(this.getEdgeKey(symPath[i], symPath[i + 1]));\r\n\r\n\t\tconst boundary: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\r\n\t\tfor (const cell of region) {\r\n\t\t\tconst edges = [\r\n\t\t\t\t{ type: \"h\" as const, r: cell.y, c: cell.x },\r\n\t\t\t\t{ type: \"h\" as const, r: cell.y + 1, c: cell.x },\r\n\t\t\t\t{ type: \"v\" as const, r: cell.y, c: cell.x },\r\n\t\t\t\t{ type: \"v\" as const, r: cell.y, c: cell.x + 1 },\r\n\t\t\t];\r\n\t\t\tfor (const e of edges) {\r\n\t\t\t\tconst p1 = e.type === \"h\" ? { x: e.c, y: e.r } : { x: e.c, y: e.r };\r\n\t\t\t\tconst p2 = e.type === \"h\" ? { x: e.c + 1, y: e.r } : { x: e.c, y: e.r + 1 };\r\n\t\t\t\tconst key = this.getEdgeKey(p1, p2);\r\n\t\t\t\tif (!pathEdges.has(key) && !this.isAbsentEdge(grid, p1, p2)) {\r\n\t\t\t\t\tboundary.push(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// \u91CD\u8907\u3092\u524A\u9664\r\n\t\tconst unique = new Map<string, { type: \"h\" | \"v\"; r: number; c: number }>();\r\n\t\tfor (const e of boundary) unique.set(`${e.type},${e.r},${e.c}`, e);\r\n\t\treturn Array.from(unique.values());\r\n\t}\r\n\r\n\tprivate setEdgeHexagon(grid: Grid, p1: Point, p2: Point, type: EdgeType = EdgeType.Hexagon) {\r\n\t\tif (p1.x === p2.x) grid.vEdges[Math.min(p1.y, p2.y)][p1.x].type = type;\r\n\t\telse grid.hEdges[p1.y][Math.min(p1.x, p2.x)].type = type;\r\n\t}\r\n\r\n\tprivate hasIncidentHexagonEdge(grid: Grid, p: Point): boolean {\r\n\t\tconst isHex = (t: EdgeType) => t === EdgeType.Hexagon || t === EdgeType.HexagonMain || t === EdgeType.HexagonSymmetry;\r\n\t\tif (p.x > 0 && isHex(grid.hEdges[p.y][p.x - 1].type)) return true;\r\n\t\tif (p.x < grid.cols && isHex(grid.hEdges[p.y][p.x].type)) return true;\r\n\t\tif (p.y > 0 && isHex(grid.vEdges[p.y - 1][p.x].type)) return true;\r\n\t\tif (p.y < grid.rows && isHex(grid.vEdges[p.y][p.x].type)) return true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprivate isEdgeAdjacentToHexagonNode(grid: Grid, edge: { type: \"h\" | \"v\"; r: number; c: number }): boolean {\r\n\t\tconst isHex = (t: NodeType) => t === NodeType.Hexagon || t === NodeType.HexagonMain || t === NodeType.HexagonSymmetry;\r\n\t\tif (edge.type === \"h\") {\r\n\t\t\treturn isHex(grid.nodes[edge.r][edge.c].type) || isHex(grid.nodes[edge.r][edge.c + 1].type);\r\n\t\t} else {\r\n\t\t\treturn isHex(grid.nodes[edge.r][edge.c].type) || isHex(grid.nodes[edge.r + 1][edge.c].type);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u8981\u6C42\u3055\u308C\u305F\u5236\u7D04\u304C\u5168\u3066\u542B\u307E\u308C\u3066\u3044\u308B\u304B\u78BA\u8A8D\u3059\u308B\r\n\t * @param grid \u30B0\u30EA\u30C3\u30C9\r\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\r\n\t * @returns \u5168\u3066\u306E\u8981\u6C42\u3055\u308C\u305F\u5236\u7D04\u304C\u542B\u307E\u308C\u3066\u3044\u308B\u304B\r\n\t */\r\n\tprivate checkAllRequestedConstraintsPresent(grid: Grid, options: GenerationOptions): boolean {\r\n\t\tconst useHexagons = options.useHexagons ?? true;\r\n\t\tconst useSquares = options.useSquares ?? true;\r\n\t\tconst useStars = options.useStars ?? true;\r\n\t\tconst useTetris = options.useTetris ?? false;\r\n\t\tconst useTetrisNegative = options.useTetrisNegative ?? false;\r\n\t\tconst useEraser = options.useEraser ?? false;\r\n\t\tconst useTriangles = options.useTriangles ?? false;\r\n\t\tconst useBrokenEdges = options.useBrokenEdges ?? false;\r\n\r\n\t\tif (useBrokenEdges) {\r\n\t\t\tlet found = false;\r\n\t\t\tfor (let r = 0; r <= grid.rows; r++)\r\n\t\t\t\tfor (let c = 0; c < grid.cols; c++)\r\n\t\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Broken || grid.hEdges[r][c].type === EdgeType.Absent) {\r\n\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\tif (!found)\r\n\t\t\t\tfor (let r = 0; r < grid.rows; r++)\r\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++)\r\n\t\t\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Broken || grid.vEdges[r][c].type === EdgeType.Absent) {\r\n\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\tif (!found) return false;\r\n\t\t}\r\n\t\tif (useHexagons) {\r\n\t\t\tlet found = false;\r\n\t\t\tconst isHexEdge = (t: EdgeType) => t === EdgeType.Hexagon || t === EdgeType.HexagonMain || t === EdgeType.HexagonSymmetry;\r\n\t\t\tconst isHexNode = (t: NodeType) => t === NodeType.Hexagon || t === NodeType.HexagonMain || t === NodeType.HexagonSymmetry;\r\n\r\n\t\t\tfor (let r = 0; r <= grid.rows; r++)\r\n\t\t\t\tfor (let c = 0; c < grid.cols; c++)\r\n\t\t\t\t\tif (isHexEdge(grid.hEdges[r][c].type)) {\r\n\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\tif (!found)\r\n\t\t\t\tfor (let r = 0; r < grid.rows; r++)\r\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++)\r\n\t\t\t\t\t\tif (isHexEdge(grid.vEdges[r][c].type)) {\r\n\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\tif (!found)\r\n\t\t\t\tfor (let r = 0; r <= grid.rows; r++)\r\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++)\r\n\t\t\t\t\t\tif (isHexNode(grid.nodes[r][c].type)) {\r\n\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\tif (!found) return false;\r\n\t\t}\r\n\t\tif (useSquares || useStars || useTetris || useEraser) {\r\n\t\t\tlet fSq = false;\r\n\t\t\tlet fSt = false;\r\n\t\t\tlet fT = false;\r\n\t\t\tlet fTN = false;\r\n\t\t\tlet fE = false;\r\n\t\t\tlet fTri = false;\r\n\t\t\tconst sqC = new Set<number>();\r\n\t\t\tconst stC = new Set<number>();\r\n\t\t\tfor (let r = 0; r < grid.rows; r++)\r\n\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\r\n\t\t\t\t\tconst type = grid.cells[r][c].type;\r\n\t\t\t\t\tif (type === CellType.Square) {\r\n\t\t\t\t\t\tfSq = true;\r\n\t\t\t\t\t\tsqC.add(grid.cells[r][c].color);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (type === CellType.Star) {\r\n\t\t\t\t\t\tfSt = true;\r\n\t\t\t\t\t\tstC.add(grid.cells[r][c].color);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (type === CellType.Tetris || type === CellType.TetrisRotated) fT = true;\r\n\t\t\t\t\tif (type === CellType.TetrisNegative || type === CellType.TetrisNegativeRotated) fTN = true;\r\n\t\t\t\t\tif (type === CellType.Eraser) fE = true;\r\n\t\t\t\t\tif (type === CellType.Triangle) fTri = true;\r\n\t\t\t\t}\r\n\t\t\tif (useSquares && !fSq) return false;\r\n\t\t\tif (useStars && !fSt) return false;\r\n\t\t\tif (useTetris && !fT) return false;\r\n\t\t\tif (useTetrisNegative && !fTN) return false;\r\n\t\t\tif (useEraser && !fE) return false;\r\n\t\t\tif (useTriangles && !fTri) return false;\r\n\r\n\t\t\t// \u56DB\u89D2\u5F62\u306E\u8FFD\u52A0\u5236\u7D04: \u4ED6\u306E\u8272\u306E\u56DB\u89D2\u5F62\u3001\u307E\u305F\u306F\u540C\u8272\u306E\u661F\u304C\u5B58\u5728\u3057\u306A\u3044\u5834\u5408\u306F2\u8272\u4EE5\u4E0A\u5FC5\u8981\r\n\t\t\tif (useSquares && fSq) {\r\n\t\t\t\tif (sqC.size < 2) {\r\n\t\t\t\t\tconst onlyColor = sqC.values().next().value;\r\n\t\t\t\t\tif (onlyColor === undefined || !stC.has(onlyColor)) return false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this.hasIsolatedMark(grid)) return false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * \u6307\u5B9A\u3055\u308C\u305F\u533A\u753B\u3092\u30D4\u30FC\u30B9\u3067\u57CB\u3081\u5C3D\u304F\u3059\u30BF\u30A4\u30EA\u30F3\u30B0\u3092\u751F\u6210\u3059\u308B\r\n\t * @param region \u533A\u753B\r\n\t * @param maxPieces \u6700\u5927\u30D4\u30FC\u30B9\u6570\r\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\r\n\t * @returns \u30BF\u30A4\u30EA\u30F3\u30B0\u7D50\u679C\r\n\t */\r\n\tprivate generateTiling(region: Point[], maxPieces: number, options: GenerationOptions): { shape: number[][]; displayShape: number[][]; isRotated: boolean }[] | null {\r\n\t\tconst minX = Math.min(...region.map((p) => p.x));\r\n\t\tconst minY = Math.min(...region.map((p) => p.y));\r\n\t\tconst maxX = Math.max(...region.map((p) => p.x));\r\n\t\tconst maxY = Math.max(...region.map((p) => p.y));\r\n\t\tconst width = maxX - minX + 1;\r\n\t\tconst height = maxY - minY + 1;\r\n\t\tconst regionGrid = Array.from({ length: height }, () => Array(width).fill(false));\r\n\t\tfor (const p of region) regionGrid[p.y - minY][p.x - minX] = true;\r\n\t\treturn this.tilingDfs(regionGrid, [], maxPieces, options);\r\n\t}\r\n\r\n\t/**\r\n\t * \u30BF\u30A4\u30EA\u30F3\u30B0\u3092\u6DF1\u3055\u512A\u5148\u63A2\u7D22\u3067\u751F\u6210\u3059\u308B\r\n\t * @param regionGrid \u9818\u57DF\u306E\u30B0\u30EA\u30C3\u30C9\u8868\u73FE\r\n\t * @param currentPieces \u73FE\u5728\u914D\u7F6E\u6E08\u307F\u306E\u30D4\u30FC\u30B9\r\n\t * @param maxPieces \u6700\u5927\u30D4\u30FC\u30B9\u6570\r\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\r\n\t * @returns \u6210\u529F\u3057\u305F\u5834\u5408\u306F\u30D4\u30FC\u30B9\u306E\u30EA\u30B9\u30C8\u3001\u5931\u6557\u3057\u305F\u5834\u5408\u306Fnull\r\n\t */\r\n\tprivate tilingDfs(regionGrid: boolean[][], currentPieces: { shape: number[][]; displayShape: number[][]; isRotated: boolean }[], maxPieces: number, options: GenerationOptions): { shape: number[][]; displayShape: number[][]; isRotated: boolean }[] | null {\r\n\t\tlet r0 = -1;\r\n\t\tlet c0 = -1;\r\n\t\tfor (let r = 0; r < regionGrid.length; r++) {\r\n\t\t\tfor (let c = 0; c < regionGrid[0].length; c++)\r\n\t\t\t\tif (regionGrid[r][c]) {\r\n\t\t\t\t\tr0 = r;\r\n\t\t\t\t\tc0 = c;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\tif (r0 !== -1) break;\r\n\t\t}\r\n\t\tif (r0 === -1) return currentPieces;\r\n\t\tif (currentPieces.length >= maxPieces) return null;\r\n\r\n\t\tconst difficulty = options.difficulty ?? 0.5;\r\n\t\tconst indices = Array.from({ length: this.TETRIS_SHAPES.length }, (_, i) => i);\r\n\t\tthis.shuffleArray(indices);\r\n\t\tif (difficulty > 0.6) indices.sort((a, b) => this.getShapeArea(this.TETRIS_SHAPES[b]) - this.getShapeArea(this.TETRIS_SHAPES[a]));\r\n\r\n\t\tfor (const idx of indices) {\r\n\t\t\tconst baseShape = this.TETRIS_SHAPES[idx];\r\n\t\t\tconst rotations = this.TETRIS_SHAPES_WITH_ROTATIONS[idx];\r\n\t\t\tconst rotIndices = Array.from({ length: rotations.length }, (_, i) => i);\r\n\t\t\tthis.shuffleArray(rotIndices);\r\n\r\n\t\t\tfor (const rotIdx of rotIndices) {\r\n\t\t\t\tconst shape = rotations[rotIdx];\r\n\t\t\t\tconst blocks: { r: number; c: number }[] = [];\r\n\t\t\t\tfor (let pr = 0; pr < shape.length; pr++) for (let pc = 0; pc < shape[0].length; pc++) if (shape[pr][pc]) blocks.push({ r: pr, c: pc });\r\n\t\t\t\tfor (const anchor of blocks) {\r\n\t\t\t\t\tconst dr = r0 - anchor.r;\r\n\t\t\t\t\tconst dc = c0 - anchor.c;\r\n\t\t\t\t\tif (this.canPlace(regionGrid, shape, dr, dc)) {\r\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, false);\r\n\t\t\t\t\t\tconst isRotated = rotations.length > 1 && this.rng!.next() < 0.3 + difficulty * 0.6;\r\n\t\t\t\t\t\tconst result = this.tilingDfs(regionGrid, [...currentPieces, { shape, displayShape: baseShape, isRotated }], maxPieces, options);\r\n\t\t\t\t\t\tif (result) return result;\r\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tprivate getShapeArea(shape: number[][]): number {\r\n\t\tlet area = 0;\r\n\t\tfor (const row of shape) for (const cell of row) if (cell) area++;\r\n\t\treturn area;\r\n\t}\r\n\tprivate isRotationallyInvariant(shape: number[][]): boolean {\r\n\t\treturn this.getAllRotations(shape).length === 1;\r\n\t}\r\n\tprivate getAllRotations(shape: number[][]): number[][][] {\r\n\t\tconst results: number[][][] = [];\r\n\t\tconst keys = new Set<string>();\r\n\t\tlet curr = shape;\r\n\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\tconst key = JSON.stringify(curr);\r\n\t\t\tif (!keys.has(key)) {\r\n\t\t\t\tresults.push(curr);\r\n\t\t\t\tkeys.add(key);\r\n\t\t\t}\r\n\t\t\tcurr = this.rotate90(curr);\r\n\t\t}\r\n\t\treturn results;\r\n\t}\r\n\tprivate rotate90(shape: number[][]): number[][] {\r\n\t\tconst rows = shape.length;\r\n\t\tconst cols = shape[0].length;\r\n\t\tconst newShape = Array.from({ length: cols }, () => Array(rows).fill(0));\r\n\t\tfor (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) newShape[c][rows - 1 - r] = shape[r][c];\r\n\t\treturn newShape;\r\n\t}\r\n\tprivate canPlace(regionGrid: boolean[][], shape: number[][], r: number, c: number): boolean {\r\n\t\tfor (let i = 0; i < shape.length; i++)\r\n\t\t\tfor (let j = 0; j < shape[0].length; j++)\r\n\t\t\t\tif (shape[i][j]) {\r\n\t\t\t\t\tconst nr = r + i,\r\n\t\t\t\t\t\tnc = c + j;\r\n\t\t\t\t\tif (nr < 0 || nr >= regionGrid.length || nc < 0 || nc >= regionGrid[0].length || !regionGrid[nr][nc]) return false;\r\n\t\t\t\t}\r\n\t\treturn true;\r\n\t}\r\n\tprivate placePiece(regionGrid: boolean[][], shape: number[][], r: number, c: number, value: boolean) {\r\n\t\tfor (let i = 0; i < shape.length; i++) for (let j = 0; j < shape[0].length; j++) if (shape[i][j]) regionGrid[r + i][c + j] = value;\r\n\t}\r\n\tprivate isSameShape(s1: number[][], s2: number[][]): boolean {\r\n\t\tconst rotations = this.getAllRotations(s1);\r\n\t\tconst s2Str = JSON.stringify(s2);\r\n\t\treturn rotations.some((r) => JSON.stringify(r) === s2Str);\r\n\t}\r\n\tprivate countRegionNonEraserSymbols(grid: Grid, region: Point[]): number {\r\n\t\tlet count = 0;\r\n\t\tfor (const cell of region) {\r\n\t\t\tconst type = grid.cells[cell.y][cell.x].type;\r\n\t\t\tif (type !== CellType.None && type !== CellType.Eraser) count++;\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\r\n\tprivate hasRegionTetrisSymbol(grid: Grid, region: Point[]): boolean {\r\n\t\tfor (const cell of region) {\r\n\t\t\tconst type = grid.cells[cell.y][cell.x].type;\r\n\t\t\tif (type === CellType.Tetris || type === CellType.TetrisRotated) return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprivate canPlaceGeneratedTetrisNegative(grid: Grid, region: Point[], potentialCells: Point[]): boolean {\r\n\t\tif (potentialCells.length < 1) return false;\r\n\t\tif (this.hasRegionTetrisSymbol(grid, region)) return true;\r\n\t\t// \u65E2\u5B58\u30C6\u30C8\u30EA\u30B9\u304C\u7121\u3044\u5834\u5408\u306F\u3001\u5BFE\u5FDC\u3059\u308B\u30C6\u30C8\u30EA\u30B9\u3092\u5225\u30BB\u30EB\u306B\u7F6E\u3051\u308B\u7A7A\u304D\u304C\u5FC5\u8981\r\n\t\treturn potentialCells.length >= 2;\r\n\t}\r\n\r\n\tprivate canPlaceGeneratedEraser(grid: Grid, region: Point[], potentialCells: Point[]): boolean {\r\n\t\tif (potentialCells.length < 1) return false;\r\n\t\tif (this.countRegionNonEraserSymbols(grid, region) > 0) return true;\r\n\t\t// \u65E2\u5B58\u306E\u6D88\u53BB\u5BFE\u8C61\u304C\u7121\u3044\u5834\u5408\u306F\u3001\u5BFE\u5FDC\u8981\u7D20\u3092\u7F6E\u304F\u305F\u3081\u306E\u7A7A\u304D\u3092\u6700\u4F4E1\u30BB\u30EB\u78BA\u4FDD\u3059\u308B\r\n\t\treturn potentialCells.length >= 2;\r\n\t}\r\n\tprivate canTilePieceWith(p: number[][], t: number[][], n: number[][]): boolean {\r\n\t\tconst areaP = this.getShapeArea(p);\r\n\t\tconst areaT = this.getShapeArea(t);\r\n\t\tconst areaN = this.getShapeArea(n);\r\n\t\tif (areaP !== areaT + areaN) return false;\r\n\r\n\t\tconst rotationsT = this.getAllRotations(t);\r\n\t\tconst rotationsN = this.getAllRotations(n);\r\n\t\tconst hP = p.length,\r\n\t\t\twP = p[0].length;\r\n\r\n\t\tfor (const rt of rotationsT) {\r\n\t\t\tfor (const rn of rotationsN) {\r\n\t\t\t\tconst hT = rt.length,\r\n\t\t\t\t\twT = rt[0].length;\r\n\t\t\t\tconst hN = rn.length,\r\n\t\t\t\t\twN = rn[0].length;\r\n\t\t\t\tfor (let rT = 0; rT <= hP - hT; rT++) {\r\n\t\t\t\t\tfor (let cT = 0; cT <= wP - wT; cT++) {\r\n\t\t\t\t\t\tfor (let rN = 0; rN <= hP - hN; rN++) {\r\n\t\t\t\t\t\t\tfor (let cN = 0; cN <= wP - wN; cN++) {\r\n\t\t\t\t\t\t\t\tconst grid = Array.from({ length: hP }, () => Array(wP).fill(0));\r\n\t\t\t\t\t\t\t\tlet possible = true;\r\n\t\t\t\t\t\t\t\t// Place T\r\n\t\t\t\t\t\t\t\tfor (let r = 0; r < hT; r++) {\r\n\t\t\t\t\t\t\t\t\tfor (let c = 0; c < wT; c++) {\r\n\t\t\t\t\t\t\t\t\t\tif (rt[r][c]) grid[rT + r][cT + c] = 1;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// Place N\r\n\t\t\t\t\t\t\t\tfor (let r = 0; r < hN; r++) {\r\n\t\t\t\t\t\t\t\t\tfor (let c = 0; c < wN; c++) {\r\n\t\t\t\t\t\t\t\t\t\tif (rn[r][c]) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (grid[rN + r][cN + c]) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tpossible = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tgrid[rN + r][cN + c] = 1;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!possible) break;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (possible) {\r\n\t\t\t\t\t\t\t\t\t// Check if matches P\r\n\t\t\t\t\t\t\t\t\tlet matches = true;\r\n\t\t\t\t\t\t\t\t\tfor (let r = 0; r < hP; r++) {\r\n\t\t\t\t\t\t\t\t\t\tfor (let c = 0; c < wP; c++) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (grid[r][c] !== p[r][c]) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tmatches = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (!matches) break;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (matches) return true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\tprivate findStandardTriple(t: number[][]): { p: number[][]; n: number[][] } | null {\r\n\t\tconst areaT = this.getShapeArea(t);\r\n\t\tconst nCandidates = [...this.TETRIS_SHAPES];\r\n\t\tthis.shuffleArray(nCandidates);\r\n\r\n\t\tfor (const n of nCandidates) {\r\n\t\t\tconst areaN = this.getShapeArea(n);\r\n\t\t\tconst areaP = areaT + areaN;\r\n\t\t\tif (areaP > 5) continue;\r\n\t\t\tconst pCandidates = this.TETRIS_SHAPES.filter((s) => this.getShapeArea(s) === areaP);\r\n\t\t\tfor (const p of pCandidates) {\r\n\t\t\t\tif (this.canTilePieceWith(p, t, n)) return { p, n };\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\tprivate shuffleArray<T>(array: T[]) {\r\n\t\tfor (let i = array.length - 1; i > 0; i--) {\r\n\t\t\tconst j = Math.floor(this.rng!.next() * (i + 1));\r\n\t\t\t[array[i], array[j]] = [array[j], array[i]];\r\n\t\t}\r\n\t}\r\n}\r\n", "import { CellType, Color, EdgeType, NodeType, SymmetryType, type CellConstraint, type Point, type PuzzleData, type ValidationResult } from \"./types\";\r\n\r\n/**\r\n * UI\u8868\u793A\u8A2D\u5B9A\r\n */\r\nexport interface WitnessUIOptions {\r\n\t/** \u7DDA\u3092\u5F15\u304F\u64CD\u4F5C\u30E2\u30FC\u30C9 */\r\n\tinputMode?: \"drag\" | \"twoClick\";\r\n\t/** \u30B0\u30EA\u30C3\u30C9\u5468\u56F2\u306E\u4F59\u767D */\r\n\tgridPadding?: number;\r\n\t/** \u30BB\u30EB1\u8FBA\u306E\u30B5\u30A4\u30BA */\r\n\tcellSize?: number;\r\n\t/** \u901A\u5E38\u30CE\u30FC\u30C9\u306E\u534A\u5F84 */\r\n\tnodeRadius?: number;\r\n\t/** \u958B\u59CB\u30CE\u30FC\u30C9\u306E\u534A\u5F84 */\r\n\tstartNodeRadius?: number;\r\n\t/** \u30D1\u30B9\u306E\u592A\u3055 */\r\n\tpathWidth?: number;\r\n\t/** \u51FA\u53E3\u306E\u9577\u3055 */\r\n\texitLength?: number;\r\n\t/** \u30D1\u30BA\u30EB\u306E\u30B5\u30A4\u30BA\u306B\u5408\u308F\u305B\u3066Canvas\u30B5\u30A4\u30BA\u3092\u81EA\u52D5\u8ABF\u6574\u3059\u308B\u304B */\r\n\tautoResize?: boolean;\r\n\t/** \u5931\u6557\u6642\u306B\u30DE\u30FC\u30AF\u3092\u8D64\u304F\u70B9\u6EC5\u3055\u305B\u308B\u304B */\r\n\tblinkMarksOnError?: boolean;\r\n\t/** \u5931\u6557\u6642\u306B\u5F15\u3044\u305F\u7DDA\uFF08\u5BFE\u79F0\u7DDA\u542B\u3080\uFF09\u3092\u6B8B\u3059\u304B\uFF08false\u306E\u5834\u5408\u306F\u30D5\u30A7\u30FC\u30C9\u30A2\u30A6\u30C8\u3059\u308B\uFF09 */\r\n\tstayPathOnError?: boolean;\r\n\t/** \u30D1\u30B9\u304C\u5B8C\u4E86\u3057\u305F\u969B\u306B\u81EA\u52D5\u7684\u306B\u30D0\u30EA\u30C7\u30FC\u30B7\u30E7\u30F3\u3092\u5B9F\u884C\u3059\u308B\u304B (Worker\u30E2\u30FC\u30C9\u6642\u306E\u307F\u6709\u52B9) */\r\n\tautoValidate?: boolean;\r\n\t/** WebWorker\u3092\u4F7F\u7528\u3057\u3066\u751F\u6210\u30FB\u691C\u8A3C\u3092\u884C\u3046\u304B */\r\n\tuseWorker?: boolean;\r\n\t/** Worker\u30B9\u30AF\u30EA\u30D7\u30C8\u306E\u30D1\u30B9 (\u30C7\u30D5\u30A9\u30EB\u30C8\u306F import.meta.url) */\r\n\tworkerScript?: string;\r\n\t/** \u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u8A2D\u5B9A */\r\n\tanimations?: {\r\n\t\t/** \u70B9\u6EC5\u30FB\u524D\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u306E\u6642\u9593(ms) */\r\n\t\tblinkDuration: number;\r\n\t\t/** \u7121\u52B9\u5316\u30D5\u30A7\u30FC\u30C9\u306E\u6642\u9593(ms) */\r\n\t\tfadeDuration: number;\r\n\t\t/** \u70B9\u6EC5\u306E\u5468\u671F(ms) */\r\n\t\tblinkPeriod: number;\r\n\t};\r\n\t/** \u8272\u8A2D\u5B9A */\r\n\tcolors?: {\r\n\t\t/** \u901A\u5E38\u306E\u30D1\u30B9\u306E\u8272 */\r\n\t\tpath?: string;\r\n\t\t/** \u30A8\u30E9\u30FC\u6642\u306E\u8272 */\r\n\t\terror?: string;\r\n\t\t/** \u6210\u529F\u6642\u306E\u30D5\u30E9\u30C3\u30B7\u30E5/\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u7528 */\r\n\t\tsuccess?: string;\r\n\t\t/** \u5BFE\u79F0\u30D1\u30B9\u306E\u8272 */\r\n\t\tsymmetry?: string;\r\n\t\t/** \u9014\u4E2D\u3067\u96E2\u3057\u305F\u969B\u306E\u30D5\u30A7\u30FC\u30C9\u8272 */\r\n\t\tinterrupted?: string;\r\n\t\t/** \u30B0\u30EA\u30C3\u30C9\u306E\u8272 */\r\n\t\tgrid?: string;\r\n\t\t/** \u30CE\u30FC\u30C9\u306E\u8272 */\r\n\t\tnode?: string;\r\n\t\t/** \u516D\u89D2\u5F62\uFF08\u901A\u904E\u5FC5\u9808\uFF09\u306E\u8272 */\r\n\t\thexagon?: string;\r\n\t\t/** \u30E1\u30A4\u30F3\u7DDA\u306E\u307F\u306E\u516D\u89D2\u5F62\u306E\u8272 */\r\n\t\thexagonMain?: string;\r\n\t\t/** \u5BFE\u79F0\u7DDA\u306E\u307F\u306E\u516D\u89D2\u5F62\u306E\u8272 */\r\n\t\thexagonSymmetry?: string;\r\n\t\t/** \u5404\u8272\u306E\u30AB\u30E9\u30FC\u30B3\u30FC\u30C9\u30DE\u30C3\u30D7 */\r\n\t\tcolorMap?: Record<number, string>;\r\n\t\t/** \u5404\u8272\u306E\u30AB\u30E9\u30FC\u30B3\u30FC\u30C9\u30EA\u30B9\u30C8\uFF08\u30A4\u30F3\u30C7\u30C3\u30AF\u30B9\u304CColor\u5024\u306B\u5BFE\u5FDC\uFF09 */\r\n\t\tcolorList?: string[];\r\n\t};\r\n\t/** \u30D1\u30BA\u30EB\u5168\u4F53\u306B\u639B\u3051\u308B\u30AB\u30E9\u30FC\u30D5\u30A3\u30EB\u30BF\u30FC\u8A2D\u5B9A */\r\n\tfilter?: {\r\n\t\t/** \u30D5\u30A3\u30EB\u30BF\u30FC\u3092\u6709\u52B9\u5316\u3059\u308B\u304B */\r\n\t\tenabled?: boolean;\r\n\t\t/** \u30AB\u30B9\u30BF\u30E0\u5358\u8272\u304B\u3001RGB 3\u8272\u30D7\u30EA\u30BB\u30C3\u30C8\u304B */\r\n\t\tmode?: \"custom\" | \"rgb\";\r\n\t\t/** custom\u30E2\u30FC\u30C9\u6642\u306B\u4F7F\u7528\u3059\u308B\u8272 */\r\n\t\tcustomColor?: string;\r\n\t\t/** rgb\u30E2\u30FC\u30C9\u6642\u306E3\u8272\u30D5\u30A3\u30EB\u30BF\u30FC */\r\n\t\trgbColors?: [string, string, string];\r\n\t\t/** rgb\u30E2\u30FC\u30C9\u6642\u306B\u4F7F\u7528\u3059\u308B\u8272\u30A4\u30F3\u30C7\u30C3\u30AF\u30B9 */\r\n\t\trgbIndex?: 0 | 1 | 2;\r\n\t\t/** \u767D\u9ED2\u5316\u306E\u3057\u304D\u3044\u5024 (0-255) */\r\n\t\tthreshold?: number;\r\n\t};\r\n\t/** \u9AD8\u89E3\u50CF\u5EA6\u30C7\u30A3\u30B9\u30D7\u30EC\u30A4(Retina\u7B49)\u306B\u5BFE\u5FDC\u3055\u305B\u308B\u305F\u3081\u306E\u30D4\u30AF\u30BB\u30EB\u6BD4\u3002\u7701\u7565\u6642\u306Fwindow.devicePixelRatio\u304C\u4F7F\u7528\u3055\u308C\u307E\u3059\u3002 */\r\n\tpixelRatio?: number;\r\n}\r\n\r\n/**\r\n * WitnessUI\u304C\u767A\u884C\u3059\u308B\u30A4\u30D9\u30F3\u30C8\u306E\u30DE\u30C3\u30D7\r\n */\r\nexport interface WitnessEventMap {\r\n\t/** \u63CF\u753B\u306E\u76F4\u524D (\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u304C\u6E21\u3055\u308C\u308B) */\r\n\t\"render:before\": { ctx: WitnessContext };\r\n\t/** \u63CF\u753B\u306E\u76F4\u5F8C (\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u304C\u6E21\u3055\u308C\u308B) */\r\n\t\"render:after\": { ctx: WitnessContext };\r\n\t/** \u30D1\u30B9\u306E\u63CF\u304D\u59CB\u3081 (\u30B0\u30EA\u30C3\u30C9\u5EA7\u6A19) */\r\n\t\"path:start\": { x: number; y: number; startIndex: number };\r\n\t/** \u30D1\u30B9\u306E\u79FB\u52D5\u4E2D (\u30B0\u30EA\u30C3\u30C9\u5EA7\u6A19\u3001\u30D1\u30B9\u5168\u4F53\u3001\u73FE\u5728\u306E\u30DE\u30A6\u30B9\u4F4D\u7F6E) */\r\n\t\"path:move\": { x: number; y: number; path: Point[]; currentMousePos: Point };\r\n\t/** \u30D1\u30B9\u306E\u7D42\u4E86 (\u30D1\u30B9\u5168\u4F53\u3001\u51FA\u53E3\u306B\u5230\u9054\u3057\u305F\u304B) */\r\n\t\"path:end\": { path: Point[]; isExit: boolean; startNode: { x: number; y: number; index: number } | null; endNode: { x: number; y: number; index: number } | null };\r\n\t/** \u30D1\u30B9\u304C\u5B8C\u4E86\u3057\u3001\u51FA\u53E3\u306B\u5230\u9054\u3057\u305F\u77AC\u9593 */\r\n\t\"path:complete\": { path: Point[]; startNode: { x: number; y: number; index: number } | null; endNode: { x: number; y: number; index: number } | null };\r\n\t/** \u30B4\u30FC\u30EB\u53EF\u80FD\u72B6\u614B\uFF08\u5148\u7AEF\u304C\u30B4\u30FC\u30EB\u306E\u51FA\u3063\u5F35\u308A\u306B\u8FD1\u3044\uFF09\u306E\u5909\u5316 */\r\n\t\"goal:reachable\": { reachable: boolean };\r\n\t/** \u30B4\u30FC\u30EB\u306B\u5230\u9054\u3057\u3001\u6210\u529F\u307E\u305F\u306F\u5931\u6557\u306E\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u304C\u958B\u59CB\u3055\u308C\u305F\u6642 */\r\n\t\"goal:reached\": { path: Point[]; isValid: boolean; startNode: { x: number; y: number; index: number } | null; endNode: { x: number; y: number; index: number } | null };\r\n\t/** \u7121\u52B9\u5316\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\uFF08\u6D88\u3057\u30B4\u30E0\u7B49\uFF09\u304C\u7D42\u4E86\u3057\u3001\u5B8C\u5168\u306B\u30D0\u30EA\u30C7\u30FC\u30B7\u30E7\u30F3\u8868\u793A\u304C\u5B8C\u4E86\u3057\u305F\u6642 */\r\n\t\"goal:validated\": { result: ValidationResult };\r\n\t/** Worker\u3067\u65B0\u3057\u3044\u30D1\u30BA\u30EB\u304C\u751F\u6210\u3055\u308C\u305F\u6642 */\r\n\t\"puzzle:generated\": { puzzle: PuzzleData; genOptions: any };\r\n\t/** \u65B0\u3057\u3044\u30D1\u30BA\u30EB\u304C\u30BB\u30C3\u30C8\u3055\u308C\u305F\u6642 */\r\n\t\"puzzle:created\": { puzzle: PuzzleData };\r\n}\r\n\r\nexport type WitnessEventName = keyof WitnessEventMap;\r\n\r\ntype WitnessContext = CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\r\n\r\nexport type WitnessHitTarget = { kind: \"node\"; x: number; y: number } | { kind: \"cell\"; r: number; c: number } | { kind: \"hEdge\"; r: number; c: number } | { kind: \"vEdge\"; r: number; c: number };\r\n\r\n/**\r\n * the witness\u30D1\u30BA\u30EB\u306E\u63CF\u753B\u3068\u30E6\u30FC\u30B6\u30FC\u64CD\u4F5C\u3092\u7BA1\u7406\u3059\u308B\u30AF\u30E9\u30B9\r\n */\r\nexport class WitnessUI {\r\n\tprivate canvas: HTMLCanvasElement | OffscreenCanvas;\r\n\tprivate ctx: WitnessContext | null = null;\r\n\tprivate worker: Worker | null = null;\r\n\tprivate puzzle: PuzzleData | null = null;\r\n\tprivate options: Required<WitnessUIOptions>;\r\n\tprivate listeners: Map<string, Set<Function>> = new Map();\r\n\r\n\tprivate path: Point[] = [];\r\n\tprivate isDrawing = false;\r\n\tprivate currentMousePos: Point = { x: 0, y: 0 };\r\n\tprivate exitTipPos: Point | null = null;\r\n\tprivate isInvalidPath = false;\r\n\tprivate isValidPath = false;\r\n\r\n\t// \u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u30FB\u72B6\u614B\u8868\u793A\u7528\r\n\tprivate invalidatedCells: Point[] = [];\r\n\tprivate invalidatedEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\r\n\tprivate invalidatedNodes: Point[] = [];\r\n\tprivate errorCells: Point[] = [];\r\n\tprivate errorEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [];\r\n\tprivate errorNodes: Point[] = [];\r\n\tprivate eraserAnimationStartTime = 0;\r\n\tprivate isFading = false;\r\n\tprivate fadeOpacity = 1.0;\r\n\tprivate fadeColor = \"#ff4444\";\r\n\tprivate fadingPath: Point[] = [];\r\n\tprivate fadingTipPos: Point | null = null;\r\n\r\n\tprivate isSuccessFading = false;\r\n\tprivate successFadeStartTime = 0;\r\n\tprivate startTime = Date.now();\r\n\r\n\t// \u900F\u904E\u63CF\u753B\u7528\u306E\u30AA\u30D5\u30B9\u30AF\u30EA\u30FC\u30F3Canvas\r\n\tprivate offscreenCanvas: HTMLCanvasElement | OffscreenCanvas | null = null;\r\n\tprivate offscreenCtx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D | null = null;\r\n\tprivate filterCanvas: HTMLCanvasElement | OffscreenCanvas | null = null;\r\n\tprivate filterCtx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D | null = null;\r\n\r\n\tprivate canvasRect: { left: number; top: number; width: number; height: number } | null = null;\r\n\tprivate isDestroyed = false;\r\n\tprivate animationFrameId: number | null = null;\r\n\tprivate timeoutId: any = null;\r\n\r\n\t// \u30A4\u30D9\u30F3\u30C8\u30CF\u30F3\u30C9\u30E9\u306E\u53C2\u7167\uFF08\u89E3\u9664\u7528\uFF09\r\n\tprivate boundMouseDown: ((e: MouseEvent) => void) | null = null;\r\n\tprivate boundMouseMove: ((e: MouseEvent) => void) | null = null;\r\n\tprivate boundMouseUp: ((e: MouseEvent) => void) | null = null;\r\n\tprivate boundTouchStart: ((e: TouchEvent) => void) | null = null;\r\n\tprivate boundTouchMove: ((e: TouchEvent) => void) | null = null;\r\n\tprivate boundTouchEnd: ((e: TouchEvent) => void) | null = null;\r\n\tprivate boundUpdateRect: (() => void) | null = null;\r\n\tprivate isTwoClickDrawing = false;\r\n\tprivate activeStartNode: { x: number; y: number; index: number } | null = null;\r\n\r\n\tconstructor(canvasOrId: HTMLCanvasElement | OffscreenCanvas | string, puzzle?: PuzzleData, options: WitnessUIOptions = {}) {\r\n\t\tif (typeof canvasOrId === \"string\") {\r\n\t\t\tif (typeof document === \"undefined\") {\r\n\t\t\t\tthrow new Error(\"Cannot look up canvas by ID in a non-browser environment.\");\r\n\t\t\t}\r\n\t\t\tconst el = document.getElementById(canvasOrId);\r\n\t\t\tif (!(el instanceof HTMLCanvasElement)) {\r\n\t\t\t\tthrow new Error(`Element with id \"${canvasOrId}\" is not a canvas.`);\r\n\t\t\t}\r\n\t\t\tthis.canvas = el;\r\n\t\t} else {\r\n\t\t\tthis.canvas = canvasOrId;\r\n\t\t}\r\n\r\n\t\tthis.options = this.mergeOptions(options);\r\n\r\n\t\t// Worker\u3092\u4F7F\u7528\u3059\u308B\u5834\u5408\u306E\u521D\u671F\u5316\r\n\t\tif (this.options.useWorker && typeof window !== \"undefined\" && this.canvas instanceof HTMLCanvasElement && this.canvas.transferControlToOffscreen) {\r\n\t\t\tconst script = this.options.workerScript ?? (import.meta as any).url;\r\n\t\t\tif (script) {\r\n\t\t\t\tthis.worker = new Worker(script, { type: \"module\" });\r\n\t\t\t\tconst offscreen = this.canvas.transferControlToOffscreen();\r\n\t\t\t\tconst sanitizedOptions = this.sanitizeOptions(this.options);\r\n\t\t\t\tthis.worker.postMessage(\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttype: \"init\",\r\n\t\t\t\t\t\tpayload: {\r\n\t\t\t\t\t\t\tcanvas: offscreen,\r\n\t\t\t\t\t\t\toptions: sanitizedOptions,\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t},\r\n\t\t\t\t\t[offscreen],\r\n\t\t\t\t);\r\n\r\n\t\t\t\tthis.worker.addEventListener(\"message\", (e) => {\r\n\t\t\t\t\tconst { type, payload } = e.data;\r\n\t\t\t\t\tif (type === \"drawingStarted\") {\r\n\t\t\t\t\t\tthis.isDrawing = payload !== false; // payload\u304Cfalse\u306A\u3089\u958B\u59CB\u5931\u6557\r\n\t\t\t\t\t\tif (!this.isDrawing) {\r\n\t\t\t\t\t\t\tthis.isTwoClickDrawing = false;\r\n\t\t\t\t\t\t\tthis.setTwoClickPointerUi(false);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (type === \"drawingEnded\") {\r\n\t\t\t\t\t\tthis.isDrawing = false;\r\n\t\t\t\t\t\tthis.isTwoClickDrawing = false;\r\n\t\t\t\t\t\tthis.setTwoClickPointerUi(false);\r\n\t\t\t\t\t} else if (type === \"pathComplete\") {\r\n\t\t\t\t\t\tconst path = Array.isArray(payload?.path) ? payload.path : payload;\r\n\t\t\t\t\t\tthis.emit(\"path:complete\", { path, startNode: this.getStartNodeMetaFromPath(), endNode: this.getEndNodeMetaFromPath() });\r\n\t\t\t\t\t} else if (type === \"puzzleCreated\") {\r\n\t\t\t\t\t\t// Worker\u3067\u751F\u6210\u3055\u308C\u305F\u30D1\u30BA\u30EB\u306F\u81EA\u52D5\u7684\u306BUI\u3078\u53CD\u6620\u3059\u308B\r\n\t\t\t\t\t\tif (payload?.puzzle) {\r\n\t\t\t\t\t\t\tthis.setPuzzle(payload.puzzle);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.emit(\"puzzle:generated\", payload);\r\n\t\t\t\t\t} else if (type === \"validationResult\") {\r\n\t\t\t\t\t\tthis.emit(\"goal:validated\", { result: payload });\r\n\t\t\t\t\t} else if (type === \"uiEvent\") {\r\n\t\t\t\t\t\tthis.emit(payload.type, payload.data);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!this.worker) {\r\n\t\t\tconst context = (this.canvas as any).getContext(\"2d\") as WitnessContext | null;\r\n\t\t\tif (!context) throw new Error(\"Could not get 2D context.\");\r\n\t\t\tthis.ctx = context;\r\n\t\t\tthis.ctx.imageSmoothingEnabled = false;\r\n\t\t\tthis.animate();\r\n\t\t}\r\n\r\n\t\tif (puzzle) {\r\n\t\t\tthis.setPuzzle(puzzle);\r\n\t\t}\r\n\r\n\t\tthis.initEvents();\r\n\t}\r\n\r\n\t/**\r\n\t * \u30C7\u30D5\u30A9\u30EB\u30C8\u30AA\u30D7\u30B7\u30E7\u30F3\u3068\u30E6\u30FC\u30B6\u30FC\u6307\u5B9A\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u30DE\u30FC\u30B8\u3059\u308B\r\n\t * @param options \u6307\u5B9A\u3055\u308C\u305F\u30AA\u30D7\u30B7\u30E7\u30F3\r\n\t * @returns \u30DE\u30FC\u30B8\u5F8C\u306E\u5168\u30AA\u30D7\u30B7\u30E7\u30F3\r\n\t */\r\n\tprivate mergeOptions(options: WitnessUIOptions): Required<WitnessUIOptions> {\r\n\t\tconst animations = {\r\n\t\t\tblinkDuration: options.animations?.blinkDuration ?? this.options?.animations?.blinkDuration ?? 1000,\r\n\t\t\tfadeDuration: options.animations?.fadeDuration ?? this.options?.animations?.fadeDuration ?? 1000,\r\n\t\t\tblinkPeriod: options.animations?.blinkPeriod ?? this.options?.animations?.blinkPeriod ?? 800,\r\n\t\t};\r\n\r\n\t\tconst colors = {\r\n\t\t\tpath: options.colors?.path ?? this.options?.colors?.path ?? \"#ffcc00\",\r\n\t\t\terror: options.colors?.error ?? this.options?.colors?.error ?? \"#ff4444\",\r\n\t\t\tsuccess: options.colors?.success ?? this.options?.colors?.success ?? \"#ffcc00\",\r\n\t\t\tsymmetry: options.colors?.symmetry ?? this.options?.colors?.symmetry ?? \"rgba(255, 255, 255, 0.5)\",\r\n\t\t\tinterrupted: options.colors?.interrupted ?? this.options?.colors?.interrupted ?? \"#ffcc00\",\r\n\t\t\tgrid: options.colors?.grid ?? this.options?.colors?.grid ?? \"#555\",\r\n\t\t\tnode: options.colors?.node ?? this.options?.colors?.node ?? \"#555\",\r\n\t\t\thexagon: options.colors?.hexagon ?? this.options?.colors?.hexagon ?? \"#000\",\r\n\t\t\thexagonMain: options.colors?.hexagonMain ?? this.options?.colors?.hexagonMain ?? \"#00ffff\",\r\n\t\t\thexagonSymmetry: options.colors?.hexagonSymmetry ?? this.options?.colors?.hexagonSymmetry ?? \"#ffff00\",\r\n\t\t\tcolorMap: options.colors?.colorMap ??\r\n\t\t\t\tthis.options?.colors?.colorMap ?? {\r\n\t\t\t\t\t[Color.Black]: \"#000\",\r\n\t\t\t\t\t[Color.White]: \"#fff\",\r\n\t\t\t\t\t[Color.Red]: \"#f00\",\r\n\t\t\t\t\t[Color.Blue]: \"#00f\",\r\n\t\t\t\t\t[Color.None]: \"#ffcc00\",\r\n\t\t\t\t},\r\n\t\t\tcolorList: options.colors?.colorList ?? this.options?.colors?.colorList,\r\n\t\t};\r\n\r\n\t\treturn {\r\n\t\t\tinputMode: options.inputMode ?? this.options?.inputMode ?? \"drag\",\r\n\t\t\tgridPadding: options.gridPadding ?? this.options?.gridPadding ?? 60,\r\n\t\t\tcellSize: options.cellSize ?? this.options?.cellSize ?? 80,\r\n\t\t\tnodeRadius: options.nodeRadius ?? this.options?.nodeRadius ?? 6,\r\n\t\t\tstartNodeRadius: options.startNodeRadius ?? this.options?.startNodeRadius ?? 22,\r\n\t\t\tpathWidth: options.pathWidth ?? this.options?.pathWidth ?? 18,\r\n\t\t\texitLength: options.exitLength ?? this.options?.exitLength ?? 25,\r\n\t\t\tautoResize: options.autoResize ?? this.options?.autoResize ?? true,\r\n\t\t\tblinkMarksOnError: options.blinkMarksOnError ?? this.options?.blinkMarksOnError ?? true,\r\n\t\t\tstayPathOnError: options.stayPathOnError ?? this.options?.stayPathOnError ?? true,\r\n\t\t\tautoValidate: options.autoValidate ?? this.options?.autoValidate ?? false,\r\n\t\t\tuseWorker: options.useWorker ?? this.options?.useWorker ?? false,\r\n\t\t\tworkerScript: options.workerScript ?? this.options?.workerScript,\r\n\t\t\tanimations,\r\n\t\t\tcolors,\r\n\t\t\tfilter: {\r\n\t\t\t\tenabled: options.filter?.enabled ?? this.options?.filter?.enabled ?? false,\r\n\t\t\t\tmode: options.filter?.mode ?? this.options?.filter?.mode ?? \"custom\",\r\n\t\t\t\tcustomColor: options.filter?.customColor ?? this.options?.filter?.customColor ?? \"#ffffff\",\r\n\t\t\t\trgbColors: options.filter?.rgbColors ?? this.options?.filter?.rgbColors ?? [\"#ff0000\", \"#00ff00\", \"#0000ff\"],\r\n\t\t\t\trgbIndex: options.filter?.rgbIndex ?? this.options?.filter?.rgbIndex ?? 0,\r\n\t\t\t\tthreshold: options.filter?.threshold ?? this.options?.filter?.threshold ?? 128,\r\n\t\t\t},\r\n\t\t\tpixelRatio: options.pixelRatio ?? this.options?.pixelRatio ?? (typeof window !== \"undefined\" ? window.devicePixelRatio : 1),\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\u3092\u8A2D\u5B9A\u3057\u3001\u518D\u63CF\u753B\u3059\u308B\r\n\t */\r\n\tpublic setPuzzle(puzzle: PuzzleData) {\r\n\t\tif (this.worker) {\r\n\t\t\tthis.puzzle = puzzle;\r\n\t\t\tif (this.options.autoResize) {\r\n\t\t\t\tthis.resizeCanvas();\r\n\t\t\t}\r\n\t\t\tthis.worker.postMessage({ type: \"setPuzzle\", payload: { puzzle } });\r\n\t\t\tthis.emit(\"puzzle:created\", { puzzle });\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.puzzle = puzzle;\r\n\t\tthis.path = [];\r\n\t\tthis.isDrawing = false;\r\n\t\tthis.exitTipPos = null;\r\n\t\tthis.isInvalidPath = false;\r\n\t\tthis.isValidPath = false;\r\n\t\tthis.invalidatedCells = [];\r\n\t\tthis.invalidatedEdges = [];\r\n\t\tthis.invalidatedNodes = [];\r\n\t\tthis.errorCells = [];\r\n\t\tthis.errorEdges = [];\r\n\t\tthis.errorNodes = [];\r\n\t\tthis.activeStartNode = null;\r\n\t\tthis.cancelFade();\r\n\r\n\t\tif (this.options.autoResize) {\r\n\t\t\tthis.resizeCanvas();\r\n\t\t}\r\n\t\tthis.draw();\r\n\t\tthis.emit(\"puzzle:created\", { puzzle });\r\n\t}\r\n\r\n\t/**\r\n\t * \u5916\u90E8\u304B\u3089\u30D1\u30B9\uFF08\u89E3\u7B54\u7D4C\u8DEF\uFF09\u3092\u5F37\u5236\u7684\u306B\u8A2D\u5B9A\u3059\u308B\r\n\t * @param path \u7D4C\u8DEF\u306E\u70B9\u914D\u5217\r\n\t */\r\n\tpublic setPath(path: Point[]) {\r\n\t\tif (this.worker) {\r\n\t\t\tthis.worker.postMessage({ type: \"setPath\", payload: { path } });\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.cancelFade();\r\n\t\tthis.isInvalidPath = false;\r\n\t\tthis.isValidPath = false;\r\n\t\tthis.isSuccessFading = false;\r\n\r\n\t\tif (path.length > 0) {\r\n\t\t\tthis.path = [...path];\r\n\t\t\tconst lastPoint = this.path[this.path.length - 1];\r\n\t\t\tconst lastPos = this.getCanvasCoords(lastPoint.x, lastPoint.y);\r\n\t\t\tconst exitDir = this.getExitDir(lastPoint.x, lastPoint.y);\r\n\r\n\t\t\tif (exitDir) {\r\n\t\t\t\tthis.exitTipPos = {\r\n\t\t\t\t\tx: lastPos.x + exitDir.x * this.options.exitLength,\r\n\t\t\t\t\ty: lastPos.y + exitDir.y * this.options.exitLength,\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\tthis.exitTipPos = null;\r\n\t\t\t}\r\n\t\t\tthis.currentMousePos = lastPos;\r\n\t\t} else {\r\n\t\t\tthis.path = [];\r\n\t\t\tthis.exitTipPos = null;\r\n\t\t}\r\n\r\n\t\tthis.draw();\r\n\t}\r\n\r\n\t/**\r\n\t * \u8868\u793A\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u66F4\u65B0\u3059\u308B\r\n\t */\r\n\tpublic setOptions(options: WitnessUIOptions) {\r\n\t\tconst prevInputMode = this.options.inputMode;\r\n\t\tthis.options = this.mergeOptions({ ...this.options, ...options });\r\n\r\n\t\tif (prevInputMode !== this.options.inputMode && this.options.inputMode !== \"twoClick\") {\r\n\t\t\tthis.isTwoClickDrawing = false;\r\n\t\t\tthis.setTwoClickPointerUi(false);\r\n\t\t}\r\n\t\tif (this.worker) {\r\n\t\t\tif (this.options.autoResize && this.puzzle) {\r\n\t\t\t\tthis.resizeCanvas();\r\n\t\t\t}\r\n\t\t\tconst sanitizedOptions = this.sanitizeOptions(options);\r\n\t\t\tthis.worker.postMessage({ type: \"setOptions\", payload: sanitizedOptions });\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.options.autoResize && this.puzzle) {\r\n\t\t\tthis.resizeCanvas();\r\n\t\t}\r\n\t\tthis.draw();\r\n\t}\r\n\r\n\t// --- Event Emitter ---\r\n\r\n\t/**\r\n\t * \u30A4\u30D9\u30F3\u30C8\u30EA\u30B9\u30CA\u30FC\u3092\u8FFD\u52A0\u3059\u308B\r\n\t */\r\n\tpublic addEventListener<K extends WitnessEventName>(type: K, listener: (data: WitnessEventMap[K]) => void) {\r\n\t\tif (!this.listeners.has(type)) {\r\n\t\t\tthis.listeners.set(type, new Set());\r\n\t\t}\r\n\t\tthis.listeners.get(type)!.add(listener);\r\n\t}\r\n\r\n\t/**\r\n\t * \u30A4\u30D9\u30F3\u30C8\u30EA\u30B9\u30CA\u30FC\u3092\u524A\u9664\u3059\u308B\r\n\t */\r\n\tpublic removeEventListener<K extends WitnessEventName>(type: K, listener: (data: WitnessEventMap[K]) => void) {\r\n\t\tconst set = this.listeners.get(type);\r\n\t\tif (set) {\r\n\t\t\tset.delete(listener);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u30A4\u30D9\u30F3\u30C8\u30EA\u30B9\u30CA\u30FC\u3092\u8FFD\u52A0\u3059\u308B (\u30A8\u30A4\u30EA\u30A2\u30B9)\r\n\t */\r\n\tpublic on<K extends WitnessEventName>(type: K, listener: (data: WitnessEventMap[K]) => void) {\r\n\t\tthis.addEventListener(type, listener);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * \u30A4\u30D9\u30F3\u30C8\u30EA\u30B9\u30CA\u30FC\u3092\u524A\u9664\u3059\u308B (\u30A8\u30A4\u30EA\u30A2\u30B9)\r\n\t */\r\n\tpublic off<K extends WitnessEventName>(type: K, listener: (data: WitnessEventMap[K]) => void) {\r\n\t\tthis.removeEventListener(type, listener);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * \u5185\u90E8\u30A4\u30D9\u30F3\u30C8\u3092\u767A\u884C\u3059\u308B\r\n\t */\r\n\tprivate emit<K extends WitnessEventName>(type: K, data: WitnessEventMap[K]) {\r\n\t\tconst set = this.listeners.get(type);\r\n\t\tif (set) {\r\n\t\t\tset.forEach((l) => l(data));\r\n\t\t}\r\n\r\n\t\t// Worker\u30E2\u30FC\u30C9\u3067\u3001\u81EA\u8EAB\u304CWorker\u5185\u3067\u52D5\u4F5C\u3057\u3066\u3044\u308B\u5834\u5408\u3001\u30E1\u30A4\u30F3\u30B9\u30EC\u30C3\u30C9\u306B\u30A4\u30D9\u30F3\u30C8\u3092\u8EE2\u9001\u3059\u308B\r\n\t\tif (typeof self !== \"undefined\" && (self as any).postMessage && !this.worker) {\r\n\t\t\tconst isOffscreen = typeof OffscreenCanvas !== \"undefined\" && this.canvas instanceof OffscreenCanvas;\r\n\t\t\tif (isOffscreen) {\r\n\t\t\t\t// \u4EE5\u4E0B\u306E\u30A4\u30D9\u30F3\u30C8\u306F\u500B\u5225\u306E\u30E1\u30C3\u30BB\u30FC\u30B8(pathComplete\u7B49)\u3067\u3082\u9001\u4FE1\u3055\u308C\u308B\u305F\u3081\u3001\r\n\t\t\t\t// \u4E8C\u91CD\u767A\u884C\u3092\u9632\u3050\u305F\u3081\u306BuiEvent\u3068\u3057\u3066\u306F\u9001\u4FE1\u3057\u306A\u3044\r\n\t\t\t\tconst redundantEvents = [\"path:complete\", \"puzzle:created\", \"goal:validated\"];\r\n\t\t\t\tif (!redundantEvents.includes(type)) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tconst serializableData = type === \"render:before\" || type === \"render:after\" ? { phase: type } : data;\r\n\t\t\t\t\t\t(self as any).postMessage({ type: \"uiEvent\", payload: { type, data: serializableData } });\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t// \u30B7\u30EA\u30A2\u30E9\u30A4\u30BA\u4E0D\u53EF\u306A\u30C7\u30FC\u30BF\u304C\u542B\u307E\u308C\u3066\u3044\u305F\u5834\u5408\u306F\u7121\u8996\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u691C\u8A3C\u7D50\u679C\u3092\u53CD\u6620\u3055\u305B\u308B\uFF08\u4E0D\u6B63\u89E3\u6642\u306E\u8D64\u70B9\u6EC5\u3084\u3001\u6D88\u3057\u30B4\u30E0\u306B\u3088\u308B\u7121\u52B9\u5316\u306E\u8868\u793A\uFF09\r\n\t */\r\n\tpublic setValidationResult(isValid: boolean, invalidatedCells: Point[] = [], invalidatedEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [], errorCells: Point[] = [], errorEdges: { type: \"h\" | \"v\"; r: number; c: number }[] = [], invalidatedNodes: Point[] = [], errorNodes: Point[] = []) {\r\n\t\tif (this.worker) {\r\n\t\t\tthis.worker.postMessage({\r\n\t\t\t\ttype: \"setValidationResult\",\r\n\t\t\t\tpayload: { isValid, invalidatedCells, invalidatedEdges, errorCells, errorEdges, invalidatedNodes, errorNodes },\r\n\t\t\t});\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.invalidatedCells = invalidatedCells;\r\n\t\tthis.invalidatedEdges = invalidatedEdges;\r\n\t\tthis.invalidatedNodes = invalidatedNodes;\r\n\t\tthis.errorCells = errorCells;\r\n\t\tthis.errorEdges = errorEdges;\r\n\t\tthis.errorNodes = errorNodes;\r\n\t\tthis.eraserAnimationStartTime = Date.now();\r\n\r\n\t\tif (isValid) {\r\n\t\t\tthis.isValidPath = true;\r\n\t\t\tthis.isSuccessFading = true;\r\n\t\t\tthis.successFadeStartTime = Date.now();\r\n\t\t} else {\r\n\t\t\tthis.isInvalidPath = true;\r\n\t\t\t// \u5931\u6557\u6642\u306E\u30D5\u30A7\u30FC\u30C9\u30A2\u30A6\u30C8\u8A2D\u5B9A\u304C\u6709\u52B9\u306A\u5834\u5408\u3001\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\uFF08\u70B9\u6EC5\uFF09\u5F85\u3061\u306E\u5F8C\u306B startFade \u304C\u547C\u3070\u308C\u308B\u3088\u3046\u306B\u3059\u308B\r\n\t\t}\r\n\r\n\t\tthis.emit(\"goal:reached\", { path: this.path, isValid, startNode: this.getStartNodeMetaFromPath(), endNode: this.getEndNodeMetaFromPath() });\r\n\t}\r\n\r\n\t/**\r\n\t * \u30D1\u30BA\u30EB\u306E\u30B5\u30A4\u30BA\u306B\u5408\u308F\u305B\u3066Canvas\u306E\u7269\u7406\u30B5\u30A4\u30BA\u3092\u8ABF\u6574\u3059\u308B\r\n\t */\r\n\tprivate resizeCanvas() {\r\n\t\tif (!this.puzzle || !this.canvas) return;\r\n\t\tconst w = this.puzzle.cols * this.options.cellSize + this.options.gridPadding * 2;\r\n\t\tconst h = this.puzzle.rows * this.options.cellSize + this.options.gridPadding * 2;\r\n\r\n\t\tconst dpr = this.options.pixelRatio;\r\n\r\n\t\tif (typeof HTMLCanvasElement !== \"undefined\" && this.canvas instanceof HTMLCanvasElement) {\r\n\t\t\ttry {\r\n\t\t\t\tthis.canvas.width = w * dpr;\r\n\t\t\t\tthis.canvas.height = h * dpr;\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// InvalidStateError occurs after transferControlToOffscreen()\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.canvas.width = w * dpr;\r\n\t\t\tthis.canvas.height = h * dpr;\r\n\t\t}\r\n\r\n\t\t// \u30B5\u30A4\u30BA\u5909\u66F4\u5F8C\u306B\u77E9\u5F62\u60C5\u5831\u3092\u518D\u8A08\u7B97\u3057\u3066Worker\u306B\u901A\u77E5\r\n\t\tif (this.worker && this.boundUpdateRect) {\r\n\t\t\tthis.boundUpdateRect();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Canvas\u306E\u8868\u793A\u4E0A\u306E\u77E9\u5F62\u60C5\u5831\u3092\u8A2D\u5B9A\u3059\u308B\uFF08Worker\u6642\u306A\u3069\u306B\u5FC5\u8981\uFF09\r\n\t */\r\n\tpublic setCanvasRect(rect: { left: number; top: number; width: number; height: number }) {\r\n\t\t// DOMRect\u7B49\u306E\u5834\u5408\u3001\u30B7\u30EA\u30A2\u30E9\u30A4\u30BA\u3067\u304D\u306A\u3044\u53EF\u80FD\u6027\u304C\u3042\u308B\u305F\u3081\u30D7\u30EC\u30FC\u30F3\u306A\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u306B\u5909\u63DB\r\n\t\tconst plainRect = {\r\n\t\t\tleft: rect.left,\r\n\t\t\ttop: rect.top,\r\n\t\t\twidth: rect.width,\r\n\t\t\theight: rect.height,\r\n\t\t};\r\n\t\tthis.canvasRect = plainRect;\r\n\t\tif (this.worker) {\r\n\t\t\tthis.worker.postMessage({ type: \"setCanvasRect\", payload: plainRect });\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Worker\u306B\u30D1\u30BA\u30EB\u751F\u6210\u3092\u4F9D\u983C\u3059\u308B (Worker\u30E2\u30FC\u30C9\u6642\u306E\u307F\u6709\u52B9)\r\n\t */\r\n\tpublic createPuzzle(rows: number, cols: number, genOptions: any) {\r\n\t\tif (this.worker) {\r\n\t\t\tthis.worker.postMessage({ type: \"createPuzzle\", payload: { rows, cols, genOptions } });\r\n\t\t}\r\n\t}\r\n\r\n\tprivate setTwoClickPointerUi(active: boolean) {\r\n\t\tif (typeof HTMLCanvasElement === \"undefined\" || !(this.canvas instanceof HTMLCanvasElement)) return;\r\n\t\tif (typeof document === \"undefined\") return;\r\n\r\n\t\tif (active) {\r\n\t\t\tthis.canvas.style.cursor = \"none\";\r\n\t\t\tthis.canvas.requestPointerLock?.();\r\n\t\t} else {\r\n\t\t\tif (document.pointerLockElement === this.canvas) {\r\n\t\t\t\tdocument.exitPointerLock?.();\r\n\t\t\t}\r\n\t\t\tthis.canvas.style.cursor = \"\";\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u30DE\u30A6\u30B9\u30FB\u30BF\u30C3\u30C1\u30A4\u30D9\u30F3\u30C8\u3092\u521D\u671F\u5316\u3059\u308B\r\n\t */\r\n\tprivate initEvents() {\r\n\t\tif (typeof window === \"undefined\" || typeof HTMLCanvasElement === \"undefined\" || !(this.canvas instanceof HTMLCanvasElement)) return;\r\n\r\n\t\tthis.boundMouseDown = (e: MouseEvent) => {\r\n\t\t\tconst consumed = this.options.inputMode === \"twoClick\" && this.isDrawing ? this.handleEnd(e, \"mouse\") : this.handleStart(e, \"mouse\");\r\n\t\t\tif (consumed) {\r\n\t\t\t\tif (e.cancelable) e.preventDefault();\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.boundMouseMove = (e: MouseEvent) => {\r\n\t\t\tif (this.isDrawing) {\r\n\t\t\t\tif (e.cancelable) e.preventDefault();\r\n\t\t\t}\r\n\t\t\tthis.handleMove(e);\r\n\t\t};\r\n\t\tthis.boundMouseUp = (e: MouseEvent) => {\r\n\t\t\tif (this.options.inputMode !== \"twoClick\" && this.isDrawing) {\r\n\t\t\t\tif (e.cancelable) e.preventDefault();\r\n\t\t\t\tthis.handleEnd(e, \"mouse\");\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.boundTouchStart = (e: TouchEvent) => {\r\n\t\t\tif (this.handleStart(e.touches[0], \"touch\")) {\r\n\t\t\t\tif (e.cancelable) e.preventDefault();\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.boundTouchMove = (e: TouchEvent) => {\r\n\t\t\tif (this.isDrawing) {\r\n\t\t\t\tif (e.cancelable) e.preventDefault();\r\n\t\t\t\tthis.handleMove(e.touches[0]);\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.boundTouchEnd = (e: TouchEvent) => {\r\n\t\t\tif (this.options.inputMode !== \"twoClick\" && this.isDrawing) {\r\n\t\t\t\tif (e.cancelable) e.preventDefault();\r\n\t\t\t\tthis.handleEnd(e.changedTouches[0], \"touch\");\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.canvas.addEventListener(\"mousedown\", this.boundMouseDown);\r\n\t\twindow.addEventListener(\"mousemove\", this.boundMouseMove, { passive: false });\r\n\t\twindow.addEventListener(\"mouseup\", this.boundMouseUp, { passive: false });\r\n\r\n\t\tthis.canvas.addEventListener(\"touchstart\", this.boundTouchStart, { passive: false });\r\n\t\twindow.addEventListener(\"touchmove\", this.boundTouchMove, { passive: false });\r\n\t\twindow.addEventListener(\"touchend\", this.boundTouchEnd, { passive: false });\r\n\r\n\t\tif (this.worker) {\r\n\t\t\tthis.boundUpdateRect = () => {\r\n\t\t\t\tif (this.canvas instanceof HTMLCanvasElement) {\r\n\t\t\t\t\tconst rect = this.canvas.getBoundingClientRect();\r\n\t\t\t\t\tthis.setCanvasRect(rect);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\twindow.addEventListener(\"resize\", this.boundUpdateRect);\r\n\t\t\twindow.addEventListener(\"scroll\", this.boundUpdateRect);\r\n\t\t\tthis.boundUpdateRect();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u30A4\u30D9\u30F3\u30C8\u30EA\u30B9\u30CA\u30FC\u3092\u89E3\u9664\u3057\u3001\u30EA\u30BD\u30FC\u30B9\u3092\u89E3\u653E\u3059\u308B\r\n\t */\r\n\tpublic destroy() {\r\n\t\tthis.isDestroyed = true;\r\n\t\tif (this.worker) {\r\n\t\t\tthis.worker.terminate();\r\n\t\t\tthis.worker = null;\r\n\t\t}\r\n\r\n\t\tif (this.animationFrameId !== null && typeof cancelAnimationFrame !== \"undefined\") {\r\n\t\t\tcancelAnimationFrame(this.animationFrameId);\r\n\t\t}\r\n\t\tif (this.timeoutId !== null) {\r\n\t\t\tclearTimeout(this.timeoutId);\r\n\t\t}\r\n\r\n\t\tif (typeof window === \"undefined\" || typeof HTMLCanvasElement === \"undefined\" || !(this.canvas instanceof HTMLCanvasElement)) return;\r\n\r\n\t\tif (this.boundMouseDown) this.canvas.removeEventListener(\"mousedown\", this.boundMouseDown);\r\n\t\tif (this.boundMouseMove) window.removeEventListener(\"mousemove\", this.boundMouseMove);\r\n\t\tif (this.boundMouseUp) window.removeEventListener(\"mouseup\", this.boundMouseUp);\r\n\r\n\t\tif (this.boundTouchStart) this.canvas.removeEventListener(\"touchstart\", this.boundTouchStart);\r\n\t\tif (this.boundTouchMove) window.removeEventListener(\"touchmove\", this.boundTouchMove);\r\n\t\tif (this.boundTouchEnd) window.removeEventListener(\"touchend\", this.boundTouchEnd);\r\n\r\n\t\tif (this.boundUpdateRect) {\r\n\t\t\twindow.removeEventListener(\"resize\", this.boundUpdateRect);\r\n\t\t\twindow.removeEventListener(\"scroll\", this.boundUpdateRect);\r\n\t\t}\r\n\r\n\t\tthis.boundMouseDown = null;\r\n\t\tthis.boundMouseMove = null;\r\n\t\tthis.boundMouseUp = null;\r\n\t\tthis.boundTouchStart = null;\r\n\t\tthis.boundTouchMove = null;\r\n\t\tthis.boundTouchEnd = null;\r\n\r\n\t\tthis.setTwoClickPointerUi(false);\r\n\t}\r\n\r\n\t// --- \u5EA7\u6A19\u5909\u63DB ---\r\n\r\n\t/**\r\n\t * \u30B0\u30EA\u30C3\u30C9\u5EA7\u6A19\u3092Canvas\u4E0A\u306E\u30D4\u30AF\u30BB\u30EB\u5EA7\u6A19\u306B\u5909\u63DB\u3059\u308B\r\n\t * @param gridX \u30B0\u30EA\u30C3\u30C9X\r\n\t * @param gridY \u30B0\u30EA\u30C3\u30C9Y\r\n\t * @returns Canvas\u5EA7\u6A19\r\n\t */\r\n\tprivate getCanvasCoords(gridX: number, gridY: number): Point {\r\n\t\treturn {\r\n\t\t\tx: this.options.gridPadding + gridX * this.options.cellSize,\r\n\t\t\ty: this.options.gridPadding + gridY * this.options.cellSize,\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * \u753B\u9762\u5EA7\u6A19\u3092Canvas\u4E0A\u306E\u8AD6\u7406\u5EA7\u6A19\u306B\u5909\u63DB\u3059\u308B\r\n\t */\r\n\tprivate toCanvasPoint(clientX: number, clientY: number): Point {\r\n\t\tconst dpr = this.options.pixelRatio;\r\n\t\tconst rect = this.canvasRect || (typeof HTMLCanvasElement !== \"undefined\" && this.canvas instanceof HTMLCanvasElement ? this.canvas.getBoundingClientRect() : { left: 0, top: 0, width: this.canvas.width / dpr, height: this.canvas.height / dpr });\r\n\t\treturn {\r\n\t\t\tx: (clientX - rect.left) * (this.canvas.width / dpr / rect.width),\r\n\t\t\ty: (clientY - rect.top) * (this.canvas.height / dpr / rect.height),\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * \u5165\u529B\u5EA7\u6A19\u304C\u30CE\u30FC\u30C9/\u30A8\u30C3\u30B8/\u30BB\u30EB\u306E\u3069\u3053\u306B\u5F53\u305F\u3063\u3066\u3044\u308B\u304B\u5224\u5B9A\u3059\u308B\r\n\t */\r\n\tpublic hitTestInput(clientX: number, clientY: number): WitnessHitTarget | null {\r\n\t\tif (!this.puzzle) return null;\r\n\t\tconst p = this.toCanvasPoint(clientX, clientY);\r\n\t\tconst gx = (p.x - this.options.gridPadding) / this.options.cellSize;\r\n\t\tconst gy = (p.y - this.options.gridPadding) / this.options.cellSize;\r\n\t\tconst nearX = Math.round(gx);\r\n\t\tconst nearY = Math.round(gy);\r\n\t\tconst dx = Math.abs(gx - nearX);\r\n\t\tconst dy = Math.abs(gy - nearY);\r\n\t\tconst nodeThreshold = 0.2;\r\n\t\tconst edgeThreshold = 0.2;\r\n\r\n\t\tif (dx <= nodeThreshold && dy <= nodeThreshold) {\r\n\t\t\tif (nearX >= 0 && nearX <= this.puzzle.cols && nearY >= 0 && nearY <= this.puzzle.rows) return { kind: \"node\", x: nearX, y: nearY };\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tif (dy <= edgeThreshold && gx >= 0 && gx <= this.puzzle.cols && nearY >= 0 && nearY <= this.puzzle.rows) {\r\n\t\t\tconst c = Math.floor(gx);\r\n\t\t\tif (c >= 0 && c < this.puzzle.cols) return { kind: \"hEdge\", r: nearY, c };\r\n\t\t}\r\n\t\tif (dx <= edgeThreshold && gy >= 0 && gy <= this.puzzle.rows && nearX >= 0 && nearX <= this.puzzle.cols) {\r\n\t\t\tconst r = Math.floor(gy);\r\n\t\t\tif (r >= 0 && r < this.puzzle.rows) return { kind: \"vEdge\", r, c: nearX };\r\n\t\t}\r\n\r\n\t\tconst c = Math.floor(gx);\r\n\t\tconst r = Math.floor(gy);\r\n\t\tif (c >= 0 && c < this.puzzle.cols && r >= 0 && r < this.puzzle.rows) return { kind: \"cell\", r, c };\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30CE\u30FC\u30C9\u304C\u51FA\u53E3\u306E\u5834\u5408\u3001\u305D\u306E\u51FA\u3063\u5F35\u308A\u306E\u65B9\u5411\u30D9\u30AF\u30C8\u30EB\u3092\u8FD4\u3059\r\n\t * @param x \u30B0\u30EA\u30C3\u30C9X\r\n\t * @param y \u30B0\u30EA\u30C3\u30C9Y\r\n\t * @returns \u65B9\u5411\u30D9\u30AF\u30C8\u30EB\u3001\u307E\u305F\u306Fnull\r\n\t */\r\n\tprivate getExitDir(x: number, y: number): Point | null {\r\n\t\tif (!this.puzzle) return null;\r\n\t\tif (this.puzzle.nodes[y]?.[x]?.type !== NodeType.End) return null;\r\n\r\n\t\tconst { cols, rows } = this.puzzle;\r\n\t\tconst isLeft = x === 0;\r\n\t\tconst isRight = x === cols;\r\n\t\tconst isTop = y === 0;\r\n\t\tconst isBottom = y === rows;\r\n\r\n\t\t// \u5916\u5468\u30C1\u30A7\u30C3\u30AF\r\n\t\tif (!isLeft && !isRight && !isTop && !isBottom) return null;\r\n\r\n\t\t// \u89D2\u306E\u30C1\u30A7\u30C3\u30AF\r\n\t\tconst isCorner = (isLeft || isRight) && (isTop || isBottom);\r\n\t\tif (isCorner) {\r\n\t\t\tif (cols >= rows) {\r\n\t\t\t\treturn isLeft ? { x: -1, y: 0 } : { x: 1, y: 0 };\r\n\t\t\t} else {\r\n\t\t\t\treturn isTop ? { x: 0, y: -1 } : { x: 0, y: 1 };\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (isLeft) return { x: -1, y: 0 };\r\n\t\tif (isRight) return { x: 1, y: 0 };\r\n\t\tif (isTop) return { x: 0, y: -1 };\r\n\t\tif (isBottom) return { x: 0, y: 1 };\r\n\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// --- \u30A4\u30D9\u30F3\u30C8\u30CF\u30F3\u30C9\u30E9 ---\r\n\r\n\tpublic handleStart(e: { clientX: number; clientY: number }, source: \"mouse\" | \"touch\" = \"mouse\"): boolean {\r\n\t\tif (this.options.inputMode === \"twoClick\" && source !== \"mouse\") {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tconst shouldStartDrawing = this.isStartNodeHit(e);\r\n\r\n\t\tif (this.worker) {\r\n\t\t\tif (!shouldStartDrawing) {\r\n\t\t\t\tthis.isDrawing = false;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tthis.isDrawing = true; // \u5148\u884C\u3057\u3066\u30D5\u30E9\u30B0\u3092\u7ACB\u3066\u308B\r\n\t\t\tthis.isTwoClickDrawing = this.options.inputMode === \"twoClick\";\r\n\t\t\tif (this.isTwoClickDrawing) {\r\n\t\t\t\tthis.setTwoClickPointerUi(true);\r\n\t\t\t}\r\n\t\t\tthis.worker.postMessage({ type: \"event\", payload: { eventType: \"mousedown\", eventData: { clientX: e.clientX, clientY: e.clientY } } });\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (!shouldStartDrawing) return false;\r\n\r\n\t\t// \u30B9\u30BF\u30FC\u30C8\u5730\u70B9\u304C\u30AF\u30EA\u30C3\u30AF\u3055\u308C\u305F\u5834\u5408\u306E\u307F\u3001\u524D\u56DE\u306E\u72B6\u614B\u3092\u30EA\u30BB\u30C3\u30C8\u3057\u3066\u958B\u59CB\u3059\u308B\r\n\t\tthis.cancelFade();\r\n\t\tthis.isSuccessFading = false;\r\n\t\tthis.isInvalidPath = false;\r\n\t\tthis.isValidPath = false;\r\n\t\tthis.invalidatedCells = [];\r\n\t\tthis.invalidatedEdges = [];\r\n\t\tthis.invalidatedNodes = [];\r\n\t\tthis.errorCells = [];\r\n\t\tthis.errorEdges = [];\r\n\t\tthis.errorNodes = [];\r\n\r\n\t\tthis.isDrawing = true;\r\n\t\tthis.isTwoClickDrawing = this.options.inputMode === \"twoClick\";\r\n\t\tthis.path = [{ x: shouldStartDrawing.x, y: shouldStartDrawing.y }];\r\n\t\tthis.currentMousePos = this.getCanvasCoords(shouldStartDrawing.x, shouldStartDrawing.y);\r\n\t\tthis.exitTipPos = null;\r\n\r\n\t\tif (this.isTwoClickDrawing) {\r\n\t\t\tthis.setTwoClickPointerUi(true);\r\n\t\t}\r\n\r\n\t\tthis.draw();\r\n\t\tthis.activeStartNode = { ...shouldStartDrawing, index: this.getNodeIndexByType(NodeType.Start, shouldStartDrawing.x, shouldStartDrawing.y) };\r\n\t\tthis.emit(\"path:start\", { x: shouldStartDrawing.x, y: shouldStartDrawing.y, startIndex: this.activeStartNode.index });\r\n\t\treturn true;\r\n\t}\r\n\r\n\tprivate isStartNodeHit(e: { clientX: number; clientY: number }): Point | null {\r\n\t\tif (!this.puzzle) return null;\r\n\r\n\t\tconst canvasPoint = this.toCanvasPoint(e.clientX, e.clientY);\r\n\t\tconst mouseX = canvasPoint.x;\r\n\t\tconst mouseY = canvasPoint.y;\r\n\r\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\r\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\r\n\t\t\t\tif (this.puzzle.nodes[r][c].type !== NodeType.Start) continue;\r\n\t\t\t\tconst nodePos = this.getCanvasCoords(c, r);\r\n\t\t\t\tif (Math.hypot(nodePos.x - mouseX, nodePos.y - mouseY) < this.options.startNodeRadius) {\r\n\t\t\t\t\treturn { x: c, y: r };\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic handleMove(e: { clientX: number; clientY: number; movementX?: number; movementY?: number; pointerLocked?: boolean }) {\r\n\t\tif (this.worker) {\r\n\t\t\tif (this.isDrawing) {\r\n\t\t\t\tthis.worker.postMessage({\r\n\t\t\t\t\ttype: \"event\",\r\n\t\t\t\t\tpayload: {\r\n\t\t\t\t\t\teventType: \"mousemove\",\r\n\t\t\t\t\t\teventData: {\r\n\t\t\t\t\t\t\tclientX: e.clientX,\r\n\t\t\t\t\t\t\tclientY: e.clientY,\r\n\t\t\t\t\t\t\tmovementX: (e as MouseEvent).movementX,\r\n\t\t\t\t\t\t\tmovementY: (e as MouseEvent).movementY,\r\n\t\t\t\t\t\t\tpointerLocked: typeof document !== \"undefined\" && typeof HTMLCanvasElement !== \"undefined\" && this.canvas instanceof HTMLCanvasElement && document.pointerLockElement === this.canvas,\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t},\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (!this.puzzle || !this.isDrawing) return;\r\n\r\n\t\tconst dpr = this.options.pixelRatio;\r\n\t\tconst rect = this.canvasRect || (typeof HTMLCanvasElement !== \"undefined\" && this.canvas instanceof HTMLCanvasElement ? this.canvas.getBoundingClientRect() : { left: 0, top: 0, width: this.canvas.width / dpr, height: this.canvas.height / dpr });\r\n\t\tconst canvasPoint = this.toCanvasPoint(e.clientX, e.clientY);\r\n\t\tlet mouseX = canvasPoint.x;\r\n\t\tlet mouseY = canvasPoint.y;\r\n\r\n\t\tconst isPointerLocked = e.pointerLocked === true || (this.isTwoClickDrawing && typeof document !== \"undefined\" && typeof HTMLCanvasElement !== \"undefined\" && this.canvas instanceof HTMLCanvasElement && document.pointerLockElement === this.canvas);\r\n\r\n\t\tif (this.isTwoClickDrawing && isPointerLocked) {\r\n\t\t\tconst scaleX = this.canvas.width / dpr / rect.width;\r\n\t\t\tconst scaleY = this.canvas.height / dpr / rect.height;\r\n\t\t\tmouseX = this.currentMousePos.x + (e.movementX ?? 0) * scaleX;\r\n\t\t\tmouseY = this.currentMousePos.y + (e.movementY ?? 0) * scaleY;\r\n\t\t}\r\n\r\n\t\tconst lastPoint = this.path[this.path.length - 1];\r\n\t\tconst lastPos = this.getCanvasCoords(lastPoint.x, lastPoint.y);\r\n\r\n\t\tconst dx = mouseX - lastPos.x;\r\n\t\tconst dy = mouseY - lastPos.y;\r\n\r\n\t\tconst symmetry = this.puzzle.symmetry || SymmetryType.None;\r\n\r\n\t\tconst exitDir = this.getExitDir(lastPoint.x, lastPoint.y);\r\n\t\tconst intendedDir = Math.abs(dx) > Math.abs(dy) ? { x: dx > 0 ? 1 : -1, y: 0 } : { x: 0, y: dy > 0 ? 1 : -1 };\r\n\r\n\t\t// \u30B4\u30FC\u30EB\u306E\u51FA\u3063\u5F35\u308A\u65B9\u5411\u3078\u306E\u79FB\u52D5\r\n\t\tif (exitDir && intendedDir.x === exitDir.x && intendedDir.y === exitDir.y) {\r\n\t\t\tconst dot = dx * exitDir.x + dy * exitDir.y;\r\n\t\t\tconst length = Math.max(0, Math.min(dot, this.options.exitLength));\r\n\t\t\tthis.currentMousePos = {\r\n\t\t\t\tx: lastPos.x + exitDir.x * length,\r\n\t\t\t\ty: lastPos.y + exitDir.y * length,\r\n\t\t\t};\r\n\t\t\tthis.draw();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst tryMoveTo = (target: Point, d: number) => {\r\n\t\t\tconst edgeType = this.getEdgeType(lastPoint, target);\r\n\t\t\tif (target.x < 0 || target.x > this.puzzle!.cols || target.y < 0 || target.y > this.puzzle!.rows || edgeType === EdgeType.Absent) {\r\n\t\t\t\tthis.currentMousePos = lastPos;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlet maxMove = edgeType === EdgeType.Broken ? this.options.cellSize * 0.35 : this.options.cellSize;\r\n\t\t\tconst antiClipDistance = Math.max(0, this.options.cellSize - this.options.pathWidth - 1);\r\n\t\t\tconst antiClipDistanceForBothTips = Math.max(0, antiClipDistance / 2);\r\n\t\t\tconst getStartNodeExtraPadding = (p: Point, start: Point): number => {\r\n\t\t\t\tif (p.x !== start.x || p.y !== start.y) return 0;\r\n\t\t\t\treturn Math.max(0, this.options.startNodeRadius - this.options.pathWidth / 2);\r\n\t\t\t};\r\n\r\n\t\t\t// \u81EA\u5DF1\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\uFF08\u30E1\u30A4\u30F3\u30D1\u30B9\u306E\u30A8\u30C3\u30B8\uFF09\r\n\t\t\tconst targetEdgeKey = this.getEdgeKey(lastPoint, target);\r\n\t\t\tconst isBacktracking = this.path.length >= 2 && target.x === this.path[this.path.length - 2].x && target.y === this.path[this.path.length - 2].y;\r\n\r\n\t\t\tif (!isBacktracking) {\r\n\t\t\t\tfor (let i = 0; i < this.path.length - 1; i++) {\r\n\t\t\t\t\tif (this.getEdgeKey(this.path[i], this.path[i + 1]) === targetEdgeKey) {\r\n\t\t\t\t\t\t// \u65E2\u306B\u4F7F\u7528\u4E2D\u306E\u30A8\u30C3\u30B8\u306B\u5411\u304B\u3046\u5834\u5408\u306F\u3001\u5373\u5EA7\u306B\u30D6\u30ED\u30C3\u30AF\uFF08\u623B\u308B\u52D5\u4F5C\u306F\u5225\u9014 handleMove \u3067 snap \u51E6\u7406\u3055\u308C\u308B\uFF09\r\n\t\t\t\t\t\tmaxMove = 0;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// \u81EA\u5DF1\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\uFF08\u30E1\u30A4\u30F3\u30D1\u30B9\u306E\u30CE\u30FC\u30C9\uFF09\r\n\t\t\tconst isTargetInPath = this.path.some((p) => p.x === target.x && p.y === target.y);\r\n\t\t\tif (isTargetInPath && this.path.length >= 2) {\r\n\t\t\t\tconst secondToLast = this.path[this.path.length - 2];\r\n\t\t\t\tif (target.x !== secondToLast.x || target.y !== secondToLast.y) {\r\n\t\t\t\t\tconst mainStart = this.path[0];\r\n\t\t\t\t\tconst extraPadding = getStartNodeExtraPadding(target, mainStart);\r\n\t\t\t\t\tmaxMove = Math.min(maxMove, Math.max(0, antiClipDistance - extraPadding));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\t\tconst symLast = this.getSymmetricalPoint(lastPoint);\r\n\t\t\t\tconst symTarget = this.getSymmetricalPoint(target);\r\n\t\t\t\tconst symEdgeType = this.getEdgeType(symLast, symTarget);\r\n\t\t\t\tconst symPath = this.getSymmetryPath(this.path);\r\n\t\t\t\tconst symEdgeKey = this.getEdgeKey(symLast, symTarget);\r\n\t\t\t\tconst mainStart = this.path[0];\r\n\t\t\t\tconst symStart = symPath[0];\r\n\r\n\t\t\t\tif (symTarget.x < 0 || symTarget.x > this.puzzle!.cols || symTarget.y < 0 || symTarget.y > this.puzzle!.rows || symEdgeType === EdgeType.Absent) {\r\n\t\t\t\t\tthis.currentMousePos = lastPos;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (symEdgeType === EdgeType.Broken) {\r\n\t\t\t\t\tmaxMove = Math.min(maxMove, this.options.cellSize * 0.35);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// \u5BFE\u79F0\u30D1\u30B9\u3068\u306E\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\r\n\t\t\t\tconst isNodeOccupiedBySym = symPath.some((p) => p.x === target.x && p.y === target.y);\r\n\t\t\t\tconst isSymNodeOccupiedByMain = this.path.some((p) => p.x === symTarget.x && p.y === symTarget.y);\r\n\t\t\t\tconst isMeetingAtNode = target.x === symTarget.x && target.y === symTarget.y;\r\n\t\t\t\tconst isEdgeOccupiedBySym = symPath.some((p, i) => i < symPath.length - 1 && this.getEdgeKey(symPath[i], symPath[i + 1]) === targetEdgeKey);\r\n\t\t\t\tconst isMirrorEdgeOccupiedByMain = this.path.some((p, i) => i < this.path.length - 1 && this.getEdgeKey(this.path[i], this.path[i + 1]) === symEdgeKey);\r\n\t\t\t\tconst isSelfMirrorEdge = targetEdgeKey === symEdgeKey;\r\n\r\n\t\t\t\tif (isNodeOccupiedBySym || isEdgeOccupiedBySym) {\r\n\t\t\t\t\tconst extraPadding = getStartNodeExtraPadding(target, symStart);\r\n\t\t\t\t\tmaxMove = Math.min(maxMove, Math.max(0, antiClipDistance - extraPadding));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isSymNodeOccupiedByMain || isMirrorEdgeOccupiedByMain) {\r\n\t\t\t\t\tconst extraPadding = getStartNodeExtraPadding(symTarget, mainStart);\r\n\t\t\t\t\tmaxMove = Math.min(maxMove, Math.max(0, antiClipDistance - extraPadding));\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// \u5BFE\u79F0\u5148\u7AEF\u3069\u3046\u3057\u304C\u4E92\u3044\u306B\u8FD1\u3065\u304F\u30B1\u30FC\u30B9\u3067\u306F\u3001\u4E21\u5148\u7AEF\u306E\u5408\u8A08\u79FB\u52D5\u91CF\u3067\u5224\u5B9A\u3059\u308B\u5FC5\u8981\u304C\u3042\u308B\r\n\t\t\t\tif (isSelfMirrorEdge) {\r\n\t\t\t\t\tmaxMove = Math.min(maxMove, antiClipDistanceForBothTips);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// \u5BFE\u79F0\u306E\u4E2D\u592E\u30CE\u30FC\u30C9\u306B\u5411\u304B\u3044\u5408\u3063\u3066\u9032\u3080\u30B1\u30FC\u30B9\uFF08\u5076\u6570\u76E4\u9762\uFF09\u306F\u3001\u901A\u5E38\u306E\u3081\u308A\u8FBC\u307F\u9632\u6B62\u8DDD\u96E2\u307E\u3067\u8A31\u53EF\u3059\u308B\r\n\t\t\t\tif (isMeetingAtNode) {\r\n\t\t\t\t\tmaxMove = Math.min(maxMove, maxMove - (maxMove - antiClipDistance) / 2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (target.x !== lastPoint.x) {\r\n\t\t\t\tthis.currentMousePos = {\r\n\t\t\t\t\tx: lastPos.x + Math.max(-maxMove, Math.min(maxMove, d)),\r\n\t\t\t\t\ty: lastPos.y,\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\tthis.currentMousePos = {\r\n\t\t\t\t\tx: lastPos.x,\r\n\t\t\t\t\ty: lastPos.y + Math.max(-maxMove, Math.min(maxMove, d)),\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tif (Math.abs(dx) > Math.abs(dy)) {\r\n\t\t\tconst dir = dx > 0 ? 1 : -1;\r\n\t\t\ttryMoveTo({ x: lastPoint.x + dir, y: lastPoint.y }, dx);\r\n\t\t} else {\r\n\t\t\tconst dir = dy > 0 ? 1 : -1;\r\n\t\t\ttryMoveTo({ x: lastPoint.x, y: lastPoint.y + dir }, dy);\r\n\t\t}\r\n\r\n\t\tconst neighbors = [\r\n\t\t\t{ x: lastPoint.x + 1, y: lastPoint.y },\r\n\t\t\t{ x: lastPoint.x - 1, y: lastPoint.y },\r\n\t\t\t{ x: lastPoint.x, y: lastPoint.y + 1 },\r\n\t\t\t{ x: lastPoint.x, y: lastPoint.y - 1 },\r\n\t\t];\r\n\r\n\t\tconst symPath = this.getSymmetryPath(this.path);\r\n\r\n\t\tfor (const n of neighbors) {\r\n\t\t\tif (n.x >= 0 && n.x <= this.puzzle.cols && n.y >= 0 && n.y <= this.puzzle.rows) {\r\n\t\t\t\tconst nPos = this.getCanvasCoords(n.x, n.y);\r\n\t\t\t\tconst dist = Math.hypot(nPos.x - this.currentMousePos.x, nPos.y - this.currentMousePos.y);\r\n\r\n\t\t\t\tif (dist < this.options.cellSize * 0.3) {\r\n\t\t\t\t\tconst idx = this.path.findIndex((p) => p.x === n.x && p.y === n.y);\r\n\t\t\t\t\tif (idx === -1) {\r\n\t\t\t\t\t\t// \u885D\u7A81\u30C1\u30A7\u30C3\u30AF\r\n\t\t\t\t\t\tif (symmetry !== SymmetryType.None) {\r\n\t\t\t\t\t\t\tconst sn = this.getSymmetricalPoint(n);\r\n\t\t\t\t\t\t\t// \u30CE\u30FC\u30C9\u81EA\u4F53\u304C\u5BFE\u79F0\u70B9\u306E\u5834\u5408\r\n\t\t\t\t\t\t\tif (n.x === sn.x && n.y === sn.y) continue;\r\n\t\t\t\t\t\t\t// \u4ED6\u306E\u7DDA\u3078\u306E\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\r\n\t\t\t\t\t\t\tif (this.path.some((p) => p.x === sn.x && p.y === sn.y)) continue;\r\n\t\t\t\t\t\t\tif (symPath.some((p) => p.x === n.x && p.y === n.y)) continue;\r\n\t\t\t\t\t\t\t// \u30A8\u30C3\u30B8\u306E\u885D\u7A81\u30C1\u30A7\u30C3\u30AF\r\n\t\t\t\t\t\t\tconst edgeKey = this.getEdgeKey(lastPoint, n);\r\n\t\t\t\t\t\t\tconst symEdgeKey = this.getEdgeKey(this.getSymmetricalPoint(lastPoint), sn);\r\n\t\t\t\t\t\t\tif (edgeKey === symEdgeKey) continue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.path.push(n);\r\n\t\t\t\t\t\tthis.emit(\"path:move\", { x: n.x, y: n.y, path: this.path, currentMousePos: this.currentMousePos });\r\n\t\t\t\t\t} else if (idx === this.path.length - 2) {\r\n\t\t\t\t\t\tconst popped = this.path.pop();\r\n\t\t\t\t\t\tif (popped) {\r\n\t\t\t\t\t\t\tthis.emit(\"path:move\", { x: popped.x, y: popped.y, path: this.path, currentMousePos: this.currentMousePos });\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.draw();\r\n\t}\r\n\r\n\tpublic handleEnd(e: { clientX: number; clientY: number }, source: \"mouse\" | \"touch\" = \"mouse\"): boolean {\r\n\t\tif (this.options.inputMode === \"twoClick\" && source !== \"mouse\") {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (this.worker) {\r\n\t\t\tif (this.isDrawing) {\r\n\t\t\t\tthis.isDrawing = false;\r\n\t\t\t\tthis.isTwoClickDrawing = false;\r\n\t\t\t\tthis.setTwoClickPointerUi(false);\r\n\t\t\t\tthis.worker.postMessage({ type: \"event\", payload: { eventType: \"mouseup\", eventData: { clientX: e.clientX, clientY: e.clientY } } });\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (!this.puzzle || !this.isDrawing) return false;\r\n\t\tthis.isDrawing = false;\r\n\t\tthis.isTwoClickDrawing = false;\r\n\t\tthis.setTwoClickPointerUi(false);\r\n\r\n\t\tconst lastPoint = this.path[this.path.length - 1];\r\n\t\tconst lastPos = this.getCanvasCoords(lastPoint.x, lastPoint.y);\r\n\t\tconst exitDir = this.getExitDir(lastPoint.x, lastPoint.y);\r\n\r\n\t\tconst startNode = this.getStartNodeMetaFromPath();\r\n\t\tconst endNode = this.getEndNodeMetaFromPath();\r\n\t\tif (exitDir) {\r\n\t\t\tconst dx_exit = this.currentMousePos.x - lastPos.x;\r\n\t\t\tconst dy_exit = this.currentMousePos.y - lastPos.y;\r\n\t\t\tconst dot = dx_exit * exitDir.x + dy_exit * exitDir.y;\r\n\r\n\t\t\tif (dot > 0) {\r\n\t\t\t\t// \u51FA\u3063\u5F35\u308A\u306E\u7BC4\u56F2\u306B\u5165\u3063\u3066\u3044\u308C\u3070\u3001\u6700\u5F8C\u307E\u3067\u4F38\u3070\u3057\u3066\u30B4\u30FC\u30EB\u3068\u3059\u308B\r\n\t\t\t\tthis.exitTipPos = {\r\n\t\t\t\t\tx: lastPos.x + exitDir.x * this.options.exitLength,\r\n\t\t\t\t\ty: lastPos.y + exitDir.y * this.options.exitLength,\r\n\t\t\t\t};\r\n\t\t\t\tthis.emit(\"path:complete\", { path: this.path, startNode, endNode });\r\n\t\t\t\tthis.emit(\"path:end\", { path: this.path, isExit: true, startNode, endNode });\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// \u30AD\u30E3\u30F3\u30BB\u30EB\u6642\u3082\u73FE\u5728\u306E\u5148\u7AEF\u4F4D\u7F6E\u3092\u4FDD\u6301\u3057\u3001\u30D5\u30A7\u30FC\u30C9\u958B\u59CB\u524D\u306B\u30CE\u30FC\u30C9\u3078\u7E2E\u307E\u306A\u3044\u3088\u3046\u306B\u3059\u308B\r\n\t\tthis.exitTipPos = { ...this.currentMousePos };\r\n\t\tthis.emit(\"path:end\", { path: this.path, isExit: false, startNode, endNode: null });\r\n\t\tthis.startFade(this.options.colors.interrupted); // \u9014\u4E2D\u3067\u96E2\u3057\u305F\u5834\u5408\u306F\u6307\u5B9A\u3055\u308C\u305F\u30D5\u30A7\u30FC\u30C9\u8272\u3067\u6D88\u3048\u308B\r\n\t\treturn true;\r\n\t}\r\n\r\n\tprivate getNodeIndexByType(type: NodeType.Start | NodeType.End, x: number, y: number): number {\r\n\t\tif (!this.puzzle) return -1;\r\n\t\tlet index = 0;\r\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\r\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\r\n\t\t\t\tif (this.puzzle.nodes[r][c].type === type) {\r\n\t\t\t\t\tif (c === x && r === y) {\r\n\t\t\t\t\t\treturn index;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tprivate getStartNodeMetaFromPath(): { x: number; y: number; index: number } | null {\r\n\t\tif (this.activeStartNode) return this.activeStartNode;\r\n\t\tif (!this.path.length) return null;\r\n\t\tconst start = this.path[0];\r\n\t\treturn { x: start.x, y: start.y, index: this.getNodeIndexByType(NodeType.Start, start.x, start.y) };\r\n\t}\r\n\r\n\tprivate getEndNodeMetaFromPath(): { x: number; y: number; index: number } | null {\r\n\t\tif (!this.path.length) return null;\r\n\t\tconst end = this.path[this.path.length - 1];\r\n\t\tif (!this.puzzle || this.puzzle.nodes[end.y]?.[end.x]?.type !== NodeType.End) return null;\r\n\t\treturn { x: end.x, y: end.y, index: this.getNodeIndexByType(NodeType.End, end.x, end.y) };\r\n\t}\r\n\r\n\t/**\r\n\t * \u4E8C\u70B9\u9593\u306E\u30A8\u30C3\u30B8\u30BF\u30A4\u30D7\u3092\u53D6\u5F97\u3059\u308B\r\n\t * @param p1 \u70B91\r\n\t * @param p2 \u70B92\r\n\t * @returns \u30A8\u30C3\u30B8\u30BF\u30A4\u30D7\r\n\t */\r\n\tprivate getEdgeType(p1: Point, p2: Point): EdgeType {\r\n\t\tif (!this.puzzle) return EdgeType.Absent;\r\n\t\tif (p1.x === p2.x) {\r\n\t\t\tconst y = Math.min(p1.y, p2.y);\r\n\t\t\tif (y < 0 || y >= this.puzzle.rows) return EdgeType.Absent;\r\n\t\t\treturn this.puzzle.vEdges[y][p1.x].type;\r\n\t\t} else {\r\n\t\t\tconst x = Math.min(p1.x, p2.x);\r\n\t\t\tif (x < 0 || x >= this.puzzle.cols) return EdgeType.Absent;\r\n\t\t\treturn this.puzzle.hEdges[p1.y][x].type;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u30D1\u30B9\u306E\u30D5\u30A7\u30FC\u30C9\u30A2\u30A6\u30C8\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u3092\u958B\u59CB\u3059\u308B\r\n\t * @param color \u30D5\u30A7\u30FC\u30C9\u6642\u306E\u8272\r\n\t */\r\n\tprivate startFade(color = \"#ff4444\") {\r\n\t\tthis.isFading = true;\r\n\t\tthis.fadeOpacity = 1.0;\r\n\t\tthis.fadeColor = color;\r\n\t\tthis.fadingPath = [...this.path];\r\n\t\tthis.fadingTipPos = this.exitTipPos ? { ...this.exitTipPos } : null;\r\n\t\tthis.path = [];\r\n\t}\r\n\r\n\t/**\r\n\t * \u73FE\u5728\u306E\u30D5\u30A7\u30FC\u30C9\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u3092\u4E2D\u6B62\u3059\u308B\r\n\t */\r\n\tprivate cancelFade() {\r\n\t\tthis.isFading = false;\r\n\t}\r\n\r\n\t/**\r\n\t * \u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u30EB\u30FC\u30D7\r\n\t */\r\n\tprivate animate() {\r\n\t\tif (this.isDestroyed) return;\r\n\t\tconst now = Date.now();\r\n\r\n\t\tif (this.isFading) {\r\n\t\t\t// \u30D5\u30A7\u30FC\u30C9\u901F\u5EA6\u3092 fadeDuration \u306B\u57FA\u3065\u3044\u3066\u8A08\u7B97\r\n\t\t\tconst step = 1000 / (this.options.animations.fadeDuration * 60); // 60FPS\u60F3\u5B9A\r\n\t\t\tthis.fadeOpacity -= step;\r\n\t\t\tif (this.fadeOpacity <= 0) {\r\n\t\t\t\tthis.isFading = false;\r\n\t\t\t\tthis.fadeOpacity = 0;\r\n\t\t\t\tif (this.isInvalidPath) {\r\n\t\t\t\t\tthis.isInvalidPath = false;\r\n\t\t\t\t\tthis.emit(\"goal:validated\", { result: { isValid: false } as any });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.isSuccessFading) {\r\n\t\t\tconst elapsed = now - this.successFadeStartTime;\r\n\t\t\tif (elapsed > this.options.animations.blinkDuration + this.options.animations.fadeDuration) {\r\n\t\t\t\tthis.isSuccessFading = false;\r\n\t\t\t\tthis.emit(\"goal:validated\", { result: { isValid: true } as any });\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// \u5931\u6557\u6642\u304B\u3064\u30D5\u30A7\u30FC\u30C9\u8A2D\u5B9A\u3042\u308A\u306E\u5834\u5408\u3001\u5373\u5EA7\u306B\u30D5\u30A7\u30FC\u30C9\u30A2\u30A6\u30C8\u3092\u958B\u59CB\u3059\u308B\r\n\t\tif (this.isInvalidPath && !this.options.stayPathOnError && !this.isFading && this.path.length > 0) {\r\n\t\t\tthis.startFade(this.options.colors.error);\r\n\t\t}\r\n\r\n\t\tthis.draw();\r\n\r\n\t\tif (typeof requestAnimationFrame !== \"undefined\") {\r\n\t\t\tthis.animationFrameId = requestAnimationFrame(() => this.animate());\r\n\t\t} else {\r\n\t\t\tthis.timeoutId = setTimeout(() => this.animate(), 1000 / 60);\r\n\t\t\tif (this.timeoutId && (this.timeoutId as any).unref) {\r\n\t\t\t\t(this.timeoutId as any).unref();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// --- Drawing Logic ---\r\n\r\n\tprivate lastGoalReachable = false;\r\n\r\n\tpublic draw() {\r\n\t\tif (!this.puzzle || !this.ctx) return;\r\n\r\n\t\tconst ctx = this.ctx;\r\n\t\tthis.emit(\"render:before\", { ctx });\r\n\r\n\t\tconst now = Date.now();\r\n\t\tconst dpr = this.options.pixelRatio;\r\n\r\n\t\tctx.setTransform(dpr, 0, 0, dpr, 0, 0);\r\n\t\tctx.globalAlpha = 1.0;\r\n\t\tctx.clearRect(0, 0, this.canvas.width / dpr, this.canvas.height / dpr);\r\n\r\n\t\tthis.drawGrid(ctx);\r\n\t\tthis.drawConstraints(ctx);\r\n\t\tthis.drawNodes(ctx);\r\n\r\n\t\tif (this.path.length === 0 && !this.isDrawing) {\r\n\t\t\tthis.drawRipples(ctx);\r\n\t\t}\r\n\r\n\t\tif (this.isFading) {\r\n\t\t\tthis.drawPath(ctx, this.fadingPath, false, this.fadeColor, this.fadeOpacity, this.fadingTipPos);\r\n\t\t\tif (this.puzzle.symmetry !== undefined && this.puzzle.symmetry !== SymmetryType.None) {\r\n\t\t\t\tconst symFadingPath = this.getSymmetryPath(this.fadingPath);\r\n\t\t\t\tlet symColor = this.options.colors.symmetry as string;\r\n\t\t\t\tif (this.isInvalidPath) {\r\n\t\t\t\t\tconst originalSymAlpha = this.colorToRgba(symColor).a;\r\n\t\t\t\t\tsymColor = this.setAlpha(this.options.colors.error as string, originalSymAlpha);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst symTipPos = this.getSymmetryTipPos(this.fadingTipPos, this.fadingPath);\r\n\t\t\t\tthis.drawPath(ctx, symFadingPath, false, symColor, this.fadeOpacity, symTipPos);\r\n\t\t\t}\r\n\t\t} else if (this.path.length > 0) {\r\n\t\t\tconst originalPathColor = this.options.colors.path as string;\r\n\t\t\tconst originalPathAlpha = this.colorToRgba(originalPathColor).a;\r\n\t\t\tconst errorColor = this.options.colors.error as string;\r\n\r\n\t\t\tlet color = this.isInvalidPath ? this.setAlpha(errorColor, originalPathAlpha) : originalPathColor;\r\n\r\n\t\t\t// \u6210\u529F\u6642\u306F\u6210\u529F\u6642\u306E\u8272\u3092\u30C7\u30D5\u30A9\u30EB\u30C8\u3068\u3059\u308B\uFF08\u5BFE\u79F0\u30E2\u30FC\u30C9\u6642\u306F\u5143\u306E\u8272\u3092\u7DAD\u6301\uFF09\r\n\t\t\tif ((this.isSuccessFading || this.isValidPath) && !this.puzzle.symmetry) {\r\n\t\t\t\tcolor = this.setAlpha(this.options.colors.success as string, originalPathAlpha);\r\n\t\t\t}\r\n\r\n\t\t\t// Eraser\u7121\u52B9\u5316\u524D\u306E\u70B9\u6EC5\u6642\u306A\u3069\u306E\u8272\u5236\u5FA1\r\n\t\t\tlet pathOpacity = 1.0;\r\n\t\t\tif (!this.isDrawing && this.exitTipPos && !this.isInvalidPath) {\r\n\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\r\n\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\r\n\t\t\t\tif (elapsed < blinkDuration) {\r\n\t\t\t\t\tif (this.isSuccessFading) {\r\n\t\t\t\t\t\tconst hasNegation = this.invalidatedCells.length > 0 || this.invalidatedEdges.length > 0 || this.invalidatedNodes.length > 0;\r\n\t\t\t\t\t\tif (hasNegation && this.options.blinkMarksOnError) {\r\n\t\t\t\t\t\t\t// \u6D88\u3057\u30B4\u30E0\u7121\u52B9\u5316\u304C\u3042\u308B\u6210\u529F\u6642\u306F\u3001\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u4E2D\u306E\u307F\u8D64\u8272\uFF08\u4E00\u77AC\u3067\u5207\u308A\u66FF\u3048\uFF09\r\n\t\t\t\t\t\t\tcolor = this.setAlpha(this.options.colors.error as string, originalPathAlpha);\r\n\t\t\t\t\t\t\tif (!this.options.stayPathOnError) {\r\n\t\t\t\t\t\t\t\tpathOpacity = Math.max(0, 1.0 - elapsed / this.options.animations.fadeDuration);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tconst mainTipPos = this.isDrawing ? this.currentMousePos : this.exitTipPos;\r\n\t\t\tconst symTipPos = this.getSymmetryTipPos(mainTipPos, this.path);\r\n\r\n\t\t\t// \u30B4\u30FC\u30EB\u5230\u9054\u6642\u306E\u767A\u5149\u51E6\u7406\uFF08\u70B9\u6EC5\uFF09\r\n\t\t\tconst isAtExit = this.isPathAtExit(this.path, this.isDrawing ? this.currentMousePos : this.exitTipPos);\r\n\r\n\t\t\tif (isAtExit !== this.lastGoalReachable) {\r\n\t\t\t\tthis.lastGoalReachable = isAtExit;\r\n\t\t\t\tthis.emit(\"goal:reachable\", { reachable: isAtExit });\r\n\t\t\t}\r\n\r\n\t\t\tif (isAtExit && !this.isInvalidPath && !this.isSuccessFading && !this.isValidPath) {\r\n\t\t\t\tconst originalAlpha = this.colorToRgba(color).a;\r\n\t\t\t\tconst pulseFactor = (Math.sin((now * Math.PI * 2) / 600) + 1) / 2;\r\n\t\t\t\tcolor = this.lerpColor(color, \"#ffffff\", pulseFactor * 0.6);\r\n\t\t\t\tcolor = this.setAlpha(color, originalAlpha);\r\n\t\t\t}\r\n\r\n\t\t\tthis.drawPath(ctx, this.path, this.isDrawing, color, pathOpacity, mainTipPos);\r\n\r\n\t\t\tif (this.puzzle.symmetry !== undefined && this.puzzle.symmetry !== SymmetryType.None) {\r\n\t\t\t\tconst symPath = this.getSymmetryPath(this.path);\r\n\t\t\t\tconst originalSymColor = this.options.colors.symmetry as string;\r\n\t\t\t\tconst originalSymAlpha = this.colorToRgba(originalSymColor).a;\r\n\t\t\t\tlet symColor = originalSymColor;\r\n\t\t\t\tlet symPathOpacity = pathOpacity;\r\n\r\n\t\t\t\t// \u30A8\u30E9\u30FC\u6642\u3084\u6210\u529F\u6642\u306F\u8272\u3092\u4E0A\u66F8\u304D\uFF08\u5BFE\u79F0\u30E2\u30FC\u30C9\u6210\u529F\u6642\u306F\u5143\u306E\u8272\u3092\u7DAD\u6301\uFF09\r\n\t\t\t\tif (this.isInvalidPath) {\r\n\t\t\t\t\tsymColor = this.setAlpha(errorColor, originalSymAlpha);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!this.isDrawing && this.exitTipPos && !this.isInvalidPath) {\r\n\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\r\n\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\r\n\t\t\t\t\tif (elapsed < blinkDuration) {\r\n\t\t\t\t\t\tif (this.isSuccessFading) {\r\n\t\t\t\t\t\t\tconst hasNegation = this.invalidatedCells.length > 0 || this.invalidatedEdges.length > 0 || this.invalidatedNodes.length > 0;\r\n\t\t\t\t\t\t\tif (hasNegation && this.options.blinkMarksOnError) {\r\n\t\t\t\t\t\t\t\tsymColor = this.setAlpha(this.options.colors.error as string, originalSymAlpha);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// \u5BFE\u79F0\u30D1\u30B9\u306E\u767A\u5149\u51E6\u7406\r\n\t\t\t\tif (isAtExit && !this.isInvalidPath && !this.isSuccessFading && !this.isValidPath) {\r\n\t\t\t\t\tconst pulseFactor = (Math.sin((now * Math.PI * 2) / 400) + 1) / 2;\r\n\t\t\t\t\tsymColor = this.lerpColor(symColor, \"#ffffff\", pulseFactor * 0.6);\r\n\t\t\t\t\tsymColor = this.setAlpha(symColor, originalSymAlpha);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.drawPath(ctx, symPath, this.isDrawing, symColor, symPathOpacity, symTipPos);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this.isDrawing && this.isTwoClickDrawing && this.path.length > 0) {\r\n\t\t\tconst lastPoint = this.path[this.path.length - 1];\r\n\t\t\tconst lastPos = this.getCanvasCoords(lastPoint.x, lastPoint.y);\r\n\t\t\tconst pointerPos = this.exitTipPos ? this.exitTipPos : this.currentMousePos || lastPos;\r\n\t\t\tthis.drawTwoClickPointer(ctx, pointerPos);\r\n\t\t}\r\n\t\tthis.applyFilter(ctx);\r\n\t\tthis.emit(\"render:after\", { ctx });\r\n\t}\r\n\r\n\tprivate drawTwoClickPointer(ctx: WitnessContext, pos: Point) {\r\n\t\tctx.save();\r\n\t\tctx.beginPath();\r\n\t\tctx.arc(pos.x, pos.y, this.options.pathWidth * 0.5, 0, Math.PI * 2);\r\n\t\tctx.fillStyle = \"rgba(255, 255, 255, 0.4)\";\r\n\t\tctx.fill();\r\n\t\tctx.restore();\r\n\t}\r\n\r\n\tprivate applyFilter(ctx: WitnessContext) {\r\n\t\tif (!this.options.filter.enabled) return;\r\n\r\n\t\tconst filterColor = this.getActiveFilterColor();\r\n\t\tif (filterColor === null || this.isNoopFilterColor(filterColor)) return;\r\n\r\n\t\tconst filterRgb = this.colorToRgba(filterColor);\r\n\t\tconst width = Math.max(1, Math.floor(this.canvas.width));\r\n\t\tconst height = Math.max(1, Math.floor(this.canvas.height));\r\n\t\tconst filterBuffer = this.prepareFilterBuffer(width, height);\r\n\r\n\t\tif (!filterBuffer) return;\r\n\t\tconst filterCtx = filterBuffer.ctx;\r\n\t\ttry {\r\n\t\t\t// \u5143\u306E\u8A08\u7B97\u5F0F (dst.rgb *= filter.rgb / 255) \u3092 blend \u3067\u518D\u73FE\u3057\u3064\u3064\u3001\r\n\t\t\t// \u30D4\u30AF\u30BB\u30EB\u8D70\u67FB\u3092\u907F\u3051\u3066\u8CA0\u8377\u3092\u4E0B\u3052\u308B\u3002\r\n\t\t\tfilterCtx.save();\r\n\t\t\tfilterCtx.setTransform(1, 0, 0, 1, 0, 0);\r\n\t\t\tfilterCtx.clearRect(0, 0, width, height);\r\n\t\t\tfilterCtx.drawImage(this.canvas as any, 0, 0, width, height);\r\n\r\n\t\t\tfilterCtx.globalCompositeOperation = \"multiply\";\r\n\t\t\tfilterCtx.fillStyle = `rgb(${filterRgb.r}, ${filterRgb.g}, ${filterRgb.b})`;\r\n\t\t\tfilterCtx.fillRect(0, 0, width, height);\r\n\r\n\t\t\t// multiply \u3067\u4E0D\u900F\u660E\u5316\u3057\u305Falpha\u3092\u5143\u753B\u50CF\u306Ealpha\u30DE\u30B9\u30AF\u3067\u623B\u3059\u3002\r\n\t\t\tfilterCtx.globalCompositeOperation = \"destination-in\";\r\n\t\t\tfilterCtx.drawImage(this.canvas as any, 0, 0, width, height);\r\n\t\t\tfilterCtx.restore();\r\n\r\n\t\t\tctx.save();\r\n\t\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\r\n\t\t\tctx.clearRect(0, 0, width, height);\r\n\t\t\tctx.drawImage(filterBuffer.canvas as any, 0, 0, width, height);\r\n\t\t\tctx.restore();\r\n\t\t} catch (e) {\r\n\t\t\t// \u7279\u6B8A\u306ACanvas\u5B9F\u88C5\u306A\u3069\u3067\u5408\u6210\u30E2\u30FC\u30C9\u304C\u4F7F\u3048\u306A\u3044\u5834\u5408\u306F\u4F55\u3082\u3057\u306A\u3044\r\n\t\t}\r\n\t}\r\n\r\n\tprivate prepareFilterBuffer(width: number, height: number): { canvas: HTMLCanvasElement | OffscreenCanvas; ctx: WitnessContext } | null {\r\n\t\tif (!this.filterCanvas) {\r\n\t\t\tif (typeof document !== \"undefined\") {\r\n\t\t\t\tthis.filterCanvas = document.createElement(\"canvas\");\r\n\t\t\t} else if (typeof OffscreenCanvas !== \"undefined\") {\r\n\t\t\t\tthis.filterCanvas = new OffscreenCanvas(width, height);\r\n\t\t\t} else {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tthis.filterCtx = (this.filterCanvas as any).getContext(\"2d\") as WitnessContext | null;\r\n\t\t}\r\n\t\tif (!this.filterCtx || !this.filterCanvas) return null;\r\n\r\n\t\tif (this.filterCanvas.width !== width || this.filterCanvas.height !== height) {\r\n\t\t\tthis.filterCanvas.width = width;\r\n\t\t\tthis.filterCanvas.height = height;\r\n\t\t}\r\n\r\n\t\treturn { canvas: this.filterCanvas, ctx: this.filterCtx as WitnessContext };\r\n\t}\r\n\r\n\tprivate getActiveFilterColor(): string | null {\r\n\t\tif (this.options.filter.mode === \"rgb\") {\r\n\t\t\tconst colors = this.options.filter.rgbColors ?? [\"#ff0000\", \"#00ff00\", \"#0000ff\"];\r\n\t\t\tconst index = Math.max(0, Math.min(2, this.options.filter.rgbIndex ?? 0));\r\n\t\t\treturn colors[index] ?? null;\r\n\t\t}\r\n\t\tconst color = this.options.filter.customColor;\r\n\t\tif (typeof color !== \"string\") return null;\r\n\t\tconst trimmed = color.trim();\r\n\t\treturn trimmed.length > 0 ? trimmed : null;\r\n\t}\r\n\r\n\tprivate isNoopFilterColor(color: string): boolean {\r\n\t\tconst normalized = color.toLowerCase().replace(/\\s+/g, \"\");\r\n\t\tif (normalized === \"#fff\" || normalized === \"#ffffff\" || normalized === \"rgb(255,255,255)\" || normalized === \"rgba(255,255,255,1)\") {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tconst rgba = this.colorToRgba(color);\r\n\t\treturn rgba.r === 255 && rgba.g === 255 && rgba.b === 255;\r\n\t}\r\n\r\n\t/**\r\n\t * \u30B4\u30FC\u30EB\u5730\u70B9\u306E\u6CE2\u7D0B\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3\u3092\u63CF\u753B\u3059\u308B\r\n\t * @param ctx \u63CF\u753B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\r\n\t */\r\n\tprivate drawRipples(ctx: WitnessContext) {\r\n\t\tif (!this.puzzle) return;\r\n\t\tconst time = (Date.now() - this.startTime) / 500;\r\n\r\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\r\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\r\n\t\t\t\tconst node = this.puzzle.nodes[r][c];\r\n\t\t\t\tif (node.type === NodeType.End) {\r\n\t\t\t\t\tconst pos = this.getCanvasCoords(c, r);\r\n\t\t\t\t\tconst dir = this.getExitDir(c, r);\r\n\t\t\t\t\tif (!dir) continue;\r\n\t\t\t\t\tconst exitPos = {\r\n\t\t\t\t\t\tx: pos.x + dir.x * this.options.exitLength,\r\n\t\t\t\t\t\ty: pos.y + dir.y * this.options.exitLength,\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tconst t = time % 4.0;\r\n\t\t\t\t\tconst radius = t * 5;\r\n\t\t\t\t\tconst opacity = Math.max(0, 1 - t / 3.0);\r\n\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tctx.arc(exitPos.x, exitPos.y, radius, 0, Math.PI * 2);\r\n\t\t\t\t\tctx.strokeStyle = `rgba(170, 170, 170, ${opacity * 0.4})`;\r\n\t\t\t\t\tctx.lineWidth = 2;\r\n\t\t\t\t\tctx.stroke();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u30B0\u30EA\u30C3\u30C9\uFF08\u80CC\u666F\u306E\u7DDA\uFF09\u3092\u63CF\u753B\u3059\u308B\r\n\t * @param ctx \u63CF\u753B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\r\n\t */\r\n\tprivate drawGrid(ctx: WitnessContext) {\r\n\t\tif (!this.puzzle || !this.options.colors.grid) return;\r\n\t\tctx.strokeStyle = this.options.colors.grid;\r\n\t\tctx.lineWidth = 12;\r\n\t\tctx.lineCap = \"round\";\r\n\r\n\t\tconst drawEdge = (p1: Point, p2: Point, type: EdgeType) => {\r\n\t\t\tif (type === EdgeType.Absent) return;\r\n\r\n\t\t\tif (type === EdgeType.Broken) {\r\n\t\t\t\tconst gapSize = 0.15;\r\n\t\t\t\tconst q1 = {\r\n\t\t\t\t\tx: p1.x + (p2.x - p1.x) * (0.5 - gapSize),\r\n\t\t\t\t\ty: p1.y + (p2.y - p1.y) * (0.5 - gapSize),\r\n\t\t\t\t};\r\n\t\t\t\tconst q2 = {\r\n\t\t\t\t\tx: p1.x + (p2.x - p1.x) * (0.5 + gapSize),\r\n\t\t\t\t\ty: p1.y + (p2.y - p1.y) * (0.5 + gapSize),\r\n\t\t\t\t};\r\n\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.moveTo(p1.x, p1.y);\r\n\t\t\t\tctx.lineTo(q1.x, q1.y);\r\n\t\t\t\tctx.stroke();\r\n\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.moveTo(q2.x, q2.y);\r\n\t\t\t\tctx.lineTo(p2.x, p2.y);\r\n\t\t\t\tctx.stroke();\r\n\t\t\t} else {\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.moveTo(p1.x, p1.y);\r\n\t\t\t\tctx.lineTo(p2.x, p2.y);\r\n\t\t\t\tctx.stroke();\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\r\n\t\t\tfor (let c = 0; c < this.puzzle.cols; c++) {\r\n\t\t\t\tdrawEdge(this.getCanvasCoords(c, r), this.getCanvasCoords(c + 1, r), this.puzzle.hEdges[r][c].type);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (let r = 0; r < this.puzzle.rows; r++) {\r\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\r\n\t\t\t\tdrawEdge(this.getCanvasCoords(c, r), this.getCanvasCoords(c, r + 1), this.puzzle.vEdges[r][c].type);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u5168\u3066\u306E\u5236\u7D04\u8A18\u53F7\uFF08\u56DB\u89D2\u3001\u661F\u3001\u516D\u89D2\u5F62\u306A\u3069\uFF09\u3092\u63CF\u753B\u3059\u308B\r\n\t * @param ctx \u63CF\u753B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\r\n\t */\r\n\tprivate drawConstraints(ctx: WitnessContext) {\r\n\t\tif (!this.puzzle) return;\r\n\t\tconst now = Date.now();\r\n\t\tconst blinkFactor = (Math.sin((now * Math.PI * 2) / this.options.animations.blinkPeriod!) + 1) / 2;\r\n\t\tconst invalidatedCellSet = new Set(this.invalidatedCells.map((p) => `${p.x},${p.y}`));\r\n\t\tconst errorCellSet = new Set(this.errorCells.map((p) => `${p.x},${p.y}`));\r\n\t\tconst invalidatedEdgeSet = new Set(this.invalidatedEdges.map((e) => `${e.type},${e.r},${e.c}`));\r\n\t\tconst errorEdgeSet = new Set(this.errorEdges.map((e) => `${e.type},${e.r},${e.c}`));\r\n\t\tconst invalidatedNodeSet = new Set(this.invalidatedNodes.map((p) => `${p.x},${p.y}`));\r\n\t\tconst errorNodeSet = new Set(this.errorNodes.map((p) => `${p.x},${p.y}`));\r\n\r\n\t\tfor (let r = 0; r < this.puzzle.rows; r++) {\r\n\t\t\tfor (let c = 0; c < this.puzzle.cols; c++) {\r\n\t\t\t\tconst cell = this.puzzle.cells[r][c];\r\n\t\t\t\tconst pos = this.getCanvasCoords(c + 0.5, r + 0.5);\r\n\t\t\t\tconst cellKey = `${c},${r}`;\r\n\r\n\t\t\t\tconst isInvalidated = invalidatedCellSet.has(cellKey);\r\n\t\t\t\tconst isError = errorCellSet.has(cellKey);\r\n\r\n\t\t\t\tlet opacity = 1.0;\r\n\t\t\t\tlet overrideColor: string | undefined = undefined;\r\n\r\n\t\t\t\tconst originalColor = this.getColorCode(cell.color);\r\n\t\t\t\tconst errorColor = this.options.colors.error as string;\r\n\r\n\t\t\t\tif (isError && this.options.blinkMarksOnError) {\r\n\t\t\t\t\toverrideColor = this.lerpColor(originalColor, errorColor, blinkFactor);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isInvalidated) {\r\n\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\r\n\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\r\n\r\n\t\t\t\t\tif (elapsed < blinkDuration) {\r\n\t\t\t\t\t\tif (this.options.blinkMarksOnError) {\r\n\t\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\r\n\t\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\r\n\t\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\r\n\t\t\t\t\t\t\toverrideColor = this.lerpColor(originalColor, errorColor, blinkFactor * transitionFactor);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\topacity = Math.max(0.3, 1.0 - (elapsed - blinkDuration) / this.options.animations.fadeDuration!);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tctx.save();\r\n\t\t\t\tif (opacity < 1.0) {\r\n\t\t\t\t\tctx.globalAlpha *= opacity;\r\n\t\t\t\t}\r\n\t\t\t\tthis.drawConstraintItem(ctx, cell, pos, overrideColor);\r\n\t\t\t\tctx.restore();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tctx.lineWidth = 2;\r\n\t\tconst hexRadius = 8;\r\n\t\tconst getHexColor = (type: EdgeType | NodeType) => {\r\n\t\t\tif (type === EdgeType.Hexagon || type === NodeType.Hexagon) return this.options.colors.hexagon as string;\r\n\t\t\tif (type === EdgeType.HexagonMain || type === NodeType.HexagonMain) return this.options.colors.hexagonMain as string;\r\n\t\t\tif (type === EdgeType.HexagonSymmetry || type === NodeType.HexagonSymmetry) return this.options.colors.hexagonSymmetry as string;\r\n\t\t\treturn this.options.colors.hexagon as string;\r\n\t\t};\r\n\r\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\r\n\t\t\tfor (let c = 0; c < this.puzzle.cols; c++) {\r\n\t\t\t\tconst type = this.puzzle.hEdges[r][c].type;\r\n\t\t\t\tif (type === EdgeType.Hexagon || type === EdgeType.HexagonMain || type === EdgeType.HexagonSymmetry) {\r\n\t\t\t\t\tconst pos = this.getCanvasCoords(c + 0.5, r);\r\n\t\t\t\t\tctx.save();\r\n\t\t\t\t\tconst edgeKey = `h,${r},${c}`;\r\n\t\t\t\t\tconst isInvalidated = invalidatedEdgeSet.has(edgeKey);\r\n\t\t\t\t\tconst isError = errorEdgeSet.has(edgeKey);\r\n\t\t\t\t\tconst baseColor = getHexColor(type);\r\n\r\n\t\t\t\t\tif (isError && this.options.blinkMarksOnError) {\r\n\t\t\t\t\t\tconst color = this.lerpColor(baseColor, this.options.colors.error as string, blinkFactor);\r\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\r\n\t\t\t\t\t} else if (isInvalidated) {\r\n\t\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\r\n\t\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\r\n\t\t\t\t\t\tif (elapsed < blinkDuration) {\r\n\t\t\t\t\t\t\tif (this.options.blinkMarksOnError) {\r\n\t\t\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\r\n\t\t\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\r\n\t\t\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\r\n\t\t\t\t\t\t\t\tconst color = this.lerpColor(baseColor, this.options.colors.error as string, blinkFactor * transitionFactor);\r\n\t\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tctx.globalAlpha *= Math.max(0.3, 1.0 - (elapsed - blinkDuration) / this.options.animations.fadeDuration!);\r\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tctx.restore();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let r = 0; r < this.puzzle.rows; r++) {\r\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\r\n\t\t\t\tconst type = this.puzzle.vEdges[r][c].type;\r\n\t\t\t\tif (type === EdgeType.Hexagon || type === EdgeType.HexagonMain || type === EdgeType.HexagonSymmetry) {\r\n\t\t\t\t\tconst pos = this.getCanvasCoords(c, r + 0.5);\r\n\t\t\t\t\tctx.save();\r\n\t\t\t\t\tconst edgeKey = `v,${r},${c}`;\r\n\t\t\t\t\tconst isInvalidated = invalidatedEdgeSet.has(edgeKey);\r\n\t\t\t\t\tconst isError = errorEdgeSet.has(edgeKey);\r\n\t\t\t\t\tconst baseColor = getHexColor(type);\r\n\r\n\t\t\t\t\tif (isError && this.options.blinkMarksOnError) {\r\n\t\t\t\t\t\tconst color = this.lerpColor(baseColor, this.options.colors.error as string, blinkFactor);\r\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\r\n\t\t\t\t\t} else if (isInvalidated) {\r\n\t\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\r\n\t\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\r\n\t\t\t\t\t\tif (elapsed < blinkDuration) {\r\n\t\t\t\t\t\t\tif (this.options.blinkMarksOnError) {\r\n\t\t\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\r\n\t\t\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\r\n\t\t\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\r\n\t\t\t\t\t\t\t\tconst color = this.lerpColor(baseColor, this.options.colors.error as string, blinkFactor * transitionFactor);\r\n\t\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tctx.globalAlpha *= Math.max(0.3, 1.0 - (elapsed - blinkDuration) / this.options.animations.fadeDuration!);\r\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tctx.restore();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\r\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\r\n\t\t\t\tconst type = this.puzzle.nodes[r][c].type;\r\n\t\t\t\tif (type === NodeType.Hexagon || type === NodeType.HexagonMain || type === NodeType.HexagonSymmetry) {\r\n\t\t\t\t\tconst pos = this.getCanvasCoords(c, r);\r\n\t\t\t\t\tctx.save();\r\n\t\t\t\t\tconst nodeKey = `${c},${r}`;\r\n\t\t\t\t\tconst isInvalidated = invalidatedNodeSet.has(nodeKey);\r\n\t\t\t\t\tconst isError = errorNodeSet.has(nodeKey);\r\n\t\t\t\t\tconst baseColor = getHexColor(type);\r\n\r\n\t\t\t\t\tif (isError && this.options.blinkMarksOnError) {\r\n\t\t\t\t\t\tconst color = this.lerpColor(baseColor, this.options.colors.error as string, blinkFactor);\r\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\r\n\t\t\t\t\t} else if (isInvalidated) {\r\n\t\t\t\t\t\tconst elapsed = now - (this.isSuccessFading ? this.successFadeStartTime : this.eraserAnimationStartTime);\r\n\t\t\t\t\t\tconst blinkDuration = this.options.animations.blinkDuration!;\r\n\t\t\t\t\t\tif (elapsed < blinkDuration) {\r\n\t\t\t\t\t\t\tif (this.options.blinkMarksOnError) {\r\n\t\t\t\t\t\t\t\tconst transitionIn = Math.min(1.0, elapsed / 200);\r\n\t\t\t\t\t\t\t\tconst transitionOut = elapsed > blinkDuration * 0.8 ? (blinkDuration - elapsed) / (blinkDuration * 0.2) : 1.0;\r\n\t\t\t\t\t\t\t\tconst transitionFactor = Math.min(transitionIn, transitionOut);\r\n\t\t\t\t\t\t\t\tconst color = this.lerpColor(baseColor, this.options.colors.error as string, blinkFactor * transitionFactor);\r\n\t\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, color);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tctx.globalAlpha *= Math.max(0.3, 1.0 - (elapsed - blinkDuration) / this.options.animations.fadeDuration!);\r\n\t\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.drawHexagon(ctx, pos.x, pos.y, hexRadius, baseColor);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tctx.restore();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u5358\u4E00\u306E\u5236\u7D04\u30A2\u30A4\u30C6\u30E0\u3092\u63CF\u753B\uFF08\u5EA7\u6A19\u306F\u30AD\u30E3\u30F3\u30D0\u30B9\u5168\u4F53\u306B\u5BFE\u3059\u308B\u7D76\u5BFE\u5EA7\u6A19\uFF09\r\n\t */\r\n\tprivate drawConstraintItem(ctx: WitnessContext, cell: CellConstraint, pos: Point, overrideColor?: string) {\r\n\t\tif (cell.type === CellType.Square) {\r\n\t\t\tconst size = 26;\r\n\t\t\tconst radius = 8;\r\n\t\t\tctx.fillStyle = overrideColor || this.getColorCode(cell.color);\r\n\t\t\tthis.drawRoundedRect(ctx, pos.x - size / 2, pos.y - size / 2, size, size, radius);\r\n\t\t} else if (cell.type === CellType.Star) {\r\n\t\t\tthis.drawStar(ctx, pos.x, pos.y, 12, 16, 8, cell.color, overrideColor);\r\n\t\t} else if (cell.type === CellType.Tetris || cell.type === CellType.TetrisRotated) {\r\n\t\t\tthis.drawTetris(ctx, pos.x, pos.y, cell.shape || [], cell.type === CellType.TetrisRotated, cell.color, false, overrideColor);\r\n\t\t} else if (cell.type === CellType.TetrisNegative || cell.type === CellType.TetrisNegativeRotated) {\r\n\t\t\tthis.drawTetris(ctx, pos.x, pos.y, cell.shape || [], cell.type === CellType.TetrisNegativeRotated, cell.color, true, overrideColor);\r\n\t\t} else if (cell.type === CellType.Eraser) {\r\n\t\t\tthis.drawEraser(ctx, pos.x, pos.y, 14, 3, cell.color, overrideColor);\r\n\t\t} else if (cell.type === CellType.Triangle) {\r\n\t\t\tthis.drawTriangle(ctx, pos.x, pos.y, cell.count || 0, cell.color, overrideColor);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u5168\u3066\u306E\u30CE\u30FC\u30C9\uFF08\u4EA4\u70B9\u3001\u59CB\u70B9\u3001\u7D42\u70B9\uFF09\u3092\u63CF\u753B\u3059\u308B\r\n\t * @param ctx \u63CF\u753B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\r\n\t */\r\n\tprivate drawNodes(ctx: WitnessContext) {\r\n\t\tif (!this.puzzle) return;\r\n\t\tconst isNodeIsolated = (c: number, r: number) => {\r\n\t\t\tconst connectedEdges: EdgeType[] = [];\r\n\t\t\tif (c > 0) connectedEdges.push(this.puzzle!.hEdges[r][c - 1].type);\r\n\t\t\tif (c < this.puzzle!.cols) connectedEdges.push(this.puzzle!.hEdges[r][c].type);\r\n\t\t\tif (r > 0) connectedEdges.push(this.puzzle!.vEdges[r - 1][c].type);\r\n\t\t\tif (r < this.puzzle!.rows) connectedEdges.push(this.puzzle!.vEdges[r][c].type);\r\n\t\t\treturn connectedEdges.length > 0 && connectedEdges.every((e) => e === EdgeType.Absent);\r\n\t\t};\r\n\r\n\t\tfor (let r = 0; r <= this.puzzle.rows; r++) {\r\n\t\t\tfor (let c = 0; c <= this.puzzle.cols; c++) {\r\n\t\t\t\tif (isNodeIsolated(c, r)) continue;\r\n\r\n\t\t\t\tconst node = this.puzzle.nodes[r][c];\r\n\t\t\t\tif (node.type === NodeType.Hexagon || node.type === NodeType.HexagonMain || node.type === NodeType.HexagonSymmetry) continue;\r\n\r\n\t\t\t\tconst pos = this.getCanvasCoords(c, r);\r\n\r\n\t\t\t\tif (node.type === NodeType.Start) {\r\n\t\t\t\t\tif (this.options.colors.node) ctx.fillStyle = this.options.colors.node;\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tctx.arc(pos.x, pos.y, this.options.startNodeRadius, 0, Math.PI * 2);\r\n\t\t\t\t\tctx.fill();\r\n\t\t\t\t} else if (node.type === NodeType.End) {\r\n\t\t\t\t\tconst dir = this.getExitDir(c, r);\r\n\t\t\t\t\tif (!dir) continue;\r\n\t\t\t\t\tif (this.options.colors.node) ctx.strokeStyle = this.options.colors.node;\r\n\t\t\t\t\tctx.lineWidth = 12;\r\n\t\t\t\t\tctx.lineCap = \"round\";\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tctx.moveTo(pos.x, pos.y);\r\n\t\t\t\t\tctx.lineTo(pos.x + dir.x * this.options.exitLength, pos.y + dir.y * this.options.exitLength);\r\n\t\t\t\t\tctx.stroke();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (this.options.colors.node) ctx.fillStyle = this.options.colors.node;\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tctx.arc(pos.x, pos.y, this.options.nodeRadius, 0, Math.PI * 2);\r\n\t\t\t\t\tctx.fill();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u89E3\u7B54\u30D1\u30B9\u3092\u63CF\u753B\u3059\u308B\uFF08\u30AA\u30D5\u30B9\u30AF\u30EA\u30FC\u30F3\u5408\u6210\u306B\u3088\u308A\u91CD\u306A\u308A\u3092\u9632\u6B62\uFF09\r\n\t * @param ctx \u63CF\u753B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\r\n\t * @param path \u30D1\u30B9\u5EA7\u6A19\u914D\u5217\r\n\t * @param isDrawing \u63CF\u753B\u4E2D\u304B\u3069\u3046\u304B\r\n\t * @param color \u30D1\u30B9\u306E\u8272\r\n\t * @param opacity \u4E0D\u900F\u660E\u5EA6\r\n\t * @param tipPos \u5148\u7AEF\u306E\u5EA7\u6A19\uFF08\u63CF\u753B\u4E2D\u7528\uFF09\r\n\t */\r\n\tprivate drawPath(ctx: WitnessContext, path: Point[], isDrawing: boolean, color: string | undefined, opacity: number, tipPos: Point | null = null) {\r\n\t\tif (path.length === 0 || !color || color === \"transparent\") return;\r\n\r\n\t\tconst rgba = this.colorToRgba(color);\r\n\t\tconst finalColor = `rgb(${rgba.r},${rgba.g},${rgba.b})`;\r\n\t\tconst finalOpacity = opacity * rgba.a;\r\n\r\n\t\t// \u91CD\u306A\u308A\u90E8\u5206\u306E\u8272\u304C\u6FC3\u304F\u306A\u308B\u306E\u3092\u9632\u3050\u305F\u3081\u3001\u5E38\u306B\u30AA\u30D5\u30B9\u30AF\u30EA\u30FC\u30F3\u3067\u4E0D\u900F\u660E\u306B\u63CF\u753B\u3057\u3066\u304B\u3089\u900F\u904E\u3067\u5408\u6210\u3059\u308B\r\n\t\tconst { canvas: tempCanvas, ctx: tempCtx } = this.prepareOffscreen();\r\n\t\tthis.drawPathInternal(tempCtx, path, isDrawing, finalColor, tipPos);\r\n\t\tctx.save();\r\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\r\n\t\tctx.globalAlpha = finalOpacity;\r\n\t\tctx.drawImage(tempCanvas, 0, 0);\r\n\t\tctx.restore();\r\n\t}\r\n\r\n\t/**\r\n\t * \u89E3\u7B54\u30D1\u30B9\u306E\u5B9F\u969B\u306E\u63CF\u753B\u51E6\u7406\r\n\t * @param ctx \u63CF\u753B\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\r\n\t * @param path \u30D1\u30B9\u5EA7\u6A19\u914D\u5217\r\n\t * @param isDrawing \u63CF\u753B\u4E2D\u304B\u3069\u3046\u304B\r\n\t * @param color \u30D1\u30B9\u306E\u8272\r\n\t * @param tipPos \u5148\u7AEF\u306E\u5EA7\u6A19\r\n\t */\r\n\tprivate drawPathInternal(ctx: WitnessContext, path: Point[], isDrawing: boolean, color: string, tipPos: Point | null = null) {\r\n\t\tctx.save();\r\n\t\tctx.strokeStyle = color;\r\n\t\tctx.fillStyle = color;\r\n\t\tctx.lineWidth = this.options.pathWidth;\r\n\t\tctx.lineCap = \"round\";\r\n\t\tctx.lineJoin = \"round\";\r\n\r\n\t\tctx.beginPath();\r\n\t\tconst startPos = this.getCanvasCoords(path[0].x, path[0].y);\r\n\t\tctx.moveTo(startPos.x, startPos.y);\r\n\r\n\t\tfor (let i = 1; i < path.length; i++) {\r\n\t\t\tconst pos = this.getCanvasCoords(path[i].x, path[i].y);\r\n\t\t\tctx.lineTo(pos.x, pos.y);\r\n\t\t}\r\n\r\n\t\tconst actualTipPos = tipPos || this.currentMousePos;\r\n\t\tif (isDrawing || tipPos) {\r\n\t\t\tctx.lineTo(actualTipPos.x, actualTipPos.y);\r\n\t\t}\r\n\r\n\t\tctx.stroke();\r\n\r\n\t\tctx.beginPath();\r\n\t\tctx.arc(startPos.x, startPos.y, this.options.startNodeRadius, 0, Math.PI * 2);\r\n\t\tctx.fill();\r\n\r\n\t\tif (isDrawing || tipPos) {\r\n\t\t\tctx.beginPath();\r\n\t\t\tctx.arc(actualTipPos.x, actualTipPos.y, this.options.pathWidth / 2, 0, Math.PI * 2);\r\n\t\t\tctx.fill();\r\n\t\t}\r\n\t\tctx.restore();\r\n\t}\r\n\r\n\t/**\r\n\t * \u89D2\u4E38\u9577\u65B9\u5F62\u3092\u63CF\u753B\u3059\u308B\r\n\t */\r\n\tprivate drawRoundedRect(ctx: WitnessContext, x: number, y: number, width: number, height: number, radius: number) {\r\n\t\tctx.beginPath();\r\n\t\tctx.moveTo(x + radius, y);\r\n\t\tctx.lineTo(x + width - radius, y);\r\n\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\r\n\t\tctx.lineTo(x + width, y + height - radius);\r\n\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\r\n\t\tctx.lineTo(x + radius, y + height);\r\n\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\r\n\t\tctx.lineTo(x, y + radius);\r\n\t\tctx.quadraticCurveTo(x, y, x + radius, y);\r\n\t\tctx.closePath();\r\n\t\tctx.fill();\r\n\t}\r\n\r\n\t/**\r\n\t * \u516D\u89D2\u5F62\uFF08\u901A\u904E\u5FC5\u9808\u30DE\u30FC\u30AF\uFF09\u3092\u63CF\u753B\u3059\u308B\r\n\t */\r\n\tprivate drawHexagon(ctx: WitnessContext, x: number, y: number, radius: number, overrideColor?: string) {\r\n\t\tif (!this.options.colors.hexagon && !overrideColor) return;\r\n\t\tctx.fillStyle = (overrideColor || this.options.colors.hexagon) as string;\r\n\t\tctx.beginPath();\r\n\t\tfor (let i = 0; i < 6; i++) {\r\n\t\t\tconst angle = (Math.PI / 3) * i;\r\n\t\t\tconst px = x + radius * Math.cos(angle);\r\n\t\t\tconst py = y + radius * Math.sin(angle);\r\n\t\t\tif (i === 0) ctx.moveTo(px, py);\r\n\t\t\telse ctx.lineTo(px, py);\r\n\t\t}\r\n\t\tctx.closePath();\r\n\t\tctx.fill();\r\n\t}\r\n\r\n\t/**\r\n\t * \u6D88\u3057\u30B4\u30E0\uFF08\u30C6\u30C8\u30E9\u30DD\u30C3\u30C9\uFF09\u3092\u63CF\u753B\u3059\u308B\r\n\t */\r\n\tprivate drawEraser(ctx: WitnessContext, x: number, y: number, radius: number, points: number, colorEnum: Color, overrideColor?: string) {\r\n\t\tctx.strokeStyle = overrideColor || this.getColorCode(colorEnum);\r\n\t\tctx.lineWidth = radius * 0.5;\r\n\t\tctx.lineCap = \"butt\";\r\n\t\tconst rotation = 0.5;\r\n\t\tctx.beginPath();\r\n\t\tfor (let i = 0; i < points; i++) {\r\n\t\t\tconst angle = ((Math.PI * 2) / points) * i + rotation;\r\n\t\t\tconst px = x + radius * Math.cos(angle);\r\n\t\t\tconst py = y + radius * Math.sin(angle);\r\n\r\n\t\t\tctx.moveTo(x, y);\r\n\t\t\tctx.lineTo(px, py);\r\n\t\t}\r\n\t\tctx.stroke();\r\n\t}\r\n\r\n\t/**\r\n\t * \u661F\u3092\u63CF\u753B\u3059\u308B\r\n\t */\r\n\tprivate drawStar(ctx: WitnessContext, x: number, y: number, innerRadius: number, outerRadius: number, points: number, colorEnum: Color, overrideColor?: string) {\r\n\t\tctx.fillStyle = overrideColor || this.getColorCode(colorEnum);\r\n\t\tctx.beginPath();\r\n\t\tfor (let i = 0; i < points * 2; i++) {\r\n\t\t\tconst radius = i % 2 === 0 ? outerRadius : innerRadius;\r\n\t\t\tconst angle = (Math.PI / points) * i;\r\n\t\t\tconst px = x + radius * Math.cos(angle);\r\n\t\t\tconst py = y + radius * Math.sin(angle);\r\n\t\t\tif (i === 0) ctx.moveTo(px, py);\r\n\t\t\telse ctx.lineTo(px, py);\r\n\t\t}\r\n\t\tctx.closePath();\r\n\t\tctx.fill();\r\n\t}\r\n\r\n\t/**\r\n\t * \u4E09\u89D2\u5F62\u3092\u63CF\u753B\u3059\u308B\r\n\t */\r\n\tprivate drawTriangle(ctx: WitnessContext, x: number, y: number, count: number, colorEnum: Color, overrideColor?: string) {\r\n\t\tif (count <= 0) return;\r\n\t\tconst color = overrideColor || this.getColorCode(colorEnum, \"#ffcc00\");\r\n\t\tctx.fillStyle = color;\r\n\r\n\t\tconst size = 12; // \u4E09\u89D2\u5F62\u306E\u5916\u63A5\u5186\u534A\u5F84\u306B\u8FD1\u3044\u30B5\u30A4\u30BA\r\n\t\tconst r = size * 0.8;\r\n\t\tconst spacing = r * 2.2;\r\n\r\n\t\tconst drawSingleTriangle = (tx: number, ty: number) => {\r\n\t\t\tctx.beginPath();\r\n\t\t\tfor (let i = 0; i < 3; i++) {\r\n\t\t\t\tconst angle = (Math.PI * 2 * i) / 3 - Math.PI / 2;\r\n\t\t\t\tconst px = tx + r * Math.cos(angle);\r\n\t\t\t\tconst py = ty + r * Math.sin(angle);\r\n\t\t\t\tif (i === 0) ctx.moveTo(px, py);\r\n\t\t\t\telse ctx.lineTo(px, py);\r\n\t\t\t}\r\n\t\t\tctx.closePath();\r\n\t\t\tctx.fill();\r\n\t\t};\r\n\r\n\t\tconst offset = (count - 1) * spacing * 0.5;\r\n\t\tfor (let i = 0; i < count; i++) {\r\n\t\t\tdrawSingleTriangle(x - offset + i * spacing, y);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u30C6\u30C8\u30EA\u30B9\u30D4\u30FC\u30B9\u3092\u63CF\u753B\u3059\u308B\r\n\t */\r\n\tprivate drawTetris(ctx: WitnessContext, x: number, y: number, shape: number[][], rotated: boolean, colorEnum: Color, isNegative: boolean, overrideColor?: string) {\r\n\t\tif (!shape || shape.length === 0) return;\r\n\t\tconst cellSize = 12;\r\n\t\tconst gap = 2;\r\n\t\tconst totalW = shape[0].length * cellSize + (shape[0].length - 1) * gap;\r\n\t\tconst totalH = shape.length * cellSize + (shape.length - 1) * gap;\r\n\r\n\t\tctx.save();\r\n\t\tctx.translate(x, y);\r\n\t\tif (rotated) {\r\n\t\t\tctx.rotate(Math.PI / 8);\r\n\t\t}\r\n\r\n\t\tconst color = overrideColor || this.getColorCode(colorEnum, isNegative ? \"#00ffff\" : \"#ffcc00\");\r\n\r\n\t\tif (isNegative) {\r\n\t\t\tctx.strokeStyle = color;\r\n\t\t\tctx.lineWidth = 2;\r\n\t\t\tfor (let r = 0; r < shape.length; r++) {\r\n\t\t\t\tfor (let c = 0; c < shape[r].length; c++) {\r\n\t\t\t\t\tif (shape[r][c]) {\r\n\t\t\t\t\t\tconst px = c * (cellSize + gap) - totalW / 2;\r\n\t\t\t\t\t\tconst py = r * (cellSize + gap) - totalH / 2;\r\n\t\t\t\t\t\tctx.strokeRect(px + 1, py + 1, cellSize - 2, cellSize - 2);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tctx.fillStyle = color;\r\n\t\t\tfor (let r = 0; r < shape.length; r++) {\r\n\t\t\t\tfor (let c = 0; c < shape[r].length; c++) {\r\n\t\t\t\t\tif (shape[r][c]) {\r\n\t\t\t\t\t\tconst px = c * (cellSize + gap) - totalW / 2;\r\n\t\t\t\t\t\tconst py = r * (cellSize + gap) - totalH / 2;\r\n\t\t\t\t\t\tctx.fillRect(px, py, cellSize, cellSize);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tctx.restore();\r\n\t}\r\n\r\n\t/**\r\n\t * Color\u5024\u306B\u5BFE\u5FDC\u3059\u308B\u30AB\u30E9\u30FC\u30B3\u30FC\u30C9\u3092\u53D6\u5F97\u3059\u308B\r\n\t * @param colorEnum Color\u5024\r\n\t * @param defaultFallback \u898B\u3064\u304B\u3089\u306A\u3044\u5834\u5408\u306E\u30C7\u30D5\u30A9\u30EB\u30C8\r\n\t * @returns \u30AB\u30E9\u30FC\u30B3\u30FC\u30C9\u6587\u5B57\u5217\r\n\t */\r\n\tprivate getColorCode(colorEnum: Color, defaultFallback = \"#666\"): string {\r\n\t\tif (this.options.colors.colorList && this.options.colors.colorList[colorEnum] !== undefined) {\r\n\t\t\treturn this.options.colors.colorList[colorEnum];\r\n\t\t}\r\n\t\tif (this.options.colors.colorMap && this.options.colors.colorMap[colorEnum] !== undefined) {\r\n\t\t\treturn this.options.colors.colorMap[colorEnum];\r\n\t\t}\r\n\t\treturn defaultFallback;\r\n\t}\r\n\r\n\t/**\r\n\t * \u30AB\u30E9\u30FC\u6587\u5B57\u5217\u3092RGBA\u6210\u5206\u306B\u5206\u89E3\u3059\u308B\r\n\t * @param color #hex \u307E\u305F\u306F rgba() \u6587\u5B57\u5217\r\n\t * @returns RGBA\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\r\n\t */\r\n\tprivate colorToRgba(color: string): { r: number; g: number; b: number; a: number } {\r\n\t\tif (!color || color === \"transparent\") {\r\n\t\t\treturn { r: 0, g: 0, b: 0, a: 0 };\r\n\t\t}\r\n\r\n\t\tif (color.startsWith(\"rgba\") || color.startsWith(\"rgb\")) {\r\n\t\t\tconst match = color.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\r\n\t\t\tif (match) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tr: parseInt(match[1]),\r\n\t\t\t\t\tg: parseInt(match[2]),\r\n\t\t\t\t\tb: parseInt(match[3]),\r\n\t\t\t\t\ta: match[4] ? parseFloat(match[4]) : 1.0,\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet c = color.startsWith(\"#\") ? color.slice(1) : color;\r\n\t\tif (c.length === 3 || c.length === 4) {\r\n\t\t\tc = c\r\n\t\t\t\t.split(\"\")\r\n\t\t\t\t.map((s) => s + s)\r\n\t\t\t\t.join(\"\");\r\n\t\t}\r\n\r\n\t\tif (c.length === 6) {\r\n\t\t\tconst i = parseInt(c, 16);\r\n\t\t\treturn {\r\n\t\t\t\tr: (i >> 16) & 255,\r\n\t\t\t\tg: (i >> 8) & 255,\r\n\t\t\t\tb: i & 255,\r\n\t\t\t\ta: 1.0,\r\n\t\t\t};\r\n\t\t} else if (c.length === 8) {\r\n\t\t\tconst i = parseInt(c, 16);\r\n\t\t\treturn {\r\n\t\t\t\tr: (i >> 24) & 255,\r\n\t\t\t\tg: (i >> 16) & 255,\r\n\t\t\t\tb: (i >> 8) & 255,\r\n\t\t\t\ta: (i & 255) / 255,\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn { r: 0, g: 0, b: 0, a: 1.0 };\r\n\t}\r\n\r\n\t/**\r\n\t * \u4E8C\u3064\u306E\u8272\u3092\u7DDA\u5F62\u88DC\u9593\u3059\u308B\r\n\t * @param c1 \u82721\r\n\t * @param c2 \u82722\r\n\t * @param t \u5272\u5408 (0.0 - 1.0)\r\n\t * @returns \u88DC\u9593\u5F8C\u306E\u8272 (rgba\u5F62\u5F0F)\r\n\t */\r\n\tprivate lerpColor(c1: string, c2: string, t: number): string {\r\n\t\ttry {\r\n\t\t\tconst rgba1 = this.colorToRgba(c1);\r\n\t\t\tconst rgba2 = this.colorToRgba(c2);\r\n\t\t\tconst r = Math.round(rgba1.r + (rgba2.r - rgba1.r) * t);\r\n\t\t\tconst g = Math.round(rgba1.g + (rgba2.g - rgba1.g) * t);\r\n\t\t\tconst b = Math.round(rgba1.b + (rgba2.b - rgba1.b) * t);\r\n\t\t\tconst a = rgba1.a + (rgba2.a - rgba1.a) * t;\r\n\t\t\treturn `rgba(${r},${g},${b},${a})`;\r\n\t\t} catch (e) {\r\n\t\t\treturn c1;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * \u8272\u306E\u30A2\u30EB\u30D5\u30A1\u5024\u3092\u4E0A\u66F8\u304D\u3059\u308B\r\n\t * @param color \u5143\u306E\u8272\r\n\t * @param alpha \u65B0\u3057\u3044\u30A2\u30EB\u30D5\u30A1\u5024\r\n\t * @returns \u5909\u66F4\u5F8C\u306E\u8272\r\n\t */\r\n\tprivate setAlpha(color: string, alpha: number): string {\r\n\t\tconst rgba = this.colorToRgba(color);\r\n\t\treturn `rgba(${rgba.r},${rgba.g},${rgba.b},${alpha})`;\r\n\t}\r\n\r\n\t/**\r\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30D1\u30B9\u306E\u5BFE\u79F0\u30D1\u30B9\u3092\u751F\u6210\u3059\u308B\r\n\t * @param path \u30E1\u30A4\u30F3\u30D1\u30B9\r\n\t * @returns \u5BFE\u79F0\u30D1\u30B9\r\n\t */\r\n\tprivate getSymmetryPath(path: Point[]): Point[] {\r\n\t\tif (!this.puzzle || !this.puzzle.symmetry) return [];\r\n\t\treturn path.map((p) => this.getSymmetricalPoint(p));\r\n\t}\r\n\r\n\t/**\r\n\t * \u6307\u5B9A\u3055\u308C\u305F\u70B9\u306E\u5BFE\u79F0\u70B9\u3092\u53D6\u5F97\u3059\u308B\r\n\t * @param p \u5143\u306E\u70B9\r\n\t * @param isFloat \u5C0F\u6570\u70B9\u5EA7\u6A19\u3092\u7DAD\u6301\u3059\u308B\u304B\r\n\t * @returns \u5BFE\u79F0\u70B9\r\n\t */\r\n\tprivate getSymmetricalPoint(p: Point, isFloat = false): Point {\r\n\t\tif (!this.puzzle || !this.puzzle.symmetry) return { ...p };\r\n\t\tconst { cols, rows, symmetry } = this.puzzle;\r\n\t\tif (symmetry === SymmetryType.Horizontal) {\r\n\t\t\treturn { x: cols - p.x, y: p.y };\r\n\t\t} else if (symmetry === SymmetryType.Vertical) {\r\n\t\t\treturn { x: p.x, y: rows - p.y };\r\n\t\t} else if (symmetry === SymmetryType.Rotational) {\r\n\t\t\treturn { x: cols - p.x, y: rows - p.y };\r\n\t\t}\r\n\t\treturn { ...p };\r\n\t}\r\n\r\n\t/**\r\n\t * \u30E1\u30A4\u30F3\u7DDA\u5148\u7AEF\u304B\u3089\u5BFE\u79F0\u7DDA\u5148\u7AEF\u5EA7\u6A19\u3092\u6C42\u3081\u308B\r\n\t */\r\n\tprivate getSymmetryTipPos(tipPos: Point | null, path: Point[]): Point | null {\r\n\t\tif (!this.puzzle || !this.puzzle.symmetry || !tipPos || path.length === 0) return null;\r\n\r\n\t\tconst symPath = this.getSymmetryPath(path);\r\n\t\tconst lastMain = path[path.length - 1];\r\n\t\tconst lastSym = symPath[symPath.length - 1];\r\n\t\tconst lastMainPos = this.getCanvasCoords(lastMain.x, lastMain.y);\r\n\t\tconst lastSymPos = this.getCanvasCoords(lastSym.x, lastSym.y);\r\n\r\n\t\tconst dx = tipPos.x - lastMainPos.x;\r\n\t\tconst dy = tipPos.y - lastMainPos.y;\r\n\r\n\t\tconst symDelta = this.getSymmetricalPoint({ x: dx / this.options.cellSize, y: dy / this.options.cellSize }, true);\r\n\t\tconst centerDelta = this.getSymmetricalPoint({ x: 0, y: 0 }, true);\r\n\r\n\t\treturn {\r\n\t\t\tx: lastSymPos.x + (symDelta.x - centerDelta.x) * this.options.cellSize,\r\n\t\t\ty: lastSymPos.y + (symDelta.y - centerDelta.y) * this.options.cellSize,\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30D1\u30B9\u306E\u5148\u7AEF\u304C\u51FA\u53E3\u306E\u51FA\u3063\u5F35\u308A\u306B\u3042\u308B\u304B\u5224\u5B9A\u3059\u308B\r\n\t */\r\n\tprivate isPathAtExit(path: Point[], tipPos: Point | null): boolean {\r\n\t\tif (path.length === 0 || !tipPos) return false;\r\n\t\tconst lastPoint = path[path.length - 1];\r\n\t\tconst exitDir = this.getExitDir(lastPoint.x, lastPoint.y);\r\n\t\tif (!exitDir) return false;\r\n\r\n\t\tconst lastPos = this.getCanvasCoords(lastPoint.x, lastPoint.y);\r\n\t\tconst dx = tipPos.x - lastPos.x;\r\n\t\tconst dy = tipPos.y - lastPos.y;\r\n\t\tconst dot = dx * exitDir.x + dy * exitDir.y;\r\n\r\n\t\treturn dot >= this.options.exitLength * 0.9; // 90%\u4EE5\u4E0A\u5F15\u304D\u5207\u3063\u3066\u3044\u305F\u3089\r\n\t}\r\n\r\n\t/**\r\n\t * \u4E8C\u70B9\u9593\u306E\u30A8\u30C3\u30B8\u3092\u8B58\u5225\u3059\u308B\u30E6\u30CB\u30FC\u30AF\u306A\u30AD\u30FC\u3092\u53D6\u5F97\u3059\u308B\r\n\t */\r\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\r\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\r\n\t}\r\n\r\n\t/**\r\n\t * \u5408\u6210\u7528\u306E\u30AA\u30D5\u30B9\u30AF\u30EA\u30FC\u30F3Canvas\u3092\u6E96\u5099\u3059\u308B\r\n\t */\r\n\t/**\r\n\t * Worker\u306B\u9001\u4FE1\u3067\u304D\u306A\u3044\u95A2\u6570\u306A\u3069\u306E\u30D7\u30ED\u30D1\u30C6\u30A3\u3092\u9664\u53BB\u3057\u305F\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u751F\u6210\u3059\u308B\r\n\t */\r\n\tprivate sanitizeOptions(options: WitnessUIOptions): any {\r\n\t\tconst sanitized: any = {};\r\n\t\tfor (const key in options) {\r\n\t\t\tconst value = (options as any)[key];\r\n\t\t\tif (value && typeof value === \"object\" && !Array.isArray(value)) {\r\n\t\t\t\tsanitized[key] = {};\r\n\t\t\t\tfor (const subKey in value) {\r\n\t\t\t\t\tif (typeof (value as any)[subKey] !== \"function\") {\r\n\t\t\t\t\t\t(sanitized[key] as any)[subKey] = (value as any)[subKey];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (typeof value !== \"function\") {\r\n\t\t\t\tsanitized[key] = value;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn sanitized;\r\n\t}\r\n\r\n\tprivate prepareOffscreen(): { canvas: HTMLCanvasElement | OffscreenCanvas; ctx: WitnessContext } {\r\n\t\tconst dpr = this.options.pixelRatio;\r\n\t\tif (!this.offscreenCanvas) {\r\n\t\t\tif (typeof document !== \"undefined\") {\r\n\t\t\t\tthis.offscreenCanvas = document.createElement(\"canvas\");\r\n\t\t\t} else if (typeof OffscreenCanvas !== \"undefined\") {\r\n\t\t\t\tthis.offscreenCanvas = new OffscreenCanvas(this.canvas.width, this.canvas.height);\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error(\"Offscreen canvas not supported in this environment.\");\r\n\t\t\t}\r\n\t\t\tthis.offscreenCtx = (this.offscreenCanvas as any).getContext(\"2d\") as WitnessContext | null;\r\n\t\t}\r\n\t\tif (this.offscreenCanvas.width !== this.canvas.width || this.offscreenCanvas.height !== this.canvas.height) {\r\n\t\t\tthis.offscreenCanvas.width = this.canvas.width;\r\n\t\t\tthis.offscreenCanvas.height = this.canvas.height;\r\n\t\t}\r\n\t\tif (!this.offscreenCtx) throw new Error(\"Could not get offscreen 2D context.\");\r\n\t\tthis.offscreenCtx.setTransform(dpr, 0, 0, dpr, 0, 0);\r\n\t\tthis.offscreenCtx.clearRect(0, 0, this.offscreenCanvas.width / dpr, this.offscreenCanvas.height / dpr);\r\n\t\treturn { canvas: this.offscreenCanvas, ctx: this.offscreenCtx };\r\n\t}\r\n}\r\n", "import { CellType, RngType, type CellConstraint, type DeserializedData, type GenerationOptions, type Point, type PuzzleData, type SerializationOptions, type SolutionPath } from \"./types\";\n\n/* ================= Bit IO ================= */\n\nclass BitWriter {\n\tprivate bytes: number[] = [];\n\tprivate cur = 0;\n\tprivate bit = 0;\n\n\twrite(value: number, bits: number) {\n\t\tfor (let i = 0; i < bits; i++) {\n\t\t\tif (value & (1 << i)) this.cur |= 1 << this.bit;\n\t\t\tthis.bit++;\n\t\t\tif (this.bit === 8) {\n\t\t\t\tthis.bytes.push(this.cur);\n\t\t\t\tthis.cur = 0;\n\t\t\t\tthis.bit = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfinish(): Uint8Array {\n\t\tif (this.bit > 0) this.bytes.push(this.cur);\n\t\treturn new Uint8Array(this.bytes);\n\t}\n}\n\nclass BitReader {\n\tprivate i = 0;\n\tprivate bit = 0;\n\tconstructor(private buf: Uint8Array) {}\n\n\tread(bits: number): number {\n\t\tlet v = 0;\n\t\tfor (let i = 0; i < bits; i++) {\n\t\t\tif (this.buf[this.i] & (1 << this.bit)) v |= 1 << i;\n\t\t\tthis.bit++;\n\t\t\tif (this.bit === 8) {\n\t\t\t\tthis.bit = 0;\n\t\t\t\tthis.i++;\n\t\t\t}\n\t\t}\n\t\treturn v;\n\t}\n\n\tget hasMore(): boolean {\n\t\treturn this.i < this.buf.length;\n\t}\n}\n\n/* ================= ECC (Reed-Solomon lite) ================= */\n\nconst GF256_EXP = new Uint8Array(512);\nconst GF256_LOG = new Uint8Array(256);\n{\n\tlet x = 1;\n\tfor (let i = 0; i < 255; i++) {\n\t\tGF256_EXP[i] = x;\n\t\tGF256_EXP[i + 255] = x;\n\t\tGF256_LOG[x] = i;\n\t\tx <<= 1;\n\t\tif (x & 0x100) x ^= 0x11d; // x^8 + x^4 + x^3 + x^2 + 1\n\t}\n}\n\nconst SHARE64_ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\nconst SHARE64_MAP = new Int16Array(128).fill(-1);\nfor (let i = 0; i < SHARE64_ALPHABET.length; i++) SHARE64_MAP[SHARE64_ALPHABET.charCodeAt(i)] = i;\n\nconst GF64_EXP = new Uint8Array(126);\nconst GF64_LOG = new Int16Array(64).fill(-1);\n{\n\tlet x = 1;\n\tfor (let i = 0; i < 63; i++) {\n\t\tGF64_EXP[i] = x;\n\t\tGF64_LOG[x] = i;\n\t\tx <<= 1;\n\t\tif (x & 0x40) x ^= 0x43; // x^6 + x + 1\n\t}\n\tfor (let i = 63; i < 126; i++) GF64_EXP[i] = GF64_EXP[i - 63];\n}\n\nfunction gf64_add(a: number, b: number): number {\n\treturn a ^ b;\n}\n\nfunction gf64_mul(a: number, b: number): number {\n\tif (a === 0 || b === 0) return 0;\n\treturn GF64_EXP[GF64_LOG[a] + GF64_LOG[b]];\n}\n\nfunction gf64_inv(a: number): number {\n\tif (a === 0) throw new Error(\"GF64 inverse of zero\");\n\treturn GF64_EXP[63 - GF64_LOG[a]];\n}\n\nfunction gf64_pow(a: number, p: number): number {\n\tif (p === 0) return 1;\n\tif (a === 0) return 0;\n\treturn GF64_EXP[(GF64_LOG[a] * p) % 63];\n}\n\n/* ================= Utils ================= */\n\nfunction collectShapes(cells: CellConstraint[][]): number[][][] {\n\tconst map = new Map<string, number[][]>();\n\tfor (const row of cells) {\n\t\tfor (const c of row) {\n\t\t\tif (c.shape) {\n\t\t\t\tconst key = JSON.stringify(c.shape);\n\t\t\t\tif (!map.has(key)) map.set(key, c.shape);\n\t\t\t}\n\t\t}\n\t}\n\treturn [...map.values()];\n}\n\n/* ================= Serializer ================= */\n\n/**\n * \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\u3001\u8A2D\u5B9A\u3001\u30B7\u30FC\u30C9\u3001\u7D4C\u8DEF\u306A\u3069\u3092\u30B7\u30EA\u30A2\u30E9\u30A4\u30BA/\u30C7\u30B7\u30EA\u30A2\u30E9\u30A4\u30BA\u3059\u308B\u30AF\u30E9\u30B9\n */\nexport class PuzzleSerializer {\n\t/**\n\t * \u30C7\u30FC\u30BF\u3092\u5727\u7E2E\u3055\u308C\u305FBase64\u6587\u5B57\u5217\u306B\u5909\u63DB\u3059\u308B\n\t */\n\tstatic async serialize(input: SerializationOptions): Promise<string> {\n\t\tconst bw = new BitWriter();\n\n\t\tlet flags = 0;\n\t\tif (input.puzzle) flags |= 1 << 0;\n\t\tif (input.seed) flags |= 1 << 1;\n\t\tif (input.options) flags |= 1 << 2;\n\t\tif (input.path) flags |= 1 << 3;\n\t\tif (input.filter) flags |= 1 << 5;\n\t\tconst recovery = input.parityMode === \"recovery\";\n\t\tif (recovery) flags |= 1 << 4;\n\n\t\tbw.write(flags, 8);\n\n\t\tif (input.puzzle) this.writePuzzle(bw, input.puzzle);\n\t\tif (input.seed) this.writeSeed(bw, input.seed);\n\t\tif (input.options) this.writeOptions(bw, input.options);\n\t\tif (input.path) this.writePath(bw, input.path);\n\t\tif (input.filter) this.writeFilter(bw, input.filter);\n\n\t\tconst raw = bw.finish();\n\t\tconst gz = new Uint8Array(await new Response(new Blob([raw.buffer as ArrayBuffer]).stream().pipeThrough(new CompressionStream(\"gzip\"))).arrayBuffer());\n\n\t\tconst useGzip = gz.length + 1 < raw.length;\n\t\tconst payload = useGzip ? gz : raw;\n\t\tconst modeByte = useGzip ? 1 : 0;\n\n\t\tconst body = new Uint8Array(payload.length + 1);\n\t\tbody[0] = modeByte;\n\t\tbody.set(payload, 1);\n\t\tlet p = 0;\n\t\tfor (const b of body) p ^= b;\n\t\tconst final = new Uint8Array(body.length + 1);\n\t\tfinal.set(body);\n\t\tfinal[body.length] = p;\n\n\t\tconst base = this.toBase64Url(final);\n\t\treturn recovery ? this.encodeRobustShareCode(base) : base;\n\t}\n\n\t/**\n\t * \u30B7\u30EA\u30A2\u30E9\u30A4\u30BA\u3055\u308C\u305F\u6587\u5B57\u5217\u304B\u3089\u30C7\u30FC\u30BF\u3092\u5FA9\u5143\u3059\u308B\n\t */\n\tstatic async deserialize(str: string): Promise<DeserializedData> {\n\t\tconst tryDecode = (s: string): Uint8Array | null => {\n\t\t\ttry {\n\t\t\t\tlet b64 = s.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\t\t\t\twhile (b64.length % 4) b64 += \"=\";\n\t\t\t\tconst bin = atob(b64);\n\t\t\t\treturn Uint8Array.from(bin, (c) => c.charCodeAt(0));\n\t\t\t} catch {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\n\t\tconst attemptRecovery = (data: Uint8Array): { payload: Uint8Array; compressed: boolean } | null => {\n\t\t\tif (data.length < 2) return null;\n\n\t\t\tlet p = 0;\n\t\t\tfor (let i = 0; i < data.length - 1; i++) p ^= data[i];\n\t\t\tconst body = p === data[data.length - 1] ? data.slice(0, -1) : null;\n\t\t\tif (!body || body.length < 1) return null;\n\t\t\tconst mode = body[0];\n\t\t\tif (mode !== 0 && mode !== 1) return null;\n\t\t\treturn { payload: body.slice(1), compressed: mode === 1 };\n\t\t};\n\n\t\tconst parseCandidate = async (candidate: string): Promise<DeserializedData | null> => {\n\t\t\tconst decoded = tryDecode(candidate);\n\t\t\tif (!decoded) return null;\n\t\t\tconst recovered = attemptRecovery(decoded);\n\t\t\tif (!recovered) return null;\n\t\t\ttry {\n\t\t\t\tconst parsed = await this.finalizeDeserialize(recovered.payload, recovered.compressed);\n\t\t\t\tif (parsed.puzzle || parsed.seed || parsed.options || parsed.path || parsed.filter) return parsed;\n\t\t\t} catch {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\n\t\tconst candidates = this.extractShareCodeCandidates(str);\n\t\tfor (const candidate of candidates) {\n\t\t\tconst parsed = await parseCandidate(candidate);\n\t\t\tif (parsed) return parsed;\n\t\t}\n\n\t\tfor (const candidate of candidates) {\n\t\t\tif (candidate.length >= 1000) continue;\n\t\t\tfor (let i = 0; i <= candidate.length; i++) {\n\t\t\t\tfor (let j = 0; j < SHARE64_ALPHABET.length; j++) {\n\t\t\t\t\tconst s = candidate.slice(0, i) + SHARE64_ALPHABET[j] + candidate.slice(i);\n\t\t\t\t\tconst parsed = await parseCandidate(s);\n\t\t\t\t\tif (parsed) return parsed;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error(\"Invalid parity data or unrecoverable corruption\");\n\t}\n\n\tprivate static toBase64Url(bytes: Uint8Array): string {\n\t\treturn btoa(String.fromCharCode(...bytes))\n\t\t\t.replace(/\\+/g, \"-\")\n\t\t\t.replace(/\\//g, \"_\")\n\t\t\t.replace(/=+$/, \"\");\n\t}\n\n\tprivate static share64Value(ch: string): number {\n\t\tconst code = ch.charCodeAt(0);\n\t\treturn code < SHARE64_MAP.length ? SHARE64_MAP[code] : -1;\n\t}\n\n\tprivate static solveLinearGF64(matrix: number[][], vector: number[]): number[] {\n\t\tconst n = matrix.length;\n\t\tconst a = matrix.map((row, i) => [...row, vector[i]]);\n\t\tfor (let col = 0; col < n; col++) {\n\t\t\tlet pivot = col;\n\t\t\twhile (pivot < n && a[pivot][col] === 0) pivot++;\n\t\t\tif (pivot === n) throw new Error(\"Singular matrix\");\n\t\t\tif (pivot !== col) [a[col], a[pivot]] = [a[pivot], a[col]];\n\t\t\tconst inv = gf64_inv(a[col][col]);\n\t\t\tfor (let j = col; j <= n; j++) a[col][j] = gf64_mul(a[col][j], inv);\n\t\t\tfor (let r = 0; r < n; r++) {\n\t\t\t\tif (r === col || a[r][col] === 0) continue;\n\t\t\t\tconst factor = a[r][col];\n\t\t\t\tfor (let j = col; j <= n; j++) a[r][j] = gf64_add(a[r][j], gf64_mul(factor, a[col][j]));\n\t\t\t}\n\t\t}\n\t\treturn a.map((row) => row[n]);\n\t}\n\n\tprivate static encodeRobustShareCode(core: string): string {\n\t\tif (core.length === 0) return \"r.0-8.0-8.0-8\";\n\t\tconst parityCount = 5;\n\t\tconst chunkSize = Math.max(8, Math.ceil(core.length / 59));\n\t\tconst dataChunkCount = Math.ceil(core.length / chunkSize);\n\t\tif (dataChunkCount + parityCount > 63) throw new Error(\"Share code is too long for recovery mode\");\n\n\t\tconst dataChunks: number[][] = [];\n\t\tfor (let i = 0; i < dataChunkCount; i++) {\n\t\t\tconst chars: number[] = [];\n\t\t\tfor (let j = 0; j < chunkSize; j++) {\n\t\t\t\tconst idx = i * chunkSize + j;\n\t\t\t\tif (idx < core.length) {\n\t\t\t\t\tconst v = this.share64Value(core[idx]);\n\t\t\t\t\tif (v < 0) throw new Error(\"Invalid core character for robust code\");\n\t\t\t\t\tchars.push(v);\n\t\t\t\t} else {\n\t\t\t\t\tchars.push(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdataChunks.push(chars);\n\t\t}\n\n\t\tconst parityChunks = Array.from({ length: parityCount }, () => Array(chunkSize).fill(0));\n\t\tfor (let pos = 0; pos < chunkSize; pos++) {\n\t\t\tfor (let pj = 0; pj < parityCount; pj++) {\n\t\t\t\tlet acc = 0;\n\t\t\t\tfor (let di = 0; di < dataChunkCount; di++) {\n\t\t\t\t\tconst coef = gf64_pow(di + 1, pj);\n\t\t\t\t\tacc = gf64_add(acc, gf64_mul(dataChunks[di][pos], coef));\n\t\t\t\t}\n\t\t\t\tparityChunks[pj][pos] = acc;\n\t\t\t}\n\t\t}\n\n\t\tconst checksum12 = (chunk: number[]): number => {\n\t\t\tlet acc = 0;\n\t\t\tfor (let i = 0; i < chunk.length; i++) acc = (acc + (i + 1) * chunk[i]) & 0xfff;\n\t\t\treturn acc;\n\t\t};\n\n\t\tconst toToken = (index: number, chunk: number[]) => {\n\t\t\tconst crc = checksum12(chunk);\n\t\t\tlet body = \"\";\n\t\t\tfor (const v of chunk) body += SHARE64_ALPHABET[v];\n\t\t\treturn `${SHARE64_ALPHABET[index]}${SHARE64_ALPHABET[(crc >> 6) & 0x3f]}${SHARE64_ALPHABET[crc & 0x3f]}${body}`;\n\t\t};\n\n\t\tconst tokens: string[] = [];\n\t\tfor (let i = 0; i < dataChunkCount; i++) tokens.push(toToken(i, dataChunks[i]));\n\t\tfor (let i = 0; i < parityCount; i++) tokens.push(toToken(dataChunkCount + i, parityChunks[i]));\n\t\tconst tokenStream = tokens.join(\".\");\n\n\t\tconst header = `${core.length.toString(36)}-${chunkSize.toString(36)}`;\n\t\tconst repeatedHeader = Array.from({ length: 8 }, () => header).join(\".\");\n\t\treturn `r.${repeatedHeader}.${tokenStream}`;\n\t}\n\n\tprivate static decodeRobustShareCode(str: string): string | null {\n\t\tif (!str.startsWith(\"r.\")) return null;\n\t\tlet coreLen = -1;\n\t\tlet chunkSize = -1;\n\t\tlet tail = \"\";\n\t\tconst compactHeader = /^r\\.([0-9a-z]+)\\.([0-9a-z]+)(?:\\.(.*))?$/.exec(str);\n\t\tif (compactHeader) {\n\t\t\tcoreLen = Number.parseInt(compactHeader[1], 36);\n\t\t\tchunkSize = Number.parseInt(compactHeader[2], 36);\n\t\t\ttail = compactHeader[3] || \"\";\n\t\t\tif (coreLen >= 0 && chunkSize >= 1) return this.decodeRobustCore(coreLen, chunkSize, tail);\n\t\t}\n\n\t\tconst segments = str.slice(2).split(\".\");\n\t\tlet headerIndex = -1;\n\t\tfor (let i = 0; i < segments.length; i++) {\n\t\t\tconst seg = segments[i];\n\t\t\tconst m = /^([0-9a-z]+)-([0-9a-z]+)$/.exec(seg);\n\t\t\tif (!m) continue;\n\t\t\tconst l = Number.parseInt(m[1], 36);\n\t\t\tconst c = Number.parseInt(m[2], 36);\n\t\t\tif (Number.isFinite(l) && l >= 0 && Number.isFinite(c) && c >= 1) {\n\t\t\t\tcoreLen = l;\n\t\t\t\tchunkSize = c;\n\t\t\t\theaderIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (headerIndex < 0 || coreLen < 0 || chunkSize < 1) return null;\n\t\ttail = segments.slice(headerIndex + 1).join(\".\");\n\t\treturn this.decodeRobustCore(coreLen, chunkSize, tail);\n\t}\n\n\tprivate static decodeRobustCore(coreLen: number, chunkSize: number, tail: string): string | null {\n\t\tconst parityCount = 5;\n\t\tconst dataChunkCount = coreLen === 0 ? 0 : Math.ceil(coreLen / chunkSize);\n\t\tconst totalChunkCount = dataChunkCount + parityCount;\n\t\tif (totalChunkCount > 63) return null;\n\t\tif (coreLen === 0) return \"\";\n\n\t\tconst tokenLen = chunkSize + 3;\n\t\tif (tail.length < tokenLen) return null;\n\n\t\tconst checksum12 = (chunk: number[]): number => {\n\t\t\tlet acc = 0;\n\t\t\tfor (let i = 0; i < chunk.length; i++) acc = (acc + (i + 1) * chunk[i]) & 0xfff;\n\t\t\treturn acc;\n\t\t};\n\n\t\tconst chunks: Array<number[] | null> = Array(totalChunkCount).fill(null);\n\t\tfor (const t of tail.split(\".\")) {\n\t\t\tif (t.length !== tokenLen) continue;\n\t\t\tconst idx = this.share64Value(t[0]);\n\t\t\tconst crcHi = this.share64Value(t[1]);\n\t\t\tconst crcLo = this.share64Value(t[2]);\n\t\t\tif (idx < 0 || idx >= totalChunkCount || crcHi < 0 || crcLo < 0) continue;\n\t\t\tconst data: number[] = [];\n\t\t\tlet ok = true;\n\t\t\tfor (let j = 3; j < t.length; j++) {\n\t\t\t\tconst v = this.share64Value(t[j]);\n\t\t\t\tif (v < 0) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdata.push(v);\n\t\t\t}\n\t\t\tif (!ok) continue;\n\t\t\tconst crc = (crcHi << 6) | crcLo;\n\t\t\tif (checksum12(data) !== crc) continue;\n\t\t\tchunks[idx] = data;\n\t\t}\n\n\t\tconst missingSet = new Set<number>();\n\t\tfor (let i = 0; i < dataChunkCount; i++) if (!chunks[i]) missingSet.add(i);\n\t\tif (missingSet.size > parityCount) return null;\n\n\t\tconst availableParity: number[] = [];\n\t\tfor (let i = 0; i < parityCount; i++) if (chunks[dataChunkCount + i]) availableParity.push(i);\n\t\tif (missingSet.size > availableParity.length) return null;\n\n\t\tconst missingData = [...missingSet];\n\t\tif (missingData.length > 0) {\n\t\t\tconst rows = availableParity.slice(0, missingData.length);\n\t\t\tfor (let pos = 0; pos < chunkSize; pos++) {\n\t\t\t\tconst mat = rows.map((r) => missingData.map((di) => gf64_pow(di + 1, r)));\n\t\t\t\tconst vec = rows.map((r) => {\n\t\t\t\t\tlet rhs = (chunks[dataChunkCount + r] as number[])[pos];\n\t\t\t\t\tfor (let di = 0; di < dataChunkCount; di++) {\n\t\t\t\t\t\tif (missingSet.has(di)) continue;\n\t\t\t\t\t\trhs = gf64_add(rhs, gf64_mul((chunks[di] as number[])[pos], gf64_pow(di + 1, r)));\n\t\t\t\t\t}\n\t\t\t\t\treturn rhs;\n\t\t\t\t});\n\t\t\t\tconst solved = this.solveLinearGF64(mat, vec);\n\t\t\t\tfor (let i = 0; i < missingData.length; i++) {\n\t\t\t\t\tconst di = missingData[i];\n\t\t\t\t\tif (!chunks[di]) chunks[di] = Array(chunkSize).fill(0);\n\t\t\t\t\t(chunks[di] as number[])[pos] = solved[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet core = \"\";\n\t\tfor (let i = 0; i < dataChunkCount; i++) {\n\t\t\tconst chunk = chunks[i];\n\t\t\tif (!chunk) return null;\n\t\t\tfor (const v of chunk) core += SHARE64_ALPHABET[v];\n\t\t}\n\t\treturn core.slice(0, coreLen);\n\t}\n\n\tprivate static extractShareCodeCandidates(str: string): string[] {\n\t\tconst set = new Set<string>();\n\t\tif (str) set.add(str);\n\t\tconst decodedRobust = this.decodeRobustShareCode(str);\n\t\tif (decodedRobust) set.add(decodedRobust);\n\t\treturn [...set];\n\t}\n\n\tprivate static async finalizeDeserialize(payload: Uint8Array, compressed: boolean): Promise<DeserializedData> {\n\t\tconst raw = compressed ? new Uint8Array(await new Response(new Blob([payload.buffer as ArrayBuffer]).stream().pipeThrough(new DecompressionStream(\"gzip\"))).arrayBuffer()) : payload;\n\t\tconst br = new BitReader(raw);\n\n\t\tconst flags = br.read(8);\n\t\tconst result: DeserializedData = {};\n\n\t\tif (flags & (1 << 0)) result.puzzle = this.readPuzzle(br);\n\t\tif (flags & (1 << 1)) result.seed = this.readSeed(br);\n\t\tif (flags & (1 << 2)) result.options = this.readOptions(br);\n\t\tif (flags & (1 << 3)) result.path = this.readPath(br);\n\t\tif (flags & (1 << 5)) result.filter = this.readFilter(br);\n\n\t\treturn result;\n\t}\n\n\tprivate static writePuzzle(bw: BitWriter, puzzle: PuzzleData) {\n\t\tbw.write(puzzle.rows, 6);\n\t\tbw.write(puzzle.cols, 6);\n\t\tbw.write(puzzle.symmetry ?? 0, 2);\n\n\t\tconst shapes = collectShapes(puzzle.cells);\n\t\tbw.write(shapes.length, 5);\n\t\tfor (const s of shapes) {\n\t\t\tbw.write(s.length, 4);\n\t\t\tbw.write(s[0].length, 4);\n\t\t\tfor (const r of s) for (const v of r) bw.write(v, 1);\n\t\t}\n\n\t\tconst shapeIndex = new Map<string, number>();\n\t\tshapes.forEach((s, i) => shapeIndex.set(JSON.stringify(s), i));\n\n\t\tfor (const row of puzzle.cells) {\n\t\t\tfor (const c of row) {\n\t\t\t\tbw.write(c.type, 4);\n\t\t\t\tbw.write(c.color, 3);\n\t\t\t\tif (c.type === CellType.Triangle) {\n\t\t\t\t\tbw.write(c.count || 0, 2);\n\t\t\t\t} else if (c.shape) {\n\t\t\t\t\tbw.write(1, 1);\n\t\t\t\t\tbw.write(shapeIndex.get(JSON.stringify(c.shape))!, 5);\n\t\t\t\t} else {\n\t\t\t\t\tbw.write(0, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let y = 0; y < puzzle.rows; y++) for (let x = 0; x < puzzle.cols + 1; x++) bw.write(puzzle.vEdges[y][x].type, 3);\n\t\tfor (let y = 0; y < puzzle.rows + 1; y++) for (let x = 0; x < puzzle.cols; x++) bw.write(puzzle.hEdges[y][x].type, 3);\n\t\tfor (let y = 0; y < puzzle.rows + 1; y++) for (let x = 0; x < puzzle.cols + 1; x++) bw.write(puzzle.nodes[y][x].type, 3);\n\t}\n\n\tprivate static readPuzzle(br: BitReader): PuzzleData {\n\t\tconst rows = br.read(6);\n\t\tconst cols = br.read(6);\n\t\tconst symmetry = br.read(2);\n\n\t\tconst shapeCount = br.read(5);\n\t\tconst shapes: number[][][] = [];\n\t\tfor (let i = 0; i < shapeCount; i++) {\n\t\t\tconst h = br.read(4);\n\t\t\tconst w = br.read(4);\n\t\t\tconst s: number[][] = [];\n\t\t\tfor (let y = 0; y < h; y++) {\n\t\t\t\tconst r: number[] = [];\n\t\t\t\tfor (let x = 0; x < w; x++) r.push(br.read(1));\n\t\t\t\ts.push(r);\n\t\t\t}\n\t\t\tshapes.push(s);\n\t\t}\n\n\t\tconst cells: CellConstraint[][] = [];\n\t\tfor (let y = 0; y < rows; y++) {\n\t\t\tconst row: CellConstraint[] = [];\n\t\t\tfor (let x = 0; x < cols; x++) {\n\t\t\t\tconst type = br.read(4) as CellType;\n\t\t\t\tconst color = br.read(3);\n\t\t\t\tconst cell: CellConstraint = { type, color };\n\t\t\t\tif (type === CellType.Triangle) {\n\t\t\t\t\tcell.count = br.read(2);\n\t\t\t\t} else {\n\t\t\t\t\tif (br.read(1)) cell.shape = shapes[br.read(5)].map((r) => r.slice());\n\t\t\t\t}\n\t\t\t\trow.push(cell);\n\t\t\t}\n\t\t\tcells.push(row);\n\t\t}\n\n\t\tconst vEdges = Array.from({ length: rows }, () => Array.from({ length: cols + 1 }, () => ({ type: br.read(3) })));\n\t\tconst hEdges = Array.from({ length: rows + 1 }, () => Array.from({ length: cols }, () => ({ type: br.read(3) })));\n\t\tconst nodes = Array.from({ length: rows + 1 }, () => Array.from({ length: cols + 1 }, () => ({ type: br.read(3) })));\n\n\t\treturn { rows, cols, cells, vEdges, hEdges, nodes, symmetry };\n\t}\n\n\tprivate static writeSeed(bw: BitWriter, seed: { type: RngType; value: string }) {\n\t\tbw.write(seed.type, 2);\n\t\tbw.write(seed.value.length, 8);\n\t\tfor (let i = 0; i < seed.value.length; i++) {\n\t\t\tbw.write(parseInt(seed.value[i], 16), 4);\n\t\t}\n\t}\n\n\tprivate static readSeed(br: BitReader): { type: RngType; value: string } {\n\t\tconst type = br.read(2) as RngType;\n\t\tconst len = br.read(8);\n\t\tlet value = \"\";\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tvalue += br.read(4).toString(16);\n\t\t}\n\t\treturn { type, value };\n\t}\n\n\tprivate static writeOptions(bw: BitWriter, options: GenerationOptions) {\n\t\tbw.write(options.rows ?? 0, 6);\n\t\tbw.write(options.cols ?? 0, 6);\n\t\tbw.write(+!!options.useHexagons, 1);\n\t\tbw.write(+!!options.useSquares, 1);\n\t\tbw.write(+!!options.useStars, 1);\n\t\tbw.write(+!!options.useTetris, 1);\n\t\tbw.write(+!!options.useTetrisNegative, 1);\n\t\tbw.write(+!!options.useEraser, 1);\n\t\tbw.write(+!!options.useTriangles, 1);\n\t\tbw.write(+!!options.useBrokenEdges, 1);\n\t\tbw.write(options.symmetry ?? 0, 2);\n\t\tbw.write(Math.round((options.complexity ?? 0) * 254), 8);\n\t\tbw.write(Math.round((options.difficulty ?? 0) * 254), 8);\n\t\tbw.write(Math.round((options.pathLength ?? 0) * 254), 8);\n\n\t\tif (options.availableColors && options.availableColors.length > 0) {\n\t\t\tbw.write(1, 1);\n\t\t\tbw.write(options.availableColors.length, 4);\n\t\t\tfor (const c of options.availableColors) bw.write(c, 3);\n\t\t} else {\n\t\t\tbw.write(0, 1);\n\t\t}\n\n\t\tif (options.defaultColors) {\n\t\t\tconst entries = Object.entries(options.defaultColors);\n\t\t\tbw.write(entries.length, 4);\n\t\t\tfor (const [key, val] of entries) {\n\t\t\t\tconst type = isNaN(Number(key)) ? (CellType as any)[key] : Number(key);\n\t\t\t\tbw.write(type, 4);\n\t\t\t\tbw.write(val as number, 3);\n\t\t\t}\n\t\t} else {\n\t\t\tbw.write(0, 4);\n\t\t}\n\t}\n\n\tprivate static readOptions(br: BitReader): GenerationOptions {\n\t\tconst options: GenerationOptions = {};\n\t\tconst rows = br.read(6);\n\t\tconst cols = br.read(6);\n\t\tif (rows > 0) options.rows = rows;\n\t\tif (cols > 0) options.cols = cols;\n\n\t\tif (br.read(1)) options.useHexagons = true;\n\t\tif (br.read(1)) options.useSquares = true;\n\t\tif (br.read(1)) options.useStars = true;\n\t\tif (br.read(1)) options.useTetris = true;\n\t\tif (br.read(1)) options.useTetrisNegative = true;\n\t\tif (br.read(1)) options.useEraser = true;\n\t\tif (br.read(1)) options.useTriangles = true;\n\t\tif (br.read(1)) options.useBrokenEdges = true;\n\t\toptions.symmetry = br.read(2);\n\n\t\tconst readRatio = () => Math.round((br.read(8) / 254) * 1000) / 1000;\n\t\toptions.complexity = readRatio();\n\t\toptions.difficulty = readRatio();\n\t\toptions.pathLength = readRatio();\n\n\t\tif (br.read(1)) {\n\t\t\tconst len = br.read(4);\n\t\t\toptions.availableColors = [];\n\t\t\tfor (let i = 0; i < len; i++) options.availableColors.push(br.read(3));\n\t\t}\n\n\t\tconst defLen = br.read(4);\n\t\tif (defLen > 0) {\n\t\t\toptions.defaultColors = {};\n\t\t\tfor (let i = 0; i < defLen; i++) {\n\t\t\t\tconst type = br.read(4);\n\t\t\t\tconst color = br.read(3);\n\t\t\t\t(options.defaultColors as any)[type] = color;\n\t\t\t}\n\t\t}\n\n\t\treturn options;\n\t}\n\n\tprivate static writePath(bw: BitWriter, path: SolutionPath) {\n\t\tbw.write(path.points.length, 12);\n\t\tif (path.points.length === 0) return;\n\t\tbw.write(path.points[0].x, 6);\n\t\tbw.write(path.points[0].y, 6);\n\t\tfor (let i = 1; i < path.points.length; i++) {\n\t\t\tconst p1 = path.points[i - 1];\n\t\t\tconst p2 = path.points[i];\n\t\t\tconst dx = p2.x - p1.x;\n\t\t\tconst dy = p2.y - p1.y;\n\t\t\tlet dir = 0;\n\t\t\tif (dy === -1) dir = 0;\n\t\t\telse if (dx === 1) dir = 1;\n\t\t\telse if (dy === 1) dir = 2;\n\t\t\telse if (dx === -1) dir = 3;\n\t\t\tbw.write(dir, 2);\n\t\t}\n\t}\n\n\tprivate static readPath(br: BitReader): SolutionPath {\n\t\tconst len = br.read(12);\n\t\tif (len === 0) return { points: [] };\n\t\tconst points: Point[] = [];\n\t\tlet x = br.read(6);\n\t\tlet y = br.read(6);\n\t\tpoints.push({ x, y });\n\t\tfor (let i = 1; i < len; i++) {\n\t\t\tconst dir = br.read(2);\n\t\t\tif (dir === 0) y--;\n\t\t\telse if (dir === 1) x++;\n\t\t\telse if (dir === 2) y++;\n\t\t\telse if (dir === 3) x--;\n\t\t\tpoints.push({ x, y });\n\t\t}\n\t\treturn { points };\n\t}\n\n\tprivate static writeColorHex24(bw: BitWriter, color: string) {\n\t\tconst v = /^#[0-9a-fA-F]{6}$/.test(color) ? color : \"#000000\";\n\t\tbw.write(parseInt(v.slice(1), 16), 24);\n\t}\n\n\tprivate static readColorHex24(br: BitReader): string {\n\t\treturn `#${br.read(24).toString(16).padStart(6, \"0\")}`;\n\t}\n\n\tprivate static writeFilter(bw: BitWriter, filter: { enabled?: boolean; mode?: \"custom\" | \"rgb\"; customColor?: string; rgbColors?: [string, string, string]; rgbIndex?: 0 | 1 | 2; threshold?: number }) {\n\t\tbw.write(+!!filter.enabled, 1);\n\t\tbw.write(filter.mode === \"rgb\" ? 1 : 0, 1);\n\t\tthis.writeColorHex24(bw, filter.customColor ?? \"#ffffff\");\n\t\tconst rgb = filter.rgbColors ?? [\"#ff0000\", \"#00ff00\", \"#0000ff\"];\n\t\tthis.writeColorHex24(bw, rgb[0]);\n\t\tthis.writeColorHex24(bw, rgb[1]);\n\t\tthis.writeColorHex24(bw, rgb[2]);\n\t\tbw.write(Math.max(0, Math.min(2, filter.rgbIndex ?? 0)), 2);\n\t\tbw.write(Math.max(0, Math.min(255, Math.round(filter.threshold ?? 128))), 8);\n\t}\n\n\tprivate static readFilter(br: BitReader): {\n\t\tenabled?: boolean;\n\t\tmode?: \"custom\" | \"rgb\";\n\t\tcustomColor?: string;\n\t\trgbColors?: [string, string, string];\n\t\trgbIndex?: 0 | 1 | 2;\n\t\tthreshold?: number;\n\t} {\n\t\treturn {\n\t\t\tenabled: !!br.read(1),\n\t\t\tmode: br.read(1) ? \"rgb\" : \"custom\",\n\t\t\tcustomColor: this.readColorHex24(br),\n\t\t\trgbColors: [this.readColorHex24(br), this.readColorHex24(br), this.readColorHex24(br)],\n\t\t\trgbIndex: br.read(2) as 0 | 1 | 2,\n\t\t\tthreshold: br.read(8),\n\t\t};\n\t}\n}\n", "import { PuzzleGenerator } from \"./generator\";\nimport { Grid } from \"./grid\";\nimport { type GenerationOptions, type Point, type PuzzleData, type SolutionPath, type ValidationResult } from \"./types\";\nimport { WitnessUI } from \"./ui\";\nimport { PuzzleValidator } from \"./validator\";\n\n// \u30E9\u30A4\u30D6\u30E9\u30EA\u306E\u30D5\u30A1\u30B5\u30FC\u30C9\u30AF\u30E9\u30B9\nexport { PuzzleGenerator } from \"./generator\";\nexport { Grid } from \"./grid\";\nexport { PuzzleSerializer } from \"./serializer\";\nexport { WitnessUI } from \"./ui\";\nexport { PuzzleValidator } from \"./validator\";\n\n/**\n * the witness\u30D1\u30BA\u30EB\u306E\u30B3\u30A2\u6A5F\u80FD\uFF08\u751F\u6210\u30FB\u691C\u8A3C\u30FB\u96E3\u6613\u5EA6\u8A08\u7B97\uFF09\u3092\u63D0\u4F9B\u3059\u308B\u30E1\u30A4\u30F3\u30AF\u30E9\u30B9\n */\nexport class WitnessCore {\n\tprivate generator: PuzzleGenerator;\n\tprivate validator: PuzzleValidator;\n\n\t/**\n\t * \u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u3092\u751F\u6210\u3059\u308B\n\t */\n\tconstructor() {\n\t\tthis.generator = new PuzzleGenerator();\n\t\tthis.validator = new PuzzleValidator();\n\t}\n\n\t/**\n\t * \u6307\u5B9A\u3055\u308C\u305F\u30B5\u30A4\u30BA\u3068\u30AA\u30D7\u30B7\u30E7\u30F3\u3067\u65B0\u3057\u3044\u30D1\u30BA\u30EB\u3092\u751F\u6210\u3059\u308B\n\t * @param rows \u884C\u6570\n\t * @param cols \u5217\u6570\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\n\t * @returns \u751F\u6210\u3055\u308C\u305F\u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\n\t */\n\tpublic createPuzzle(rows: number, cols: number, options: GenerationOptions = {}): PuzzleData {\n\t\tconst grid = this.generator.generate(rows, cols, options);\n\t\treturn grid.export();\n\t}\n\n\t/**\n\t * \u4E0E\u3048\u3089\u308C\u305F\u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\u306B\u5BFE\u3057\u3066\u89E3\u7B54\u30D1\u30B9\u3092\u691C\u8A3C\u3059\u308B\n\t * @param puzzleData \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\n\t * @param solution \u89E3\u7B54\u30D1\u30B9\n\t * @returns \u691C\u8A3C\u7D50\u679C\n\t */\n\tpublic validateSolution(puzzleData: PuzzleData, solution: SolutionPath): ValidationResult {\n\t\tconst grid = Grid.fromData(puzzleData);\n\t\treturn this.validator.validate(grid, solution);\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\u306E\u96E3\u6613\u5EA6\u3092\u7B97\u51FA\u3059\u308B\n\t * @param puzzleData \u30D1\u30BA\u30EB\u30C7\u30FC\u30BF\n\t * @returns \u96E3\u6613\u5EA6\u30B9\u30B3\u30A2 (0.0 - 1.0)\n\t */\n\tpublic calculateDifficulty(puzzleData: PuzzleData): number {\n\t\tconst grid = Grid.fromData(puzzleData);\n\t\treturn this.validator.calculateDifficulty(grid);\n\t}\n}\n\n// \u30D6\u30E9\u30A6\u30B6/Node.js\u74B0\u5883\u4E21\u5BFE\u5FDC\u306E\u305F\u3081\u306E\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\nexport * from \"./types\";\n\n/**\n * Worker\u74B0\u5883\u3067\u306E\u81EA\u52D5\u30BB\u30C3\u30C8\u30A2\u30C3\u30D7\n * MiniWitness\u81EA\u4F53\u3092Worker\u3068\u3057\u3066\u6307\u5B9A\u3057\u305F\u5834\u5408\uFF08new Worker(\"MiniWitness.js\")\uFF09\u306B\n * \u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u30CF\u30F3\u30C9\u30EB\u3057\u3066\u30D1\u30BA\u30EB\u751F\u6210\u3084UI\u7BA1\u7406\u3092\u81EA\u52D5\u3067\u884C\u3046\u6A5F\u80FD\n */\nif (typeof self !== \"undefined\" && \"postMessage\" in self && !(\"document\" in self)) {\n\tconst core = new WitnessCore();\n\tlet ui: WitnessUI | null = null;\n\tlet currentPuzzle: PuzzleData | null = null;\n\n\t(self as any).addEventListener(\"message\", (e: MessageEvent) => {\n\t\tconst { type, payload } = e.data;\n\n\t\tswitch (type) {\n\t\t\tcase \"init\": {\n\t\t\t\tconst { canvas, options } = payload;\n\t\t\t\tui = new WitnessUI(canvas, undefined, options);\n\t\t\t\tui.on(\"path:complete\", ({ path }: { path: Point[] }) => {\n\t\t\t\t\t(self as any).postMessage({ type: \"drawingEnded\" });\n\t\t\t\t\t// Always send pathComplete to allow the main thread to track the current path\n\t\t\t\t\t(self as any).postMessage({ type: \"pathComplete\", payload: path });\n\n\t\t\t\t\tif (options.autoValidate && currentPuzzle) {\n\t\t\t\t\t\tconst result = core.validateSolution(currentPuzzle, { points: path });\n\t\t\t\t\t\tui!.setValidationResult(result.isValid, result.invalidatedCells, result.invalidatedEdges, result.errorCells, result.errorEdges, result.invalidatedNodes, result.errorNodes);\n\t\t\t\t\t\t(self as any).postMessage({ type: \"validationResult\", payload: result });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"createPuzzle\": {\n\t\t\t\tconst { rows, cols, genOptions } = payload;\n\t\t\t\tconst puzzle = core.createPuzzle(rows, cols, genOptions);\n\t\t\t\tself.postMessage({ type: \"puzzleCreated\", payload: { puzzle, genOptions } });\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"setPuzzle\": {\n\t\t\t\tcurrentPuzzle = payload.puzzle;\n\t\t\t\tif (ui && currentPuzzle) {\n\t\t\t\t\tui.setPuzzle(currentPuzzle);\n\t\t\t\t\tif (payload.options) {\n\t\t\t\t\t\tui.setOptions(payload.options);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"setOptions\": {\n\t\t\t\tif (ui) ui.setOptions(payload);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"setPath\": {\n\t\t\t\tif (ui) ui.setPath(payload.path);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"setValidationResult\": {\n\t\t\t\tif (ui) {\n\t\t\t\t\tui.setValidationResult(payload.isValid, payload.invalidatedCells, payload.invalidatedEdges, payload.errorCells, payload.errorEdges, payload.invalidatedNodes, payload.errorNodes);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"setCanvasRect\": {\n\t\t\t\tif (ui) ui.setCanvasRect(payload);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"validate\": {\n\t\t\t\tif (currentPuzzle) {\n\t\t\t\t\tconst result = core.validateSolution(currentPuzzle, { points: payload.path });\n\t\t\t\t\tif (ui) {\n\t\t\t\t\t\tui.setValidationResult(result.isValid, result.invalidatedCells, result.invalidatedEdges, result.errorCells, result.errorEdges, result.invalidatedNodes, result.errorNodes);\n\t\t\t\t\t}\n\t\t\t\t\tself.postMessage({ type: \"validationResult\", payload: result });\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase \"event\": {\n\t\t\t\tconst { eventType, eventData } = payload;\n\t\t\t\tif (ui) {\n\t\t\t\t\tif (eventType === \"mousedown\" || eventType === \"touchstart\") {\n\t\t\t\t\t\tconst started = ui.handleStart(eventData, eventType === \"touchstart\" ? \"touch\" : \"mouse\");\n\t\t\t\t\t\t(self as any).postMessage({ type: \"drawingStarted\", payload: started });\n\t\t\t\t\t} else if (eventType === \"mousemove\" || eventType === \"touchmove\") {\n\t\t\t\t\t\tui.handleMove(eventData);\n\t\t\t\t\t} else if (eventType === \"mouseup\" || eventType === \"touchend\") {\n\t\t\t\t\t\tui.handleEnd(eventData, eventType === \"touchend\" ? \"touch\" : \"mouse\");\n\t\t\t\t\t\t(self as any).postMessage({ type: \"drawingEnded\" });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n}\n"],
  "mappings": "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",
  "names": ["Direction", "CellType", "EdgeType", "NodeType", "SymmetryType", "RngType", "errorCells", "nodeCols", "path", "grid", "symmetry", "p", "c", "r", "symPath"]
}
