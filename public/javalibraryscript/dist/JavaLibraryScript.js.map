{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/base/Enum.js",
    "src/base/Interface.js",
    "src/base/index.js",
    "src/index.js",
    "src/libs/IndexProxy.js",
    "src/libs/ProxyManager.js",
    "src/libs/TypeChecker.js",
    "src/libs/cache/CacheWrapper.js",
    "src/libs/cache/index.js",
    "src/libs/index.js",
    "src/libs/sys/JavaLibraryScriptCore.js",
    "src/libs/sys/Logger.js",
    "src/libs/sys/index.js",
    "src/libs/sys/symbol/SymbolDict.js",
    "src/libs/sys/symbol/index.js",
    "src/main.js",
    "src/math/BigFloat.js",
    "src/math/index.js",
    "src/util/ArrayList.js",
    "src/util/HashMap.js",
    "src/util/HashSet.js",
    "src/util/ListInterface.js",
    "src/util/MapInterface.js",
    "src/util/SetInterface.js",
    "src/util/index.js",
    "src/util/stream/AsyncStream.js",
    "src/util/stream/BigFloatStream.js",
    "src/util/stream/EntryStream.js",
    "src/util/stream/NumberStream.js",
    "src/util/stream/Stream.js",
    "src/util/stream/StreamChecker.js",
    "src/util/stream/StreamInterface.js",
    "src/util/stream/StringStream.js",
    "src/util/stream/index.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9RA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvbA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3dA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3tFA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACngBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "const JavaLibraryScriptCore = require(\"../libs/sys/JavaLibraryScriptCore\");\r\n\r\n/**\r\n * 単一のEnum要素を表すクラス\r\n * @extends {JavaLibraryScriptCore}\r\n * @class\r\n */\r\nclass _EnumItem extends JavaLibraryScriptCore {\r\n\t/**\r\n\t * @param {string} name - Enumのキー名\r\n\t * @param {number} ordinal - 順序番号（自動インクリメント）\r\n\t * @param {any} value - 任意の値（name, 数値, オブジェクトなど）\r\n\t * @param {_EnumCore} [owner] - Enumのインスタンス\r\n\t * @param {{[methodName: string]: (...args: any[]) => any}} [methods] - Enumのメソッド\r\n\t */\r\n\tconstructor(name, ordinal, value = name, owner = null, methods = {}) {\r\n\t\tsuper();\r\n\t\tthis.name = name;\r\n\t\tthis.ordinal = ordinal;\r\n\t\tthis.value = value;\r\n\r\n\t\tthis.owner = owner;\r\n\r\n\t\tfor (const [key, fn] of Object.entries(methods)) {\r\n\t\t\tif (typeof fn === \"function\") {\r\n\t\t\t\tthis[key] = fn.bind(this);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tObject.freeze(this);\r\n\t}\r\n\r\n\t/**\r\n\t * 名前を返す\r\n\t * @returns {string}\r\n\t */\r\n\ttoString() {\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\t/**\r\n\t * JSON化\r\n\t * @returns {string}\r\n\t */\r\n\ttoJSON() {\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\t/**\r\n\t * ordinalでの比較\r\n\t * @param {this} other\r\n\t * @returns {number}\r\n\t */\r\n\tcompareTo(other) {\r\n\t\treturn this.ordinal - other.ordinal;\r\n\t}\r\n\r\n\t/**\r\n\t * 同一EnumItemかチェック\r\n\t * @param {this} other\r\n\t * @returns {boolean}\r\n\t */\r\n\tequals(other) {\r\n\t\treturn other instanceof _EnumItem && this.name === other.name && this.ordinal === other.ordinal && this.value === other.value;\r\n\t}\r\n\r\n\t/**\r\n\t * ハッシュコード生成（簡易）\r\n\t * @returns {number}\r\n\t */\r\n\thashCode() {\r\n\t\treturn this.name.split(\"\").reduce((h, c) => h + c.charCodeAt(0), 0) + this.ordinal * 31;\r\n\t}\r\n}\r\n\r\n/**\r\n * Enum を生成するクラス\r\n * @extends {JavaLibraryScriptCore}\r\n * @class\r\n */\r\nclass _EnumCore extends JavaLibraryScriptCore {\r\n\t/**\r\n\t * @param {Array<string | [string, any]> | Record<string, any>} defs - 定義\r\n\t * @param {{[methodName: string]: (...args: any[]) => any}} [options.methods] - Enumのメソッド\r\n\t */\r\n\tconstructor(defs, options = {}) {\r\n\t\tsuper();\r\n\t\t/** @type {_EnumItem[]} */\r\n\t\tthis._items = [];\r\n\t\tthis._methods = options.methods || {};\r\n\r\n\t\tlet entries;\r\n\r\n\t\tif (Array.isArray(defs)) {\r\n\t\t\tentries = defs.map((def) => (Array.isArray(def) ? def : [def, def]));\r\n\t\t} else if (typeof defs === \"object\" && defs !== null) {\r\n\t\t\tentries = Object.entries(defs);\r\n\t\t} else {\r\n\t\t\tthrow new TypeError(\"Enum: 配列か連想配列で定義してください\");\r\n\t\t}\r\n\r\n\t\tentries.forEach(([name, value], index) => {\r\n\t\t\tconst item = new _EnumItem(name, index, value, this, this._methods);\r\n\t\t\tObject.defineProperty(this, name, {\r\n\t\t\t\tvalue: item,\r\n\t\t\t\twritable: false,\r\n\t\t\t\tconfigurable: false,\r\n\t\t\t\tenumerable: true,\r\n\t\t\t});\r\n\t\t\tthis._items.push(item);\r\n\t\t});\r\n\r\n\t\tObject.freeze(this._items);\r\n\t}\r\n\r\n\t/**\r\n\t * Enumの全要素を配列で取得\r\n\t * @returns {_EnumItem[]}\r\n\t */\r\n\tvalues() {\r\n\t\treturn this._items.slice();\r\n\t}\r\n\r\n\t/**\r\n\t * 名前からEnumItemを取得\r\n\t * @param {string} name\r\n\t * @returns {_EnumItem | undefined}\r\n\t */\r\n\tvalueOf(name) {\r\n\t\treturn this[name];\r\n\t}\r\n\t/**\r\n\t * 名前からEnumItemを取得\r\n\t * @param {string} name\r\n\t * @returns {_EnumItem | undefined}\r\n\t */\r\n\tfromName = valueOf;\r\n\r\n\t/**\r\n\t * 値からEnumItemを取得\r\n\t * @param {any} value\r\n\t * @returns {_EnumItem | undefined}\r\n\t */\r\n\tfromValue(value) {\r\n\t\treturn this._items.find((e) => e.value === value);\r\n\t}\r\n\r\n\t/**\r\n\t * ordinalからEnumItemを取得\r\n\t * @param {number} ordinal\r\n\t * @returns {_EnumItem | undefined}\r\n\t */\r\n\tfromOrdinal(ordinal) {\r\n\t\treturn this._items.find((e) => e.ordinal === ordinal);\r\n\t}\r\n\r\n\t/**\r\n\t * Enumにそのnameが存在するか\r\n\t * @param {string} name\r\n\t * @returns {boolean}\r\n\t */\r\n\thas(name) {\r\n\t\treturn typeof this[name] === \"object\" && this[name] instanceof _EnumItem;\r\n\t}\r\n\r\n\t/**\r\n\t * name → _EnumItem の [name, item] 配列を返す\r\n\t * @returns {[string, _EnumItem][]}\r\n\t */\r\n\tentries() {\r\n\t\treturn this._items.map((e) => [e.name, e]);\r\n\t}\r\n\r\n\t/**\r\n\t * Enumの全nameを返す\r\n\t * @returns {string[]}\r\n\t */\r\n\tkeys() {\r\n\t\treturn this._items.map((e) => e.name);\r\n\t}\r\n\r\n\t/**\r\n\t * name → value のマップを返す\r\n\t * @returns {Record<string, any>}\r\n\t */\r\n\ttoMap() {\r\n\t\tconst map = {};\r\n\t\tfor (const e of this._items) {\r\n\t\t\tmap[e.name] = e.value;\r\n\t\t}\r\n\t\treturn map;\r\n\t}\r\n\r\n\t/**\r\n\t * JSONシリアライズ用のtoJSONメソッド\r\n\t * @returns {Array<{name: string, ordinal: number, value: any}>} 列挙子の配列\r\n\t */\r\n\ttoJSON() {\r\n\t\treturn this._items.map((item) => item.toJSON());\r\n\t}\r\n\r\n\t/**\r\n\t * for...of に対応\r\n\t */\r\n\t*[Symbol.iterator]() {\r\n\t\tyield* this._items;\r\n\t}\r\n\r\n\t/**\r\n\t * インデックス付きで列挙子を返すジェネレータ\r\n\t * @returns {Generator<[number, _EnumItem]>} インデックスと列挙子のペア\r\n\t */\r\n\t*enumerate() {\r\n\t\tfor (let i = 0; i < this._items.length; i++) {\r\n\t\t\tyield [i, this._items[i]];\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * DynamicEnum生成関数（インデックスアクセスに対応したProxy付き）\r\n * @param {Array<string | [string, any]> | Record<string, any>} defs\r\n * @param {{[methodName: string]: (...args: any[]) => any}} [options.methods] - Enumのメソッド\r\n * @returns {_EnumCore & Proxy}\r\n */\r\nfunction Enum(defs, options = {}) {\r\n\tconst core = new _EnumCore(defs, options);\r\n\treturn new Proxy(core, {\r\n\t\tget(target, prop, receiver) {\r\n\t\t\tif (typeof prop === \"string\" && /^[0-9]+$/.test(prop)) {\r\n\t\t\t\tconst index = Number(prop);\r\n\t\t\t\treturn target._items[index];\r\n\t\t\t}\r\n\t\t\treturn Reflect.get(target, prop, receiver);\r\n\t\t},\r\n\r\n\t\tenumerate(target) {\r\n\t\t\t// 数字のインデックスを除外\r\n\t\t\treturn Object.keys(target._items).map((i) => i.toString());\r\n\t\t},\r\n\r\n\t\thas(target, prop) {\r\n\t\t\tif (typeof prop === \"string\" && /^[0-9]+$/.test(prop)) {\r\n\t\t\t\tconst index = Number(prop);\r\n\t\t\t\treturn index >= 0 && index < target._items.length;\r\n\t\t\t}\r\n\t\t\treturn prop in target;\r\n\t\t},\r\n\r\n\t\townKeys(target) {\r\n\t\t\tconst keys = Reflect.ownKeys(target);\r\n\t\t\tconst indexes = target._items.map((_, i) => i.toString());\r\n\t\t\treturn [...keys, ...indexes];\r\n\t\t},\r\n\r\n\t\tgetOwnPropertyDescriptor(target, prop) {\r\n\t\t\tif (typeof prop === \"string\" && /^[0-9]+$/.test(prop)) {\r\n\t\t\t\t// プロパティがターゲットに存在するか確認\r\n\t\t\t\tif (prop in target._items) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tvalue: target._items[Number(prop)],\r\n\t\t\t\t\t\twritable: false,\r\n\t\t\t\t\t\tconfigurable: false,\r\n\t\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\t};\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// プロパティが存在しない場合はエラーを避ける\r\n\t\t\t\t\treturn undefined; // これでエラーを避ける\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn Object.getOwnPropertyDescriptor(target, prop);\r\n\t\t},\r\n\r\n\t\tset(target, prop, value) {\r\n\t\t\tthrow new TypeError(`Enumは変更できません: ${String(prop)} = ${value}`);\r\n\t\t},\r\n\r\n\t\tdefineProperty(target, prop, descriptor) {\r\n\t\t\tthrow new TypeError(`Enumにプロパティを追加/変更できません: ${String(prop)}`);\r\n\t\t},\r\n\r\n\t\tdeleteProperty(target, prop) {\r\n\t\t\tthrow new TypeError(`Enumのプロパティを削除できません: ${String(prop)}`);\r\n\t\t},\r\n\t});\r\n}\r\n\r\nmodule.exports = {\r\n\t_EnumItem,\r\n\t_EnumCore,\r\n\tEnum,\r\n};\r\n",
    "const JavaLibraryScriptCore = require(\"../libs/sys/JavaLibraryScriptCore\");\r\nconst { logging } = require(\"../libs/sys/Logger\");\r\nconst TypeChecker = require(\"../libs/TypeChecker\");\r\nconst { _EnumItem, Enum } = require(\"./Enum\");\r\n\r\n/**\r\n * @typedef {{throw: _EnumItem, log: _EnumItem, ignore: _EnumItem}} ErrorModeItem\r\n */\r\n\r\n/**\r\n * @typedef {Object} InterfaceTypeData\r\n * @property {Function[] | null} [args] - 引数の型定義\r\n * @property {Function | Function[] | null} [returns] - 戻り値の型定義\r\n * @property {boolean} [abstract=true] - 抽象クラス化\r\n */\r\n\r\n/**\r\n * @typedef {Object.<string, InterfaceTypeData>} InterfaceTypeDataList\r\n */\r\n\r\n/**\r\n * インターフェイス管理\r\n * @extends {JavaLibraryScriptCore}\r\n * @class\r\n */\r\nclass Interface extends JavaLibraryScriptCore {\r\n\t/**\r\n\t * デバッグモード\r\n\t * @type {boolean}\r\n\t * @static\r\n\t */\r\n\tstatic isDebugMode = false;\r\n\r\n\t/**\r\n\t * エラーモード\r\n\t * @type {ErrorModeItem}\r\n\t * @static\r\n\t * @readonly\r\n\t */\r\n\tstatic ErrorMode = Enum([\"throw\", \"log\", \"ignore\"]);\r\n\r\n\t/**\r\n\t * エラーモード\r\n\t * @type {ErrorModeItem}\r\n\t * @static\r\n\t */\r\n\tstatic _errorMode = this.ErrorMode.throw;\r\n\r\n\t/**\r\n\t * エラーモード設定\r\n\t * @param {ErrorModeItem} mode - エラーモード\r\n\t * @static\r\n\t */\r\n\tstatic setErrorMode(mode) {\r\n\t\tif (!this.ErrorMode.has(mode)) throw new Error(`不正な errorMode: ${mode}`);\r\n\t\tthis._errorMode = mode;\r\n\t}\r\n\r\n\t/**\r\n\t * エラー処理\r\n\t * @param {typeof Error} error\r\n\t * @param {string} message - エラーメッセージ\r\n\t * @returns {undefined}\r\n\t * @throws {Error}\r\n\t * @static\r\n\t */\r\n\tstatic _handleError(error, message) {\r\n\t\tconst ErrorMode = this.ErrorMode;\r\n\t\tswitch (this._errorMode) {\r\n\t\t\tcase ErrorMode.throw:\r\n\t\t\t\tthrow new error(message);\r\n\t\t\tcase ErrorMode.log:\r\n\t\t\t\tlogging.warn(\"[Interface Warning]\", message);\r\n\t\t\t\tbreak;\r\n\t\t\tcase ErrorMode.ignore:\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 型定義\r\n\t * @param {Function} TargetClass - 型定義を追加するクラス\r\n\t * @param {InterfaceTypeDataList} [newMethods] - 追加するメソッド群\r\n\t * @param {Object} [opt] - オプション\r\n\t * @param {boolean} [opt.inherit=true] - 継承モード\r\n\t * @returns {undefined}\r\n\t * @static\r\n\t */\r\n\tstatic applyTo(TargetClass, newDefs = {}, { inherit = true } = {}) {\r\n\t\tconst proto = TargetClass.prototype;\r\n\r\n\t\t// 継承モードなら親の型定義をマージ\r\n\t\tlet inheritedDefs = {};\r\n\t\tif (inherit) {\r\n\t\t\tconst parentProto = Object.getPrototypeOf(proto);\r\n\t\t\tif (parentProto && parentProto.__interfaceTypes) {\r\n\t\t\t\tinheritedDefs = { ...parentProto.__interfaceTypes };\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// クラスの型定義ストレージを用意 or 上書き\r\n\t\tif (!proto.__interfaceTypes) {\r\n\t\t\tObject.defineProperty(proto, \"__interfaceTypes\", {\r\n\t\t\t\tvalue: {},\r\n\t\t\t\tconfigurable: false,\r\n\t\t\t\twritable: false,\r\n\t\t\t\tenumerable: false,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// 継承＋新規定義マージ（子定義優先）\r\n\t\tObject.assign(proto.__interfaceTypes, inheritedDefs, newDefs);\r\n\t}\r\n\r\n\t/**\r\n\t * 型定義とメゾットの強制実装\r\n\t * @template T\r\n\t * @param {new (...args: any[]) => T} TargetClass - 型定義を追加するクラス\r\n\t * @param {InterfaceTypeDataList} [newMethods] - 追加するメソッド群\r\n\t * @param {Object} [opt] - オプション\r\n\t * @param {boolean} [opt.inherit=true] - 継承モード\r\n\t * @param {boolean} [opt.abstract=true] - 抽象クラス化\r\n\t * @returns {new (...args: any[]) => T}\r\n\t * @static\r\n\t */\r\n\tstatic convert(TargetClass, newDefs = {}, { inherit = true, abstract = true } = {}) {\r\n\t\tthis.applyTo(TargetClass, newDefs, { inherit });\r\n\r\n\t\tconst this_ = this;\r\n\r\n\t\tconst interfaceClass = class extends TargetClass {\r\n\t\t\tconstructor(...args) {\r\n\t\t\t\tif (abstract) {\r\n\t\t\t\t\tif (new.target === interfaceClass) {\r\n\t\t\t\t\t\tnew TypeError(`Cannot instantiate abstract class ${TargetClass.name}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tsuper(...args);\r\n\r\n\t\t\t\tif (!Interface.isDebugMode) return;\r\n\r\n\t\t\t\tconst proto = Object.getPrototypeOf(this);\r\n\t\t\t\tconst defs = proto.__interfaceTypes || {};\r\n\r\n\t\t\t\tfor (const methodName of Object.keys(defs)) {\r\n\t\t\t\t\tconst def = defs[methodName];\r\n\t\t\t\t\tconst original = this[methodName];\r\n\t\t\t\t\tconst isAbstract = !!def.abstract;\r\n\r\n\t\t\t\t\tif (typeof original !== \"function\") {\r\n\t\t\t\t\t\tif (isAbstract) continue;\r\n\t\t\t\t\t\tthis_._handleError(Error, `\"${this.constructor.name}\" はメソッド \"${methodName}\" を実装する必要があります`);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// ラップは一度だけ（重複防止）\r\n\t\t\t\t\tif (!original.__isWrapped) {\r\n\t\t\t\t\t\tconst wrapped = (...args) => {\r\n\t\t\t\t\t\t\t// 引数チェック\r\n\t\t\t\t\t\t\tconst expectedArgs = def.args || [];\r\n\t\t\t\t\t\t\tfor (let i = 0; i < expectedArgs.length; i++) {\r\n\t\t\t\t\t\t\t\tif (!TypeChecker.matchType(args[i], expectedArgs[i])) {\r\n\t\t\t\t\t\t\t\t\tthis_._handleError(TypeError, `\"${this.constructor.name}.${methodName}\" 第${i + 1}引数: ${TypeChecker.typeNames(expectedArgs[i])} を期待 → 実際: ${TypeChecker.stringify(args[i])}`);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tconst result = original.apply(this, args);\r\n\t\t\t\t\t\t\tconst expectedReturn = TypeChecker.checkFunction(def.returns) ? def.returns(args) : def.returns;\r\n\r\n\t\t\t\t\t\t\tconst validate = (val) => {\r\n\t\t\t\t\t\t\t\tif (!TypeChecker.matchType(val, expectedReturn)) {\r\n\t\t\t\t\t\t\t\t\tif (expectedReturn === TypeChecker.NoReturn) {\r\n\t\t\t\t\t\t\t\t\t\tthis_._handleError(TypeError, `\"${this.constructor.name}.${methodName}\" は戻り値を返してはいけません → 実際: ${TypeChecker.stringify(val)}`);\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tthis_._handleError(TypeError, `\"${this.constructor.name}.${methodName}\" の戻り値: ${TypeChecker.typeNames(expectedReturn)} を期待 → 実際: ${TypeChecker.stringify(val)}`);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn val;\r\n\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\treturn result instanceof Promise ? result.then(validate) : validate(result);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\twrapped.__isWrapped = true;\r\n\t\t\t\t\t\tthis[methodName] = wrapped;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tObject.defineProperty(interfaceClass, \"name\", { value: TargetClass.name });\r\n\r\n\t\treturn interfaceClass;\r\n\t}\r\n\r\n\t/**\r\n\t * 抽象メソッドが未実装かを個別に検査\r\n\t * @param {Object} instance\r\n\t * @returns {boolean}\r\n\t */\r\n\tstatic isAbstractImplemented(instance) {\r\n\t\tconst proto = Object.getPrototypeOf(instance);\r\n\t\tconst defs = proto.__interfaceTypes || {};\r\n\r\n\t\tfor (const [methodName, def] of Object.entries(defs)) {\r\n\t\t\tif (!def.abstract) continue;\r\n\t\t\tif (typeof instance[methodName] !== \"function\") return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * 型定義を取得\r\n\t * @param {Function|Object} ClassOrInstance\r\n\t * @returns {InterfaceTypeDataList}\r\n\t * @static\r\n\t */\r\n\tstatic getDefinition(ClassOrInstance) {\r\n\t\tconst proto = typeof ClassOrInstance === \"function\" ? ClassOrInstance.prototype : Object.getPrototypeOf(ClassOrInstance);\r\n\t\treturn proto.__interfaceTypes || {};\r\n\t}\r\n\r\n\t/**\r\n\t * 型定義を文字列化\r\n\t * @param {Function|Object} ClassOrInstance\r\n\t * @returns {string}\r\n\t * @static\r\n\t */\r\n\tstatic describe(ClassOrInstance) {\r\n\t\tconst defs = this.getDefinition(ClassOrInstance);\r\n\t\tconst lines = [];\r\n\t\tfor (const [name, def] of Object.entries(defs)) {\r\n\t\t\tconst argsStr = (def.args || []).map((t) => TypeChecker.typeNames(t)).join(\", \");\r\n\t\t\tconst retStr = TypeChecker.typeNames(def.returns);\r\n\t\t\tlines.push(`${def.abstract ? \"abstract \" : \"\"}function ${name}(${argsStr}) → ${retStr}`);\r\n\t\t}\r\n\t\treturn lines.join(\"\\n\");\r\n\t}\r\n\r\n\t/**\r\n\t * メソッド名を取得\r\n\t * @param {Function|Object} ClassOrInstance\r\n\t * @param {Object} [opt]\r\n\t * @param {boolean} [opt.abstractOnly=false]\r\n\t * @returns {string[]}\r\n\t * @static\r\n\t */\r\n\tstatic getMethodNames(ClassOrInstance, { abstractOnly = false } = {}) {\r\n\t\tconst defs = this.getDefinition(ClassOrInstance);\r\n\t\treturn Object.entries(defs)\r\n\t\t\t.filter(([_, def]) => !abstractOnly || def.abstract)\r\n\t\t\t.map(([name]) => name);\r\n\t}\r\n\r\n\t/**\r\n\t * メソッド定義を取得\r\n\t * @param {Function|Object} classOrInstance\r\n\t * @param {string} methodName\r\n\t * @returns {InterfaceTypeData | null}\r\n\t * @static\r\n\t */\r\n\tstatic getExpectedSignature(classOrInstance, methodName) {\r\n\t\tconst defs = this.getDefinition(classOrInstance);\r\n\t\tif (!(methodName in defs)) return null;\r\n\t\treturn {\r\n\t\t\targs: defs[methodName].args,\r\n\t\t\treturns: defs[methodName].returns,\r\n\t\t\tabstract: !!defs[methodName].abstract,\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * 型定義を結合\r\n\t * @param {...InterfaceTypeDataList} defs\r\n\t * @returns {InterfaceTypeDataList}\r\n\t * @static\r\n\t */\r\n\tstatic merge(...defs) {\r\n\t\tconst result = {};\r\n\t\tfor (const def of defs) {\r\n\t\t\tObject.assign(result, def);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n\r\nmodule.exports = Interface;\r\n",
    "module.exports = {\n    ...require(\"./Enum.js\"),\n    Interface: require(\"./Interface.js\")\n};\n",
    "module.exports = {\n    base: require(\"./base/index.js\"),\n    libs: require(\"./libs/index.js\"),\n    math: require(\"./math/index.js\"),\n    util: require(\"./util/index.js\")\n};\n",
    "const SymbolDict = require(\"./sys/symbol/SymbolDict\");\nconst JavaLibraryScriptCore = require(\"./sys/JavaLibraryScriptCore\");\nconst ProxyManager = require(\"./ProxyManager\");\nconst TypeChecker = require(\"./TypeChecker\");\n\n/** @type {Symbol} */\nconst instanceofTarget = SymbolDict.instanceofTarget;\n\n/**\n * Index参照機能を提供する\n * @template T\n * @extends {JavaLibraryScriptCore}\n * @class\n */\nclass IndexProxy extends JavaLibraryScriptCore {\n\t/**\n\t * @param {new (...args: any[]) => T} targetClass\n\t * @param {{getMethod?: string, setMethod?: string, sizeMethod?: string, addMethod?: string, typeCheckMethod?: string | null, autoExtend?: boolean}} options\n\t */\n\tconstructor(targetClass, { getMethod = \"get\", setMethod = \"set\", sizeMethod = \"size\", addMethod = \"add\", typeCheckMethod = null, autoExtend = true } = {}) {\n\t\tsuper();\n\t\tthis._TargetClass = targetClass;\n\t\tthis._config = {\n\t\t\tgetMethod,\n\t\t\tsetMethod,\n\t\t\tsizeMethod,\n\t\t\taddMethod,\n\t\t\ttypeCheckMethod,\n\t\t\tautoExtend,\n\t\t};\n\t\tthis._cachedMethods = {\n\t\t\tget: null,\n\t\t\tset: null,\n\t\t\tsize: null,\n\t\t\tadd: null,\n\t\t\ttypeCheck: null,\n\t\t};\n\t}\n\n\t/**\n\t * @param {...any} args\n\t * @returns {T}\n\t */\n\tcreate(...args) {\n\t\tconst target = new this._TargetClass(...args);\n\t\tconst class_name = TypeChecker.typeNames(this._TargetClass);\n\n\t\tconst cfg = this._config;\n\t\tconst m = this._cachedMethods;\n\n\t\tif (typeof target[cfg.getMethod] !== \"function\") {\n\t\t\tthrow new TypeError(`${class_name}.${cfg.getMethod}(index) メソッドが必要です。`);\n\t\t}\n\t\tif (typeof target[cfg.setMethod] !== \"function\") {\n\t\t\tthrow new TypeError(`${class_name}.${cfg.setMethod}(index, value) メソッドが必要です。`);\n\t\t}\n\t\tm.get = target[cfg.getMethod].bind(target);\n\t\tm.set = target[cfg.setMethod].bind(target);\n\n\t\t// sizeは関数かgetterか判定\n\t\tconst sizeVal = target[cfg.sizeMethod];\n\t\tif (typeof sizeVal === \"function\") {\n\t\t\tm.size = sizeVal.bind(target);\n\t\t} else if (typeof sizeVal === \"number\") {\n\t\t\t// getterはbind不要なので関数化\n\t\t\tm.size = () => target[cfg.sizeMethod];\n\t\t} else {\n\t\t\tthrow new TypeError(`${class_name}.${cfg.sizeMethod}() メソッドまたは、${class_name}.${cfg.sizeMethod} getterが必要です。`);\n\t\t}\n\n\t\tif (typeof target[cfg.addMethod] === \"function\") {\n\t\t\tm.add = target[cfg.addMethod].bind(target);\n\t\t} else if (this._config.autoExtend) {\n\t\t\tthrow new TypeError(`${this._TargetClass}.${cfg.addMethod}(item) メソッドが必要です。範囲外追加を許容しない場合はautoExtendをfalseにしてください。`);\n\t\t}\n\t\tif (typeof target[cfg.typeCheckMethod] === \"function\") {\n\t\t\tm.typeCheck = target[cfg.typeCheckMethod].bind(target);\n\t\t}\n\n\t\treturn new Proxy(target, {\n\t\t\tget: (t, prop, r) => {\n\t\t\t\tif (!isNaN(prop)) {\n\t\t\t\t\treturn m.get(Number(prop));\n\t\t\t\t}\n\t\t\t\treturn ProxyManager.over_get(t, prop, r);\n\t\t\t},\n\t\t\tset: (t, prop, val, r) => {\n\t\t\t\tif (!isNaN(prop)) {\n\t\t\t\t\tconst i = Number(prop);\n\t\t\t\t\tif (m.typeCheck) {\n\t\t\t\t\t\tm.typeCheck(val);\n\t\t\t\t\t}\n\t\t\t\t\tconst size = m.size();\n\n\t\t\t\t\tif (i < size) {\n\t\t\t\t\t\tm.set(i, val);\n\t\t\t\t\t} else if (i === size && this._config.autoExtend) {\n\t\t\t\t\t\tm.add(val);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(`インデックス ${i} は無効です（サイズ: ${size}）`);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn Reflect.set(t, prop, val, r);\n\t\t\t},\n\t\t\thas: (t, prop) => {\n\t\t\t\tif (!isNaN(prop)) {\n\t\t\t\t\tconst i = Number(prop);\n\t\t\t\t\tconst size = m.size();\n\t\t\t\t\treturn i >= 0 && i < size;\n\t\t\t\t}\n\t\t\t\treturn prop in t;\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * インスタンス化時に初期データを設定する\n\t * @template C\n\t * @param {C} targetInstance\n\t */\n\tstatic defineInitData(targetInstance) {\n\t\tObject.defineProperty(targetInstance, instanceofTarget, {\n\t\t\tvalue: targetInstance,\n\t\t\tenumerable: false,\n\t\t\twritable: false,\n\t\t});\n\t}\n\n\t/**\n\t * [Symbol.hasInstance]の処理を自動化\n\t * @template S, C\n\t * @param {new (...args: any[]) => S} targetClass - 多くの場合、this\n\t * @param {C} otherInstance\n\t */\n\tstatic hasInstance(targetClass, otherInstance) {\n\t\tconst target = otherInstance?.[instanceofTarget];\n\t\treturn typeof target === \"object\" && target !== null && targetClass.prototype.isPrototypeOf(target);\n\t}\n}\n\nmodule.exports = IndexProxy;\n",
    "const JavaLibraryScriptCore = require(\"./sys/JavaLibraryScriptCore\");\n\n/**\n * プロキシマネージャー\n * @class\n */\nclass ProxyManager extends JavaLibraryScriptCore {\n\t/**\n\t * getのreturnのオーバーライド\n\t * @param {any} target\n\t * @param {any} prop\n\t * @param {any} receiver\n\t * @returns {any}\n\t */\n\tstatic over_get(target, prop, receiver) {\n\t\tswitch (prop) {\n\t\t\tcase \"toString\":\n\t\t\t\treturn () => `Proxy(${target.toString()})`;\n\t\t}\n\t\treturn Reflect.get(target, prop, receiver);\n\t}\n}\n\nmodule.exports = ProxyManager;\n",
    "const SymbolDict = require(\"../libs/sys/symbol/SymbolDict\");\r\nconst JavaLibraryScriptCore = require(\"../libs/sys/JavaLibraryScriptCore\");\r\nconst { _EnumCore, _EnumItem } = require(\"../base/Enum\");\r\n\r\n/**\r\n * 型チェッカー\r\n * @extends {JavaLibraryScriptCore}\r\n * @class\r\n */\r\nclass TypeChecker extends JavaLibraryScriptCore {\r\n\tstatic _CLASS_REG = /^\\s*class\\s+/;\r\n\r\n\t// ==================================================\r\n\t/**\r\n\t * Typeの否定\r\n\t * @extends {JavaLibraryScriptCore}\r\n\t * @class\r\n\t * @static\r\n\t */\r\n\tstatic _NotType = class _NotType extends JavaLibraryScriptCore {\r\n\t\t/**\r\n\t\t * @param {Function | Function[]} typeToExclude\r\n\t\t */\r\n\t\tconstructor(typeToExclude) {\r\n\t\t\tsuper();\r\n\t\t\tif (typeToExclude instanceof TypeChecker._NotType) throw new TypeError(\"typeToExclude must be instance of NotType\");\r\n\t\t\tthis.typeToExclude = typeToExclude;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * 否定型を返す\r\n\t * @param {Function | Function[]} typeToExclude\r\n\t * @returns {TypeChecker._NotType}\r\n\t */\r\n\tstatic NotType(typeToExclude) {\r\n\t\treturn new TypeChecker._NotType(typeToExclude);\r\n\t}\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * 任意の型\r\n\t * @type {Symbol}\r\n\t * @static\r\n\t * @readonly\r\n\t */\r\n\tstatic Any = SymbolDict.TypeAny;\r\n\t/**\r\n\t * 返り値を返さない関数の型\r\n\t * @type {Symbol}\r\n\t * @static\r\n\t * @readonly\r\n\t */\r\n\tstatic Void = SymbolDict.TypeVoid;\r\n\t/**\r\n\t * 返り値を返さない関数の型\r\n\t * @type {Symbol}\r\n\t * @static\r\n\t * @readonly\r\n\t */\r\n\tstatic NoReturn = this.Void;\r\n\r\n\t/**\r\n\t * null以外の型\r\n\t * @type {TypeChecker._NotType}\r\n\t * @static\r\n\t * @readonly\r\n\t */\r\n\tstatic NotNull = this.NotType(null);\r\n\t/**\r\n\t * undefined以外の型\r\n\t * @type {TypeChecker._NotType}\r\n\t * @static\r\n\t * @readonly\r\n\t */\r\n\tstatic NotUndefined = this.NotType(undefined);\r\n\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * 型チェック(一括)\r\n\t * @param {any} value\r\n\t * @param {Function} expected\r\n\t * @returns {boolean}\r\n\t * @static\r\n\t */\r\n\tstatic matchType(value, expected) {\r\n\t\tif (Array.isArray(expected)) {\r\n\t\t\tconst notTypes = expected.filter((t) => t instanceof this._NotType);\r\n\t\t\tconst isNotExcluded = notTypes.some((t) => this.checkType(value, t.typeToExclude));\r\n\t\t\tif (isNotExcluded) return false;\r\n\t\t\tconst notExcluded = expected.filter((t) => !(t instanceof this._NotType));\r\n\t\t\tif (notExcluded.length === 0) return true;\r\n\t\t\treturn notExcluded.some((e) => this.checkType(value, e));\r\n\t\t}\r\n\t\treturn this.checkType(value, expected);\r\n\t}\r\n\r\n\t/**\r\n\t * 型チェック(個別)\r\n\t * @param {any} value\r\n\t * @param {Function} expected\r\n\t * @returns {boolean}\r\n\t * @static\r\n\t */\r\n\tstatic checkType(value, expected) {\r\n\t\tif (expected instanceof this._NotType) {\r\n\t\t\t// 除外型なので、valueが除外型にマッチしたらfalse\r\n\t\t\treturn !this.checkType(value, expected.typeToExclude);\r\n\t\t}\r\n\t\tif (expected === this.Any) return true;\r\n\t\tif (expected === this.NoReturn) return value === undefined;\r\n\t\tif (expected === null) return value === null;\r\n\t\tif (expected === undefined) return value === undefined;\r\n\t\tif (expected === String || expected === Number || expected === Boolean || expected === Symbol || expected === Function || expected === BigInt) return typeof value === expected.name.toLowerCase();\r\n\t\tif (expected === Object) return typeof value === \"object\" && value !== null && !Array.isArray(value);\r\n\t\tif (expected === Array) return Array.isArray(value);\r\n\t\t// ----- Enum対応\r\n\t\tif (expected instanceof _EnumCore) {\r\n\t\t\t// Enumの場合\r\n\t\t\treturn expected.has(value?.name);\r\n\t\t}\r\n\t\tif (expected === _EnumItem) return value instanceof _EnumItem;\r\n\t\t// -----\r\n\t\tif (typeof expected === \"function\") return value instanceof expected;\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * 型を取得する\r\n\t * @param {any} value\r\n\t * @returns {Function | null}\r\n\t */\r\n\tstatic getType(value) {\r\n\t\tif (value === null) return null;\r\n\t\tif (value === undefined) return undefined;\r\n\t\tconst type = typeof value;\r\n\t\tswitch (type) {\r\n\t\t\tcase \"string\":\r\n\t\t\t\treturn String;\r\n\t\t\tcase \"number\":\r\n\t\t\t\treturn Number;\r\n\t\t\tcase \"boolean\":\r\n\t\t\t\treturn Boolean;\r\n\t\t\tcase \"symbol\":\r\n\t\t\t\treturn Symbol;\r\n\t\t\tcase \"function\":\r\n\t\t\t\treturn Function;\r\n\t\t\tcase \"bigint\":\r\n\t\t\t\treturn BigInt;\r\n\t\t\tcase \"object\":\r\n\t\t\t\tif (Array.isArray(value)) return Array;\r\n\t\t\t\treturn value.constructor;\r\n\t\t}\r\n\t\tthrow new TypeError(`TypeChecker: getType()に対応していない型:${type}`);\r\n\t}\r\n\r\n\t/**\r\n\t * 型名を取得\r\n\t * @param {Function} expected\r\n\t * @returns {string}\r\n\t * @static\r\n\t */\r\n\tstatic typeNames(expected) {\r\n\t\tif (Array.isArray(expected)) return expected.map((t) => t?.name || TypeChecker.stringify(t)).join(\" | \");\r\n\t\treturn expected?.name || TypeChecker.stringify(expected);\r\n\t}\r\n\r\n\t/**\r\n\t * 値を文字列に変換\r\n\t * @param {any} value\r\n\t * @returns {string}\r\n\t * @static\r\n\t */\r\n\tstatic stringify(value) {\r\n\t\tif (value === null || value === undefined) {\r\n\t\t\treturn String(value);\r\n\t\t}\r\n\t\tif (typeof value === \"symbol\") {\r\n\t\t\tswitch (value) {\r\n\t\t\t\tcase this.Any:\r\n\t\t\t\t\treturn \"Any\";\r\n\t\t\t\tcase this.NoReturn:\r\n\t\t\t\tcase this.Void:\r\n\t\t\t\t\treturn \"NoReturn\";\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (typeof value === \"object\") {\r\n\t\t\tif (value?.toString() !== \"[object Object]\") {\r\n\t\t\t\treturn String(value);\r\n\t\t\t}\r\n\t\t\tif (value instanceof this._NotType) {\r\n\t\t\t\treturn `NotType(${TypeChecker.stringify(value.typeToExclude)})`;\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tconst jsonString = JSON.stringify(\r\n\t\t\t\t\tvalue,\r\n\t\t\t\t\t(key, val) => {\r\n\t\t\t\t\t\tif (val && typeof val === \"object\") {\r\n\t\t\t\t\t\t\tconst size = Object.keys(val).length;\r\n\t\t\t\t\t\t\t// オブジェクトが大きすぎる場合は省略表示\r\n\t\t\t\t\t\t\tif (size > 5) {\r\n\t\t\t\t\t\t\t\treturn `Object with ${size} properties`;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn val;\r\n\t\t\t\t\t},\r\n\t\t\t\t\t0\r\n\t\t\t\t);\r\n\t\t\t\t// JSON.stringifyエラー時にfallback\r\n\t\t\t\tif (jsonString === undefined) {\r\n\t\t\t\t\treturn \"Object is too large to display or contains circular references\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn jsonString.length > 1000 ? \"Object is too large to display\" : jsonString; // 文字数が多すぎる場合は省略\r\n\t\t\t} catch (e) {\r\n\t\t\t\treturn `[オブジェクト表示エラー: ${e.message}]`; // サークル参照等のエラー防止\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn String(value); // それ以外の型はそのまま文字列に変換\r\n\t}\r\n\r\n\t/**\r\n\t * 関数かチェック\r\n\t * @param {any} fn\r\n\t * @returns {boolean}\r\n\t * @static\r\n\t */\r\n\tstatic checkFunction(fn) {\r\n\t\tif (typeof fn !== \"function\") return false;\r\n\t\tif (this.checkClass(fn)) return false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * クラスかチェック\r\n\t * @param {any} fn\r\n\t * @returns {boolean}\r\n\t * @static\r\n\t */\r\n\tstatic checkClass(fn) {\r\n\t\tif (typeof fn !== \"function\") return false;\r\n\t\tif (this._CLASS_REG.test(fn.toString())) return true;\r\n\t\tif (fn === Function) return true;\r\n\t\ttry {\r\n\t\t\tnew new Proxy(fn, { construct: () => ({}) })();\r\n\t\t\treturn true;\r\n\t\t} catch {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = TypeChecker;\r\n",
    "const JavaLibraryScriptCore = require(\"../sys/JavaLibraryScriptCore\");\nconst Interface = require(\"../../base/Interface\");\nconst TypeChecker = require(\"../TypeChecker\");\n\n/**\n * キャッシュのオプション\n * @typedef {{ whitelist: string[] | null, blacklist: string[], maxSize: number, policy: CacheMapInterface }} CacheWrapperOptions\n */\n\n/**\n * キャッシュ用のマップ\n * @class\n * @abstract\n * @interface\n */\nclass CacheMapInterface extends JavaLibraryScriptCore {\n\t/**\n\t * @param {number} limit\n\t */\n\tconstructor(limit) {\n\t\tsuper();\n\t\tthis._limit = limit;\n\t\tthis._cache = new Map();\n\t}\n}\n\nconst Any = TypeChecker.Any;\nconst NoReturn = TypeChecker.NoReturn;\n\nCacheMapInterface = Interface.convert(CacheMapInterface, {\n\tget: { args: [String], returns: Any },\n\tset: { args: [String, Any], returns: NoReturn },\n\thas: { args: [String], returns: Boolean },\n\tclear: { returns: NoReturn },\n});\n\n/**\n * FIFOキャッシュ\n * @class\n */\nclass FIFOCache extends CacheMapInterface {\n\tconstructor(limit) {\n\t\tsuper(limit);\n\t}\n\t/**\n\t * キーに対応する値を返却する\n\t * @param {string} key\n\t * @returns {any}\n\t */\n\tget(key) {\n\t\treturn this._cache.get(key);\n\t}\n\t/**\n\t * キーに対応する値を設定する\n\t * @param {string} key\n\t * @param {any} value\n\t */\n\tset(key, value) {\n\t\tconst c = this._cache;\n\t\tif (!c.has(key) && c.size >= this._limit) {\n\t\t\tconst firstKey = c.keys().next().value;\n\t\t\tc.delete(firstKey);\n\t\t}\n\t\tc.set(key, value);\n\t}\n\t/**\n\t * キーの存在を確認する\n\t * @param {string} key\n\t * @returns {boolean}\n\t */\n\thas(key) {\n\t\treturn this._cache.has(key);\n\t}\n\t/**\n\t * キャッシュをクリアする\n\t */\n\tclear() {\n\t\tthis._cache.clear();\n\t}\n}\n\n/**\n * LFUキャッシュ\n * @class\n */\nclass LFUCache extends CacheMapInterface {\n\t/**\n\t * @param {number} limit\n\t */\n\tconstructor(limit) {\n\t\tsuper(limit);\n\t\tthis._freq = new Map(); // 使用回数追跡\n\t}\n\t/**\n\t * キーに対応する値を返却する\n\t * @param {string} key\n\t * @returns {any}\n\t */\n\tget(key) {\n\t\tconst c = this._cache;\n\t\tif (!c.has(key)) return undefined;\n\t\tconst freq = this.freq;\n\t\tfreq.set(key, (freq.get(key) || 0) + 1);\n\t\treturn c.get(key);\n\t}\n\t/**\n\t * キーに対応する値を設定する\n\t * @param {string} key\n\t * @param {any} value\n\t */\n\tset(key, value) {\n\t\tconst c = this._cache;\n\t\tconst freq = this._freq;\n\t\tif (!c.has(key) && c.size >= this._limit) {\n\t\t\tlet leastUsedKey = null;\n\t\t\tlet minFreq = Infinity;\n\t\t\tfor (const k of c.keys()) {\n\t\t\t\tconst f = freq.get(k) || 0;\n\t\t\t\tif (f < minFreq) {\n\t\t\t\t\tminFreq = f;\n\t\t\t\t\tleastUsedKey = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (leastUsedKey !== null) {\n\t\t\t\tc.delete(leastUsedKey);\n\t\t\t\tfreq.delete(leastUsedKey);\n\t\t\t}\n\t\t}\n\n\t\tc.set(key, value);\n\t\tfreq.set(key, (freq.get(key) || 0) + 1);\n\t}\n\t/**\n\t * キーの存在を確認する\n\t * @param {string} key\n\t * @returns {boolean}\n\t */\n\thas(key) {\n\t\treturn this._cache.has(key);\n\t}\n\t/**\n\t * キャッシュをクリアする\n\t */\n\tclear() {\n\t\tthis._cache.clear();\n\t\tthis._freq.clear();\n\t}\n}\n\n/**\n * LRUキャッシュ\n * @class\n */\nclass LRUCache extends CacheMapInterface {\n\t/**\n\t * @param {number} limit\n\t */\n\tconstructor(limit) {\n\t\tsuper(limit);\n\t}\n\t/**\n\t * キーに対応する値を返却する\n\t * @param {string} key\n\t * @returns {any}\n\t */\n\tget(key) {\n\t\tconst c = this._cache;\n\t\tif (!c.has(key)) return undefined;\n\t\tconst val = c.get(key);\n\t\tc.delete(key);\n\t\tc.set(key, val);\n\t\treturn val;\n\t}\n\t/**\n\t * キーに対応する値を設定する\n\t * @param {string} key\n\t * @param {any} val\n\t */\n\tset(key, val) {\n\t\tconst c = this._cache;\n\t\tif (c.has(key)) c.delete(key);\n\t\telse if (c.size === this._limit) {\n\t\t\tconst oldestKey = c.keys().next().value;\n\t\t\tc.delete(oldestKey);\n\t\t}\n\t\tc.set(key, val);\n\t}\n\t/**\n\t * キーの存在を確認する\n\t * @param {string} key\n\t * @returns {boolean}\n\t */\n\thas(key) {\n\t\treturn this._cache.has(key);\n\t}\n\t/**\n\t * キャッシュをクリアする\n\t */\n\tclear() {\n\t\tthis._cache.clear();\n\t}\n}\n\n/**\n * クラスのstaticメゾットをキャッシュするクラス\n * @template T\n * @class\n */\nclass CacheWrapper extends JavaLibraryScriptCore {\n\t/**\n\t * 先入れ先出し\n\t * @type {FIFOCache}\n\t * @static\n\t * @readonly\n\t */\n\tstatic POLICY_FIFO = FIFOCache;\n\t/**\n\t * 最頻出順\n\t * @type {LFUCache}\n\t * @static\n\t * @readonly\n\t */\n\tstatic POLICY_LFU = LFUCache;\n\t/**\n\t * 最近使った順\n\t * @type {LRUCache}\n\t * @static\n\t * @readonly\n\t */\n\tstatic POLICY_LRU = LRUCache;\n\n\t/**\n\t * @type {WeakMap<object, number>}\n\t * @static\n\t * @readonly\n\t */\n\tstatic _objectIdMap = new WeakMap();\n\t/**\n\t * @type {number}\n\t * @static\n\t */\n\tstatic _objectIdCounter = 1;\n\n\t/**\n\t * MurmurHash3 32bit ハッシュ関数 (36進数)\n\t * @see https://github.com/garycourt/murmurhash-js/blob/master/murmurhash3_gc.js\n\t * @param {string} key\n\t * @param {number} [seed=0]\n\t * @returns {string}\n\t * @static\n\t */\n\tstatic _murmurhash3_32_gc(key, seed = 0) {\n\t\tconst key_len = key.length;\n\t\tlet remainder = key_len & 3;\n\t\tlet bytes = key_len - remainder;\n\t\tlet h1 = seed;\n\t\tlet c1 = 0xcc9e2d51;\n\t\tlet c2 = 0x1b873593;\n\t\tlet i = 0;\n\n\t\twhile (i < bytes) {\n\t\t\tlet k1 = (key.charCodeAt(i) & 0xff) | ((key.charCodeAt(i + 1) & 0xff) << 8) | ((key.charCodeAt(i + 2) & 0xff) << 16) | ((key.charCodeAt(i + 3) & 0xff) << 24);\n\t\t\ti += 4;\n\n\t\t\tk1 = ((k1 & 0xffff) * c1 + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n\t\t\tk1 = (k1 << 15) | (k1 >>> 17);\n\t\t\tk1 = ((k1 & 0xffff) * c2 + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n\n\t\t\th1 ^= k1;\n\t\t\th1 = (h1 << 13) | (h1 >>> 19);\n\t\t\tconst h1b = ((h1 & 0xffff) * 5 + ((((h1 >>> 16) * 5) & 0xffff) << 16)) & 0xffffffff;\n\t\t\th1 = (h1b & 0xffff) + 0x6b64 + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16);\n\t\t}\n\n\t\tlet k1 = 0;\n\t\tswitch (remainder) {\n\t\t\tcase 3:\n\t\t\t\tk1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n\t\t\tcase 2:\n\t\t\t\tk1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n\t\t\tcase 1:\n\t\t\t\tk1 ^= key.charCodeAt(i) & 0xff;\n\t\t\t\tk1 = ((k1 & 0xffff) * c1 + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n\t\t\t\tk1 = (k1 << 15) | (k1 >>> 17);\n\t\t\t\tk1 = ((k1 & 0xffff) * c2 + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n\t\t\t\th1 ^= k1;\n\t\t}\n\n\t\th1 ^= key_len;\n\n\t\t// fmix(h1)\n\t\th1 ^= h1 >>> 16;\n\t\th1 = ((h1 & 0xffff) * 0x85ebca6b + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\n\t\th1 ^= h1 >>> 13;\n\t\th1 = ((h1 & 0xffff) * 0xc2b2ae35 + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16)) & 0xffffffff;\n\t\th1 ^= h1 >>> 16;\n\n\t\treturn (h1 >>> 0).toString(36);\n\t}\n\n\t/**\n\t * オブジェクトのIDを返す\n\t * @param {Object} obj\n\t * @returns {number}\n\t * @static\n\t */\n\tstatic _getObjectId(obj) {\n\t\tconst oim = this._objectIdMap;\n\t\tif (!oim.has(obj)) {\n\t\t\toim.set(obj, this._objectIdCounter++);\n\t\t}\n\t\treturn oim.get(obj);\n\t}\n\t/**\n\t * オブジェクトを文字列(key)に変換する\n\t * @param {Object} obj\n\t * @returns {string}\n\t * @static\n\t */\n\tstatic _toStringObject(obj) {\n\t\tif (obj === null) return \"null\";\n\t\tconst type = typeof obj;\n\t\tif (type === \"object\" || type === \"function\") {\n\t\t\treturn `#id:${this._getObjectId(obj)}`;\n\t\t}\n\t\tif (type === \"bigint\") {\n\t\t\treturn `#bigint:${obj.toString()}`;\n\t\t}\n\t\treturn `${type}:${String(obj)}`;\n\t}\n\t/**\n\t * オブジェクト配列を文字列(key)に変換する\n\t * @param {Object[]} args\n\t * @returns {string}\n\t * @static\n\t */\n\tstatic _identityHash(args) {\n\t\tconst key = args.map(this._toStringObject.bind(this)).join(\"|\");\n\t\treturn this._murmurhash3_32_gc(key);\n\t}\n\n\tstatic isGeneratorObject(obj) {\n\t\tif (!obj || !obj.constructor) return false;\n\t\treturn obj.constructor.name === \"Generator\" || obj.constructor.name === \"GeneratorFunction\" || obj.constructor.name === \"AsyncGenerator\";\n\t}\n\n\t/**\n\t * クラスを変換する\n\t * @template T\n\t * @param {new (...args: any[]) => T} BaseClass - 変換するクラス\n\t * @param {CacheWrapperOptions} options\n\t * @static\n\t */\n\tstatic convert(BaseClass, { whitelist = null, blacklist = [], maxSize = 100, policy = LRUCache } = {}) {\n\t\t/** @type {Set<string> | null} */\n\t\twhitelist = whitelist && new Set(whitelist);\n\t\t/** @type {Set<string>} */\n\t\tblacklist = new Set(blacklist);\n\n\t\tif (!policy || !(policy.prototype instanceof CacheMapInterface)) throw new TypeError(\"policy must be instance of CacheMapInterface\");\n\n\t\t// キャッシュを有効化するかどうか\n\t\tfunction _isCacheEnabled(methodName) {\n\t\t\tif (whitelist) return whitelist.has(methodName);\n\t\t\treturn !blacklist.has(methodName);\n\t\t}\n\n\t\tconst methodCaches = new Map();\n\n\t\t/** @type {typeof CacheWrapper} */\n\t\tconst thisClass = this;\n\n\t\tconst Wrapped = class extends BaseClass {\n\t\t\tstatic __clearCache(methodName) {\n\t\t\t\tif (methodName) {\n\t\t\t\t\tmethodCaches.get(methodName)?.clear();\n\t\t\t\t} else {\n\t\t\t\t\tmethodCaches.forEach((c) => c.clear());\n\t\t\t\t}\n\t\t\t}\n\t\t\tstatic __getCache(methodName) {\n\t\t\t\treturn methodCaches.get(methodName);\n\t\t\t}\n\t\t\tstatic __getCacheDict() {\n\t\t\t\treturn Object.fromEntries(methodCaches);\n\t\t\t}\n\t\t\tstatic __getCacheSize() {\n\t\t\t\tlet sum = 0;\n\t\t\t\tfor (const cache of methodCaches.values()) {\n\t\t\t\t\tsum += cache._cache.size;\n\t\t\t\t}\n\t\t\t\treturn sum;\n\t\t\t}\n\t\t};\n\n\t\tconst staticProps = Object.getOwnPropertyNames(BaseClass).filter((name) => {\n\t\t\tconst fn = BaseClass[name];\n\t\t\tconst isFunc = typeof fn === \"function\";\n\t\t\tconst isGen = fn?.constructor?.name === \"GeneratorFunction\" || fn?.constructor?.name === \"AsyncGeneratorFunction\";\n\t\t\treturn isFunc && !isGen && _isCacheEnabled(name);\n\t\t});\n\n\t\tfor (const name of staticProps) {\n\t\t\tconst original = BaseClass[name];\n\t\t\tconst cache = new policy(maxSize);\n\t\t\tmethodCaches.set(name, cache);\n\n\t\t\tWrapped[name] = function (...args) {\n\t\t\t\tif (args.some(thisClass.isGeneratorObject)) {\n\t\t\t\t\treturn original.apply(this, args);\n\t\t\t\t}\n\n\t\t\t\tconst key = thisClass._identityHash(args);\n\t\t\t\tif (cache.has(key)) return cache.get(key);\n\t\t\t\tconst result = original.apply(this, args);\n\n\t\t\t\tif (thisClass.isGeneratorObject(result)) {\n\t\t\t\t\tcaches.delete(name);\n\t\t\t\t\tWrapped[name] = original;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcache.set(key, result);\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}\n\n\t\tObject.defineProperty(Wrapped, \"name\", { value: BaseClass.name });\n\n\t\treturn Wrapped;\n\t}\n}\n\nmodule.exports = {\n\tCacheMapInterface,\n\tLRUCache,\n\tFIFOCache,\n\tLFUCache,\n\tCacheWrapper,\n};\n",
    "module.exports = {\n    ...require(\"./CacheWrapper.js\")\n};\n",
    "module.exports = {\n    IndexProxy: require(\"./IndexProxy.js\"),\n    ProxyManager: require(\"./ProxyManager.js\"),\n    TypeChecker: require(\"./TypeChecker.js\"),\n    cache: require(\"./cache/index.js\"),\n    sys: require(\"./sys/index.js\")\n};\n",
    "const SymbolDict = require(\"./symbol/SymbolDict\");\n\n/**\n * JavaLibraryScriptの共通継承元\n * @class\n */\nclass JavaLibraryScriptCore {\n\t/** @type {true} */\n\tstatic [SymbolDict.JavaLibraryScript] = true;\n}\n\nmodule.exports = JavaLibraryScriptCore;\n",
    "const SymbolDict = require(\"./symbol/SymbolDict\");\nconst JavaLibraryScriptCore = require(\"./JavaLibraryScriptCore\");\n\n/**\n * ログ出力管理クラス\n * @class\n */\nclass Logger extends JavaLibraryScriptCore {\n\t/**\n\t * コンソールスタイルを有効にする\n\t * @type {boolean}\n\t * @default true\n\t * @static\n\t */\n\tstatic ENABLE_CONSOLE_STYLE = this._isEnableCustomConsole();\n\t/**\n\t * 折りたたみなしのログを有効にする\n\t * @type {boolean}\n\t * @default true\n\t * @static\n\t */\n\tstatic ENABLE_SIMPLE_LOG = true;\n\t/**\n\t * スタックトレースを有効にする\n\t * @type {boolean}\n\t * @default true\n\t * @static\n\t */\n\tstatic ENABLE_STACK_TRACE = true;\n\t/**\n\t * 区切り線の長さの初期値\n\t * @type {number}\n\t * @default 50\n\t * @static\n\t */\n\tstatic DEFAULT_HR_SIZE = 40;\n\n\t/**\n\t * ログレベル\n\t * @enum {number}\n\t * @readonly\n\t * @static\n\t */\n\tstatic LOG_LEVEL = {\n\t\tDEBUG: 0,\n\t\tTIME: 1,\n\t\tLOG: 3,\n\t\tWARN: 5,\n\t\tERROR: 7,\n\t\tINFO: 9,\n\t\tIGNORE: 11,\n\t};\n\t/**\n\t * コンソールスタイル\n\t * @enum {string}\n\t * @readonly\n\t * @static\n\t */\n\tstatic CONSOLE_STYLE = {\n\t\tDEBUG_TITLE: \"color: gray;font-weight: normal;\",\n\t\tDEBUG: \"color: gray;\",\n\t\tLOG_TITLE: \"color: teal;font-weight: normal;\",\n\t\tLOG: \"color: teal;\",\n\t\tWARN_TITLE: \"background-color: #fef6d5;font-weight: normal;\",\n\t\tWARN: \"\",\n\t\tERROR_TITLE: \"background-color: #fcebeb;font-weight: normal;\",\n\t\tERROR: \"\",\n\t\tINFO_TITLE: \"color: blue;font-weight: normal;\",\n\t\tINFO: \"font-family: serif;\",\n\t\tSTACK_TRACE: \"font-size: 0.8em;color: darkblue;\",\n\t};\n\t/**\n\t * スタックトレースを取得する正規表現\n\t * @type {RegExp}\n\t * @readonly\n\t * @static\n\t */\n\tstatic STACK_TRACE_GET_REG = /at (?:.+? )?\\(?(.+):(\\d+):(?:\\d+)\\)?/;\n\n\t/**\n\t * @param {String} [prefix=\"\"]\n\t * @param {number} [visibleLevel=Logger.LOG_LEVEL.WARN]\n\t */\n\tconstructor(prefix = \"\", visibleLevel = Logger.LOG_LEVEL.WARN) {\n\t\tsuper();\n\n\t\t/**\n\t\t * ログの先頭の文字列\n\t\t * @type {String}\n\t\t */\n\t\tthis._prefix = prefix;\n\t\t/**\n\t\t * 表示するログレベル\n\t\t * @type {number}\n\t\t */\n\t\tthis._visibleLevel = visibleLevel;\n\t}\n\n\t/**\n\t * ログの先頭の文字列を変更する\n\t * @param {String} prefix\n\t */\n\tsetPrefix(prefix) {\n\t\tthis._prefix = prefix;\n\t}\n\t/**\n\t * ログの先頭の文字列を取得する\n\t * @returns {String}\n\t */\n\tgetPrefix() {\n\t\treturn this._prefix;\n\t}\n\n\t/**\n\t * 表示するログレベルを変更する\n\t * @param {number} level\n\t */\n\tsetVisibleLevel(level) {\n\t\tthis._visibleLevel = level;\n\t}\n\t/**\n\t * 表示するログレベルを取得する\n\t * @returns {number}\n\t */\n\tgetVisibleLevel() {\n\t\treturn this._visibleLevel;\n\t}\n\n\t/**\n\t * カスタムコンソールが使用可能か判定する\n\t * @returns {boolean}\n\t * @static\n\t */\n\tstatic _isEnableCustomConsole() {\n\t\tconst t = navigator?.userAgent?.toLowerCase();\n\t\tif (!t) return false;\n\t\treturn /(chrome|firefox|safari)/.test(t);\n\t}\n\n\t/**\n\t * 表示可能なログレベルか判定する\n\t * @param {number} level\n\t * @returns {boolean}\n\t */\n\t_isVisible(level) {\n\t\treturn level >= this._visibleLevel;\n\t}\n\n\t/**\n\t * ログの先頭の文字列を生成する\n\t * @returns {String}\n\t */\n\t_generatePrefix() {\n\t\tif (!this._prefix) return \"\";\n\t\treturn `[${this._prefix}] `;\n\t}\n\n\t/**\n\t * ログレベルを文字列に変換する\n\t * @param {number} level\n\t * @returns {String | false}\n\t */\n\t_getLevelToString(level) {\n\t\t/** @type {typeof Logger.LOG_LEVEL} */\n\t\tconst LOG_LEVEL = this.constructor.LOG_LEVEL;\n\t\tswitch (level) {\n\t\t\tcase LOG_LEVEL.DEBUG:\n\t\t\t\treturn \"DEBUG\";\n\t\t\tcase LOG_LEVEL.LOG:\n\t\t\t\treturn \"LOG\";\n\t\t\tcase LOG_LEVEL.WARN:\n\t\t\t\treturn \"WARN\";\n\t\t\tcase LOG_LEVEL.ERROR:\n\t\t\t\treturn \"ERROR\";\n\t\t\tcase LOG_LEVEL.INFO:\n\t\t\t\treturn \"INFO\";\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * 呼び出し元のスタックトレースを取得する\n\t * @returns {String}\n\t */\n\t_getTopStackTrace() {\n\t\tconst stackLines = new Error().stack.split(\"\\n\");\n\t\t/** @type {typeof Logger} */\n\t\tconst construct = this.constructor;\n\t\tconst className = construct.name;\n\t\tconst LibName = SymbolDict.LIBRARY_NAME;\n\n\t\tconst reg = new RegExp(`(?:^|\\\\W)(?:${className}|${LibName})\\\\.`);\n\n\t\t// Logger.* 系のフレームを飛ばす\n\t\tlet callerLine = \"\";\n\t\tfor (let i = 1; i < stackLines.length; i++) {\n\t\t\tconst line = stackLines[i];\n\t\t\tif (!reg.test(line)) {\n\t\t\t\tcallerLine = line.trim();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst match = callerLine.match(construct.STACK_TRACE_GET_REG);\n\t\tlet location = \"\";\n\t\tif (match) {\n\t\t\tconst filePath = match[1];\n\t\t\tconst lineNumber = match[2];\n\n\t\t\tconst parts = filePath.split(/[\\\\/]/);\n\t\t\tconst shortPath = parts.slice(-1).join(\"/\");\n\t\t\tlocation = `${shortPath}:${lineNumber}`;\n\t\t}\n\n\t\treturn location;\n\t}\n\n\t/**\n\t * ログを出力する\n\t * @param {number} level\n\t * @param {any[]} args\n\t * @returns {boolean}\n\t */\n\t_levelToPrint(level, args) {\n\t\tif (!this._isVisible(level)) return true;\n\n\t\tconst levelStr = this._getLevelToString(level);\n\t\tif (!levelStr) return false;\n\n\t\t/** @type {typeof Logger} */\n\t\tconst construct = this.constructor;\n\n\t\tlet logFunc,\n\t\t\ttitle_prefix = \"\";\n\t\t/** @type {typeof Logger.LOG_LEVEL} */\n\t\tconst LOG_LEVEL = construct.LOG_LEVEL;\n\t\tswitch (level) {\n\t\t\tcase LOG_LEVEL.DEBUG:\n\t\t\tcase LOG_LEVEL.LOG:\n\t\t\t\tlogFunc = console.log.bind(console);\n\t\t\t\tbreak;\n\t\t\tcase LOG_LEVEL.WARN:\n\t\t\t\tlogFunc = console.warn.bind(console);\n\t\t\t\ttitle_prefix = \"⚠️\";\n\t\t\t\tbreak;\n\t\t\tcase LOG_LEVEL.ERROR:\n\t\t\t\tlogFunc = console.error.bind(console);\n\t\t\t\ttitle_prefix = \"🛑\";\n\t\t\t\tbreak;\n\t\t\tcase LOG_LEVEL.INFO:\n\t\t\t\tlogFunc = console.info.bind(console);\n\t\t\t\ttitle_prefix = \"ℹ️\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlogFunc = console.log.bind(console);\n\t\t}\n\n\t\tconst format = args.map((a) => (typeof a === \"string\" ? \"%s\" : \"%o\")).join(\" \");\n\t\t/** @type {typeof Logger.CONSOLE_STYLE} */\n\t\tconst console_style = construct.CONSOLE_STYLE;\n\n\t\tlet stackTrace = \"\";\n\t\tif (construct.ENABLE_STACK_TRACE) {\n\t\t\tstackTrace = this._getTopStackTrace();\n\t\t}\n\n\t\tif (construct.ENABLE_SIMPLE_LOG) {\n\t\t\tlet stackName = \"\";\n\t\t\tif (stackTrace) {\n\t\t\t\tstackName = `[${stackTrace}]\\n`;\n\t\t\t}\n\t\t\tif (construct.ENABLE_CONSOLE_STYLE) {\n\t\t\t\tlogFunc(\n\t\t\t\t\t// 通常表示\n\t\t\t\t\t`%c%s%c${this._generatePrefix()}${format}`,\n\t\t\t\t\tconsole_style.STACK_TRACE,\n\t\t\t\t\tstackName,\n\t\t\t\t\tconsole_style[levelStr],\n\t\t\t\t\t...args\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tlogFunc(\n\t\t\t\t\t// 通常表示\n\t\t\t\t\t`%s${format}`,\n\t\t\t\t\tstackName,\n\t\t\t\t\t...args\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (construct.ENABLE_CONSOLE_STYLE) {\n\t\t\tconsole.groupCollapsed(\n\t\t\t\t// タイトル表示\n\t\t\t\t`%c${this._generatePrefix()}${title_prefix}${format}`,\n\t\t\t\tconsole_style[`${levelStr}_TITLE`],\n\t\t\t\t...args\n\t\t\t);\n\t\t} else {\n\t\t\tconsole.groupCollapsed(\n\t\t\t\t// タイトル表示\n\t\t\t\t`${this._generatePrefix()}${title_prefix}${format}`,\n\t\t\t\t...args\n\t\t\t);\n\t\t}\n\n\t\tif (stackTrace) {\n\t\t\tif (construct.ENABLE_CONSOLE_STYLE) {\n\t\t\t\tconsole.log(`%c[%s]`, console_style.STACK_TRACE, stackTrace);\n\t\t\t} else {\n\t\t\t\tconsole.log(`[%s]`, stackTrace);\n\t\t\t}\n\t\t}\n\t\tif (construct.ENABLE_CONSOLE_STYLE) {\n\t\t\tlogFunc(\n\t\t\t\t// 内部表示\n\t\t\t\t`%c${format}`,\n\t\t\t\tconsole_style[levelStr],\n\t\t\t\t...args\n\t\t\t);\n\t\t} else {\n\t\t\tlogFunc(\n\t\t\t\t// 内部表示\n\t\t\t\t`${format}`,\n\t\t\t\t...args\n\t\t\t);\n\t\t}\n\t\tconsole.groupEnd();\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * 開発用ログ\n\t * @param {...any} args\n\t */\n\tdebug(...args) {\n\t\tconst level = this.constructor.LOG_LEVEL.DEBUG;\n\t\tthis._levelToPrint(level, args);\n\t}\n\t/**\n\t * 通常ログ\n\t * @param {...any} args\n\t */\n\tlog(...args) {\n\t\tconst level = this.constructor.LOG_LEVEL.LOG;\n\t\tthis._levelToPrint(level, args);\n\t}\n\t/**\n\t * 警告ログ\n\t * @param {...any} args\n\t */\n\twarning(...args) {\n\t\tconst level = this.constructor.LOG_LEVEL.WARN;\n\t\tthis._levelToPrint(level, args);\n\t}\n\t/**\n\t * 警告ログ\n\t * @param {...any} args\n\t */\n\twarn(...args) {\n\t\tthis.warning(...args);\n\t}\n\t/**\n\t * エラーログ\n\t * @param {...any} args\n\t */\n\terror(...args) {\n\t\tconst level = this.constructor.LOG_LEVEL.ERROR;\n\t\tthis._levelToPrint(level, args);\n\t}\n\t/**\n\t * エラーログ\n\t * @param {...any} args\n\t */\n\terr(...args) {\n\t\tthis.error(...args);\n\t}\n\t/**\n\t * 情報ログ\n\t * @param {...any} args\n\t */\n\tinformation(...args) {\n\t\tconst level = this.constructor.LOG_LEVEL.INFO;\n\t\tthis._levelToPrint(level, args);\n\t}\n\t/**\n\t * 情報ログ\n\t * @param {...any} args\n\t */\n\tinfo(...args) {\n\t\tthis.information(...args);\n\t}\n\t/**\n\t * タイムログ (開始)\n\t * @param {String} label\n\t * @returns {String}\n\t */\n\ttime(label) {\n\t\tconst level = this.constructor.LOG_LEVEL.TIME;\n\t\tif (this._isVisible(level)) {\n\t\t\tconst str = `${this._generatePrefix()}${label}`;\n\t\t\tconsole.log(`${str}: Start`);\n\t\t\tconsole.time(str);\n\t\t}\n\t\treturn label;\n\t}\n\t/**\n\t * タイムログ (終了)\n\t * @param {String} label\n\t */\n\ttimeEnd(label) {\n\t\tconst level = this.constructor.LOG_LEVEL.TIME;\n\t\tif (this._isVisible(level)) {\n\t\t\tconsole.timeEnd(`${this._generatePrefix()}${label}`);\n\t\t}\n\t}\n\t/**\n\t * 区切り線を出力する\n\t * @param {Number} [size]\n\t */\n\thr(size) {\n\t\tconst hr_size = size || this.constructor.DEFAULT_HR_SIZE;\n\n\t\tlet hr = \"\".padEnd(hr_size, \"-\");\n\t\tif (this._isVisible(this.constructor.LOG_LEVEL.LOG)) {\n\t\t\tconsole.log(hr);\n\t\t}\n\t}\n\n\t/**\n\t * クラスのインスタンスをラップする\n\t * @template {Object} T\n\t * @param {T} instance\n\t * @returns {T}\n\t */\n\twrapInstanceIO(instance) {\n\t\t// すでにラップ済みならそのまま返す\n\t\tif (instance[SymbolDict.LoggerWrapped]) return instance;\n\n\t\tconst Log = this;\n\t\tconst classRef = instance.constructor;\n\t\tconst className = classRef.name;\n\t\tconst proxy = new Proxy(instance, {\n\t\t\tget(target, prop, receiver) {\n\t\t\t\tconst value = target[prop];\n\t\t\t\tif (typeof value === \"function\") {\n\t\t\t\t\treturn (...args) => {\n\t\t\t\t\t\tLog.debug(`call ${className}.${prop}:`, args);\n\t\t\t\t\t\tconst result = value.apply(target, args);\n\n\t\t\t\t\t\t// 戻り値が同じクラスのインスタンスなら再ラップ\n\t\t\t\t\t\tif (result instanceof classRef) {\n\t\t\t\t\t\t\treturn Log.wrapInstanceIO(result, classRef);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t},\n\t\t});\n\n\t\tproxy[SymbolDict.LoggerWrapped] = true;\n\t\treturn proxy;\n\t}\n}\n\n/**\n * 内容ログ出力用のインスタンス\n * @type {Logger}\n */\nconst logging = new Logger(\"JLS\", Logger.LOG_LEVEL.LOG);\n\nmodule.exports = { Logger, logging };\n",
    "module.exports = {\n    JavaLibraryScriptCore: require(\"./JavaLibraryScriptCore.js\"),\n    ...require(\"./Logger.js\"),\n    symbol: require(\"./symbol/index.js\")\n};\n",
    "/**\n * Symbolの共通プレフィックス\n * @type {string}\n * @readonly\n */\nconst prefix = \"@@JLS_\";\n\nconst LIBRARY_NAME = \"JavaLibraryScript\";\n\n/**\n * 内部利用Symbolの辞書\n * @enum {Symbol}\n * @readonly\n */\nconst SYMBOL_DICT = {\n\t// 定数\n\t/** @type {string} */\n\tLIBRARY_NAME,\n\t// 公開\n\tJavaLibraryScript: Symbol.for(`${prefix}${LIBRARY_NAME}`),\n\tinstanceofTarget: Symbol.for(`${prefix}instanceofTarget`),\n\tLoggerWrapped: Symbol.for(`${prefix}LoggerWrapped`),\n\t// 内部\n\tTypeAny: Symbol(\"Any\"),\n\tTypeVoid: Symbol(\"Void\"),\n};\n\nmodule.exports = SYMBOL_DICT;\n",
    "module.exports = {\n    ...require(\"./SymbolDict.js\")\n};\n",
    "const JavaLibraryScript = require(\"./index\");\n\nif (typeof window !== \"undefined\") {\n\twindow.JavaLibraryScript = JavaLibraryScript;\n}\nif (typeof self !== \"undefined\") {\n\tself.JavaLibraryScript = JavaLibraryScript;\n}\n\nmodule.exports = JavaLibraryScript;\n",
    "const JavaLibraryScriptCore = require(\"../libs/sys/JavaLibraryScriptCore\");\nconst { logging } = require(\"../libs/sys/Logger\");\nconst { CacheWrapper } = require(\"../libs/cache/CacheWrapper\");\n\n/**\n * BigFloat の設定\n * @class\n */\nclass BigFloatConfig extends JavaLibraryScriptCore {\n\t/**\n\t * 0に近い方向に切り捨て\n\t * @type {number}\n\t * @static\n\t * @readonly\n\t */\n\tstatic ROUND_TRUNCATE = 0;\n\t/**\n\t * 絶対値が小さい方向に切り捨て（ROUND_TRUNCATEと同じ）\n\t * @type {number}\n\t * @static\n\t * @readonly\n\t */\n\tstatic ROUND_DOWN = 0;\n\t/**\n\t * 絶対値が大きい方向に切り上げ\n\t * @type {number}\n\t * @static\n\t * @readonly\n\t */\n\tstatic ROUND_UP = 1;\n\t/**\n\t * 正の無限大方向に切り上げ\n\t * @type {number}\n\t * @static\n\t * @readonly\n\t */\n\tstatic ROUND_CEIL = 2;\n\t/**\n\t * 負の無限大方向に切り捨て\n\t * @type {number}\n\t * @static\n\t * @readonly\n\t */\n\tstatic ROUND_FLOOR = 3;\n\t/**\n\t * 四捨五入\n\t * @type {number}\n\t * @static\n\t * @readonly\n\t */\n\tstatic ROUND_HALF_UP = 4;\n\t/**\n\t * 五捨六入（5未満切り捨て）\n\t * @type {number}\n\t * @static\n\t * @readonly\n\t */\n\tstatic ROUND_HALF_DOWN = 5;\n\n\t/**\n\t * 円周率の計算アルゴリズム\n\t * @type {number}\n\t * @static\n\t * @readonly\n\t */\n\tstatic PI_MATH_DEFAULT = 0;\n\t/**\n\t * 円周率[Gregory-Leibniz法] (超高速・超低収束)\n\t * @type {number}\n\t * @static\n\t * @readonly\n\t */\n\tstatic PI_LEIBNIZ = 1;\n\t/**\n\t * 円周率[ニュートン法] (高速・低収束)\n\t * @type {number}\n\t * @static\n\t * @readonly\n\t */\n\tstatic PI_NEWTON = 2;\n\t/**\n\t * 円周率[Chudnovsky法] (低速・高収束)\n\t * @type {number}\n\t * @static\n\t * @readonly\n\t */\n\tstatic PI_CHUDNOVSKY = 3;\n\n\t/**\n\t * @param {Object | BigFloatConfig} [options]\n\t * @param {boolean} [options.allowPrecisionMismatch=false] - 精度の不一致を許容する\n\t * @param {boolean} [options.mutateResult=false] - 破壊的な計算(自身の上書き)をする (falseは新インスタンスを作成)\n\t * @param {number} [options.roundingMode=BigFloatConfig.ROUND_TRUNCATE] - 丸めモード\n\t * @param {BigInt} [options.extraPrecision=2n] - 追加の精度\n\t * @param {number} [options.piAlgorithm=BigFloatConfig.PI_CHUDNOVSKY] - 円周率算出アルゴリズム\n\t * @param {BigInt} [options.trigFuncsMaxSteps=5000n] - 三角関数の最大ステップ数\n\t * @param {BigInt} [options.lnMaxSteps=10000n] - 自然対数の最大ステップ数\n\t */\n\tconstructor({\n\t\t// 設定\n\t\tallowPrecisionMismatch = false,\n\t\tmutateResult = false,\n\t\troundingMode = BigFloatConfig.ROUND_TRUNCATE,\n\t\textraPrecision = 2n,\n\t\tpiAlgorithm = BigFloatConfig.PI_CHUDNOVSKY,\n\t\ttrigFuncsMaxSteps = 5000n,\n\t\tlnMaxSteps = 10000n,\n\t} = {}) {\n\t\tsuper();\n\t\t/**\n\t\t * 精度の不一致を許容する\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.allowPrecisionMismatch = allowPrecisionMismatch;\n\t\t/**\n\t\t * 破壊的な計算(自身の上書き)をする (falseは新インスタンスを作成)\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.mutateResult = mutateResult;\n\t\t/**\n\t\t * 丸めモード\n\t\t * @type {number}\n\t\t * @default BigFloatConfig.ROUND_TRUNCATE\n\t\t */\n\t\tthis.roundingMode = roundingMode;\n\t\t/**\n\t\t * 追加の精度\n\t\t * @type {BigInt}\n\t\t * @default 2n\n\t\t */\n\t\tthis.extraPrecision = extraPrecision;\n\t\t/**\n\t\t * 円周率算出アルゴリズム\n\t\t * @type {number}\n\t\t * @default BigFloatConfig.PI_CHUDNOVSKY\n\t\t */\n\t\tthis.piAlgorithm = piAlgorithm;\n\t\t/**\n\t\t * 三角関数の最大ステップ数\n\t\t * @type {BigInt}\n\t\t * @default 1000n\n\t\t */\n\t\tthis.trigFuncsMaxSteps = trigFuncsMaxSteps;\n\t\t/**\n\t\t * 自然対数の最大ステップ数\n\t\t * @type {BigInt}\n\t\t * @default 50000n\n\t\t */\n\t\tthis.lnMaxSteps = lnMaxSteps;\n\t}\n\n\t/**\n\t * 設定オブジェクトを複製する\n\t * @returns {BigFloatConfig}\n\t */\n\tclone() {\n\t\t// shallow copy で新しい設定オブジェクトを返す\n\t\treturn new BigFloatConfig({ ...this });\n\t}\n\n\t/**\n\t * 精度の不一致を許容するかどうかを切り替える\n\t */\n\ttoggleMismatch() {\n\t\tthis.allowPrecisionMismatch = !this.allowPrecisionMismatch;\n\t}\n\n\t/**\n\t * 破壊的な計算(自身の上書き)をするかどうかを切り替える\n\t */\n\ttoggleMutation() {\n\t\tthis.mutateResult = !this.mutateResult;\n\t}\n}\n\n/**\n * 大きな浮動小数点数を扱えるクラス\n * @class\n */\nclass BigFloat extends JavaLibraryScriptCore {\n\t/**\n\t * 最大精度 (Stringの限界)\n\t * @type {BigInt}\n\t * @static\n\t */\n\tstatic MAX_PRECISION = 200000000n;\n\n\t/**\n\t * 設定\n\t * @type {BigFloatConfig}\n\t * @static\n\t */\n\tstatic config = new BigFloatConfig();\n\n\t/**\n\t * キャッシュ\n\t * @type {Record<string, {value: BigInt, precision: BigInt, priority: number}>}\n\t * @static\n\t * @readonly\n\t */\n\tstatic _cached = {};\n\n\t/**\n\t * @param {string | number | BigInt | BigFloat} value - 初期値\n\t * @param {number} [precision=20] - 精度\n\t * @throws {Error}\n\t */\n\tconstructor(value, precision = 20n) {\n\t\tsuper();\n\n\t\tif (value instanceof BigFloat) {\n\t\t\tthis.value = value.value;\n\t\t\treturn;\n\t\t}\n\n\t\t/** @type {BigInt} */\n\t\tthis._precision = BigInt(precision);\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconstruct._checkPrecision(this._precision);\n\n\t\tif (!value) {\n\t\t\tthis.value = 0n;\n\t\t\treturn;\n\t\t}\n\n\t\tconst { intPart, fracPart, sign } = this._parse(value);\n\t\tconst exPrec = this._precision + construct.config.extraPrecision;\n\t\tconst frac = fracPart.padEnd(Number(exPrec), \"0\").slice(0, Number(exPrec));\n\t\tconst rawValue = BigInt(intPart + frac) * BigInt(sign);\n\n\t\t/** @type {BigInt} */\n\t\tthis.value = construct._round(rawValue, exPrec, this._precision);\n\t}\n\n\t// ====================================================================================================\n\t// * 基本ユーティリティ (クラス生成・変換・クローン)\n\t// ====================================================================================================\n\t// --------------------------------------------------\n\t// クラス操作\n\t// --------------------------------------------------\n\t/**\n\t * BigFloatのstaticメゾット実行結果をキャッシュ化するクラスを生成する (同じ計算を繰り返さない限り使用した方が遅い)\n\t * @param {number} [maxSize=10000] - キャッシュサイズ\n\t * @param {string[]} [addBlacklist=[]] - 追加ブラックリスト\n\t * @returns {typeof BigFloat}\n\t */\n\tstatic generateCachedClass(maxSize = 10000, addBlacklist = []) {\n\t\treturn CacheWrapper.convert(this, {\n\t\t\tblacklist: [\n\t\t\t\t// オブジェクトを返却するため\n\t\t\t\t\"generateCachedClass\",\n\t\t\t\t\"clone\",\n\t\t\t\t\"max\",\n\t\t\t\t\"min\",\n\t\t\t\t\"sum\",\n\t\t\t\t\"average\",\n\t\t\t\t\"median\",\n\t\t\t\t\"product\",\n\t\t\t\t\"variance\",\n\t\t\t\t\"stddev\",\n\t\t\t\t\"_normalizeArgs\",\n\t\t\t\t\"_batchRescale\",\n\t\t\t\t\"_makeResult\",\n\t\t\t\t\"pi\",\n\t\t\t\t\"e\",\n\t\t\t\t// 何も返却しないため\n\t\t\t\t\"_checkPrecision\",\n\t\t\t\t// 毎回ランダムなため\n\t\t\t\t\"_randomBigInt\",\n\t\t\t\t\"random\",\n\t\t\t\t// 同業者\n\t\t\t\t\"_getCheckCache\",\n\t\t\t\t\"_getCache\",\n\t\t\t\t\"_updateCache\",\n\t\t\t\t// 定数\n\t\t\t\t\"minusOne\",\n\t\t\t\t\"zero\",\n\t\t\t\t\"one\",\n\t\t\t\t// 追加\n\t\t\t\t...addBlacklist,\n\t\t\t],\n\t\t\tmaxSize,\n\t\t});\n\t}\n\t// --------------------------------------------------\n\t// オブジェクト複製\n\t// --------------------------------------------------\n\t/**\n\t * クラスを複製する (設定複製用)\n\t * @returns {BigFloat}\n\t * @static\n\t */\n\tstatic clone() {\n\t\tconst Parent = this;\n\t\treturn class extends Parent {\n\t\t\tstatic config = Parent.config.clone();\n\t\t\tstatic MAX_PRECISION = Parent.MAX_PRECISION;\n\t\t};\n\t}\n\t/**\n\t * インスタンスを複製する\n\t * @returns {BigFloat}\n\t */\n\tclone() {\n\t\tconst instance = new this.constructor();\n\t\tinstance._precision = this._precision;\n\t\tinstance.value = this.value;\n\t\treturn instance;\n\t}\n\t// --------------------------------------------------\n\t// パース・変換\n\t// --------------------------------------------------\n\t/**\n\t * 文字列を数値に変換する\n\t * @param {string} str - 変換する文字列\n\t * @param {BigInt} precision - 小数点以下の桁数\n\t * @param {number} base - 基数\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic parseFloat(str, precision = 20n, base = 10) {\n\t\tif (str instanceof BigFloat) return str.clone();\n\t\tif (typeof str !== \"string\") str = String(str);\n\t\tif (base < 2 || base > 36) throw new RangeError(\"Base must be between 2 and 36\");\n\t\tif (base === 10) return new this(str, precision);\n\n\t\tconst [rawInt, rawFrac = \"\"] = str.toLowerCase().replace(/^\\+/, \"\").split(\".\");\n\t\tconst sign = str.trim().startsWith(\"-\") ? -1n : 1n;\n\t\tconst digits = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n\t\tconst toDigit = (ch) => {\n\t\t\tconst d = digits.indexOf(ch);\n\t\t\tif (d < 0 || d >= base) throw new Error(`Invalid digit '${ch}' for base ${base}`);\n\t\t\treturn BigInt(d);\n\t\t};\n\n\t\tconst bigBase = BigInt(base);\n\n\t\t// 整数部分\n\t\tlet intVal = 0n;\n\t\tfor (const ch of rawInt.replace(/^[-+]/, \"\")) {\n\t\t\tintVal = intVal * bigBase + toDigit(ch);\n\t\t}\n\n\t\t// 小数部分\n\t\tlet fracVal = 0n;\n\t\tlet scale = 1n;\n\t\tlet basePow = 1n;\n\n\t\tfor (let i = 0; i < rawFrac.length && i < precision; i++) {\n\t\t\tbasePow *= bigBase;\n\t\t\tfracVal = fracVal * bigBase + toDigit(rawFrac[i]);\n\t\t\tscale = basePow;\n\t\t}\n\n\t\tprecision = BigInt(precision);\n\n\t\tconst scale10 = 10n ** precision;\n\t\tconst fracScaled = scale === 0n ? 0n : (fracVal * scale10) / scale;\n\t\tconst total = (intVal * scale10 + fracScaled) * sign;\n\n\t\treturn this._makeResult(total, precision);\n\t}\n\t// ====================================================================================================\n\t// * 内部ユーティリティ・補助関数\n\t// ====================================================================================================\n\t// --------------------------------------------------\n\t// 解析・正規化\n\t// --------------------------------------------------\n\t/**\n\t * 文字列を解析して数値を取得\n\t * @param {string} str - 文字列\n\t * @returns {{intPart: string, fracPart: string, sign: number}}\n\t */\n\t_parse(str) {\n\t\tstr = str.toString().trim();\n\n\t\tconst expMatch = str.match(/^([+-]?[\\d.]+)[eE]([+-]?\\d+)$/);\n\t\tif (expMatch) {\n\t\t\t// 指数表記を通常の小数に変換\n\t\t\tlet [_, base, expStr] = expMatch;\n\t\t\tconst exp = parseInt(expStr, 10);\n\n\t\t\t// 小数点位置をずらす\n\t\t\tlet [intPart, fracPart = \"\"] = base.split(\".\");\n\t\t\tconst allDigits = intPart + fracPart;\n\n\t\t\tlet pointIndex = intPart.length + exp;\n\t\t\tif (pointIndex < 0) {\n\t\t\t\tbase = \"0.\" + \"0\".repeat(-pointIndex) + allDigits;\n\t\t\t} else if (pointIndex >= allDigits.length) {\n\t\t\t\tbase = allDigits + \"0\".repeat(pointIndex - allDigits.length);\n\t\t\t} else {\n\t\t\t\tbase = allDigits.slice(0, pointIndex) + \".\" + allDigits.slice(pointIndex);\n\t\t\t}\n\n\t\t\tstr = base;\n\t\t}\n\n\t\tconst [intPartRaw, fracPartRaw = \"\"] = str.split(\".\");\n\t\tconst sign = intPartRaw.startsWith(\"-\") ? -1 : 1;\n\t\tconst intPart = intPartRaw.replace(\"-\", \"\");\n\t\treturn { intPart, fracPart: fracPartRaw, sign };\n\t}\n\t/**\n\t * 数値を正規化\n\t * @param {BigInt} val\n\t * @returns {string}\n\t */\n\t_normalize(val) {\n\t\tconst sign = val < 0n ? \"-\" : \"\";\n\t\tconst absVal = val < 0n ? -val : val;\n\t\tconst prec = Number(this._precision);\n\t\tif (prec === 0) {\n\t\t\treturn `${sign}${absVal.toString()}`;\n\t\t}\n\t\tconst s = absVal.toString().padStart(prec + 1, \"0\");\n\t\tconst intPart = s.slice(0, -prec);\n\t\tconst fracPart = s.slice(-prec);\n\t\treturn `${sign}${intPart}.${fracPart}`;\n\t}\n\t/**\n\t * 引数を正規化する\n\t * @param {any[]} args\n\t * @returns {any[]}\n\t */\n\tstatic _normalizeArgs(args) {\n\t\t// 配列か複数引数か判別して配列にまとめる\n\t\tif (args.length === 1 && Array.isArray(args[0])) {\n\t\t\treturn args[0];\n\t\t}\n\t\treturn args;\n\t}\n\t// --------------------------------------------------\n\t// スケーリング関連\n\t// --------------------------------------------------\n\t/**\n\t * 精度を合わせる\n\t * @param {BigFloat} other\n\t * @param {boolean} [useExPrecision=false] - 追加の精度を使う\n\t * @returns {[BigInt, BigInt, BigInt, BigInt]}\n\t * @throws {Error}\n\t */\n\t_bothRescale(other, useExPrecision = false) {\n\t\tconst precisionA = this._precision;\n\t\tif (!(other instanceof BigFloat)) {\n\t\t\tother = new this.constructor(other);\n\t\t}\n\t\tconst precisionB = other._precision;\n\t\t/** @type {BigFloatConfig} */\n\t\tconst config = this.constructor.config;\n\t\tif (precisionA === precisionB) {\n\t\t\tif (useExPrecision) {\n\t\t\t\tconst exPr = config.extraPrecision;\n\t\t\t\tconst exScale = 10n ** exPr;\n\t\t\t\tconst valA = this.value * exScale;\n\t\t\t\tconst valB = other.value * exScale;\n\t\t\t\treturn [valA, valB, precisionA + exPr, precisionA];\n\t\t\t}\n\t\t\treturn [this.value, other.value, precisionA, precisionA];\n\t\t}\n\t\tif (!config.allowPrecisionMismatch) throw new Error(\"Precision mismatch\");\n\n\t\tconst maxPrecision = precisionA > precisionB ? precisionA : precisionB;\n\t\tconst maxExPrecision = maxPrecision + (useExPrecision ? config.extraPrecision : 0n);\n\t\tconst scaleDiffA = maxExPrecision - precisionA;\n\t\tconst scaleDiffB = maxExPrecision - precisionB;\n\t\tconst valA = this.value * 10n ** scaleDiffA;\n\t\tconst valB = other.value * 10n ** scaleDiffB;\n\t\treturn [valA, valB, maxExPrecision, maxPrecision];\n\t}\n\t/**\n\t * 複数の精度を合わせる\n\t * @param {BigFloat[]} arr\n\t * @param {boolean} [useExPrecision=false]\n\t * @returns {[BigFloat[], BigInt, BigInt]}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic _batchRescale(arr, useExPrecision = false) {\n\t\t/** @type {BigFloatConfig} */\n\t\tconst config = this.config;\n\t\tconst exPr = config.extraPrecision;\n\t\tif (arr.length === 0) {\n\t\t\tif (useExPrecision) {\n\t\t\t\treturn [[], exPr, 0n];\n\t\t\t}\n\t\t\treturn [[], 0n, 0n];\n\t\t}\n\t\tarr = arr.slice();\n\n\t\tconst allowMismatch = config.allowPrecisionMismatch;\n\t\t// 最大精度を探す\n\t\tlet maxPrecision = 0n;\n\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\tlet bf = arr[i];\n\t\t\tif (!(bf instanceof this)) {\n\t\t\t\tbf = arr[i] = new this(bf);\n\t\t\t}\n\t\t\tif (!allowMismatch && bf._precision !== maxPrecision) {\n\t\t\t\tthrow new Error(\"Precision mismatch and allowPrecisionMismatch = false\");\n\t\t\t}\n\t\t\tif (bf._precision > maxPrecision) maxPrecision = bf._precision;\n\t\t}\n\n\t\tlet maxExPrecision = maxPrecision + (useExPrecision ? exPr : 0n);\n\t\t// スケール計算とBigInt変換\n\t\tconst retArr = arr.map((bf) => {\n\t\t\tconst diff = maxExPrecision - bf._precision;\n\t\t\treturn bf.value * 10n ** diff;\n\t\t});\n\t\treturn [retArr, maxExPrecision, maxPrecision];\n\t}\n\t// --------------------------------------------------\n\t// 結果生成\n\t// --------------------------------------------------\n\t/**\n\t * 結果を作成する\n\t * @param {BigInt} val\n\t * @param {BigInt} precision\n\t * @param {BigInt} [exPrecision]\n\t * @returns {BigFloat}\n\t * @static\n\t */\n\tstatic _makeResult(val, precision, exPrecision = precision) {\n\t\tconst rounded = this._round(val, exPrecision, precision);\n\t\tconst result = new this();\n\t\tresult._precision = precision;\n\t\tresult.value = rounded;\n\t\treturn result;\n\t}\n\t/**\n\t * 結果を作成する\n\t * @param {BigInt} val\n\t * @param {BigInt} precision\n\t * @param {BigInt} [exPrecision]\n\t * @param {boolean} [okMutate=true] - 破壊的変更を許容\n\t * @returns {this}\n\t */\n\t_makeResult(val, precision, exPrecision = precision, okMutate = true) {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tif (construct.config.mutateResult && okMutate) {\n\t\t\tconst rounded = construct._round(val, exPrecision, precision);\n\t\t\tthis._precision = precision;\n\t\t\tthis.value = rounded;\n\t\t\treturn this;\n\t\t}\n\t\treturn construct._makeResult(val, precision, exPrecision);\n\t}\n\t// --------------------------------------------------\n\t// 精度チェック\n\t// --------------------------------------------------\n\t/**\n\t * 精度をチェックする\n\t * @param {BigInt} precision\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic _checkPrecision(precision) {\n\t\tif (precision < 0n) {\n\t\t\tthrow new RangeError(`Precision must be greater than 0`);\n\t\t}\n\t\tif (precision > this.MAX_PRECISION) {\n\t\t\tthrow new RangeError(`Precision exceeds ${this.name}.MAX_PRECISION`);\n\t\t}\n\t}\n\t/**\n\t * 精度を変更する\n\t * @param {BigInt} precision\n\t * @returns {this}\n\t */\n\tchangePrecision(precision) {\n\t\tprecision = BigInt(precision);\n\t\tthis.value = this.constructor._round(this.value, this._precision, precision);\n\t\tthis._precision = precision;\n\t\treturn this;\n\t}\n\t/**\n\t * どこまで精度が一致しているかを判定する\n\t * @param {BigFloat | number | string | BigInt} other - 比較する値\n\t * @returns {number}\n\t * @throws {Error}\n\t */\n\tmatchingPrecision(other) {\n\t\tconst [valA, valB, prec] = this._bothRescale(other);\n\t\tlet diff = valA - valB;\n\t\tif (diff === 0n) return prec;\n\t\tdiff = diff < 0n ? -diff : diff;\n\n\t\tlet factor = 10n ** prec;\n\t\tlet matched = 0n;\n\n\t\twhile (matched < prec) {\n\t\t\tfactor /= 10n;\n\t\t\tif (diff < factor) {\n\t\t\t\tmatched += 1n;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t}\n\t// ====================================================================================================\n\t// * 精度・比較系\n\t// ====================================================================================================\n\t// --------------------------------------------------\n\t// 比較演算\n\t// --------------------------------------------------\n\t/**\n\t * 等しいかどうかを判定する\n\t * @param {BigFloat | number | string | BigInt} other - 比較する値\n\t * @returns {boolean}\n\t * @throws {Error}\n\t */\n\tcompare(other) {\n\t\tconst [valA, valB] = this._bothRescale(other);\n\t\tif (valA < valB) return -1;\n\t\tif (valA > valB) return 1;\n\t\treturn 0;\n\t}\n\t/**\n\t * 等しいかどうかを判定する\n\t * @param {BigFloat | number | string | BigInt} other - 比較する値\n\t * @returns {boolean}\n\t * @throws {Error}\n\t */\n\teq(other) {\n\t\treturn this.compare(other) === 0;\n\t}\n\t/**\n\t * 等しいかどうかを判定する\n\t * @param {BigFloat | number | string | BigInt} other - 比較する値\n\t * @returns {boolean}\n\t * @throws {Error}\n\t */\n\tequals(other) {\n\t\treturn this.compare(other) === 0;\n\t}\n\t/**\n\t * 等しくないかどうかを判定する\n\t * @param {BigFloat | number | string | BigInt} other - 比較する値\n\t * @returns {boolean}\n\t * @throws {Error}\n\t */\n\tne(other) {\n\t\treturn this.compare(other) !== 0;\n\t}\n\t/**\n\t * this < other かどうかを判定する\n\t * @param {BigFloat | number | string | BigInt} other - 比較する値\n\t * @returns {boolean}\n\t * @throws {Error}\n\t */\n\tlt(other) {\n\t\treturn this.compare(other) === -1;\n\t}\n\t/**\n\t * this <= other かどうかを判定する\n\t * @param {BigFloat | number | string | BigInt} other - 比較する値\n\t * @returns {boolean}\n\t * @throws {Error}\n\t */\n\tlte(other) {\n\t\treturn this.compare(other) <= 0;\n\t}\n\t/**\n\t * this > other かどうかを判定する\n\t * @param {BigFloat | number | string | BigInt} other - 比較する値\n\t * @returns {boolean}\n\t * @throws {Error}\n\t */\n\tgt(other) {\n\t\treturn this.compare(other) === 1;\n\t}\n\t/**\n\t * this >= other かどうかを判定する\n\t * @param {BigFloat | number | string | BigInt} other - 比較する値\n\t * @returns {boolean}\n\t * @throws {Error}\n\t */\n\tgte(other) {\n\t\treturn this.compare(other) >= 0;\n\t}\n\t// --------------------------------------------------\n\t// 状態判定\n\t// --------------------------------------------------\n\t/**\n\t * 0かどうかを判定する\n\t * @returns {boolean}\n\t */\n\tisZero() {\n\t\treturn this.value === 0n;\n\t}\n\t/**\n\t * 正かどうかを判定する\n\t * @returns {boolean}\n\t */\n\tisPositive() {\n\t\treturn this.value > 0n;\n\t}\n\t/**\n\t * 負かどうかを判定する\n\t * @returns {boolean}\n\t */\n\tisNegative() {\n\t\treturn this.value < 0n;\n\t}\n\t// --------------------------------------------------\n\t// 差分・誤差計算\n\t// --------------------------------------------------\n\t/**\n\t * 相対差を計算する\n\t * @param {BigFloat | number | string | BigInt} other - 比較する値\n\t * @returns {BigInt}\n\t * @throws {Error}\n\t */\n\trelativeDiff(other) {\n\t\tconst [valA, valB, prec] = this._bothRescale(other);\n\n\t\tconst absA = valA < 0n ? -valA : valA;\n\t\tconst absB = valB < 0n ? -valB : valB;\n\t\tconst diff = valA > valB ? valA - valB : valB - valA;\n\n\t\tconst denominator = absA > absB ? absA : absB;\n\t\tif (denominator === 0n) return 0n;\n\n\t\tconst scale = 10n ** prec;\n\t\treturn this._makeResult((diff * scale) / denominator, prec);\n\t}\n\t/**\n\t * 絶対差を計算する\n\t * @param {BigFloat | number | string | BigInt} other - 比較する値\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t */\n\tabsoluteDiff(other) {\n\t\tconst [valA, valB, prec] = this._bothRescale(other);\n\t\treturn this._makeResult(valA > valB ? valA - valB : valB - valA, prec);\n\t}\n\t/**\n\t * 差分の非一致度を計算する\n\t * @param {BigFloat | number | string | BigInt} other - 比較する値\n\t * @returns {BigInt}\n\t * @throws {Error}\n\t */\n\tpercentDiff(other) {\n\t\tconst [valA, valB, prec] = this._bothRescale(other);\n\n\t\tconst absB = valB < 0n ? -valB : valB;\n\t\tconst diff = valA > valB ? valA - valB : valB - valA;\n\n\t\tif (absB === 0n) return 0n;\n\n\t\tconst scale = 10n ** prec;\n\t\treturn this._makeResult((diff * scale * 100n) / absB, prec);\n\t}\n\t// ====================================================================================================\n\t// * 数値変換・出力系\n\t// ====================================================================================================\n\t// --------------------------------------------------\n\t// 基本変換\n\t// --------------------------------------------------\n\t/**\n\t * 文字列に変換する\n\t * @param {number} base - 基数\n\t * @param {number} precision - 精度\n\t * @returns {string}\n\t */\n\ttoString(base = 10, precision = this._precision) {\n\t\tif (base < 2 || base > 36) throw new RangeError(\"Base must be between 2 and 36\");\n\t\tif (base === 10) return this._normalize(this.value);\n\t\tconst val = this.value;\n\t\tconst scale = 10n ** this._precision;\n\n\t\tconst digits = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\t\tconst sign = val < 0n ? \"-\" : \"\";\n\t\tconst absVal = val < 0n ? -val : val;\n\n\t\tconst intPart = absVal / scale;\n\t\tconst fracPart = absVal % scale;\n\n\t\tconst bigBase = BigInt(base);\n\n\t\t// 整数部\n\t\tlet intStr = \"\";\n\t\tlet intCopy = intPart;\n\t\tif (intCopy === 0n) {\n\t\t\tintStr = \"0\";\n\t\t} else {\n\t\t\twhile (intCopy > 0n) {\n\t\t\t\tconst digit = intCopy % bigBase;\n\t\t\t\tintStr = digits[digit] + intStr;\n\t\t\t\tintCopy /= bigBase;\n\t\t\t}\n\t\t}\n\t\tif (this._precision === 0n) return `${sign}${intStr}`;\n\t\tprecision = BigInt(precision);\n\n\t\t// 小数部\n\t\tlet fracStr = \"\";\n\t\tlet frac = fracPart;\n\t\tfor (let i = 0n; i < precision; i++) {\n\t\t\tfrac *= bigBase;\n\t\t\tconst digit = frac / scale;\n\t\t\tfracStr += digits[digit];\n\t\t\tfrac %= scale;\n\t\t\tif (frac === 0n) break;\n\t\t}\n\n\t\treturn fracStr.length > 0 ? `${sign}${intStr}.${fracStr}` : `${sign}${intStr}`;\n\t}\n\t/**\n\t * JSONに変換する\n\t * @returns {string}\n\t */\n\ttoJSON() {\n\t\t/** @type {BigFloatConfig} */\n\t\tconst config = this.constructor.config;\n\t\tlet bf = this;\n\t\tif (config.mutateResult) bf = bf.clone();\n\t\treturn bf.scale().toString();\n\t}\n\t/**\n\t * 数値に変換する\n\t * @returns {number}\n\t */\n\ttoNumber() {\n\t\treturn Number(this.toString());\n\t}\n\t// --------------------------------------------------\n\t// フォーマット\n\t// --------------------------------------------------\n\t/**\n\t * 小数点以下の桁数を指定して数値を丸める\n\t * @param {number} digits - 小数点以下の桁数\n\t * @returns {string}\n\t */\n\ttoFixed(digits) {\n\t\tconst str = this._normalize(this.value);\n\t\tconst [intPart, fracPart = \"\"] = str.split(\".\");\n\t\tconst d = Math.max(0, Number(digits));\n\t\tif (d === 0) return intPart;\n\t\tconst fracFixed = fracPart.padEnd(d, \"0\").slice(0, d);\n\t\treturn `${intPart}.${fracFixed}`;\n\t}\n\t/**\n\t * 指数表記に変換する\n\t * @param {number} digits - 小数点以下の桁数\n\t * @returns {string}\n\t */\n\ttoExponential(digits = Number(this._precision)) {\n\t\tconst prec = Number(this._precision);\n\t\tif (digits <= 0 || digits > prec) throw new RangeError(\"Invalid digits (must be between 1 and precision)\");\n\t\tconst isNeg = this.value < 0n;\n\t\tconst absVal = isNeg ? -this.value : this.value;\n\t\tconst s = absVal.toString().padStart(prec + 1, \"0\");\n\n\t\tconst intPart = s.slice(0, -prec) || \"0\";\n\t\tconst fracPart = s.slice(-prec);\n\t\tconst raw = `${intPart}${fracPart}`;\n\n\t\t// 最初の非ゼロ桁探す（有効数字先頭）\n\t\tconst firstDigitIndex = raw.search(/[1-9]/);\n\t\tif (firstDigitIndex === -1) return \"0e+0\";\n\n\t\tconst mantissa = raw.slice(firstDigitIndex, firstDigitIndex + digits);\n\t\tlet decimal;\n\t\tif (digits === 1) {\n\t\t\tdecimal = raw[firstDigitIndex]; // 有効数字1桁だけ（整数部）\n\t\t} else if (mantissa.length === 1) {\n\t\t\tdecimal = `${mantissa[0]}.0`;\n\t\t} else {\n\t\t\tdecimal = `${mantissa[0]}.${mantissa.slice(1)}`;\n\t\t}\n\t\tconst exp = intPart.length - firstDigitIndex - 1;\n\n\t\tconst signStr = isNeg ? \"-\" : \"\";\n\t\tconst expStr = exp >= 0 ? `e+${exp}` : `e${exp}`;\n\t\treturn `${signStr}${decimal}${expStr}`;\n\t}\n\t// ====================================================================================================\n\t// * 四則演算・基本関数\n\t// ====================================================================================================\n\t// --------------------------------------------------\n\t// 基本演算\n\t// --------------------------------------------------\n\t/**\n\t * 加算\n\t * @param {BigFloat} other\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tadd(other) {\n\t\tconst [valA, valB, prec] = this._bothRescale(other);\n\t\treturn this._makeResult(valA + valB, prec);\n\t}\n\t/**\n\t * 減算\n\t * @param {BigFloat} other\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tsub(other) {\n\t\tconst [valA, valB, prec] = this._bothRescale(other);\n\t\treturn this._makeResult(valA - valB, prec);\n\t}\n\t/**\n\t * 乗算\n\t * @param {BigFloat} other\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tmul(other) {\n\t\tconst [valA, valB, exPrec, prec] = this._bothRescale(other, true);\n\t\tconst scale = 10n ** exPrec;\n\t\tconst result = (valA * valB) / scale;\n\t\treturn this._makeResult(result, prec, exPrec);\n\t}\n\t/**\n\t * 除算\n\t * @param {BigFloat} other\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tdiv(other) {\n\t\tconst [valA, valB, exPrec, prec] = this._bothRescale(other, true);\n\t\tconst scale = 10n ** exPrec;\n\t\tif (valB === 0n) throw new Error(\"Division by zero\");\n\t\tconst result = (valA * scale) / valB;\n\t\treturn this._makeResult(result, prec, exPrec);\n\t}\n\t/**\n\t * 剰余\n\t * @param {BigInt} x\n\t * @param {BigInt} m\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _mod(x, m) {\n\t\tconst r = x % m;\n\t\treturn r < 0n ? r + m : r;\n\t}\n\t/**\n\t * 剰余\n\t * @param {BigFloat} other\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tmod(other) {\n\t\tconst [valA, valB, prec] = this._bothRescale(other);\n\t\tconst result = this.constructor._mod(valA, valB);\n\t\treturn this._makeResult(result, prec);\n\t}\n\t// --------------------------------------------------\n\t// 符号操作\n\t// --------------------------------------------------\n\t/**\n\t * 符号反転\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tneg() {\n\t\treturn this._makeResult(-this.value, this._precision);\n\t}\n\t/**\n\t * 絶対値\n\t * @param {BigInt} val\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _abs(val) {\n\t\treturn val < 0n ? -val : val;\n\t}\n\t/**\n\t * 絶対値\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tabs() {\n\t\treturn this._makeResult(this.constructor._abs(this.value), this._precision);\n\t}\n\t/**\n\t * 逆数を返す\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t */\n\treciprocal() {\n\t\tif (this.value === 0n) throw new Error(\"Division by zero\");\n\t\tconst exPr = this.constructor.config.extraPrecision;\n\t\tconst totalPr = this._precision + exPr;\n\t\tconst val = this.value * 10n ** exPr;\n\n\t\tconst scale = 10n ** totalPr;\n\t\t// 1をスケール倍して割る\n\t\tconst result = (scale * scale) / val;\n\t\treturn this._makeResult(result, this._precision, totalPr);\n\t}\n\t// --------------------------------------------------\n\t// 丸め・切り捨て・切り上げ\n\t// --------------------------------------------------\n\t/**\n\t * 小数点以下を切り捨て\n\t * @returns {BigFloat}\n\t */\n\tfloor() {\n\t\tconst scale = 10n ** this._precision;\n\t\tconst scaled = this.value / scale;\n\t\tconst floored = this.value < 0n && this.value % scale !== 0n ? scaled - 1n : scaled;\n\t\treturn this._makeResult(floored * scale, this._precision);\n\t}\n\t/**\n\t * 小数点以下を切り上げ\n\t * @returns {BigFloat}\n\t */\n\tceil() {\n\t\tconst scale = 10n ** this._precision;\n\t\tconst scaled = this.value / scale;\n\t\tconst ceiled = this.value > 0n && this.value % scale !== 0n ? scaled + 1n : scaled;\n\t\treturn this._makeResult(ceiled * scale, this._precision);\n\t}\n\t/**\n\t * 数値を丸める\n\t * @param {BigInt} val\n\t * @param {BigInt} currentPrec\n\t * @param {BigInt} targetPrec\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _round(val, currentPrec, targetPrec) {\n\t\tconst diff = currentPrec - targetPrec;\n\t\tif (diff < 0n) {\n\t\t\t// 精度が上がる場合は0埋め\n\t\t\treturn diff === 0n ? val : val * 10n ** -diff;\n\t\t}\n\t\t// 精度が下がる場合は丸める\n\t\tconst scale = 10n ** diff;\n\t\tconst rem = val % scale;\n\t\tconst base = val - rem;\n\t\tif (rem === 0n) return base / scale;\n\n\t\tconst mode = this.config.roundingMode;\n\t\tconst absRem = rem < 0n ? -rem : rem;\n\t\tconst half = scale / 2n;\n\t\tconst isNeg = val < 0n;\n\n\t\tlet offset = 0n;\n\t\tswitch (mode) {\n\t\t\tcase BigFloatConfig.ROUND_UP:\n\t\t\t\toffset = isNeg ? -scale : scale;\n\t\t\t\tbreak;\n\t\t\tcase BigFloatConfig.ROUND_CEIL:\n\t\t\t\tif (!isNeg) offset = scale;\n\t\t\t\tbreak;\n\t\t\tcase BigFloatConfig.ROUND_FLOOR:\n\t\t\t\tif (isNeg) offset = -scale;\n\t\t\t\tbreak;\n\t\t\tcase BigFloatConfig.ROUND_HALF_UP:\n\t\t\t\tif (absRem >= half) offset = isNeg ? -scale : scale;\n\t\t\t\tbreak;\n\t\t\tcase BigFloatConfig.ROUND_HALF_DOWN:\n\t\t\t\tif (absRem > half) offset = isNeg ? -scale : scale;\n\t\t\t\tbreak;\n\t\t\tcase BigFloatConfig.ROUND_TRUNCATE:\n\t\t\tcase BigFloatConfig.ROUND_DOWN:\n\t\t\tdefault:\n\t\t\t\t// 何もしないの...?\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn (base + offset) / scale;\n\t}\n\t/**\n\t * 四捨五入\n\t * @returns {BigFloat}\n\t */\n\tround() {\n\t\tconst scale = 10n ** this._precision;\n\t\tconst scaled = this.value / scale;\n\t\tconst remainder = this.value % scale;\n\t\tconst half = scale / 2n;\n\n\t\tlet rounded;\n\t\tif (this.value >= 0n) {\n\t\t\trounded = remainder >= half ? scaled + 1n : scaled;\n\t\t} else {\n\t\t\trounded = -remainder >= half ? scaled - 1n : scaled;\n\t\t}\n\n\t\treturn this._makeResult(rounded * scale, this._precision);\n\t}\n\t/**\n\t * 整数部分だけを取得\n\t * @returns {BigFloat}\n\t */\n\ttrunc() {\n\t\tconst scale = 10n ** this._precision;\n\t\tconst truncated = this.value / scale;\n\t\treturn this._makeResult(truncated * scale, this._precision);\n\t}\n\t// ====================================================================================================\n\t// * 冪乗・ルート・スケーリング\n\t// ====================================================================================================\n\t// --------------------------------------------------\n\t// べき乗\n\t// --------------------------------------------------\n\t/**\n\t * べき乗\n\t * @param {BigInt} base - 基数\n\t * @param {BigInt} exponent - 指数\n\t * @param {BigInt} precision\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _pow(base, exponent, precision) {\n\t\tconst scale = 10n ** precision;\n\t\tif (exponent === 0n) return scale;\n\t\tif (base === 0n) return 0n;\n\t\tif (exponent < 0n) {\n\t\t\tconst positivePow = this._pow(base, -exponent, precision);\n\t\t\tif (positivePow === 0n) throw new Error(\"Division by zero in power function\");\n\t\t\t// (scale * scale) は、スケールされた値の除算で精度を維持するためのおまじない\n\t\t\treturn (scale * scale) / positivePow;\n\t\t}\n\t\tif (exponent % scale === 0n) {\n\t\t\t// 整数が指数の場合\n\t\t\texponent /= scale;\n\t\t\tlet result = scale;\n\t\t\twhile (exponent > 0n) {\n\t\t\t\tif (exponent & 1n) {\n\t\t\t\t\tresult = (result * base) / scale;\n\t\t\t\t}\n\t\t\t\tbase = (base * base) / scale;\n\t\t\t\texponent >>= 1n;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t// 小数が指数の場合\n\t\tconst config = this.config;\n\t\tconst maxSteps = config.lnMaxSteps;\n\n\t\tconst lnBase = this._ln(base, precision, maxSteps);\n\t\tconst mul = (lnBase * exponent) / scale;\n\t\treturn this._exp(mul, precision, maxSteps);\n\t}\n\t/**\n\t * べき乗\n\t * @param {BigFloat} exponent - 指数\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tpow(exponent) {\n\t\tconst [valA, valB, exPrec, prec] = this._bothRescale(exponent, true);\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst result = construct._pow(valA, valB, exPrec);\n\t\treturn this._makeResult(result, prec, exPrec);\n\t}\n\t// --------------------------------------------------\n\t// 平方根・立方根・任意根\n\t// --------------------------------------------------\n\t/**\n\t * 平方根[ニュートン法] (_nthRootとは高速化のために分離)\n\t * @param {BigInt} n\n\t * @param {BigInt} precision\n\t * @returns {BigInt}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic _sqrt(n, precision) {\n\t\tif (n < 0n) throw new Error(\"Cannot compute square root of negative number\");\n\t\tif (n === 0n) return 0n;\n\n\t\tconst scale = 10n ** precision;\n\t\tconst nScaled = n * scale;\n\t\tconst TWO = 2n;\n\n\t\tlet x = nScaled;\n\n\t\tlet last;\n\t\twhile (true) {\n\t\t\tlast = x;\n\t\t\tx = (x + nScaled / x) / TWO;\n\t\t\tif (x === last) break;\n\t\t}\n\n\t\treturn x;\n\t}\n\t/**\n\t * 平方根[ニュートン法]\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tsqrt() {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst exPr = construct.config.extraPrecision;\n\t\tconst prec = this._precision;\n\t\tconst totalPr = prec + exPr;\n\t\tconst val = this.value * 10n ** exPr;\n\n\t\tconst x = construct._sqrt(val, totalPr);\n\n\t\treturn this._makeResult(x, prec, totalPr);\n\t}\n\t/**\n\t * 立方根[ニュートン法]\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tcbrt() {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst exPr = construct.config.extraPrecision;\n\t\tconst prec = this._precision;\n\t\tconst totalPr = prec + exPr;\n\t\tconst val = this.value * 10n ** exPr;\n\n\t\tconst x = construct._nthRoot(val, 3n, totalPr);\n\n\t\treturn this._makeResult(x, prec, totalPr);\n\t}\n\t/**\n\t * n乗根[ニュートン法]\n\t * @param {BigInt} v\n\t * @param {BigInt} n\n\t * @param {BigInt} precision\n\t * @returns {BigInt}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic _nthRoot(v, n, precision) {\n\t\tif (n <= 0n) {\n\t\t\tthrow new Error(\"n must be a positive integer\");\n\t\t}\n\t\tif (v < 0n) {\n\t\t\tif (n % 2n === 0n) {\n\t\t\t\tthrow new Error(\"Even root of negative number is not real\");\n\t\t\t}\n\t\t\treturn -this._nthRoot(-v, n, precision);\n\t\t}\n\t\tconst scale = 10n ** precision;\n\n\t\t// 初期値 x = 1.0 (scaled)\n\t\tlet x = scale;\n\n\t\twhile (true) {\n\t\t\t// x_{k+1} = ((n - 1) * x_k + target / x_k^{n-1}) / n\n\t\t\t// BigIntでべき乗計算\n\t\t\tlet xPow = x;\n\t\t\tif (n === 1n) {\n\t\t\t\txPow = scale; // n=1は例外処理\n\t\t\t} else {\n\t\t\t\tfor (let j = 1n; j < n - 1n; j++) {\n\t\t\t\t\txPow = (xPow * x) / scale;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst numerator = (n - 1n) * x + (v * scale) / xPow;\n\t\t\tconst xNext = numerator / n;\n\n\t\t\tif (xNext === x) break; // 収束判定\n\t\t\tx = xNext;\n\t\t}\n\t\treturn x;\n\t}\n\t/**\n\t * n乗根[ニュートン法]\n\t * @param {BigInt} n\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tnthRoot(n) {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst exPr = construct.config.extraPrecision;\n\t\tconst prec = this._precision;\n\t\tconst totalPr = prec + exPr;\n\t\tconst val = this.value * 10n ** exPr;\n\n\t\tconst x = construct._nthRoot(val, BigInt(n), totalPr);\n\n\t\treturn this._makeResult(x, prec, totalPr);\n\t}\n\t// --------------------------------------------------\n\t// スケーリング\n\t// --------------------------------------------------\n\t/**\n\t * precisionを最小限まで縮める\n\t * @returns {this}\n\t */\n\tscale() {\n\t\tlet val = this.value;\n\t\tlet scale = this._precision;\n\n\t\tconst ZERO = 0n;\n\t\tconst TEN = 10n;\n\n\t\twhile (scale > ZERO && val % TEN === ZERO) {\n\t\t\tval /= TEN;\n\t\t\tscale--;\n\t\t}\n\t\treturn this._makeResult(val, scale);\n\t}\n\t// ====================================================================================================\n\t// * 三角関数\n\t// ====================================================================================================\n\t// --------------------------------------------------\n\t// 基本三角関数\n\t// --------------------------------------------------\n\t/**\n\t * 正弦[Maclaurin展開]\n\t * @param {BigInt} x\n\t * @param {BigInt} precision\n\t * @param {BigInt} maxSteps\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _sin(x, precision, maxSteps) {\n\t\tconst scale = 10n ** precision;\n\n\t\tconst pi = this._pi(precision);\n\t\tconst twoPi = 2n * pi;\n\t\tconst halfPi = pi / 2n;\n\n\t\t// xを[0, 2π)に\n\t\tx = this._mod(x, twoPi);\n\t\t// xを[-π, π]に\n\t\tif (x > pi) x -= twoPi;\n\t\t// xを[-π/2, π/2]に\n\t\tlet sign = 1n;\n\t\tif (x > halfPi) {\n\t\t\tx = pi - x;\n\t\t\tsign = 1n;\n\t\t} else if (x < -halfPi) {\n\t\t\tx = -pi - x;\n\t\t\tsign = -1n;\n\t\t}\n\n\t\tlet term = x; // x^1 / 1!\n\t\tlet result = term;\n\t\tlet x2 = (x * x) / scale;\n\t\tlet sgn = -1n;\n\n\t\tfor (let n = 1n; n <= maxSteps; n++) {\n\t\t\tconst denom = 2n * n;\n\n\t\t\tterm = (term * x2) / scale;\n\t\t\tterm = term / (denom * (denom + 1n));\n\n\t\t\tif (term === 0n) break;\n\t\t\tresult += sgn * term;\n\t\t\tsgn *= -1n;\n\t\t}\n\t\treturn result * sign;\n\t}\n\t/**\n\t * 正弦[Maclaurin展開]\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tsin() {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst config = construct.config;\n\t\tconst maxSteps = config.trigFuncsMaxSteps;\n\t\tconst exPr = construct.config.extraPrecision;\n\t\tconst totalPr = this._precision + exPr;\n\t\tconst val = this.value * 10n ** exPr;\n\n\t\tconst result = construct._sin(val, totalPr, maxSteps);\n\t\treturn this._makeResult(result, this._precision, totalPr);\n\t}\n\t/**\n\t * 余弦\n\t * @param {BigInt} x\n\t * @param {BigInt} precision\n\t * @param {BigInt} maxSteps\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _cos(x, precision, maxSteps) {\n\t\tconst scale = 10n ** precision;\n\n\t\tlet term = scale; // x^0 / 0! = 1\n\t\tlet result = term;\n\t\tlet x2 = (x * x) / scale;\n\t\tlet sign = -1n;\n\n\t\tfor (let n = 1n, denom = 2n; n <= maxSteps; n++, denom += 2n) {\n\t\t\tterm = (term * x2) / scale;\n\t\t\tterm = term / (denom * (denom - 1n));\n\t\t\tif (term === 0n) break;\n\t\t\tresult += sign * term;\n\t\t\tsign *= -1n;\n\t\t}\n\t\treturn result;\n\t}\n\t/**\n\t * 余弦\n\t * @returns {this}\n\t */\n\tcos() {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst config = construct.config;\n\t\tconst maxSteps = config.trigFuncsMaxSteps;\n\t\tconst exPr = construct.config.extraPrecision;\n\t\tconst totalPr = this._precision + exPr;\n\t\tconst val = this.value * 10n ** exPr;\n\n\t\tconst result = construct._cos(val, totalPr, maxSteps);\n\t\treturn this._makeResult(result, this._precision, totalPr);\n\t}\n\t/**\n\t * 正接\n\t * @param {BigInt} x\n\t * @param {BigInt} precision\n\t * @param {BigInt} maxSteps\n\t * @returns {BigInt}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic _tan(x, precision, maxSteps) {\n\t\tconst cosX = this._cos(x, precision, maxSteps);\n\t\tconst EPSILON = 10n ** (precision - 4n);\n\t\tif (cosX === 0n || (cosX > -EPSILON && cosX < EPSILON)) throw new Error(\"tan(x) is undefined or numerically unstable at this point\");\n\t\tconst sinX = this._sin(x, precision, maxSteps);\n\t\tconst scale = 10n ** precision;\n\t\treturn (sinX * scale) / cosX;\n\t}\n\t/**\n\t * 正接\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\ttan() {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst config = construct.config;\n\t\tconst maxSteps = config.trigFuncsMaxSteps;\n\t\tconst exPr = construct.config.extraPrecision;\n\t\tconst totalPr = this._precision + exPr;\n\t\tconst val = this.value * 10n ** exPr;\n\n\t\tconst result = construct._tan(val, totalPr, maxSteps);\n\t\treturn this._makeResult(result, this._precision, totalPr);\n\t}\n\t// --------------------------------------------------\n\t// 逆三角関数\n\t// --------------------------------------------------\n\t/**\n\t * 逆正弦\n\t * @param {BigInt} x\n\t * @param {BigInt} precision\n\t * @param {BigInt} maxSteps\n\t * @returns {BigInt}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic _asin(x, precision, maxSteps) {\n\t\tconst scale = 10n ** precision;\n\t\tif (x > scale || x < -scale) throw new Error(\"asin input out of range [-1,1]\");\n\n\t\tconst halfPi = this._pi(precision) / 2n;\n\t\t// 初期値を x * π/2 にして必ず [-π/2, π/2] に収める\n\t\tconst initial = (x * halfPi) / scale;\n\n\t\tconst f = (theta) => this._sin(theta, precision, maxSteps) - x;\n\t\tconst df = (theta) => this._cos(theta, precision, maxSteps);\n\t\treturn this._trigFuncsNewton(f, df, initial, precision, BigInt(maxSteps));\n\t}\n\t/**\n\t * 逆正弦\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tasin() {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst config = construct.config;\n\t\tconst maxSteps = config.trigFuncsMaxSteps;\n\t\tconst exPr = construct.config.extraPrecision;\n\t\tconst totalPr = this._precision + exPr;\n\t\tconst val = this.value * 10n ** exPr;\n\n\t\tconst result = construct._asin(val, totalPr, maxSteps);\n\t\treturn this._makeResult(result, this._precision, totalPr);\n\t}\n\t/**\n\t * 逆余弦\n\t * @param {BigInt} x\n\t * @param {BigInt} precision\n\t * @param {BigInt} maxSteps\n\t * @returns {BigInt}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic _acos(x, precision, maxSteps) {\n\t\tconst halfPi = this._pi(precision) / 2n;\n\t\tconst asinX = this._asin(x, precision, maxSteps);\n\t\treturn halfPi - asinX;\n\t}\n\t/**\n\t * 逆余弦\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tacos() {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst config = construct.config;\n\t\tconst maxSteps = config.trigFuncsMaxSteps;\n\t\tconst exPr = construct.config.extraPrecision;\n\t\tconst totalPr = this._precision + exPr;\n\t\tconst val = this.value * 10n ** exPr;\n\n\t\tconst result = construct._acos(val, totalPr, maxSteps);\n\t\treturn this._makeResult(result, this._precision, totalPr);\n\t}\n\t/**\n\t * 逆正接\n\t * @param {BigInt} x\n\t * @param {BigInt} precision\n\t * @param {BigInt} maxSteps\n\t * @returns {BigInt}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic _atan(x, precision, maxSteps) {\n\t\tconst scale = 10n ** precision;\n\t\tconst absX = x < 0n ? -x : x;\n\n\t\t// |x| <= 1 → そのままニュートン法\n\t\tif (absX <= scale) {\n\t\t\tconst f = (theta) => this._tan(theta, precision, maxSteps) - x;\n\t\t\tconst df = (theta) => {\n\t\t\t\tconst cosTheta = this._cos(theta, precision, maxSteps);\n\t\t\t\tif (cosTheta === 0n) throw new Error(\"Derivative undefined\");\n\n\t\t\t\treturn (scale * scale * scale) / (cosTheta * cosTheta);\n\t\t\t};\n\t\t\treturn this._trigFuncsNewton(f, df, x, precision, BigInt(maxSteps));\n\t\t}\n\n\t\t// |x| > 1 → atan(x) = sign * (π/2 - atan(1 / |x|))\n\t\tconst sign = x < 0n ? -1n : 1n;\n\t\tconst halfPi = this._pi(precision) / 2n;\n\t\tconst invX = (scale * scale) / absX;\n\t\tconst innerAtan = this._atan(invX, precision, maxSteps);\n\t\treturn sign * (halfPi - innerAtan);\n\t}\n\t/**\n\t * 逆正接\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tatan() {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst config = construct.config;\n\t\tconst maxSteps = config.trigFuncsMaxSteps;\n\t\tconst exPr = construct.config.extraPrecision;\n\t\tconst totalPr = this._precision + exPr;\n\t\tconst val = this.value * 10n ** exPr;\n\n\t\tconst result = construct._atan(val, totalPr, maxSteps);\n\t\treturn this._makeResult(result, this._precision, totalPr);\n\t}\n\t/**\n\t * 逆正接2 (atan2(y, x))\n\t * @param {BigInt} y\n\t * @param {BigInt} x\n\t * @param {BigInt} precision\n\t * @param {BigInt} maxSteps\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _atan2(y, x, precision, maxSteps) {\n\t\t// x == 0\n\t\tif (x === 0n) {\n\t\t\tif (y > 0n) return this._pi(precision) / 2n;\n\t\t\tif (y < 0n) return -this._pi(precision) / 2n;\n\t\t\treturn 0n;\n\t\t}\n\n\t\tconst scale = 10n ** precision;\n\t\tconst angle = this._atan((y * scale) / x, precision, maxSteps);\n\n\t\tif (x > 0n) return angle;\n\t\tif (y >= 0n) return angle + this._pi(precision);\n\t\treturn angle - this._pi(precision);\n\t}\n\t/**\n\t * 逆正接2 (atan2(y, x))\n\t * @param {BigFloat} x\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tatan2(x) {\n\t\tconst [valA, valB, exPrec, prec] = this._bothRescale(x, true);\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst config = construct.config;\n\t\tconst maxSteps = config.trigFuncsMaxSteps;\n\t\tconst result = construct._atan2(valA, valB, exPrec, maxSteps);\n\t\treturn this._makeResult(result, prec, exPrec);\n\t}\n\t// --------------------------------------------------\n\t// 内部計算補助・その他\n\t// --------------------------------------------------\n\t/**\n\t * 逆正接[Machine's formula]\n\t * @param {BigInt} invX\n\t * @param {BigInt} precision\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _atanMachine(invX, precision) {\n\t\tconst scale = 10n ** precision;\n\n\t\tconst x = scale / invX;\n\t\tconst x2 = (x * x) / scale;\n\t\tlet term = x;\n\t\tlet sum = term;\n\t\tlet sign = -1n;\n\n\t\tlet lastTerm = 0n;\n\t\tfor (let n = 3n; term !== lastTerm; n += 2n) {\n\t\t\tterm = (term * x2) / scale;\n\t\t\tlastTerm = term;\n\t\t\tsum += (sign * term) / n;\n\t\t\tsign *= -1n;\n\t\t}\n\t\treturn sum;\n\t}\n\t/**\n\t * Newton法\n\t * @param {(x:BigInt) => BigInt} f\n\t * @param {(x:BigInt) => BigInt} df\n\t * @param {BigInt} initial\n\t * @param {BigInt} precision\n\t * @param {number} maxSteps\n\t * @returns {BigInt}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic _trigFuncsNewton(f, df, initial, precision, maxSteps = 50) {\n\t\tconst scale = 10n ** precision;\n\t\tlet x = initial;\n\n\t\tfor (let i = 0; i < maxSteps; i++) {\n\t\t\tconst fx = f(x);\n\t\t\tif (fx === 0n) break;\n\t\t\tconst dfx = df(x);\n\t\t\tif (dfx === 0n) throw new Error(\"Derivative zero during Newton iteration\");\n\n\t\t\t// dx = fx / dfx （整数で割り算）\n\t\t\t// dx は分母あるから SCALEかけて割る\n\t\t\tconst dx = (fx * scale) / dfx;\n\t\t\tx = x - dx;\n\n\t\t\tif (dx === 0n) break; // 収束判定\n\t\t}\n\t\treturn x;\n\t}\n\t/**\n\t * sin(π * z)\n\t * @param {BigInt} z\n\t * @param {BigInt} precision\n\t * @returns {BigInt}\n\t */\n\tstatic _sinPi(z, precision) {\n\t\t// π * z / scale のsinを計算\n\t\t// 既存の_sinと_pi使う想定\n\t\tconst pi = this._pi(precision);\n\t\tconst x = (pi * z) / 10n ** precision;\n\t\treturn this._sin(x, precision);\n\t}\n\t// ====================================================================================================\n\t// * 対数・指数・自然定数\n\t// ====================================================================================================\n\t// --------------------------------------------------\n\t// 指数関数\n\t// --------------------------------------------------\n\t/**\n\t * 指数関数のTaylor展開\n\t * @param {BigInt} x\n\t * @param {BigInt} precision\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _exp(x, precision) {\n\t\tconst scale = 10n ** precision;\n\t\tlet sum = scale;\n\t\tlet term = scale;\n\t\tlet n = 1n;\n\n\t\twhile (true) {\n\t\t\tterm = (term * x) / (scale * n); // term *= x / n\n\t\t\tif (term === 0n) break;\n\t\t\tsum += term;\n\t\t\tn++;\n\t\t}\n\t\treturn sum;\n\t}\n\t/**\n\t * 指数関数\n\t * @param {BigInt} [precision=20n] - 精度\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\texp() {\n\t\tconst construct = this.constructor;\n\t\tconst exPr = construct.config.extraPrecision;\n\t\tconst totalPr = this._precision + exPr;\n\t\tconst val = this.value * 10n ** exPr;\n\t\tconst expInt = construct._exp(val, totalPr);\n\t\treturn this._makeResult(expInt, this._precision, totalPr);\n\t}\n\t/**\n\t * 2の指数関数\n\t * @param {BigInt} value\n\t * @param {BigInt} precision\n\t * @param {number} maxSteps\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _exp2(value, precision, maxSteps) {\n\t\tconst LN2 = this._ln2(precision, maxSteps);\n\t\tconst scale = 10n ** precision;\n\n\t\treturn this._exp((LN2 * value) / scale, precision);\n\t}\n\t/**\n\t * 2の指数関数\n\t * @returns {this}\n\t */\n\texp2() {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst config = construct.config;\n\t\tconst maxSteps = config.lnMaxSteps;\n\t\tconst exPr = config.extraPrecision;\n\t\tconst totalPr = this._precision + exPr;\n\t\tconst val = this.value * 10n ** exPr;\n\t\tconst exp2Int = construct._exp2(val, totalPr, maxSteps);\n\t\treturn this._makeResult(exp2Int, this._precision, totalPr);\n\t}\n\t/**\n\t * 指数関数 exp(x) - 1\n\t * @param {BigInt} value\n\t * @param {BigInt} precision\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _expm1(value, precision) {\n\t\tconst scale = 10n ** precision;\n\n\t\t// |x| が小さい場合はテイラー級数で近似\n\t\tconst absValue = value < 0n ? -value : value;\n\t\tconst threshold = scale / 10n; // 適当な小さい値の閾値\n\n\t\tif (absValue < threshold) {\n\t\t\t// テイラー展開で計算 (x + x^2/2 + x^3/6 + ... 最大 maxSteps 項)\n\t\t\tlet term = value; // 初項 x\n\t\t\tlet result = term;\n\t\t\tlet factorial = 1n;\n\t\t\tlet addend = 1n;\n\t\t\tfor (let n = 2n; addend !== 0n; n++) {\n\t\t\t\tfactorial *= n;\n\t\t\t\tterm = (term * value) / scale; // x^n\n\t\t\t\taddend = term / factorial;\n\t\t\t\tresult += addend;\n\t\t\t}\n\t\t\treturn result;\n\t\t} else {\n\t\t\t// 大きい値は exp(x) - 1 = exp(x) - 1 を計算（_expは別途実装想定）\n\t\t\treturn this._exp(value, precision) - scale;\n\t\t}\n\t}\n\t/**\n\t * 指数関数 exp(x) - 1\n\t * @returns {this}\n\t */\n\texpm1() {\n\t\tconst construct = this.constructor;\n\t\tconst exPr = construct.config.extraPrecision;\n\t\tconst totalPr = this._precision + exPr;\n\t\tconst val = this.value * 10n ** exPr;\n\t\tconst expInt = construct._expm1(val, totalPr);\n\t\treturn this._makeResult(expInt, this._precision, totalPr);\n\t}\n\t// --------------------------------------------------\n\t// 対数関数\n\t// --------------------------------------------------\n\t/**\n\t * 自然対数[Atanh法]\n\t * @param {BigInt} value\n\t * @param {BigInt} precision\n\t * @param {BigInt} maxSteps\n\t * @returns {BigInt}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic _ln(value, precision, maxSteps) {\n\t\tif (value <= 0n) throw new Error(\"ln(x) is undefined for x <= 0\");\n\n\t\tconst scale = 10n ** precision;\n\n\t\tlet x = value;\n\t\tlet k = 0n;\n\t\twhile (x > 10n * scale) {\n\t\t\tx /= 10n;\n\t\t\tk += 1n;\n\t\t}\n\t\twhile (x < scale) {\n\t\t\tx *= 10n;\n\t\t\tk -= 1n;\n\t\t}\n\n\t\tconst z = ((x - scale) * scale) / (x + scale);\n\t\tlet zSquared = (z * z) / scale;\n\n\t\tlet term = z;\n\t\tlet result = term;\n\t\tfor (let n = 1n; n < maxSteps; n++) {\n\t\t\tterm = (term * zSquared) / scale; // 次の奇数乗 z^(2n+1)\n\t\t\tconst denom = 2n * n + 1n;\n\t\t\tconst addend = term / denom;\n\t\t\tif (addend === 0n) break;\n\t\t\tresult += addend;\n\t\t}\n\n\t\tconst LN10 = this._ln10(precision, maxSteps);\n\t\treturn 2n * result + k * LN10;\n\t}\n\t/**\n\t * 自然対数 ln(x)\n\t * @returns {BigFloat}\n\t */\n\tln() {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst config = construct.config;\n\t\tconst maxSteps = config.lnMaxSteps;\n\t\tconst exPr = config.extraPrecision;\n\n\t\tconst totalPr = this._precision + exPr;\n\t\tconst val = this.value * 10n ** exPr;\n\n\t\tconst raw = construct._ln(val, totalPr, maxSteps);\n\t\treturn this._makeResult(raw, this._precision, totalPr);\n\t}\n\t/**\n\t * 対数\n\t * @param {BigInt} baseValue\n\t * @param {BigInt} precision\n\t * @param {BigInt} maxSteps\n\t * @returns {BigInt}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic _log(value, baseValue, precision, maxSteps) {\n\t\tif (value === 1n) return 0n;\n\t\tconst lnB = this._ln(baseValue, precision, maxSteps);\n\t\tif (lnB === 0n) throw new Error(\"log base cannot be 1 or 0\");\n\t\tconst lnX = this._ln(value, precision, maxSteps);\n\n\t\t// log_b(x) = ln(x) / ln(b)\n\t\tconst SCALE = 10n ** precision;\n\t\tconst result = (lnX * SCALE) / lnB;\n\n\t\treturn result;\n\t}\n\t/**\n\t * 対数\n\t * @param {BigFloat} base\n\t * @returns {BigFloat}\n\t */\n\tlog(base) {\n\t\tconst [valA, valB, exPrec, prec] = this._bothRescale(base, true);\n\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst maxSteps = construct.config.lnMaxSteps;\n\t\tconst raw = construct._log(valA, valB, exPrec, maxSteps);\n\t\treturn this._makeResult(raw, prec, exPrec);\n\t}\n\t/**\n\t * 底2の対数\n\t * @param {BigInt} value\n\t * @param {BigInt} precision\n\t * @param {BigInt} maxSteps\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _log2(value, precision, maxSteps) {\n\t\tconst scale = 10n ** precision;\n\t\tconst baseValue = 2n * scale;\n\t\treturn this._log(value, baseValue, precision, maxSteps);\n\t}\n\t/**\n\t * 底2の対数\n\t * @returns {BigFloat}\n\t */\n\tlog2() {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst maxSteps = construct.config.lnMaxSteps;\n\t\tconst exPrec = construct.config.extraPrecision;\n\t\tconst totalPr = this._precision + exPrec;\n\t\tconst val = this.value * 10n ** exPrec;\n\t\tconst raw = construct._log2(val, totalPr, maxSteps);\n\t\treturn this._makeResult(raw, this._precision, totalPr);\n\t}\n\t/**\n\t * 底10の対数\n\t * @param {BigInt} value\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _log10(value, precision, maxSteps) {\n\t\tconst baseValue = 10n * 10n ** precision;\n\t\treturn this._log(value, baseValue, precision, maxSteps);\n\t}\n\t/**\n\t * 底10の対数\n\t * @returns {BigFloat}\n\t */\n\tlog10() {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst maxSteps = construct.config.lnMaxSteps;\n\t\tconst exPrec = construct.config.extraPrecision;\n\t\tconst totalPr = this._precision + exPrec;\n\t\tconst val = this.value * 10n ** exPrec;\n\t\tconst raw = construct._log10(val, totalPr, maxSteps);\n\t\treturn this._makeResult(raw, this._precision, totalPr);\n\t}\n\t/**\n\t * 対数 log(1 + x)\n\t * @returns {BigFloat}\n\t * @static\n\t */\n\tstatic _log1p(value, precision, maxSteps) {\n\t\t// 1 + x を計算\n\t\tconst scale = 10n ** precision;\n\t\tconst onePlusX = scale + value;\n\n\t\t// _logを利用して log(1+x) を計算\n\t\treturn this._log(onePlusX, scale, precision, maxSteps);\n\t}\n\t/**\n\t * 対数 log(1 + x)\n\t * @returns {BigFloat}\n\t */\n\tlog1p() {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst maxSteps = construct.config.lnMaxSteps;\n\t\tconst exPrec = construct.config.extraPrecision;\n\t\tconst totalPr = this._precision + exPrec;\n\t\tconst val = this.value * 10n ** exPrec;\n\t\tconst raw = construct._log1p(val, totalPr, maxSteps);\n\t\treturn this._makeResult(raw, this._precision, totalPr);\n\t}\n\t// --------------------------------------------------\n\t// 定数（対数関連）\n\t// --------------------------------------------------\n\t/**\n\t * 自然対数 ln(10) (簡易計算用)\n\t * @param {BigInt} precision - 精度\n\t * @param {BigInt} [maxSteps=10000n] - 最大反復回数\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _ln10(precision, maxSteps = 10000n) {\n\t\tconst scale = 10n ** precision;\n\t\tconst x = 10n * scale; // ln(10) の対象\n\n\t\t// z = (x - ONE) / (x + ONE)\n\t\tconst z = ((x - scale) * scale) / (x + scale);\n\t\tconst zSquared = (z * z) / scale;\n\n\t\tlet term = z;\n\t\tlet result = term;\n\n\t\tfor (let n = 1n; n < maxSteps; n++) {\n\t\t\tterm = (term * zSquared) / scale;\n\t\t\tconst denom = 2n * n + 1n;\n\t\t\tconst addend = term / denom;\n\t\t\tif (addend === 0n) break;\n\t\t\tresult += addend;\n\t\t}\n\n\t\treturn 2n * result;\n\t}\n\t/**\n\t * 自然対数 ln(2)\n\t * @param {BigInt} precision\n\t * @param {BigInt} maxSteps\n\t * @returns {BigInt}\n\t */\n\tstatic _ln2(precision, maxSteps) {\n\t\tconst scale = 10n ** precision;\n\t\treturn this._ln(2n * scale, precision, maxSteps);\n\t}\n\t// --------------------------------------------------\n\t// 自然対数の底・定数\n\t// --------------------------------------------------\n\t/**\n\t * ネイピア数\n\t * @param {BigInt} precision\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _e(precision) {\n\t\tif (this._getCheckCache(\"e\", precision)) {\n\t\t\treturn this._getCache(\"e\", precision);\n\t\t}\n\n\t\tconst scale = 10n ** precision;\n\t\tconst eInt = this._exp(scale, precision);\n\n\t\tthis._updateCache(\"e\", eInt, precision);\n\t\treturn eInt;\n\t}\n\t/**\n\t * ネイピア数\n\t * @param {BigInt} [precision=20n] - 精度\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic e(precision = 20n) {\n\t\tprecision = BigInt(precision);\n\t\tthis._checkPrecision(precision);\n\n\t\tconst exPr = this.config.extraPrecision;\n\t\tconst totalPr = precision + exPr;\n\n\t\tconst eInt = this._e(totalPr);\n\t\treturn this._makeResult(eInt, precision, totalPr);\n\t}\n\t// ====================================================================================================\n\t// * 定数（π, τ）\n\t// ====================================================================================================\n\t// --------------------------------------------------\n\t// π関連の計算手法\n\t// --------------------------------------------------\n\t/**\n\t * 円周率[Gregory-Leibniz法] (超高速・超低収束)\n\t * @param {BigInt} [precision=20n] - 精度\n\t * @param {BigInt} [mulPrecision=100n] - 計算精度の倍率\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _piLeibniz(precision = 20n, mulPrecision = 100n) {\n\t\tconst scale = 10n ** precision;\n\t\tconst iterations = precision * mulPrecision;\n\t\tlet sum = 0n;\n\n\t\tconst scale_4 = scale * 4n;\n\t\tconst ZERO = 0n;\n\t\tconst ONE = 1n;\n\t\tconst TWO = 2n;\n\n\t\tlet lastTerm = 0n;\n\t\tfor (let i = 0n; i < iterations; i++) {\n\t\t\tconst term = scale_4 / (TWO * i + ONE);\n\t\t\tif (term === lastTerm) break;\n\t\t\tlastTerm = term;\n\t\t\tsum += i % TWO === ZERO ? term : -term;\n\t\t}\n\n\t\treturn sum;\n\t}\n\t/**\n\t * 円周率[ニュートン法] (高速・低収束)\n\t * @param {BigInt} [precision=20n] - 精度\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _piNewton(precision = 20n) {\n\t\tconst EXTRA = 10n;\n\t\tconst prec = precision + EXTRA;\n\n\t\tconst atan1_5 = this._atanMachine(5n, prec);\n\t\tconst atan1_239 = this._atanMachine(239n, prec);\n\n\t\tconst value = 16n * atan1_5 - 4n * atan1_239;\n\n\t\treturn value / 10n ** EXTRA;\n\t}\n\t/**\n\t * 円周率[Chudnovsky法] (低速・高収束)\n\t * @param {BigInt} [precision=20n] - 精度\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _piChudnovsky(precision = 20n) {\n\t\tconst scale = 10n ** precision;\n\t\tconst digitsPerTerm = 14n;\n\t\tconst terms = precision / digitsPerTerm + 1n;\n\n\t\tconst C = 426880n * this._sqrt(10005n * scale, precision);\n\t\tlet sum = 0n;\n\n\t\tfunction bigPower(base, exp) {\n\t\t\tlet res = 1n;\n\t\t\tfor (let i = 0n; i < exp; i++) res *= base;\n\t\t\treturn res;\n\t\t}\n\n\t\tfor (let k = 0n; k < terms; k++) {\n\t\t\tconst numerator = this._factorial(6n * k) * (545140134n * k + 13591409n) * (k % 2n === 0n ? 1n : -1n);\n\t\t\tconst denominator = this._factorial(3n * k) * bigPower(this._factorial(k), 3n) * bigPower(640320n, 3n * k);\n\n\t\t\tsum += (scale * numerator) / denominator;\n\t\t}\n\n\t\tif (sum === 0n) {\n\t\t\tlogging.error(\"Chudnovsky法の計算に失敗しました\");\n\t\t\treturn 0n;\n\t\t}\n\n\t\t// C / sum = π⁻¹ → π = 1/π⁻¹\n\t\treturn (C * scale) / sum;\n\t}\n\t// --------------------------------------------------\n\t// π定数\n\t// --------------------------------------------------\n\t/**\n\t * 円周率\n\t * @param {BigInt} [precision=20n] - 精度\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _pi(precision) {\n\t\tconst piAlgorithm = this.config.piAlgorithm;\n\t\tif (this._getCheckCache(\"pi\", precision, piAlgorithm)) {\n\t\t\treturn this._getCache(\"pi\", precision);\n\t\t}\n\n\t\tlet piRet;\n\t\tswitch (piAlgorithm) {\n\t\t\tcase BigFloatConfig.PI_CHUDNOVSKY: // 3\n\t\t\t\tpiRet = this._piChudnovsky(precision);\n\t\t\t\tbreak;\n\t\t\tcase BigFloatConfig.PI_NEWTON: // 2\n\t\t\t\tpiRet = this._piNewton(precision);\n\t\t\t\tbreak;\n\t\t\tcase BigFloatConfig.PI_LEIBNIZ: // 1\n\t\t\t\tpiRet = this._piLeibniz(precision);\n\t\t\t\tbreak;\n\t\t\tcase BigFloatConfig.PI_MATH_DEFAULT: // 0\n\t\t\tdefault:\n\t\t\t\tthis._checkPrecision(precision);\n\t\t\t\treturn new this(`${Math.PI}`, precision).value;\n\t\t}\n\n\t\t// キャッシュ\n\t\tthis._updateCache(\"pi\", piRet, precision, piAlgorithm);\n\t\treturn piRet;\n\t}\n\t/**\n\t * 円周率\n\t * @param {BigInt} [precision=20n] - 精度\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic pi(precision = 20n) {\n\t\tprecision = BigInt(precision);\n\t\tthis._checkPrecision(precision);\n\n\t\tconst piRet = new this();\n\t\tpiRet.value = this._pi(precision);\n\t\tpiRet._precision = precision;\n\t\treturn piRet;\n\t}\n\t// --------------------------------------------------\n\t// τ定数\n\t// --------------------------------------------------\n\t/**\n\t * 円周率の2倍\n\t * @param {BigInt} [precision=20n] - 精度\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _tau(precision) {\n\t\tconst pi = this._pi(precision);\n\t\treturn pi * 2n;\n\t}\n\t/**\n\t * 円周率の2倍\n\t * @param {BigInt} [precision=20n] - 精度\n\t * @returns {BigFloat}\n\t * @static\n\t */\n\tstatic tau(precision = 20n) {\n\t\tprecision = BigInt(precision);\n\t\tthis._checkPrecision(precision);\n\n\t\tconst tauRet = new this();\n\t\ttauRet.value = this._tau(precision);\n\t\ttauRet._precision = precision;\n\t\treturn tauRet;\n\t}\n\t// ====================================================================================================\n\t// * 統計関数\n\t// ====================================================================================================\n\t// --------------------------------------------------\n\t// 集計\n\t// --------------------------------------------------\n\t/**\n\t * 最大値を返す\n\t * @param {...(BigFloat | number | string | BigInt) | Array<BigFloat | number | string | BigInt>} args\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic max(...args) {\n\t\tconst arr = this._normalizeArgs(args);\n\t\tif (arr.length === 0) throw new Error(\"No arguments provided\");\n\n\t\tconst [scaled, prec] = this._batchRescale(arr);\n\n\t\tlet max = scaled[0];\n\t\tfor (let i = 1; i < scaled.length; i++) {\n\t\t\tif (scaled[i] > max) max = scaled[i];\n\t\t}\n\n\t\treturn this._makeResult(max, prec);\n\t}\n\t/**\n\t * 最小値を返す\n\t * @param {...(BigFloat | number | string | BigInt) | Array<BigFloat | number | string | BigInt>} args\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic min(...args) {\n\t\tconst arr = this._normalizeArgs(args);\n\t\tif (arr.length === 0) throw new Error(\"No arguments provided\");\n\n\t\tconst [scaled, prec] = this._batchRescale(arr);\n\n\t\tlet min = scaled[0];\n\t\tfor (let i = 1; i < scaled.length; i++) {\n\t\t\tif (scaled[i] < min) min = scaled[i];\n\t\t}\n\n\t\treturn this._makeResult(min, prec);\n\t}\n\t/**\n\t * 合計値を返す\n\t * @param {...(BigFloat | number | string | BigInt) | Array<BigFloat | number | string | BigInt>} args\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic sum(...args) {\n\t\tconst arr = this._normalizeArgs(args);\n\t\tif (arr.length === 0) return new this();\n\n\t\tconst [scaled, prec] = this._batchRescale(arr);\n\t\tconst totalVal = scaled.reduce((acc, cur) => acc + cur, 0n);\n\t\treturn this._makeResult(totalVal, prec);\n\t}\n\t/**\n\t * 積を返す (丸め誤差に注意)\n\t * @param {...(BigFloat | number | string | BigInt) | Array<BigFloat | number | string | BigInt>} args\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic product(...args) {\n\t\tconst arr = this._normalizeArgs(args);\n\t\tif (arr.length === 0) return new this(\"1\");\n\n\t\tconst [scaled, exPrec, prec] = this._batchRescale(arr, true);\n\t\t// 積をBigIntで計算\n\t\tlet prod = new this(1, exPrec);\n\t\tfor (const item of scaled) {\n\t\t\tconst a = new this();\n\t\t\ta.value = item;\n\t\t\ta._precision = exPrec;\n\t\t\tprod = prod.mul(a);\n\t\t}\n\t\treturn this._makeResult(prod.value, prec, exPrec);\n\t}\n\t// --------------------------------------------------\n\t// 平均・中央値\n\t// --------------------------------------------------\n\t/**\n\t * 平均値を返す\n\t * @param {...(BigFloat | number | string | BigInt) | Array<BigFloat | number | string | BigInt>} args\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic average(...args) {\n\t\tconst arr = this._normalizeArgs(args);\n\t\tif (arr.length === 0) return new this();\n\n\t\tconst total = this.sum(arr);\n\t\treturn total.div(new this(arr.length));\n\t}\n\t/**\n\t * 中央値を返す\n\t * @param {...(BigFloat | number | string | BigInt) | Array<BigFloat | number | string | BigInt>} args\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic median(...args) {\n\t\tconst arr = this._normalizeArgs(args);\n\t\tif (arr.length === 0) throw new Error(\"No arguments provided\");\n\n\t\tconst [scaled, prec] = this._batchRescale(arr);\n\t\t// valでソート\n\t\tconst sorted = scaled.sort();\n\t\tconst mid = Math.floor(sorted.length / 2);\n\n\t\tif (sorted.length % 2 === 1) {\n\t\t\treturn this._makeResult(sorted[mid], prec);\n\t\t} else {\n\t\t\t// 偶数の場合は中間2つの平均\n\t\t\tconst a = new this();\n\t\t\ta.value = sorted[mid - 1];\n\t\t\ta._precision = prec;\n\t\t\tconst b = new this();\n\t\t\tb.value = sorted[mid];\n\t\t\tb._precision = prec;\n\t\t\treturn a.add(b).div(2);\n\t\t}\n\t}\n\t// --------------------------------------------------\n\t// 分散・標準偏差\n\t// --------------------------------------------------\n\t/**\n\t * 分散を返す\n\t * @param {...(BigFloat | number | string | BigInt) | Array<BigFloat | number | string | BigInt>} args\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic variance(...args) {\n\t\tconst arr = this._normalizeArgs(args);\n\t\tif (arr.length === 0) throw new Error(\"No arguments provided\");\n\t\tif (arr.length === 1) return new this(\"0\");\n\n\t\tconst [scaled, exPrec, prec] = this._batchRescale(arr, true);\n\t\tconst n = new this(arr.length, exPrec);\n\n\t\t// 平均値計算\n\t\tconst total = this.sum(arr);\n\t\tconst meanVal = total.div(n).changePrecision(exPrec);\n\n\t\t// 分散 = Σ(x_i - mean)^2 / n\n\t\tlet sumSquares = 0n;\n\t\tfor (const item of scaled) {\n\t\t\tconst a = new this();\n\t\t\ta.value = item;\n\t\t\ta._precision = exPrec;\n\t\t\tconst diff = a.sub(meanVal);\n\t\t\tsumSquares += diff.mul(diff).value;\n\t\t}\n\n\t\tconst sumS = new this();\n\t\tsumS.value = sumSquares;\n\t\tsumS._precision = exPrec;\n\n\t\t// 分散は元の精度に合わせて返す\n\t\treturn this._makeResult(sumS.div(n).value, prec, exPrec);\n\t}\n\t/**\n\t * 標準偏差を返す\n\t * @param {...(BigFloat | number | string | BigInt) | Array<BigFloat | number | string | BigInt>} args\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic stddev(...args) {\n\t\tconst variance = this.variance(args);\n\t\treturn variance.sqrt();\n\t}\n\t// ====================================================================================================\n\t// * ランダム・乱数生成\n\t// ====================================================================================================\n\t/**\n\t * bigintの乱数を生成する\n\t * @param {BigInt} precision\n\t * @returns {BigInt}\n\t */\n\tstatic _randomBigInt(precision) {\n\t\tconst maxSteps = this.config.lnMaxSteps;\n\t\tconst scale = 10n ** precision;\n\t\t// 0 <= r < scale になる乱数BigIntを作る\n\t\t// JSのMath.randomは53bitまでなので複数回繰り返し足し合わせる\n\t\tlet result = 0n;\n\t\tconst maxBits = this._log2(scale * scale, precision, maxSteps);\n\t\tconst rawBits = (maxBits + scale - 1n) / scale; // ← ceil相当\n\t\tconst rounds = Number((rawBits + 52n) / 53n);\n\n\t\tfor (let i = 0; i < rounds; i++) {\n\t\t\t// 53bit乱数取得\n\t\t\tconst r = BigInt(Math.floor(Math.random() * Number(2 ** 53)));\n\t\t\tresult = (result << 53n) + r;\n\t\t}\n\t\treturn result % scale;\n\t}\n\t/**\n\t * 乱数を生成する\n\t * @param {BigInt} [precision=20n] - 精度\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic random(precision = 20n) {\n\t\tprecision = BigInt(precision);\n\t\tthis._checkPrecision(precision);\n\t\tlet randBigInt = this._randomBigInt(precision);\n\t\treturn this._makeResult(randBigInt, precision);\n\t}\n\t// ====================================================================================================\n\t// * 特殊関数・積分・ガンマ関数など\n\t// ====================================================================================================\n\t// --------------------------------------------------\n\t// ガンマ関数・積分\n\t// --------------------------------------------------\n\t/**\n\t * 台形積分\n\t * @param {(k:BigInt) => BigInt} f\n\t * @param {BigInt} a - スケール済\n\t * @param {BigInt} b - スケール済\n\t * @param {BigInt} n\n\t * @param {BigInt} precision\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _integral(f, a, b, n, precision) {\n\t\tconst scale = 10n ** precision;\n\n\t\tif (n <= 0n || a === b) return 0n;\n\n\t\tconst delta = b - a;\n\n\t\tlet sum = f(a) + f(b);\n\n\t\tfor (let i = 1n; i < n; i++) {\n\t\t\tconst numerator = a * n + i * delta;\n\t\t\tconst x_i = numerator / n;\n\t\t\tconst term = 2n * f(x_i);\n\t\t\tif (term === 0n) break;\n\t\t\tsum += term;\n\t\t}\n\n\t\tconst denominator = scale * n * 2n;\n\t\tif (denominator === 0n) return 0n;\n\t\treturn (delta * sum) / denominator;\n\t}\n\n\t/**\n\t * ベルヌーイ数 [阿部-Zeta関数/Akiyama-Tanigawaアルゴリズム]\n\t * @param {number} n - ベルヌーイ数のインデックス (偶数のみ有効)\n\t * @param {BigInt} precision - 精度\n\t * @returns {BigInt[]} 0からnまでのベルヌーイ数の配列\n\t * @static\n\t */\n\tstatic _bernoulliNumbers(n, precision) {\n\t\tconst A = new Array(n + 1).fill(0n);\n\t\tconst B = new Array(n + 1).fill(0n);\n\n\t\tconst scale = 10n ** precision;\n\n\t\tfor (let m = 0; m <= n; m++) {\n\t\t\tA[m] = scale / BigInt(m + 1);\n\t\t\tfor (let j = m; j >= 1; j--) {\n\t\t\t\tconst term = A[j - 1] - A[j];\n\t\t\t\tA[j - 1] = BigInt(j) * term;\n\t\t\t}\n\t\t\tB[m] = A[0];\n\t\t}\n\n\t\tif (n >= 1) {\n\t\t\tB[1] = -scale / 2n;\n\t\t}\n\t\treturn B;\n\t}\n\n\t/**\n\t * Lanczos-Spouge近似のパラメータ a を決定\n\t * @param {BigInt} precision - 精度\n\t * @returns {number} 非スケール\n\t * @static\n\t */\n\tstatic _getSpougeParamA(precision) {\n\t\tconst config = this.config;\n\t\tconst maxSteps = config.lnMaxSteps;\n\t\tconst log10_2pi = this._log10(2n * this._pi(precision), precision, maxSteps);\n\n\t\tconst b = new this();\n\t\tb.value = precision * log10_2pi;\n\t\tb._precision = precision;\n\n\t\t// 予備で+10\n\t\tconst calculated_a = Math.ceil(b.toNumber() + 10);\n\t\t// a > 2 が必要。\n\t\treturn Math.max(3, calculated_a);\n\t}\n\n\t/**\n\t * Lanczos-Spouge近似の係数を動的に計算\n\t * @param {number} numCoeffs - 係数の数\n\t * @param {number} a - 非スケール\n\t * @param {BigInt} precision - 精度\n\t * @returns {BigInt[]} 係数\n\t * @static\n\t */\n\tstatic _lanczosSpougeCoefficients(numCoeffs, a, precision) {\n\t\tconst scale = 10n ** precision;\n\t\tconst half_scale = scale / 2n;\n\n\t\tconst aBig = BigInt(a) * scale;\n\n\t\tconst coeffs = [scale];\n\n\t\tlet sign = 1n;\n\t\tfor (let k = 1; k < numCoeffs; k++) {\n\t\t\tconst k_minus_1_fact = this._factorial(BigInt(k - 1));\n\n\t\t\tconst kBig = BigInt(k) * scale;\n\n\t\t\t// (-k + a)\n\t\t\tconst term_base = aBig - kBig;\n\t\t\t// k - 1/2\n\t\t\tconst term1_exp = kBig - half_scale;\n\t\t\t// (-k + a)^(k - 1/2)\n\t\t\tconst term1 = this._pow(term_base, term1_exp, precision);\n\n\t\t\t// e^(-k + a)\n\t\t\tconst term2 = this._exp(term_base, precision);\n\n\t\t\t//let c_k = (((((sign * scale) / k_minus_1_fact) * term1) / scale) * term2) / scale;\n\t\t\tlet c_k = (sign * term1 * term2) / (k_minus_1_fact * scale);\n\n\t\t\tcoeffs.push(c_k);\n\n\t\t\tsign *= -1n;\n\t\t}\n\t\treturn coeffs;\n\t}\n\n\t/**\n\t * gamma関数[Lanczos-Spouge近似]\n\t * @param {BigInt} z - スケール済\n\t * @param {BigInt} precision - 精度\n\t * @returns {BigInt}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic _gammaLanczos(z, precision) {\n\t\tconst scale = 10n ** precision;\n\t\tif (z <= 0n && z % scale === 0n) {\n\t\t\tthrow new Error(\"z must not be a minus integer\");\n\t\t}\n\t\tconst scale2 = scale * scale;\n\t\tconst half_scale = scale / 2n;\n\n\t\tif (z < half_scale) {\n\t\t\tconst config = this.config;\n\t\t\tconst maxSteps = config.trigFuncsMaxSteps;\n\t\t\t// 反射公式\n\t\t\tconst pi = this._pi(precision);\n\t\t\tconst oneMinusZ = scale - z;\n\t\t\tconst gammaOneMinusZ = this._gammaLanczos(oneMinusZ, precision);\n\t\t\tconst pi_z = (pi * z) / scale;\n\t\t\tconst sin_pi_z = this._sin(pi_z, precision, maxSteps);\n\t\t\tconst denominator = sin_pi_z * gammaOneMinusZ; // scale^2\n\t\t\tif (denominator === 0n) {\n\t\t\t\tthrow new Error(\"division by zero\");\n\t\t\t}\n\t\t\treturn (pi * scale2) / denominator;\n\t\t}\n\n\t\tconst a = this._getSpougeParamA(precision);\n\t\tconst numCoeffs = Math.trunc(a);\n\t\tconst coeffs = this._lanczosSpougeCoefficients(numCoeffs, a, precision);\n\n\t\tconst z_minus_1 = z - scale;\n\t\tlet series = coeffs[0];\n\t\tfor (let k = 1; k < numCoeffs; k++) {\n\t\t\tconst term = (coeffs[k] * scale) / (z_minus_1 + BigInt(k) * scale);\n\t\t\tseries += term;\n\t\t}\n\n\t\tconst t = z_minus_1 + BigInt(a) * scale;\n\t\tconst exponent = z - half_scale;\n\t\tconst t_pow_exp = this._pow(t, exponent, precision);\n\t\tconst exp_minus_t = this._exp(-t, precision);\n\n\t\treturn (t_pow_exp * exp_minus_t * series) / scale2;\n\t}\n\n\t/**\n\t * ガンマ関数[Lanczos-Spouge近似]\n\t * @returns {BigFloat}\n\t */\n\tgamma() {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst exPrec = construct.config.extraPrecision;\n\t\tconst totalPr = this._precision + exPrec;\n\t\tconst val = this.value * 10n ** exPrec;\n\t\tconst raw = construct._gammaLanczos(val, totalPr);\n\t\treturn this._makeResult(raw, this._precision, totalPr);\n\t}\n\t// --------------------------------------------------\n\t// 階乗・二項係数\n\t// --------------------------------------------------\n\t/**\n\t * 階乗を計算する (整数のみ)\n\t * @param {BigInt} n - スケールなし\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _factorial(n) {\n\t\tlet f = 1n;\n\t\tfor (let i = 2n; i <= n; i++) f *= i;\n\t\treturn f;\n\t}\n\t/**\n\t * 階乗を計算する (小数対応)\n\t * @param {BigInt} n - スケールあり\n\t * @param {BigInt} precision\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _factorialGamma(n, precision) {\n\t\tconst scale = 10n ** precision;\n\t\treturn this._gammaLanczos(n + scale, precision);\n\t}\n\t/**\n\t * 階乗を計算する (小数計算の場合の精度に注意)\n\t * @returns {BigFloat}\n\t */\n\tfactorial() {\n\t\t/** @type {typeof BigFloat} */\n\t\tconst construct = this.constructor;\n\t\tconst exPrec = construct.config.extraPrecision;\n\t\tconst totalPr = this._precision + exPrec;\n\t\tconst val = this.value * 10n ** exPrec;\n\t\tconst scale = 10n ** totalPr;\n\t\tlet raw;\n\t\tif (val % scale === 0n && val >= 0n) {\n\t\t\t// 整数の場合\n\t\t\traw = construct._factorial(val / scale) * scale;\n\t\t} else {\n\t\t\t// 小数の場合\n\t\t\traw = construct._factorialGamma(val, totalPr);\n\t\t}\n\t\treturn this._makeResult(raw, this._precision, totalPr);\n\t}\n\t/**\n\t * 二項係数を計算する\n\t * @param {BigInt} n\n\t * @param {BigInt} k\n\t * @returns {BigInt}\n\t * @static\n\t */\n\tstatic _binomial(n, k) {\n\t\tif (k > n) return 0n;\n\t\tif (k > n - k) k = n - k;\n\t\tlet result = 1n;\n\t\tfor (let i = 1n; i <= k; i++) {\n\t\t\tresult = (result * (n - i + 1n)) / i;\n\t\t}\n\t\treturn result;\n\t}\n\t// ====================================================================================================\n\t// * キャッシュ管理\n\t// ====================================================================================================\n\t/**\n\t * キャッシュを取得すべきか判定\n\t * @param {String} key\n\t * @param {BigInt} precision\n\t * @param {Number} [priority=0]\n\t * @returns {Boolean}\n\t * @static\n\t */\n\tstatic _getCheckCache(key, precision, priority = 0) {\n\t\tconst cachedData = this._cached[key];\n\t\treturn cachedData && cachedData.precision >= precision && cachedData.priority >= priority;\n\t}\n\t/**\n\t * キャッシュを取得する\n\t * @param {String} name\n\t * @param {BigInt} precision\n\t * @returns {BigInt}\n\t * @throws {Error}\n\t * @static\n\t */\n\tstatic _getCache(key, precision) {\n\t\tconst cachedData = this._cached[key];\n\t\tif (cachedData) {\n\t\t\treturn this._round(cachedData.value, cachedData.precision, precision);\n\t\t}\n\t\tthrow new Error(`use _getCheckCache first`);\n\t}\n\t/**\n\t * キャッシュを更新する\n\t * @param {String} key\n\t * @param {BigInt} value\n\t * @param {BigInt} precision\n\t * @param {Number} [priority=0]\n\t * @static\n\t */\n\tstatic _updateCache(key, value, precision, priority = 0) {\n\t\tconst cachedData = this._cached[key];\n\t\tif (cachedData && cachedData.precision >= precision && cachedData.priority >= priority) {\n\t\t\treturn;\n\t\t}\n\t\tthis._cached[key] = { value, precision, priority };\n\t}\n\t// ====================================================================================================\n\t// * 定数オブジェクト\n\t// ====================================================================================================\n\t/**\n\t * -1のBigFloat\n\t * @param {BigInt} [precision=20n] 精度\n\t * @returns {BigFloat}\n\t * @static\n\t */\n\tstatic minusOne(precision = 20n) {\n\t\treturn new this(-1n, precision);\n\t}\n\t/**\n\t * 0のBigFloat\n\t * @param {BigInt} [precision=20n] 精度\n\t * @returns {BigFloat}\n\t * @static\n\t */\n\tstatic zero(precision = 20n) {\n\t\treturn new this(0n, precision);\n\t}\n\t/**\n\t * 1のBigFloat\n\t * @param {BigInt} [precision=20n] 精度\n\t * @returns {BigFloat}\n\t * @static\n\t */\n\tstatic one(precision = 20n) {\n\t\treturn new this(1n, precision);\n\t}\n}\n\n/**\n * BigFloat を作成する\n * @param {string | number | BigInt | BigFloat} value 初期値\n * @param {number} [precision=20] 精度\n * @returns {BigFloat}\n * @throws {Error}\n */\nfunction bigFloat(value, precision) {\n\treturn new BigFloat(value, precision);\n}\n\nmodule.exports = {\n\tBigFloatConfig,\n\tBigFloat,\n\tbigFloat,\n};\n",
    "module.exports = {\n    ...require(\"./BigFloat.js\")\n};\n",
    "const IndexProxy = require(\"../libs/IndexProxy\");\nconst ListInterface = require(\"./ListInterface\");\nconst TypeChecker = require(\"../libs/TypeChecker\");\nconst StreamChecker = require(\"./stream/StreamChecker\");\nconst Stream = require(\"./stream/Stream\");\n\n/**\n * 型チェック機能のついたList\n * @template V\n * @extends {ListInterface<V>}\n * @class\n */\nclass ArrayList extends ListInterface {\n\t/**\n\t * @param {Function} ValueType\n\t * @param {Iterable<V>} [collection]\n\t */\n\tconstructor(ValueType, collection) {\n\t\tsuper(ValueType);\n\t\tthis._list = [];\n\n\t\tif (collection) this.addAll(collection);\n\n\t\tIndexProxy.defineInitData(this);\n\t}\n\n\t/**\n\t * instanceof を実装する\n\t * @param {any} obj\n\t * @returns {boolean}\n\t */\n\t[Symbol.hasInstance](obj) {\n\t\treturn IndexProxy.hasInstance(this, obj);\n\t}\n\n\t// ==================================================\n\t// 基本操作\n\t// ==================================================\n\n\t/**\n\t * 要素を追加する\n\t * @param {V} item\n\t * @returns {this}\n\t * @throws {TypeError}\n\t */\n\tadd(item) {\n\t\tthis._checkValue(item);\n\t\tthis._list.push(item);\n\t\treturn this;\n\t}\n\n\t/**\n\t * 値を一括で追加する\n\t * @param {Iterable<V>} collection\n\t * @returns {this}\n\t * @throws {TypeError}\n\t */\n\taddAll(collection) {\n\t\tfor (const item of collection) {\n\t\t\tthis.add(item);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * 指定したインデックスの要素を取得する\n\t * @param {Number} index\n\t * @returns {V}\n\t */\n\tget(index) {\n\t\treturn this._list[index];\n\t}\n\n\t/**\n\t * 指定したインデックスの要素を設定する\n\t * @param {Number} index\n\t * @param {V} item\n\t * @returns {this}\n\t * @throws {TypeError}\n\t */\n\tset(index, item) {\n\t\tthis._checkValue(item);\n\t\tthis._list[index] = item;\n\t\treturn this;\n\t}\n\n\t/**\n\t * 指定したインデックスの要素を削除する\n\t * @param {Number} index\n\t * @returns {V}\n\t */\n\tremove(index) {\n\t\treturn this._list.splice(index, 1)[0];\n\t}\n\n\t/**\n\t * 要素数を返却する\n\t * @returns {Number}\n\t * @readonly\n\t */\n\tget size() {\n\t\treturn this._list.length;\n\t}\n\n\t/**\n\t * 全要素を削除する\n\t */\n\tclear() {\n\t\tthis._list.length = 0;\n\t}\n\n\t// ==================================================\n\t// 追加機能\n\t// ==================================================\n\n\t/**\n\t * 等価判定を行う\n\t * @param {this} other\n\t * @returns {boolean}\n\t */\n\tequals(other) {\n\t\tif (!(other instanceof ArrayList) || this.size !== other.size) return false;\n\n\t\tfor (let i = 0; i < this.size; i++) {\n\t\t\tif (this._list[i] !== other._list[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * EnumのIteratorを返却する\n\t * @returns {ArrayIterator<V>}\n\t */\n\tvalues() {\n\t\treturn this._list.values();\n\t}\n\n\t/**\n\t * 全てのデータを呼び出す\n\t * @param {Function} callback\n\t * @param {any} [thisArg]\n\t */\n\tforEach(callback, thisArg) {\n\t\tfor (const item of this._list) {\n\t\t\tcallback.call(thisArg, item, item, this._list);\n\t\t}\n\t}\n\n\t/**\n\t * ソートする\n\t * @param {Function} [compareFn]\n\t * @returns {this}\n\t */\n\tsort(compareFn = undefined) {\n\t\tthis._list.sort(compareFn);\n\t}\n\n\t/**\n\t * ソートしたStreamを返却する\n\t * @param {Function} [compareFn]\n\t * @returns {Generator<V>}\n\t */\n\t*sorted(compareFn = undefined) {\n\t\tyield* this.toArray().sort(compareFn);\n\t}\n\n\t/**\n\t * 指定した範囲の配列を返却する\n\t * @param {Number} from\n\t * @param {Number} to\n\t * @returns {ArrayList<V>}\n\t */\n\tsubList(from, to) {\n\t\tif (from < 0 || to > this.size || from > to) {\n\t\t\tthrow new RangeError(`subList(${from}, ${to}) は無効な範囲です`);\n\t\t}\n\t\treturn new this.constructor(this._ValueType, this._list.slice(from, to));\n\t}\n\n\t// ==================================================\n\t// Stream\n\t// ==================================================\n\n\t/**\n\t * Streamを返却する\n\t * @returns {Stream<V>}\n\t */\n\tstream() {\n\t\treturn StreamChecker.typeToStream(this._ValueType).from(this._list, this._ValueType);\n\t}\n\n\t// ==================================================\n\t// 基本操作(システム)\n\t// ==================================================\n\n\t/**\n\t * 配列に変換する\n\t * @returns {V[]}\n\t */\n\ttoArray() {\n\t\treturn this._list.slice();\n\t}\n\n\t/**\n\t * 文字列に変換する\n\t * @returns {string}\n\t */\n\ttoString() {\n\t\treturn `${this.constructor.name}<${TypeChecker.typeNames(this._ValueType)}>(size=${this.size})`;\n\t}\n\n\t/**\n\t * イテレータを返却する\n\t * @returns {Iterator<V>}\n\t */\n\t[Symbol.iterator]() {\n\t\treturn this.values();\n\t}\n}\n\n/**\n * 直接参照機能を提供する\n * @type {IndexProxy<ArrayList>}\n * @readonly\n */\nconst indProxy = new IndexProxy(ArrayList);\n\n/**\n * 配列を返却する\n * @param {Function} ValueType\n * @param {Iterable<V>} [collection]\n * @returns {ArrayList<V>}\n */\nfunction arrayList(ValueType, collection) {\n\treturn indProxy.create(ValueType, collection);\n}\n\nmodule.exports = { ArrayList, arrayList };\n",
    "const { TypeChecker } = require(\"../libs\");\r\nconst MapInterface = require(\"./MapInterface\");\r\nconst EntryStream = require(\"./stream/EntryStream\");\r\n\r\n/**\r\n * 型チェック機能のついたMap\r\n * @template K, V\r\n * @extends {MapInterface<K, V>}\r\n * @class\r\n */\r\nclass HashMap extends MapInterface {\r\n\t/**\r\n\t * @param {Function} KeyType\r\n\t * @param {Function} ValueType\r\n\t */\r\n\tconstructor(KeyType, ValueType) {\r\n\t\tsuper(KeyType, ValueType);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// 基本操作(override)\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * データを追加・更新する\r\n\t * @param {K} key\r\n\t * @param {V} value\r\n\t * @returns {this}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tset(key, value) {\r\n\t\tthis._checkKey(key);\r\n\t\tthis._checkValue(value);\r\n\t\treturn super.set(key, value);\r\n\t}\r\n\t/**\r\n\t * データを追加・更新する\r\n\t * @param {K} key\r\n\t * @param {V} value\r\n\t * @returns {this}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tput(key, value) {\r\n\t\treturn this.set(key, value);\r\n\t}\r\n\r\n\t/**\r\n\t * データを一括で追加・更新する\r\n\t * @param {Map<K, V>} map\r\n\t * @throws {TypeError}\r\n\t */\r\n\tsetAll(map) {\r\n\t\tfor (const [k, v] of map.entries()) {\r\n\t\t\tthis.set(k, v);\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * データを一括で追加・更新する\r\n\t * @param {Map<K, V>} map\r\n\t * @throws {TypeError}\r\n\t */\r\n\tputAll(map) {\r\n\t\treturn this.setAll(map);\r\n\t}\r\n\r\n\t/**\r\n\t * データを取得する\r\n\t * @param {K} key\r\n\t * @returns {V}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tget(key) {\r\n\t\tthis._checkKey(key);\r\n\t\treturn super.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Keyの存在を確認する\r\n\t * @param {K} key\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\thas(key) {\r\n\t\tthis._checkKey(key);\r\n\t\treturn super.has(key);\r\n\t}\r\n\t/**\r\n\t * Keyの存在を確認する\r\n\t * @param {K} key\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tcontainsKey(key) {\r\n\t\treturn this.has(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Valueの存在を確認する\r\n\t * @param {V} value\r\n\t * @returns {boolean}\r\n\t */\r\n\tcontainsValue(value) {\r\n\t\tfor (const v of super.values()) {\r\n\t\t\tif (v === value) return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * データを削除する\r\n\t * @param {K} key\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tdelete(key) {\r\n\t\tthis._checkKey(key);\r\n\t\treturn super.delete(key);\r\n\t}\r\n\t/**\r\n\t * データを削除する\r\n\t * @param {K} key\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tremove(key) {\r\n\t\treturn this.delete(key);\r\n\t}\r\n\r\n\t/**\r\n\t * EntrySetを返却する\r\n\t * @returns {MapIterator<[...[K, V]]>}\r\n\t */\r\n\tentrySet() {\r\n\t\treturn this.entries();\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// 追加機能\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * 等価判定を行う\r\n\t * @param {this} otherMap\r\n\t * @returns {boolean}\r\n\t */\r\n\tequals(otherMap) {\r\n\t\tif (!(otherMap instanceof Map) || this.size !== otherMap.size) return false;\r\n\t\tfor (const [k, v] of this.entries()) {\r\n\t\t\tif (!otherMap.has(k) || otherMap.get(k) !== v) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * 全てのデータを呼び出す\r\n\t * @param {Function} callback\r\n\t * @param {any} thisArg\r\n\t */\r\n\tforEach(callback, thisArg) {\r\n\t\tfor (const [key, value] of this.entries()) {\r\n\t\t\tcallback.call(thisArg, value, key, this);\r\n\t\t}\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// Stream\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * Streamを返却する\r\n\t * @returns {EntryStream<K, V>}\r\n\t */\r\n\tstream() {\r\n\t\treturn EntryStream.from(this.entries(), this._KeyType, this._ValueType);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// 基本操作(システム)\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * 文字列に変換する\r\n\t * @returns {string}\r\n\t */\r\n\ttoString() {\r\n\t\treturn `${this.constructor.name}<${TypeChecker.typeNames(this._KeyType)}, ${TypeChecker.typeNames(this._ValueType)}>(size=${this.size})`;\r\n\t}\r\n\r\n\t/**\r\n\t * イテレータを返却する\r\n\t * @returns {Iterator<V>}\r\n\t */\r\n\t[Symbol.iterator]() {\r\n\t\treturn this.entries();\r\n\t}\r\n}\r\n\r\nmodule.exports = HashMap;\r\n",
    "const SetInterface = require(\"./SetInterface\");\r\nconst TypeChecker = require(\"../libs/TypeChecker\");\r\nconst StreamChecker = require(\"./stream/StreamChecker\");\r\nconst Stream = require(\"./stream/Stream\");\r\n\r\n/**\r\n * 型チェック機能のついたSet\r\n * @template V\r\n * @extends {SetInterface<V>}\r\n * @class\r\n */\r\nclass HashSet extends SetInterface {\r\n\t/**\r\n\t * @param {Function} ValueType\r\n\t */\r\n\tconstructor(ValueType) {\r\n\t\tsuper(ValueType);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// 基本操作(override)\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * 値を追加する\r\n\t * @param {V} value\r\n\t * @returns {this}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tadd(value) {\r\n\t\tthis._checkValue(value);\r\n\t\treturn super.add(value);\r\n\t}\r\n\r\n\t/**\r\n\t * 値を一括で追加する\r\n\t * @param {Iterable<V>} collection\r\n\t * @returns {this}\r\n\t * @throws {TypeError}\r\n\t */\r\n\taddAll(collection) {\r\n\t\tfor (const item of collection) {\r\n\t\t\tthis.add(item);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * 値の存在を確認\r\n\t * @param {V} value\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\thas(value) {\r\n\t\tthis._checkValue(value);\r\n\t\treturn super.has(value);\r\n\t}\r\n\t/**\r\n\t * 値の存在を確認\r\n\t * @param {V} value\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tcontains(value) {\r\n\t\treturn this.has(value);\r\n\t}\r\n\r\n\t/**\r\n\t * 全ての値の存在を確認\r\n\t * @param {Iterable<V>} collection\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tcontainsAll(collection) {\r\n\t\tfor (const item of collection) {\r\n\t\t\tif (!this.has(item)) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * 値を削除する\r\n\t * @param {V} value\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tdelete(value) {\r\n\t\tthis._checkValue(value);\r\n\t\treturn super.delete(value);\r\n\t}\r\n\t/**\r\n\t * 値を削除する\r\n\t * @param {V} value\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tremove(value) {\r\n\t\treturn this.delete(value);\r\n\t}\r\n\r\n\t/**\r\n\t * 全ての値を削除する\r\n\t * @param {Iterable<V>} collection\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tremoveAll(collection) {\r\n\t\tlet modified = false;\r\n\t\tfor (const item of collection) {\r\n\t\t\tmodified = this.delete(item) || modified;\r\n\t\t}\r\n\t\treturn modified;\r\n\t}\r\n\r\n\t/**\r\n\t * 含まれない要素を全削除する\r\n\t * @param {Iterable<V>} collection\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tretainAll(collection) {\r\n\t\tconst otherSet = new Set(collection);\r\n\t\tlet modified = false;\r\n\t\tfor (const item of this) {\r\n\t\t\tif (!otherSet.has(item)) {\r\n\t\t\t\tthis.delete(item);\r\n\t\t\t\tmodified = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn modified;\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// 追加機能\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * 等価判定を行う\r\n\t * @param {this} otherSet\r\n\t * @returns {boolean}\r\n\t */\r\n\tequals(otherSet) {\r\n\t\tif (!(otherSet instanceof Set) || this.size !== otherSet.size) return false;\r\n\t\tfor (const item of this) {\r\n\t\t\tif (!otherSet.has(item)) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * 全てのデータを呼び出す\r\n\t * @param {Function} callback\r\n\t * @param {any} [thisArg]\r\n\t */\r\n\tforEach(callback, thisArg) {\r\n\t\tfor (const item of this) {\r\n\t\t\tcallback.call(thisArg, item, item, this);\r\n\t\t}\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// Stream\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * Streamを返却する\r\n\t * @returns {Stream<V>}\r\n\t */\r\n\tstream() {\r\n\t\treturn StreamChecker.typeToStream(this._ValueType).from(this.values(), this._ValueType);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// 基本操作(システム)\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * 配列に変換する\r\n\t * @returns {V[]}\r\n\t */\r\n\ttoArray() {\r\n\t\treturn Array.from(this);\r\n\t}\r\n\r\n\t/**\r\n\t * 文字列に変換する\r\n\t * @returns {string}\r\n\t */\r\n\ttoString() {\r\n\t\treturn `${this.constructor.name}<${TypeChecker.typeNames(this._ValueType)}>(size=${this.size})`;\r\n\t}\r\n\r\n\t/**\r\n\t * イテレータを返却する\r\n\t * @returns {Iterator<V>}\r\n\t */\r\n\t[Symbol.iterator]() {\r\n\t\treturn this.values();\r\n\t}\r\n}\r\n\r\nmodule.exports = HashSet;\r\n",
    "const JavaLibraryScriptCore = require(\"../libs/sys/JavaLibraryScriptCore\");\nconst Interface = require(\"../base/Interface\");\nconst TypeChecker = require(\"../libs/TypeChecker\");\n\nconst Any = TypeChecker.Any;\nconst NoReturn = TypeChecker.NoReturn;\nconst NotNull = TypeChecker.NotNull;\nconst NotUndefined = TypeChecker.NotUndefined;\n\nconst NotEmpty = [NotNull, NotUndefined];\n\n/**\n * Listの基底クラス\n * @template V\n * @extends {JavaLibraryScriptCore}\n * @class\n * @abstract\n * @interface\n */\nclass ListInterface extends JavaLibraryScriptCore {\n\t/**\n\t * @param {Function} ValueType\n\t */\n\tconstructor(ValueType) {\n\t\tsuper();\n\t\tthis._ValueType = ValueType || Any;\n\t}\n\n\t/**\n\t * Valueの型をチェックする\n\t * @param {V} value\n\t * @throws {TypeError}\n\t */\n\t_checkValue(value) {\n\t\tif (!TypeChecker.matchType(value, this._ValueType)) {\n\t\t\tthrow new TypeError(`値型が一致しません。期待: ${TypeChecker.typeNames(this._ValueType)} → 実際: ${TypeChecker.stringify(value)}`);\n\t\t}\n\t}\n\n\t/**\n\t * 空かどうかを返却する\n\t * @returns {boolean}\n\t */\n\tisEmpty() {\n\t\treturn this.size === 0;\n\t}\n}\n\nListInterface = Interface.convert(ListInterface, {\n\tadd: { args: [NotEmpty], returns: ListInterface },\n\tget: { args: [Number], returns: Any },\n\tset: { args: [Number, NotEmpty], returns: ListInterface },\n\tremove: { args: [Number], returns: Any },\n\tisEmpty: { returns: Boolean, abstract: true },\n\tclear: { returns: NoReturn },\n\ttoArray: { returns: Array },\n});\n\nmodule.exports = ListInterface;\n",
    "const Interface = require(\"../base/Interface\");\nconst TypeChecker = require(\"../libs/TypeChecker\");\n\nconst Any = TypeChecker.Any;\nconst NoReturn = TypeChecker.NoReturn;\nconst NotNull = TypeChecker.NotNull;\nconst NotUndefined = TypeChecker.NotUndefined;\n\nconst NotEmpty = [NotNull, NotUndefined];\n\n/**\n * Mapの基底クラス\n * @template K, V\n * @extends {Map<K, V>}\n * @class\n * @abstract\n * @interface\n */\nclass MapInterface extends Map {\n\t/**\n\t * @param {Function} KeyType\n\t * @param {Function} ValueType\n\t */\n\tconstructor(KeyType, ValueType) {\n\t\tsuper();\n\t\tthis._KeyType = KeyType || Any;\n\t\tthis._ValueType = ValueType || Any;\n\t}\n\n\t/**\n\t * Keyの型をチェックする\n\t * @param {K} key\n\t * @throws {TypeError}\n\t */\n\t_checkKey(key) {\n\t\tif (!TypeChecker.matchType(key, this._KeyType)) {\n\t\t\tthrow new TypeError(`キー型が一致しません。期待: ${TypeChecker.typeNames(this._KeyType)} → 実際: ${TypeChecker.stringify(key)}`);\n\t\t}\n\t}\n\n\t/**\n\t * Valueの型をチェックする\n\t * @param {V} value\n\t * @throws {TypeError}\n\t */\n\t_checkValue(value) {\n\t\tif (!TypeChecker.matchType(value, this._ValueType)) {\n\t\t\tthrow new TypeError(`値型が一致しません。期待: ${TypeChecker.typeNames(this._ValueType)} → 実際: ${TypeChecker.stringify(value)}`);\n\t\t}\n\t}\n\n\t/**\n\t * 空かどうかを返却する\n\t * @returns {boolean}\n\t */\n\tisEmpty() {\n\t\treturn this.size === 0;\n\t}\n}\n\nMapInterface = Interface.convert(MapInterface, {\n\tset: { args: [NotEmpty, NotEmpty], returns: MapInterface, abstract: true },\n\tput: { args: [NotEmpty, NotEmpty], returns: MapInterface },\n\tget: { args: [NotEmpty], returns: Any, abstract: true },\n\tdelete: { args: [NotEmpty], returns: Boolean, abstract: true },\n\tremove: { args: [NotEmpty], returns: Boolean },\n\tisEmpty: { returns: Boolean, abstract: true },\n\tclear: { returns: NoReturn },\n\thas: { args: [NotEmpty], returns: Boolean, abstract: true },\n\tcontainsKey: { args: [NotEmpty], returns: Boolean },\n\tcontainsValue: { args: [NotEmpty], returns: Boolean },\n});\n\nmodule.exports = MapInterface;\n",
    "const Interface = require(\"../base/Interface\");\nconst TypeChecker = require(\"../libs/TypeChecker\");\n\nconst Any = TypeChecker.Any;\nconst NoReturn = TypeChecker.NoReturn;\nconst NotNull = TypeChecker.NotNull;\nconst NotUndefined = TypeChecker.NotUndefined;\n\nconst NotEmpty = [NotNull, NotUndefined];\n\n/**\n * Setの基底クラス\n * @template V\n * @extends {Set<V>}\n * @class\n * @abstract\n * @interface\n */\nclass SetInterface extends Set {\n\t/**\n\t * @param {Function} ValueType\n\t */\n\tconstructor(ValueType) {\n\t\tsuper();\n\t\tthis._ValueType = ValueType || Any;\n\t}\n\n\t/**\n\t * Valueの型をチェックする\n\t * @param {V} value\n\t * @throws {TypeError}\n\t */\n\t_checkValue(value) {\n\t\tif (!TypeChecker.matchType(value, this._ValueType)) {\n\t\t\tthrow new TypeError(`値型が一致しません。期待: ${TypeChecker.typeNames(this._ValueType)} → 実際: ${TypeChecker.stringify(value)}`);\n\t\t}\n\t}\n\n\t/**\n\t * 空かどうかを返却する\n\t * @returns {boolean}\n\t */\n\tisEmpty() {\n\t\treturn this.size === 0;\n\t}\n}\n\nSetInterface = Interface.convert(SetInterface, {\n\tadd: { args: [NotEmpty], returns: SetInterface },\n\tdelete: { args: [NotEmpty], returns: Boolean },\n\tremove: { args: [NotEmpty], returns: Boolean },\n\tisEmpty: { returns: Boolean, abstract: true },\n\tclear: { returns: NoReturn },\n\thas: { args: [NotEmpty], returns: Boolean },\n\tcontains: { args: [NotEmpty], returns: Boolean },\n});\n\nmodule.exports = SetInterface;\n",
    "module.exports = {\n    ...require(\"./ArrayList.js\"),\n    HashMap: require(\"./HashMap.js\"),\n    HashSet: require(\"./HashSet.js\"),\n    ListInterface: require(\"./ListInterface.js\"),\n    MapInterface: require(\"./MapInterface.js\"),\n    SetInterface: require(\"./SetInterface.js\"),\n    stream: require(\"./stream/index.js\")\n};\n",
    "const StreamInterface = require(\"./StreamInterface\");\r\nconst Stream = require(\"./Stream\");\r\n\r\n/**\r\n * 非同期Stream (LazyAsyncList)\r\n * @extends {StreamInterface}\r\n * @class\r\n */\r\nclass AsyncStream extends StreamInterface {\r\n\t/**\r\n\t * @param {Iterable | AsyncIterator} source\r\n\t */\r\n\tconstructor(source) {\r\n\t\tsuper();\r\n\t\tthis._iter = AsyncStream._normalize(source);\r\n\t\tthis._pipeline = [];\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStream化\r\n\t * @template {AsyncStream} T\r\n\t * @this {new (iterable: Iterable | AsyncIterator) => T}\r\n\t * @param {Iterable | AsyncIterator} iterable\r\n\t * @returns {T}\r\n\t * @static\r\n\t */\r\n\tstatic from(iterable) {\r\n\t\treturn new AsyncStream(iterable);\r\n\t}\r\n\r\n\t/**\r\n\t * Iterable化\r\n\t * @param {Iterable | AsyncIterator} input\r\n\t * @returns {AsyncIterator}\r\n\t */\r\n\tstatic _normalize(input) {\r\n\t\tif (typeof input[Symbol.asyncIterator] === \"function\") return input;\r\n\t\tif (typeof input[Symbol.iterator] === \"function\") {\r\n\t\t\treturn (async function* () {\r\n\t\t\t\tfor (const x of input) yield x;\r\n\t\t\t})();\r\n\t\t}\r\n\t\tthrow new TypeError(\"not (Async)Iterable\");\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// パイプライン計算\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * pipelineに追加\r\n\t * @param {Generator} fn\r\n\t * @returns {this}\r\n\t */\r\n\t_use(fn) {\r\n\t\tthis._pipeline.push(fn);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * pipelineを圧縮\r\n\t * @returns {this}\r\n\t */\r\n\tflattenPipeline() {\r\n\t\tconst flattenedFn = this._pipeline.reduceRight(\r\n\t\t\t(nextFn, currentFn) => {\r\n\t\t\t\treturn async function* (iterable) {\r\n\t\t\t\t\tyield* currentFn(nextFn(iterable));\r\n\t\t\t\t};\r\n\t\t\t},\r\n\t\t\tasync function* (x) {\r\n\t\t\t\tyield* x;\r\n\t\t\t}\r\n\t\t);\r\n\t\tconst flat = new this.constructor([]);\r\n\t\tflat._iter = this._iter;\r\n\t\tflat._pipeline = [flattenedFn];\r\n\t\treturn flat;\r\n\t}\r\n\r\n\t/**\r\n\t * 処理を一括関数化\r\n\t * @returns {Function}\r\n\t */\r\n\ttoFunction() {\r\n\t\tconst flat = this.flattenPipeline();\r\n\t\tconst fn = flat._pipeline[0];\r\n\t\treturn (input) => fn(input);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// Pipeline\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * AsyncStreamをマップ\r\n\t * @param {Function | Promise} fn\r\n\t * @returns {this}\r\n\t */\r\n\tmap(fn) {\r\n\t\treturn this._use(async function* (iter) {\r\n\t\t\tfor await (const x of iter) yield await fn(x);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamをフィルタ\r\n\t * @param {Function | Promise} fn\r\n\t * @returns {this}\r\n\t */\r\n\tfilter(fn) {\r\n\t\treturn this._use(async function* (iter) {\r\n\t\t\tfor await (const x of iter) {\r\n\t\t\t\tif (await fn(x)) yield x;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamを展開\r\n\t * @param {Function | Promise} fn\r\n\t * @returns {this}\r\n\t */\r\n\tflatMap(fn) {\r\n\t\treturn this._use(async function* (iter) {\r\n\t\t\tfor await (const x of iter) {\r\n\t\t\t\tconst sub = await fn(x);\r\n\t\t\t\tfor await (const y of AsyncStream._normalize(sub)) yield y;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamの重複を排除\r\n\t * @param {Function | Promise} keyFn\r\n\t * @returns {this}\r\n\t */\r\n\tdistinct(keyFn = (x) => x) {\r\n\t\treturn this._use(async function* (iter) {\r\n\t\t\tconst seen = new Set();\r\n\t\t\tfor await (const x of iter) {\r\n\t\t\t\tconst key = await keyFn(x);\r\n\t\t\t\tif (!seen.has(key)) {\r\n\t\t\t\t\tseen.add(key);\r\n\t\t\t\t\tyield x;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamの要素は変更せずに関数のみを実行\r\n\t * @param {Function} fn\r\n\t * @returns {this}\r\n\t */\r\n\tpeek(fn) {\r\n\t\treturn this._use(async function* (iter) {\r\n\t\t\tfor await (const x of iter) {\r\n\t\t\t\tfn(x);\r\n\t\t\t\tyield x;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamの要素数を先頭から制限\r\n\t * @param {Number} n\r\n\t * @returns {this}\r\n\t */\r\n\tlimit(n) {\r\n\t\treturn this._use(async function* (iter) {\r\n\t\t\tlet i = 0;\r\n\t\t\tfor await (const x of iter) {\r\n\t\t\t\tif (i++ < n) yield x;\r\n\t\t\t\telse break;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamの要素数を先頭からスキップ\r\n\t * @param {Number} n\r\n\t * @returns {this}\r\n\t */\r\n\tskip(n) {\r\n\t\treturn this._use(async function* (iter) {\r\n\t\t\tlet i = 0;\r\n\t\t\tfor await (const x of iter) {\r\n\t\t\t\tif (i++ >= n) yield x;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// Iterator\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * Streamをイテレータ化(非同期)\r\n\t * @returns {AsyncIterator}\r\n\t */\r\n\t[Symbol.asyncIterator]() {\r\n\t\tlet iter = this._iter;\r\n\t\tfor (const op of this._pipeline) {\r\n\t\t\titer = op(iter);\r\n\t\t}\r\n\t\treturn iter[Symbol.asyncIterator]();\r\n\t}\r\n\t// ==================================================\r\n\t// End\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * AsyncStreamをforEach\r\n\t * @param {Function | Promise} fn\r\n\t * @async\r\n\t */\r\n\tasync forEach(fn) {\r\n\t\tfor await (const x of this) {\r\n\t\t\tawait fn(x);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamを配列化\r\n\t * @returns {Array}\r\n\t * @async\r\n\t */\r\n\tasync toArray() {\r\n\t\tconst result = [];\r\n\t\tfor await (const x of this) {\r\n\t\t\tresult.push(x);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamをreduce\r\n\t * @param {Function | Promise} fn\r\n\t * @param {any} initial\r\n\t * @returns {any}\r\n\t * @async\r\n\t */\r\n\tasync reduce(fn, initial) {\r\n\t\tlet acc = initial;\r\n\t\tfor await (const x of this) {\r\n\t\t\tacc = await fn(acc, x);\r\n\t\t}\r\n\t\treturn acc;\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamの要素数を取得\r\n\t * @returns {Number}\r\n\t * @async\r\n\t */\r\n\tasync count() {\r\n\t\treturn await this.reduce((acc) => acc + 1, 0);\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamで条件を満たす要素があるか検査\r\n\t * @param {Function | Promise} fn\r\n\t * @returns {Boolean}\r\n\t * @async\r\n\t */\r\n\tasync some(fn) {\r\n\t\tfor await (const x of this) {\r\n\t\t\tif (await fn(x)) return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Streamで全ての要素が条件を満たすか検査\r\n\t * @param {Function | Promise} fn\r\n\t * @returns {Boolean}\r\n\t * @async\r\n\t */\r\n\tasync every(fn) {\r\n\t\tfor await (const x of this) {\r\n\t\t\tif (!(await fn(x))) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamから最初の要素を取得\r\n\t * @returns {any}\r\n\t * @async\r\n\t */\r\n\tasync findFirst() {\r\n\t\tfor await (const item of this) return item;\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Streamから任意の要素を取得\r\n\t * @returns {any}\r\n\t * @async\r\n\t */\r\n\tasync find() {\r\n\t\treturn await this.findFirst();\r\n\t}\r\n\r\n\t/**\r\n\t * Java Collectors 相当\r\n\t * @param {Function} collectorFn\r\n\t * @returns {any}\r\n\t */\r\n\tcollectWith(collectorFn) {\r\n\t\treturn collectorFn(this);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// mapTo\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * AsyncStreamをStreamに変換\r\n\t * @returns {Stream}\r\n\t * @async\r\n\t */\r\n\tasync toLazy() {\r\n\t\tconst arr = [];\r\n\t\tfor await (const item of this) {\r\n\t\t\tarr.push(item);\r\n\t\t}\r\n\t\treturn new Stream(arr);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// その他\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * 文字列に変換する\r\n\t * @returns {String}\r\n\t */\r\n\ttoString() {\r\n\t\treturn `${this.constructor.name}<Promise>`;\r\n\t}\r\n}\r\n\r\nmodule.exports = AsyncStream;\r\n",
    "const Stream = require(\"./Stream\");\nconst { BigFloat } = require(\"../../math/BigFloat\");\n\n/**\n * BigFloat専用Stream (LazyList)\n * @extends {Stream<BigFloat>}\n * @class\n */\nclass BigFloatStream extends Stream {\n\t/**\n\t * @param {Iterable<BigFloat>} source\n\t */\n\tconstructor(source) {\n\t\tsuper(source, BigFloat);\n\n\t\tthis.mapToBigFloat = undefined;\n\t}\n\n\t// ====================================================================================================\n\t// * 内部ユーティリティ・補助関数\n\t// ====================================================================================================\n\t// --------------------------------------------------\n\t// 精度チェック\n\t// --------------------------------------------------\n\t/**\n\t * 精度を変更する\n\t * @param {BigInt} precision\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tchangePrecision(precision) {\n\t\treturn this.peek((x) => x.changePrecision(precision));\n\t}\n\t// ====================================================================================================\n\t// * 四則演算・基本関数\n\t// ====================================================================================================\n\t// --------------------------------------------------\n\t// 基本演算\n\t// --------------------------------------------------\n\t/**\n\t * 加算\n\t * @param {BigFloat} other\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tadd(other) {\n\t\treturn this.map((x) => x.add(other));\n\t}\n\t/**\n\t * 減算\n\t * @param {BigFloat} other\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tsub(other) {\n\t\treturn this.map((x) => x.sub(other));\n\t}\n\t/**\n\t * 乗算\n\t * @param {BigFloat} other\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tmul(other) {\n\t\treturn this.map((x) => x.mul(other));\n\t}\n\t/**\n\t * 除算\n\t * @param {BigFloat} other\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tdiv(other) {\n\t\treturn this.map((x) => x.div(other));\n\t}\n\t/**\n\t * 剰余\n\t * @param {BigFloat} other\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tmod(other) {\n\t\treturn this.map((x) => x.mod(other));\n\t}\n\t// --------------------------------------------------\n\t// 符号操作\n\t// --------------------------------------------------\n\t/**\n\t * 符号反転\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tneg() {\n\t\treturn this.map((x) => x.neg());\n\t}\n\t/**\n\t * 絶対値\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tabs() {\n\t\treturn this.map((x) => x.abs());\n\t}\n\t/**\n\t * 逆数を返す\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t */\n\treciprocal() {\n\t\treturn this.map((x) => x.reciprocal());\n\t}\n\t// ====================================================================================================\n\t// * 冪乗・ルート・スケーリング\n\t// ====================================================================================================\n\t// --------------------------------------------------\n\t// べき乗\n\t// --------------------------------------------------\n\t/**\n\t * べき乗\n\t * @param {BigFloat} exponent - 指数\n\t * @returns {this}\n\t */\n\tpow(exponent) {\n\t\treturn this.map((x) => x.pow(exponent));\n\t}\n\t// --------------------------------------------------\n\t// 平方根・立方根・任意根\n\t// --------------------------------------------------\n\t/**\n\t * 平方根\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tsqrt() {\n\t\treturn this.map((x) => x.sqrt());\n\t}\n\t/**\n\t * 立方根\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tcbrt() {\n\t\treturn this.map((x) => x.cbrt());\n\t}\n\t/**\n\t * n乗根\n\t * @param {BigInt} n\n\t * @returns {this}\n\t * @throws {Error}\n\t */\n\tnthRoot(n) {\n\t\treturn this.map((x) => x.nthRoot(n));\n\t}\n\t// ====================================================================================================\n\t// * 統計関数\n\t// ====================================================================================================\n\t// --------------------------------------------------\n\t// 集計\n\t// --------------------------------------------------\n\t/**\n\t * 最大値を返す\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t */\n\tmax() {\n\t\treturn BigFloat.max(this.toArray());\n\t}\n\t/**\n\t * 最小値を返す\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t */\n\tmin() {\n\t\treturn BigFloat.min(this.toArray());\n\t}\n\t/**\n\t * 合計値を返す\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t */\n\tsum() {\n\t\treturn BigFloat.sum(this.toArray());\n\t}\n\t/**\n\t * 積を返す (丸め誤差に注意)\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t */\n\tproduct() {\n\t\treturn BigFloat.product(this.toArray());\n\t}\n\t// --------------------------------------------------\n\t// 平均・中央値\n\t// --------------------------------------------------\n\t/**\n\t * 平均値を返す\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t */\n\taverage() {\n\t\treturn BigFloat.average(this.toArray());\n\t}\n\t/**\n\t * 中央値を返す\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t */\n\tmedian() {\n\t\treturn BigFloat.median(this.toArray());\n\t}\n\t// --------------------------------------------------\n\t// 分散・標準偏差\n\t// --------------------------------------------------\n\t/**\n\t * 分散を返す\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t */\n\tvariance() {\n\t\treturn BigFloat.variance(this.toArray());\n\t}\n\t/**\n\t * 標準偏差を返す\n\t * @returns {BigFloat}\n\t * @throws {Error}\n\t */\n\tstddev() {\n\t\treturn BigFloat.stddev(this.toArray());\n\t}\n\t// ====================================================================================================\n\t// * 三角関数\n\t// ====================================================================================================\n\t// --------------------------------------------------\n\t// 基本三角関数\n\t// --------------------------------------------------\n}\n\nmodule.exports = BigFloatStream;\n",
    "const Stream = require(\"./Stream\");\nconst StreamChecker = require(\"./StreamChecker\");\nconst TypeChecker = require(\"../../libs/TypeChecker\");\n\n/** @typedef {import(\"../HashMap.js\")} HashMapType */\n\nconst Any = TypeChecker.Any;\n\nlet HashMap;\nfunction init() {\n\tif (HashMap) return;\n\tHashMap = require(\"../HashMap\");\n}\n\n/**\n * Entry専用Stream (LazyList)\n * @template K, V\n * @extends {Stream<V>}\n * @class\n */\nclass EntryStream extends Stream {\n\t/**\n\t * @param {Iterable<[K, V]>} source\n\t * @param {Function} KeyType\n\t * @param {Function} ValueType\n\t */\n\tconstructor(source, KeyType, ValueType) {\n\t\tsuper(source, ValueType);\n\n\t\tthis.mapToEntry = undefined;\n\t\tthis._KeyType = KeyType || Any;\n\t}\n\n\t/**\n\t * Stream化\n\t * @template {EntryStream} T\n\t * @this {new (Iterable, Function, Function) => T}\n\t * @param {Iterable} iterable\n\t * @param {Function} KeyType\n\t * @param {Function} ValueType\n\t * @returns {T}\n\t * @overload\n\t * @static\n\t */\n\tstatic from(iterable, KeyType, ValueType) {\n\t\treturn new this(iterable, KeyType, ValueType);\n\t}\n\n\t/**\n\t * EntryStreamからキーのStreamを返却\n\t * @returns {Stream<K>}\n\t */\n\tkeys() {\n\t\treturn this._convertToX(StreamChecker.typeToStream(this._KeyType)).map(([k, _]) => k);\n\t}\n\n\t/**\n\t * EntryStreamから値のStreamを返却\n\t * @returns {Stream<V>}\n\t */\n\tvalues() {\n\t\treturn this._convertToX(StreamChecker.typeToStream(this._ValueType)).map(([_, v]) => v);\n\t}\n\n\t/**\n\t * EntryStreamのキーをマップ\n\t * @param {Function} fn\n\t * @returns {this}\n\t */\n\tmapKeys(fn) {\n\t\treturn this.map(([k, v]) => [fn(k), v]);\n\t}\n\n\t/**\n\t * EntryStreamの値をマップ\n\t * @param {Function} fn\n\t * @returns {this}\n\t */\n\tmapValues(fn) {\n\t\treturn this.map(([k, v]) => [k, fn(v)]);\n\t}\n\n\t// ==================================================\n\t// to\n\t// ==================================================\n\n\t/**\n\t * EntryStreamをHashMapに変換する\n\t * @param {Function} [KeyType]\n\t * @param {Function} [ValueType]\n\t * @returns {HashMapType}\n\t */\n\ttoHashMap(KeyType = this._KeyType, ValueType = this._ValueType) {\n\t\tinit();\n\t\tconst map = new HashMap(KeyType, ValueType);\n\t\tthis.forEach(([k, v]) => map.set(k, v));\n\t\treturn map;\n\t}\n\n\t/**\n\t * 文字列に変換する\n\t * @returns {String}\n\t * @override\n\t */\n\ttoString() {\n\t\treturn `${this.constructor.name}<${TypeChecker.typeNames(this._KeyType)}, ${TypeChecker.typeNames(this._ValueType)}>`;\n\t}\n}\n\nmodule.exports = EntryStream;\n",
    "const Stream = require(\"./Stream\");\n\n/**\n * 数値専用Stream (LazyList)\n * @extends {Stream<Number>}\n * @class\n */\nclass NumberStream extends Stream {\n\t/**\n\t * @param {Iterable<Number>} source\n\t */\n\tconstructor(source) {\n\t\tsuper(source, Number);\n\n\t\tthis.mapToNumber = undefined;\n\t}\n\n\t/**\n\t * 合計\n\t * @returns {Number}\n\t */\n\tsum() {\n\t\tlet total = 0;\n\t\tfor (const num of this) {\n\t\t\ttotal += num;\n\t\t}\n\t\treturn total;\n\t}\n\n\t/**\n\t * 平均\n\t * @returns {Number}\n\t */\n\taverage() {\n\t\tlet total = 0;\n\t\tlet count = 0;\n\t\tfor (const num of this) {\n\t\t\ttotal += num;\n\t\t\tcount++;\n\t\t}\n\t\treturn count === 0 ? NaN : total / count;\n\t}\n\n\t/**\n\t * 最小値\n\t * @returns {Number | null}\n\t */\n\tmin() {\n\t\tlet min = Infinity;\n\t\tfor (const num of this) {\n\t\t\tif (num < min) min = num;\n\t\t}\n\t\treturn min === Infinity ? null : min;\n\t}\n\n\t/**\n\t * 最大値\n\t * @returns {Number | null}\n\t */\n\tmax() {\n\t\tlet max = -Infinity;\n\t\tfor (const num of this) {\n\t\t\tif (num > max) max = num;\n\t\t}\n\t\treturn max === -Infinity ? null : max;\n\t}\n}\n\nmodule.exports = NumberStream;\n",
    "const StreamInterface = require(\"./StreamInterface\");\r\nconst TypeChecker = require(\"../../libs/TypeChecker\");\r\nconst { BigFloat } = require(\"../../math/BigFloat\");\r\n\r\nconst Any = TypeChecker.Any;\r\n\r\n/** @typedef {import(\"./NumberStream.js\")} NumberStreamType */\r\n// /** @typedef {import(\"./StringStream.js\")} StringStream_forceRep */ // なぜかこいつだけ動かん\r\n/** @typedef {import(\"./BigFloatStream\")} BigFloatStreamType */\r\n/** @typedef {import(\"./EntryStream.js\")} EntryStreamType */\r\n/** @typedef {import(\"./AsyncStream.js\")} AsyncStreamType */\r\n/** @typedef {import(\"../HashSet.js\")} HashSetType */\r\n\r\nlet NumberStream, StringStream, BigFloatStream, EntryStream, AsyncStream, HashSet;\r\nfunction init() {\r\n\tif (NumberStream) return;\r\n\tNumberStream = require(\"./NumberStream\");\r\n\tStringStream = require(\"./StringStream\");\r\n\tBigFloatStream = require(\"./BigFloatStream\");\r\n\tEntryStream = require(\"./EntryStream\");\r\n\tAsyncStream = require(\"./AsyncStream\");\r\n\tHashSet = require(\"../HashSet\");\r\n}\r\n\r\n/**\r\n * Streamオブジェクト(LazyList)\r\n * @template V\r\n * @extends {StreamInterface}\r\n * @class\r\n */\r\nclass Stream extends StreamInterface {\r\n\t/**\r\n\t * @param {Iterable<V>} source\r\n\t * @param {Function} ValueType\r\n\t */\r\n\tconstructor(source, ValueType) {\r\n\t\tsuper();\r\n\t\tthis._iter = source[Symbol.iterator]();\r\n\t\tthis._pipeline = [];\r\n\r\n\t\tthis._ValueType = ValueType || Any;\r\n\r\n\t\tinit();\r\n\t}\r\n\r\n\t/**\r\n\t * Stream化\r\n\t * @template {Stream} T\r\n\t * @this {new (Iterable) => T}\r\n\t * @param {Iterable<V>} iterable\r\n\t * @param {Function} ValueType\r\n\t * @returns {T}\r\n\t * @static\r\n\t */\r\n\tstatic from(iterable, ValueType) {\r\n\t\treturn new this(iterable, ValueType);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// パイプライン計算\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * pipelineに追加\r\n\t * @param {Generator} fn\r\n\t * @returns {this}\r\n\t */\r\n\t_use(fn) {\r\n\t\tthis._pipeline.push(fn);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * 他Streamに変換\r\n\t * @param {Function} construct\r\n\t * @param {Generator} fn\r\n\t * @param {...any} args\r\n\t * @returns {this}\r\n\t */\r\n\t_convertToX(construct, fn, ...args) {\r\n\t\tconst newStream = new construct([], ...args);\r\n\t\tnewStream._iter = this._iter;\r\n\t\tnewStream._pipeline = [...this._pipeline];\r\n\t\tif (fn) newStream._pipeline.push(fn);\r\n\t\treturn newStream;\r\n\t}\r\n\r\n\t/**\r\n\t * pipelineを圧縮\r\n\t * @returns {this}\r\n\t */\r\n\tflattenPipeline() {\r\n\t\tconst flattenedFn = this._pipeline.reduceRight(\r\n\t\t\t(nextFn, currentFn) => {\r\n\t\t\t\treturn function* (iterable) {\r\n\t\t\t\t\tyield* currentFn(nextFn(iterable));\r\n\t\t\t\t};\r\n\t\t\t},\r\n\t\t\t(x) => x\r\n\t\t);\r\n\r\n\t\tconst flat = new this.constructor([]); // 継承クラス対応\r\n\t\tflat._iter = this._iter;\r\n\t\tflat._pipeline = [flattenedFn];\r\n\t\treturn flat;\r\n\t}\r\n\r\n\t/**\r\n\t * 処理を一括関数化\r\n\t * @returns {Function}\r\n\t */\r\n\ttoFunction() {\r\n\t\tconst flat = this.flattenPipeline();\r\n\t\tconst fn = flat._pipeline[0];\r\n\t\treturn (input) => fn(input);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// Pipeline\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * Streamをマップ\r\n\t * @param {Function} fn\r\n\t * @returns {this}\r\n\t */\r\n\tmap(fn) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tfor (const item of iter) yield fn(item);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamをフィルタ\r\n\t * @param {Function} fn\r\n\t * @returns {this}\r\n\t */\r\n\tfilter(fn) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tfor (const item of iter) if (fn(item)) yield item;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamを展開\r\n\t * @param {Function} fn\r\n\t * @returns {this}\r\n\t */\r\n\tflatMap(fn) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tconst sub = fn(item);\r\n\t\t\t\tyield* sub instanceof StreamInterface ? sub : sub[Symbol.iterator]();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamの重複を排除\r\n\t * @param {Function} keyFn\r\n\t * @returns {this}\r\n\t */\r\n\tdistinct(keyFn = JSON.stringify.bind(JSON)) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tconst seen = new Set();\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tconst key = keyFn(item);\r\n\t\t\t\tif (!seen.has(key)) {\r\n\t\t\t\t\tseen.add(key);\r\n\t\t\t\t\tyield item;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamをソート\r\n\t * @param {Function} compareFn\r\n\t * @returns {this}\r\n\t */\r\n\tsorted(compareFn = (a, b) => (a > b ? 1 : a < b ? -1 : 0)) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tconst arr = [...iter].sort(compareFn);\r\n\t\t\tyield* arr;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamの要素は変更せずに関数のみを実行\r\n\t * @param {Function} fn\r\n\t * @returns {this}\r\n\t */\r\n\tpeek(fn) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tfn(item);\r\n\t\t\t\tyield item;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamの要素数を先頭から制限\r\n\t * @param {Number} n\r\n\t * @returns {this}\r\n\t */\r\n\tlimit(n) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tlet i = 0;\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tif (i++ >= n) break;\r\n\t\t\t\tyield item;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamの要素数を先頭からスキップ\r\n\t * @param {Number} n\r\n\t * @returns {this}\r\n\t */\r\n\tskip(n) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tlet i = 0;\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tif (i++ < n) continue;\r\n\t\t\t\tyield item;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamを分割\r\n\t * @param {Number} size\r\n\t * @returns {this}\r\n\t */\r\n\tchunk(size) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tlet buf = [];\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tbuf.push(item);\r\n\t\t\t\tif (buf.length === size) {\r\n\t\t\t\t\tyield buf;\r\n\t\t\t\t\tbuf = [];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (buf.length) yield buf;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamをスライド分割\r\n\t * @param {Number} size\r\n\t * @param {Number} step\r\n\t * @returns {this}\r\n\t */\r\n\twindowed(size, step = size) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tconst buffer = [];\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tbuffer.push(item);\r\n\t\t\t\tif (buffer.length === size) {\r\n\t\t\t\t\tyield buffer.slice();\r\n\t\t\t\t\tbuffer.splice(0, step); // スライド\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// Iterator\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * Streamをイテレータ化\r\n\t * @returns {Iterator}\r\n\t */\r\n\t[Symbol.iterator]() {\r\n\t\treturn this._pipeline.reduce((iter, fn) => fn(iter), this._iter);\r\n\t}\r\n\r\n\t/**\r\n\t * Streamをイテレータ化(非同期)\r\n\t * @returns {AsyncIterator}\r\n\t */\r\n\t[Symbol.asyncIterator]() {\r\n\t\tlet iter = this._pipeline.reduce((i, fn) => fn(i), this._iter);\r\n\t\treturn {\r\n\t\t\tasync next() {\r\n\t\t\t\treturn Promise.resolve(iter.next());\r\n\t\t\t},\r\n\t\t};\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// End\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * StreamをforEach\r\n\t * @param {Function} fn\r\n\t */\r\n\tforEach(fn) {\r\n\t\tfor (const item of this) fn(item);\r\n\t}\r\n\r\n\t/**\r\n\t * Streamを配列化\r\n\t * @returns {V[]}\r\n\t */\r\n\ttoArray() {\r\n\t\treturn Array.from(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Streamをreduce\r\n\t * @param {Function} fn\r\n\t * @param {any} initial\r\n\t * @returns {any}\r\n\t */\r\n\treduce(fn, initial) {\r\n\t\tlet acc = initial;\r\n\t\tfor (const item of this) {\r\n\t\t\tacc = fn(acc, item);\r\n\t\t}\r\n\t\treturn acc;\r\n\t}\r\n\r\n\t/**\r\n\t * Streamの要素数を取得\r\n\t * @returns {Number}\r\n\t */\r\n\tcount() {\r\n\t\tlet c = 0;\r\n\t\tfor (const _ of this) c++;\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * Streamで条件を満たす要素があるか検査\r\n\t * @param {Function} fn\r\n\t * @returns {Boolean}\r\n\t */\r\n\tsome(fn) {\r\n\t\tfor (const item of this) {\r\n\t\t\tif (fn(item)) return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Streamで全ての要素が条件を満たすか検査\r\n\t * @param {Function} fn\r\n\t * @returns {Boolean}\r\n\t */\r\n\tevery(fn) {\r\n\t\tfor (const item of this) {\r\n\t\t\tif (!fn(item)) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Streamから最初の要素を取得\r\n\t * @returns {any}\r\n\t */\r\n\tfindFirst() {\r\n\t\tfor (const item of this) return item;\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Streamから任意の要素を取得\r\n\t * @returns {any}\r\n\t */\r\n\tfindAny() {\r\n\t\treturn this.findFirst(); // 同義（非並列）\r\n\t}\r\n\r\n\t/**\r\n\t * Java Collectors 相当\r\n\t * @param {Function} collectorFn\r\n\t * @returns {any}\r\n\t */\r\n\tcollectWith(collectorFn) {\r\n\t\treturn collectorFn(this);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// mapTo\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * StreamをNumberStreamに変換\r\n\t * @param {Function} fn\r\n\t * @returns {NumberStreamType}\r\n\t */\r\n\tmapToNumber(fn) {\r\n\t\treturn this._convertToX(NumberStream, function* (iter) {\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tconst mapped = fn(item);\r\n\t\t\t\tif (typeof mapped !== \"number\") {\r\n\t\t\t\t\tthrow new TypeError(`mapToNumber() must return number. Got ${typeof mapped}`);\r\n\t\t\t\t}\r\n\t\t\t\tyield mapped;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * StreamをStringStreamに変換\r\n\t * @param {Function} fn\r\n\t * @returns {StringStream_forceRep}\r\n\t */\r\n\tmapToString(fn) {\r\n\t\treturn this._convertToX(StringStream, function* (iter) {\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tconst mapped = fn(item);\r\n\t\t\t\tif (typeof mapped !== \"string\") {\r\n\t\t\t\t\tthrow new TypeError(`mapToString() must return string. Got ${typeof mapped}`);\r\n\t\t\t\t}\r\n\t\t\t\tyield mapped;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * StreamをBigFloatStreamに変換\r\n\t * @param {Function | number | BigInt} [fn=20n] - 数値なら自動変換\r\n\t * @returns {BigFloatStreamType}\r\n\t */\r\n\tmapToBigFloat(fn = 20n) {\r\n\t\tconst type = typeof fn;\r\n\t\treturn this._convertToX(BigFloatStream, function* (iter) {\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tlet mapped;\r\n\r\n\t\t\t\tif (type === \"function\") mapped = fn(item);\r\n\t\t\t\telse if (type === \"number\" || type === \"bigint\") {\r\n\t\t\t\t\tmapped = new BigFloat(item, fn);\r\n\t\t\t\t}\r\n\t\t\t\tif (!(mapped instanceof BigFloat)) {\r\n\t\t\t\t\tthrow new TypeError(`mapToBigFloat() must return BigFloat. Got ${typeof mapped}`);\r\n\t\t\t\t}\r\n\t\t\t\tyield mapped;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * StreamをEntryStreamに変換\r\n\t * @param {Function} fn\r\n\t * @returns {EntryStreamType}\r\n\t */\r\n\tmapToEntry(fn) {\r\n\t\treturn this._convertToX(\r\n\t\t\tEntryStream,\r\n\t\t\tfunction* (iter) {\r\n\t\t\t\tfor (const item of iter) {\r\n\t\t\t\t\tconst entry = fn(item);\r\n\t\t\t\t\tif (!Array.isArray(entry) || entry.length !== 2) {\r\n\t\t\t\t\t\tthrow new TypeError(`mapToEntry() must return [key, value] pair. Got: ${entry}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tyield entry;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tAny,\r\n\t\t\tAny\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * StreamをAsyncStreamに変換\r\n\t * @param {Function} fn\r\n\t * @returns {AsyncStreamType}\r\n\t */\r\n\tmapToAsync(fn) {\r\n\t\tconst input = this.flattenPipeline();\r\n\t\tconst sourceIterable = input._pipeline[0](input._iter); // 実行（同期 generator）\r\n\r\n\t\t// AsyncStream に渡す非同期イテレータを構築\r\n\t\tconst asyncIterable = (async function* () {\r\n\t\t\tfor (const item of sourceIterable) {\r\n\t\t\t\tyield await fn(item);\r\n\t\t\t}\r\n\t\t})();\r\n\r\n\t\treturn new AsyncStream(asyncIterable);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// to\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * StreamをHashSetに変換\r\n\t * @param {Function} [ValueType]\r\n\t * @returns {HashSetType}\r\n\t */\r\n\ttoHashSet(ValueType = this._ValueType) {\r\n\t\tconst set = new HashSet(ValueType);\r\n\t\tfor (const item of this) set.add(item);\r\n\t\treturn set;\r\n\t}\r\n\r\n\t/**\r\n\t * 文字列に変換する\r\n\t * @returns {String}\r\n\t */\r\n\ttoString() {\r\n\t\treturn `${this.constructor.name}<${TypeChecker.typeNames(this._ValueType)}>`;\r\n\t}\r\n}\r\n\r\nmodule.exports = Stream;\r\n",
    "const JavaLibraryScriptCore = require(\"../../libs/sys/JavaLibraryScriptCore\");\nconst TypeChecker = require(\"../../libs/TypeChecker\");\nconst StreamInterface = require(\"./StreamInterface\");\nconst { BigFloat } = require(\"../../math/BigFloat\");\n\nlet Stream, NumberStream, StringStream, BigFloatStream, EntryStream, AsyncStream;\nfunction init() {\n\tif (Stream) return;\n\tStream = require(\"./Stream\");\n\tNumberStream = require(\"./NumberStream\");\n\tStringStream = require(\"./StringStream\");\n\tBigFloatStream = require(\"./BigFloatStream\");\n\tEntryStream = require(\"./EntryStream\");\n\tAsyncStream = require(\"./AsyncStream\");\n}\n\n/**\n * Streamの型チェック\n * @extends {JavaLibraryScriptCore}\n * @class\n */\nclass StreamChecker extends JavaLibraryScriptCore {\n\t/**\n\t * TypeをStreamに変換する\n\t * @param {Function} expected\n\t * @returns {StreamInterface}\n\t */\n\tstatic typeToStream(expected) {\n\t\tinit();\n\t\tif (expected == null) return Stream;\n\t\tif (expected === String) return StringStream;\n\t\tif (expected === Number) return NumberStream;\n\t\tif (expected?.prototype instanceof BigFloat) return BigFloatStream;\n\t\tif (expected === Map) return EntryStream;\n\t\tif (expected === Promise) return AsyncStream;\n\t\treturn Stream;\n\t}\n\n\t/**\n\t * StreamをTypeに変換する\n\t * @param {StreamInterface} stream\n\t * @returns {Function}\n\t * @static\n\t */\n\tstatic streamToType(stream) {\n\t\tinit();\n\t\t// Stream継承\n\t\tif (stream instanceof StringStream) return String;\n\t\tif (stream instanceof NumberStream) return Number;\n\t\tif (stream instanceof BigFloatStream) return BigFloat;\n\t\tif (stream instanceof EntryStream) return Map;\n\t\t// StreamInterface継承\n\t\tif (stream instanceof AsyncStream) return Promise;\n\t\tif (stream instanceof Stream) return TypeChecker.Any;\n\t\treturn null;\n\t}\n}\n\nmodule.exports = StreamChecker;\n",
    "const JavaLibraryScriptCore = require(\"../../libs/sys/JavaLibraryScriptCore\");\nconst Interface = require(\"../../base/Interface\");\n\n/**\n * Streamの基底クラス\n * @extends {JavaLibraryScriptCore}\n * @class\n * @abstract\n */\nclass StreamInterface extends JavaLibraryScriptCore {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nStreamInterface = Interface.convert(StreamInterface, {\n\tmap: {\n\t\targs: [Function],\n\t\treturns: StreamInterface,\n\t},\n\tfilter: {\n\t\targs: [Function],\n\t\treturns: StreamInterface,\n\t},\n\tflatMap: {\n\t\targs: [Function],\n\t\treturns: StreamInterface,\n\t},\n\t//\n\tforEach: {\n\t\targs: [[Function, Promise]],\n\t\treturns: [undefined, Promise],\n\t},\n});\n\nmodule.exports = StreamInterface;\n",
    "const Stream = require(\"./Stream\");\n\n/**\n * 文字列専用Stream (LazyList)\n * @extends {Stream<String>}\n * @class\n */\nclass StringStream extends Stream {\n\t/**\n\t * @param {Iterable<String>} source\n\t */\n\tconstructor(source) {\n\t\tsuper(source, String);\n\n\t\tthis.mapToString = undefined;\n\t}\n\n\t/**\n\t * 文字列連結\n\t * @param {string} separator\n\t * @returns {string}\n\t */\n\tjoin(separator = \" \") {\n\t\treturn Array.from(this).join(separator);\n\t}\n\n\t/**\n\t * 文字列を結合\n\t * @returns {string}\n\t */\n\tconcatAll() {\n\t\treturn this.join(\"\");\n\t}\n\n\t/**\n\t * 最長の文字列を返す\n\t * @returns {string}\n\t */\n\tlongest() {\n\t\tlet max = \"\";\n\t\tfor (const str of this) {\n\t\t\tif (str.length > max.length) max = str;\n\t\t}\n\t\treturn max || null;\n\t}\n\n\t/**\n\t * 最短の文字列を返す\n\t * @returns {string}\n\t */\n\tshortest() {\n\t\tlet min = null;\n\t\tfor (const str of this) {\n\t\t\tif (min === null || str.length < min.length) min = str;\n\t\t}\n\t\treturn min || null;\n\t}\n}\n\nmodule.exports = StringStream;\n",
    "module.exports = {\n    AsyncStream: require(\"./AsyncStream.js\"),\n    BigFloatStream: require(\"./BigFloatStream.js\"),\n    EntryStream: require(\"./EntryStream.js\"),\n    NumberStream: require(\"./NumberStream.js\"),\n    Stream: require(\"./Stream.js\"),\n    StreamChecker: require(\"./StreamChecker.js\"),\n    StreamInterface: require(\"./StreamInterface.js\"),\n    StringStream: require(\"./StringStream.js\")\n};\n"
  ]
}